/ Note that summary_part#cache_key will be called and will return something like this
/
/  renalware/problems/problems/query-470b1201d5696133ec89b9415d438586-6-20180218160613719105
/
/ (see http://www.rubydoc.info/github/rails/rails/ActiveRecord%2FRelation%3Acache_key)
/ and because we are caching inside a partial, Rails will append the MD5 digest of this template's
/ content i.e. 1ff2cfc1505d571ac18a3d1d3708ebb4 and so in Redis the final cache key will be e.g.
/
/  renalware/problems/problems/...86-6-20180218160613719105/1ff2cfc1505d571ac18a3d1d3708ebb4
/
/ Note you can get the partial digest value using `cache_fragment_name[0]`
- cache_if(summary_part.cache?, summary_part) do
  .summary-part--problems
    article
      header
        h1
          = link_to "#{t('titles.problems')} (#{summary_part.problems.length})",
                    patient_problems_path(summary_part.patient)

        = link_to t("btn.add"), patient_problems_path(summary_part.patient), class: "button"


      table#problems.toggleable.toggleable--without-border-between-toggled-and-non-toggled-tr(data-controller="toggle")
        thead.toggleable--open
          th.togglers.noprint =rows_toggler
          th= t("thead.description")
          th.col-width-date= t("thead.date_")

        - summary_part.problems.each_with_index do |problem|
          tbody.toggleable--open(class=("toggleable--no-toggleable-content" if problem.notes.none?))
            tr
              td.toggleable--toggler-container.noprint = row_toggler
              td
                span= problem.full_description
              td= problem.created_at.to_date
            tr
              td
              td
                - if problem.notes.any?
                  ol
                    - problem.notes.each do |note|
                      li= note.description
              td
