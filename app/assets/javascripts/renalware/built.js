
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

var check = function (it) {
  return it && it.Math == Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global$K =
// eslint-disable-next-line es-x/no-global-this -- safe
check(typeof globalThis == 'object' && globalThis) || check(typeof window == 'object' && window) ||
// eslint-disable-next-line no-restricted-globals -- safe
check(typeof self == 'object' && self) || check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||
// eslint-disable-next-line no-new-func -- fallback
function () {
  return this;
}() || Function('return this')();

var objectGetOwnPropertyDescriptor = {};

var fails$j = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};

var fails$i = fails$j;

// Detect IE8's incomplete defineProperty implementation
var descriptors = !fails$i(function () {
  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing
  return Object.defineProperty({}, 1, {
    get: function () {
      return 7;
    }
  })[1] != 7;
});

var fails$h = fails$j;
var functionBindNative = !fails$h(function () {
  // eslint-disable-next-line es-x/no-function-prototype-bind -- safe
  var test = function () {/* empty */}.bind();
  // eslint-disable-next-line no-prototype-builtins -- safe
  return typeof test != 'function' || test.hasOwnProperty('prototype');
});

var NATIVE_BIND$3 = functionBindNative;
var call$h = Function.prototype.call;
var functionCall = NATIVE_BIND$3 ? call$h.bind(call$h) : function () {
  return call$h.apply(call$h, arguments);
};

var objectPropertyIsEnumerable = {};

var $propertyIsEnumerable = {}.propertyIsEnumerable;
// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor$3 = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor$3 && !$propertyIsEnumerable.call({
  1: 2
}, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
objectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor$3(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;

var createPropertyDescriptor$6 = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

var NATIVE_BIND$2 = functionBindNative;
var FunctionPrototype$2 = Function.prototype;
var bind$9 = FunctionPrototype$2.bind;
var call$g = FunctionPrototype$2.call;
var uncurryThis$l = NATIVE_BIND$2 && bind$9.bind(call$g, call$g);
var functionUncurryThis = NATIVE_BIND$2 ? function (fn) {
  return fn && uncurryThis$l(fn);
} : function (fn) {
  return fn && function () {
    return call$g.apply(fn, arguments);
  };
};

var uncurryThis$k = functionUncurryThis;
var toString$7 = uncurryThis$k({}.toString);
var stringSlice$2 = uncurryThis$k(''.slice);
var classofRaw$1 = function (it) {
  return stringSlice$2(toString$7(it), 8, -1);
};

var global$J = global$K;
var uncurryThis$j = functionUncurryThis;
var fails$g = fails$j;
var classof$a = classofRaw$1;
var Object$5 = global$J.Object;
var split = uncurryThis$j(''.split);

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var indexedObject = fails$g(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !Object$5('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof$a(it) == 'String' ? split(it, '') : Object$5(it);
} : Object$5;

var global$I = global$K;
var TypeError$f = global$I.TypeError;

// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
var requireObjectCoercible$4 = function (it) {
  if (it == undefined) throw TypeError$f("Can't call method on " + it);
  return it;
};

// toObject with fallback for non-array-like ES3 strings
var IndexedObject$2 = indexedObject;
var requireObjectCoercible$3 = requireObjectCoercible$4;
var toIndexedObject$6 = function (it) {
  return IndexedObject$2(requireObjectCoercible$3(it));
};

// `IsCallable` abstract operation
// https://tc39.es/ecma262/#sec-iscallable
var isCallable$n = function (argument) {
  return typeof argument == 'function';
};

var isCallable$m = isCallable$n;
var isObject$e = function (it) {
  return typeof it == 'object' ? it !== null : isCallable$m(it);
};

var global$H = global$K;
var isCallable$l = isCallable$n;
var aFunction = function (argument) {
  return isCallable$l(argument) ? argument : undefined;
};
var getBuiltIn$a = function (namespace, method) {
  return arguments.length < 2 ? aFunction(global$H[namespace]) : global$H[namespace] && global$H[namespace][method];
};

var uncurryThis$i = functionUncurryThis;
var objectIsPrototypeOf = uncurryThis$i({}.isPrototypeOf);

var getBuiltIn$9 = getBuiltIn$a;
var engineUserAgent = getBuiltIn$9('navigator', 'userAgent') || '';

var global$G = global$K;
var userAgent$4 = engineUserAgent;
var process$3 = global$G.process;
var Deno$1 = global$G.Deno;
var versions = process$3 && process$3.versions || Deno$1 && Deno$1.version;
var v8 = versions && versions.v8;
var match$1, version$1;
if (v8) {
  match$1 = v8.split('.');
  // in old Chrome, versions of V8 isn't V8 = Chrome / 10
  // but their correct versions are not interesting for us
  version$1 = match$1[0] > 0 && match$1[0] < 4 ? 1 : +(match$1[0] + match$1[1]);
}

// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
// so check `userAgent` even if `.v8` exists, but 0
if (!version$1 && userAgent$4) {
  match$1 = userAgent$4.match(/Edge\/(\d+)/);
  if (!match$1 || match$1[1] >= 74) {
    match$1 = userAgent$4.match(/Chrome\/(\d+)/);
    if (match$1) version$1 = +match$1[1];
  }
}
var engineV8Version = version$1;

/* eslint-disable es-x/no-symbol -- required for testing */

var V8_VERSION$1 = engineV8Version;
var fails$f = fails$j;

// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- required for testing
var nativeSymbol = !!Object.getOwnPropertySymbols && !fails$f(function () {
  var symbol = Symbol();
  // Chrome 38 Symbol has incorrect toString conversion
  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||
  // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
  !Symbol.sham && V8_VERSION$1 && V8_VERSION$1 < 41;
});

/* eslint-disable es-x/no-symbol -- required for testing */

var NATIVE_SYMBOL$1 = nativeSymbol;
var useSymbolAsUid = NATIVE_SYMBOL$1 && !Symbol.sham && typeof Symbol.iterator == 'symbol';

var global$F = global$K;
var getBuiltIn$8 = getBuiltIn$a;
var isCallable$k = isCallable$n;
var isPrototypeOf$3 = objectIsPrototypeOf;
var USE_SYMBOL_AS_UID$1 = useSymbolAsUid;
var Object$4 = global$F.Object;
var isSymbol$2 = USE_SYMBOL_AS_UID$1 ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  var $Symbol = getBuiltIn$8('Symbol');
  return isCallable$k($Symbol) && isPrototypeOf$3($Symbol.prototype, Object$4(it));
};

var global$E = global$K;
var String$5 = global$E.String;
var tryToString$4 = function (argument) {
  try {
    return String$5(argument);
  } catch (error) {
    return 'Object';
  }
};

var global$D = global$K;
var isCallable$j = isCallable$n;
var tryToString$3 = tryToString$4;
var TypeError$e = global$D.TypeError;

// `Assert: IsCallable(argument) is true`
var aCallable$9 = function (argument) {
  if (isCallable$j(argument)) return argument;
  throw TypeError$e(tryToString$3(argument) + ' is not a function');
};

var aCallable$8 = aCallable$9;

// `GetMethod` abstract operation
// https://tc39.es/ecma262/#sec-getmethod
var getMethod$3 = function (V, P) {
  var func = V[P];
  return func == null ? undefined : aCallable$8(func);
};

var global$C = global$K;
var call$f = functionCall;
var isCallable$i = isCallable$n;
var isObject$d = isObject$e;
var TypeError$d = global$C.TypeError;

// `OrdinaryToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-ordinarytoprimitive
var ordinaryToPrimitive$1 = function (input, pref) {
  var fn, val;
  if (pref === 'string' && isCallable$i(fn = input.toString) && !isObject$d(val = call$f(fn, input))) return val;
  if (isCallable$i(fn = input.valueOf) && !isObject$d(val = call$f(fn, input))) return val;
  if (pref !== 'string' && isCallable$i(fn = input.toString) && !isObject$d(val = call$f(fn, input))) return val;
  throw TypeError$d("Can't convert object to primitive value");
};

var shared$3 = {exports: {}};

var global$B = global$K;

// eslint-disable-next-line es-x/no-object-defineproperty -- safe
var defineProperty$7 = Object.defineProperty;
var defineGlobalProperty$3 = function (key, value) {
  try {
    defineProperty$7(global$B, key, {
      value: value,
      configurable: true,
      writable: true
    });
  } catch (error) {
    global$B[key] = value;
  }
  return value;
};

var global$A = global$K;
var defineGlobalProperty$2 = defineGlobalProperty$3;
var SHARED = '__core-js_shared__';
var store$3 = global$A[SHARED] || defineGlobalProperty$2(SHARED, {});
var sharedStore = store$3;

var store$2 = sharedStore;
(shared$3.exports = function (key, value) {
  return store$2[key] || (store$2[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.22.6',
  mode: 'global',
  copyright: '© 2014-2022 Denis Pushkarev (zloirock.ru)',
  license: 'https://github.com/zloirock/core-js/blob/v3.22.6/LICENSE',
  source: 'https://github.com/zloirock/core-js'
});

var global$z = global$K;
var requireObjectCoercible$2 = requireObjectCoercible$4;
var Object$3 = global$z.Object;

// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
var toObject$5 = function (argument) {
  return Object$3(requireObjectCoercible$2(argument));
};

var uncurryThis$h = functionUncurryThis;
var toObject$4 = toObject$5;
var hasOwnProperty = uncurryThis$h({}.hasOwnProperty);

// `HasOwnProperty` abstract operation
// https://tc39.es/ecma262/#sec-hasownproperty
// eslint-disable-next-line es-x/no-object-hasown -- safe
var hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty(toObject$4(it), key);
};

var uncurryThis$g = functionUncurryThis;
var id$1 = 0;
var postfix = Math.random();
var toString$6 = uncurryThis$g(1.0.toString);
var uid$3 = function (key) {
  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString$6(++id$1 + postfix, 36);
};

var global$y = global$K;
var shared$2 = shared$3.exports;
var hasOwn$a = hasOwnProperty_1;
var uid$2 = uid$3;
var NATIVE_SYMBOL = nativeSymbol;
var USE_SYMBOL_AS_UID = useSymbolAsUid;
var WellKnownSymbolsStore = shared$2('wks');
var Symbol$1 = global$y.Symbol;
var symbolFor = Symbol$1 && Symbol$1['for'];
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid$2;
var wellKnownSymbol$h = function (name) {
  if (!hasOwn$a(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {
    var description = 'Symbol.' + name;
    if (NATIVE_SYMBOL && hasOwn$a(Symbol$1, name)) {
      WellKnownSymbolsStore[name] = Symbol$1[name];
    } else if (USE_SYMBOL_AS_UID && symbolFor) {
      WellKnownSymbolsStore[name] = symbolFor(description);
    } else {
      WellKnownSymbolsStore[name] = createWellKnownSymbol(description);
    }
  }
  return WellKnownSymbolsStore[name];
};

var global$x = global$K;
var call$e = functionCall;
var isObject$c = isObject$e;
var isSymbol$1 = isSymbol$2;
var getMethod$2 = getMethod$3;
var ordinaryToPrimitive = ordinaryToPrimitive$1;
var wellKnownSymbol$g = wellKnownSymbol$h;
var TypeError$c = global$x.TypeError;
var TO_PRIMITIVE = wellKnownSymbol$g('toPrimitive');

// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
var toPrimitive$1 = function (input, pref) {
  if (!isObject$c(input) || isSymbol$1(input)) return input;
  var exoticToPrim = getMethod$2(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === undefined) pref = 'default';
    result = call$e(exoticToPrim, input, pref);
    if (!isObject$c(result) || isSymbol$1(result)) return result;
    throw TypeError$c("Can't convert object to primitive value");
  }
  if (pref === undefined) pref = 'number';
  return ordinaryToPrimitive(input, pref);
};

var toPrimitive = toPrimitive$1;
var isSymbol = isSymbol$2;

// `ToPropertyKey` abstract operation
// https://tc39.es/ecma262/#sec-topropertykey
var toPropertyKey$3 = function (argument) {
  var key = toPrimitive(argument, 'string');
  return isSymbol(key) ? key : key + '';
};

var global$w = global$K;
var isObject$b = isObject$e;
var document$3 = global$w.document;
// typeof document.createElement is 'object' in old IE
var EXISTS$1 = isObject$b(document$3) && isObject$b(document$3.createElement);
var documentCreateElement$1 = function (it) {
  return EXISTS$1 ? document$3.createElement(it) : {};
};

var DESCRIPTORS$b = descriptors;
var fails$e = fails$j;
var createElement$2 = documentCreateElement$1;

// Thanks to IE8 for its funny defineProperty
var ie8DomDefine = !DESCRIPTORS$b && !fails$e(function () {
  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing
  return Object.defineProperty(createElement$2('div'), 'a', {
    get: function () {
      return 7;
    }
  }).a != 7;
});

var DESCRIPTORS$a = descriptors;
var call$d = functionCall;
var propertyIsEnumerableModule$1 = objectPropertyIsEnumerable;
var createPropertyDescriptor$5 = createPropertyDescriptor$6;
var toIndexedObject$5 = toIndexedObject$6;
var toPropertyKey$2 = toPropertyKey$3;
var hasOwn$9 = hasOwnProperty_1;
var IE8_DOM_DEFINE$1 = ie8DomDefine;

// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
objectGetOwnPropertyDescriptor.f = DESCRIPTORS$a ? $getOwnPropertyDescriptor$1 : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject$5(O);
  P = toPropertyKey$2(P);
  if (IE8_DOM_DEFINE$1) try {
    return $getOwnPropertyDescriptor$1(O, P);
  } catch (error) {/* empty */}
  if (hasOwn$9(O, P)) return createPropertyDescriptor$5(!call$d(propertyIsEnumerableModule$1.f, O, P), O[P]);
};

var objectDefineProperty = {};

var DESCRIPTORS$9 = descriptors;
var fails$d = fails$j;

// V8 ~ Chrome 36-
// https://bugs.chromium.org/p/v8/issues/detail?id=3334
var v8PrototypeDefineBug = DESCRIPTORS$9 && fails$d(function () {
  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing
  return Object.defineProperty(function () {/* empty */}, 'prototype', {
    value: 42,
    writable: false
  }).prototype != 42;
});

var global$v = global$K;
var isObject$a = isObject$e;
var String$4 = global$v.String;
var TypeError$b = global$v.TypeError;

// `Assert: Type(argument) is Object`
var anObject$b = function (argument) {
  if (isObject$a(argument)) return argument;
  throw TypeError$b(String$4(argument) + ' is not an object');
};

var global$u = global$K;
var DESCRIPTORS$8 = descriptors;
var IE8_DOM_DEFINE = ie8DomDefine;
var V8_PROTOTYPE_DEFINE_BUG$1 = v8PrototypeDefineBug;
var anObject$a = anObject$b;
var toPropertyKey$1 = toPropertyKey$3;
var TypeError$a = global$u.TypeError;
// eslint-disable-next-line es-x/no-object-defineproperty -- safe
var $defineProperty = Object.defineProperty;
// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var ENUMERABLE = 'enumerable';
var CONFIGURABLE$1 = 'configurable';
var WRITABLE = 'writable';

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
objectDefineProperty.f = DESCRIPTORS$8 ? V8_PROTOTYPE_DEFINE_BUG$1 ? function defineProperty(O, P, Attributes) {
  anObject$a(O);
  P = toPropertyKey$1(P);
  anObject$a(Attributes);
  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
    var current = $getOwnPropertyDescriptor(O, P);
    if (current && current[WRITABLE]) {
      O[P] = Attributes.value;
      Attributes = {
        configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],
        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  }
  return $defineProperty(O, P, Attributes);
} : $defineProperty : function defineProperty(O, P, Attributes) {
  anObject$a(O);
  P = toPropertyKey$1(P);
  anObject$a(Attributes);
  if (IE8_DOM_DEFINE) try {
    return $defineProperty(O, P, Attributes);
  } catch (error) {/* empty */}
  if ('get' in Attributes || 'set' in Attributes) throw TypeError$a('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

var DESCRIPTORS$7 = descriptors;
var definePropertyModule$4 = objectDefineProperty;
var createPropertyDescriptor$4 = createPropertyDescriptor$6;
var createNonEnumerableProperty$6 = DESCRIPTORS$7 ? function (object, key, value) {
  return definePropertyModule$4.f(object, key, createPropertyDescriptor$4(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

var makeBuiltIn$2 = {exports: {}};

var DESCRIPTORS$6 = descriptors;
var hasOwn$8 = hasOwnProperty_1;
var FunctionPrototype$1 = Function.prototype;
// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
var getDescriptor = DESCRIPTORS$6 && Object.getOwnPropertyDescriptor;
var EXISTS = hasOwn$8(FunctionPrototype$1, 'name');
// additional protection from minified / mangled / dropped function names
var PROPER = EXISTS && function something() {/* empty */}.name === 'something';
var CONFIGURABLE = EXISTS && (!DESCRIPTORS$6 || DESCRIPTORS$6 && getDescriptor(FunctionPrototype$1, 'name').configurable);
var functionName = {
  EXISTS: EXISTS,
  PROPER: PROPER,
  CONFIGURABLE: CONFIGURABLE
};

var uncurryThis$f = functionUncurryThis;
var isCallable$h = isCallable$n;
var store$1 = sharedStore;
var functionToString = uncurryThis$f(Function.toString);

// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
if (!isCallable$h(store$1.inspectSource)) {
  store$1.inspectSource = function (it) {
    return functionToString(it);
  };
}
var inspectSource$4 = store$1.inspectSource;

var global$t = global$K;
var isCallable$g = isCallable$n;
var inspectSource$3 = inspectSource$4;
var WeakMap$2 = global$t.WeakMap;
var nativeWeakMap = isCallable$g(WeakMap$2) && /native code/.test(inspectSource$3(WeakMap$2));

var shared$1 = shared$3.exports;
var uid$1 = uid$3;
var keys = shared$1('keys');
var sharedKey$3 = function (key) {
  return keys[key] || (keys[key] = uid$1(key));
};

var hiddenKeys$5 = {};

var NATIVE_WEAK_MAP = nativeWeakMap;
var global$s = global$K;
var uncurryThis$e = functionUncurryThis;
var isObject$9 = isObject$e;
var createNonEnumerableProperty$5 = createNonEnumerableProperty$6;
var hasOwn$7 = hasOwnProperty_1;
var shared = sharedStore;
var sharedKey$2 = sharedKey$3;
var hiddenKeys$4 = hiddenKeys$5;
var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
var TypeError$9 = global$s.TypeError;
var WeakMap$1 = global$s.WeakMap;
var set$1, get, has;
var enforce = function (it) {
  return has(it) ? get(it) : set$1(it, {});
};
var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject$9(it) || (state = get(it)).type !== TYPE) {
      throw TypeError$9('Incompatible receiver, ' + TYPE + ' required');
    }
    return state;
  };
};
if (NATIVE_WEAK_MAP || shared.state) {
  var store = shared.state || (shared.state = new WeakMap$1());
  var wmget = uncurryThis$e(store.get);
  var wmhas = uncurryThis$e(store.has);
  var wmset = uncurryThis$e(store.set);
  set$1 = function (it, metadata) {
    if (wmhas(store, it)) throw new TypeError$9(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    wmset(store, it, metadata);
    return metadata;
  };
  get = function (it) {
    return wmget(store, it) || {};
  };
  has = function (it) {
    return wmhas(store, it);
  };
} else {
  var STATE = sharedKey$2('state');
  hiddenKeys$4[STATE] = true;
  set$1 = function (it, metadata) {
    if (hasOwn$7(it, STATE)) throw new TypeError$9(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty$5(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return hasOwn$7(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return hasOwn$7(it, STATE);
  };
}
var internalState = {
  set: set$1,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};

var fails$c = fails$j;
var isCallable$f = isCallable$n;
var hasOwn$6 = hasOwnProperty_1;
var DESCRIPTORS$5 = descriptors;
var CONFIGURABLE_FUNCTION_NAME$1 = functionName.CONFIGURABLE;
var inspectSource$2 = inspectSource$4;
var InternalStateModule$4 = internalState;
var enforceInternalState = InternalStateModule$4.enforce;
var getInternalState$2 = InternalStateModule$4.get;
// eslint-disable-next-line es-x/no-object-defineproperty -- safe
var defineProperty$6 = Object.defineProperty;
var CONFIGURABLE_LENGTH = DESCRIPTORS$5 && !fails$c(function () {
  return defineProperty$6(function () {/* empty */}, 'length', {
    value: 8
  }).length !== 8;
});
var TEMPLATE = String(String).split('String');
var makeBuiltIn$1 = makeBuiltIn$2.exports = function (value, name, options) {
  if (String(name).slice(0, 7) === 'Symbol(') {
    name = '[' + String(name).replace(/^Symbol\(([^)]*)\)/, '$1') + ']';
  }
  if (options && options.getter) name = 'get ' + name;
  if (options && options.setter) name = 'set ' + name;
  if (!hasOwn$6(value, 'name') || CONFIGURABLE_FUNCTION_NAME$1 && value.name !== name) {
    defineProperty$6(value, 'name', {
      value: name,
      configurable: true
    });
  }
  if (CONFIGURABLE_LENGTH && options && hasOwn$6(options, 'arity') && value.length !== options.arity) {
    defineProperty$6(value, 'length', {
      value: options.arity
    });
  }
  if (options && hasOwn$6(options, 'constructor') && options.constructor) {
    if (DESCRIPTORS$5) try {
      defineProperty$6(value, 'prototype', {
        writable: false
      });
    } catch (error) {/* empty */}
  } else value.prototype = undefined;
  var state = enforceInternalState(value);
  if (!hasOwn$6(state, 'source')) {
    state.source = TEMPLATE.join(typeof name == 'string' ? name : '');
  }
  return value;
};

// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
// eslint-disable-next-line no-extend-native -- required
Function.prototype.toString = makeBuiltIn$1(function toString() {
  return isCallable$f(this) && getInternalState$2(this).source || inspectSource$2(this);
}, 'toString');

var isCallable$e = isCallable$n;
var createNonEnumerableProperty$4 = createNonEnumerableProperty$6;
var makeBuiltIn = makeBuiltIn$2.exports;
var defineGlobalProperty$1 = defineGlobalProperty$3;
var defineBuiltIn$9 = function (O, key, value, options) {
  if (!options) options = {};
  var simple = options.enumerable;
  var name = options.name !== undefined ? options.name : key;
  if (isCallable$e(value)) makeBuiltIn(value, name, options);
  if (options.global) {
    if (simple) O[key] = value;else defineGlobalProperty$1(key, value);
  } else {
    if (!options.unsafe) delete O[key];else if (O[key]) simple = true;
    if (simple) O[key] = value;else createNonEnumerableProperty$4(O, key, value);
  }
  return O;
};

var objectGetOwnPropertyNames = {};

var ceil = Math.ceil;
var floor = Math.floor;

// `Math.trunc` method
// https://tc39.es/ecma262/#sec-math.trunc
// eslint-disable-next-line es-x/no-math-trunc -- safe
var mathTrunc = Math.trunc || function trunc(x) {
  var n = +x;
  return (n > 0 ? floor : ceil)(n);
};

var trunc = mathTrunc;

// `ToIntegerOrInfinity` abstract operation
// https://tc39.es/ecma262/#sec-tointegerorinfinity
var toIntegerOrInfinity$3 = function (argument) {
  var number = +argument;
  // eslint-disable-next-line no-self-compare -- NaN check
  return number !== number || number === 0 ? 0 : trunc(number);
};

var toIntegerOrInfinity$2 = toIntegerOrInfinity$3;
var max$1 = Math.max;
var min$2 = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
var toAbsoluteIndex$2 = function (index, length) {
  var integer = toIntegerOrInfinity$2(index);
  return integer < 0 ? max$1(integer + length, 0) : min$2(integer, length);
};

var toIntegerOrInfinity$1 = toIntegerOrInfinity$3;
var min$1 = Math.min;

// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
var toLength$2 = function (argument) {
  return argument > 0 ? min$1(toIntegerOrInfinity$1(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};

var toLength$1 = toLength$2;

// `LengthOfArrayLike` abstract operation
// https://tc39.es/ecma262/#sec-lengthofarraylike
var lengthOfArrayLike$5 = function (obj) {
  return toLength$1(obj.length);
};

var toIndexedObject$4 = toIndexedObject$6;
var toAbsoluteIndex$1 = toAbsoluteIndex$2;
var lengthOfArrayLike$4 = lengthOfArrayLike$5;

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod$2 = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject$4($this);
    var length = lengthOfArrayLike$4(O);
    var index = toAbsoluteIndex$1(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare -- NaN check
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare -- NaN check
      if (value != value) return true;
      // Array#indexOf ignores holes, Array#includes - not
    } else for (; length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    }
    return !IS_INCLUDES && -1;
  };
};
var arrayIncludes = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod$2(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod$2(false)
};

var uncurryThis$d = functionUncurryThis;
var hasOwn$5 = hasOwnProperty_1;
var toIndexedObject$3 = toIndexedObject$6;
var indexOf$1 = arrayIncludes.indexOf;
var hiddenKeys$3 = hiddenKeys$5;
var push$2 = uncurryThis$d([].push);
var objectKeysInternal = function (object, names) {
  var O = toIndexedObject$3(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !hasOwn$5(hiddenKeys$3, key) && hasOwn$5(O, key) && push$2(result, key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (hasOwn$5(O, key = names[i++])) {
    ~indexOf$1(result, key) || push$2(result, key);
  }
  return result;
};

// IE8- don't enum bug keys
var enumBugKeys$3 = ['constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf'];

var internalObjectKeys$1 = objectKeysInternal;
var enumBugKeys$2 = enumBugKeys$3;
var hiddenKeys$2 = enumBugKeys$2.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es-x/no-object-getownpropertynames -- safe
objectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys$1(O, hiddenKeys$2);
};

var objectGetOwnPropertySymbols = {};

// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- safe
objectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;

var getBuiltIn$7 = getBuiltIn$a;
var uncurryThis$c = functionUncurryThis;
var getOwnPropertyNamesModule$1 = objectGetOwnPropertyNames;
var getOwnPropertySymbolsModule$1 = objectGetOwnPropertySymbols;
var anObject$9 = anObject$b;
var concat$1 = uncurryThis$c([].concat);

// all object keys, includes non-enumerable and symbols
var ownKeys$3 = getBuiltIn$7('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule$1.f(anObject$9(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule$1.f;
  return getOwnPropertySymbols ? concat$1(keys, getOwnPropertySymbols(it)) : keys;
};

var hasOwn$4 = hasOwnProperty_1;
var ownKeys$2 = ownKeys$3;
var getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;
var definePropertyModule$3 = objectDefineProperty;
var copyConstructorProperties$2 = function (target, source, exceptions) {
  var keys = ownKeys$2(source);
  var defineProperty = definePropertyModule$3.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!hasOwn$4(target, key) && !(exceptions && hasOwn$4(exceptions, key))) {
      defineProperty(target, key, getOwnPropertyDescriptor(source, key));
    }
  }
};

var fails$b = fails$j;
var isCallable$d = isCallable$n;
var replacement = /#|\.prototype\./;
var isForced$3 = function (feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true : value == NATIVE ? false : isCallable$d(detection) ? fails$b(detection) : !!detection;
};
var normalize = isForced$3.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};
var data = isForced$3.data = {};
var NATIVE = isForced$3.NATIVE = 'N';
var POLYFILL = isForced$3.POLYFILL = 'P';
var isForced_1 = isForced$3;

var global$r = global$K;
var getOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;
var createNonEnumerableProperty$3 = createNonEnumerableProperty$6;
var defineBuiltIn$8 = defineBuiltIn$9;
var defineGlobalProperty = defineGlobalProperty$3;
var copyConstructorProperties$1 = copyConstructorProperties$2;
var isForced$2 = isForced_1;

/*
  options.target         - name of the target object
  options.global         - target is the global object
  options.stat           - export as static methods of target
  options.proto          - export as prototype methods of target
  options.real           - real prototype method for the `pure` version
  options.forced         - export even if the native feature is available
  options.bind           - bind methods to the target, required for the `pure` version
  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe         - use the simple assignment of property instead of delete + defineProperty
  options.sham           - add a flag to not completely full polyfills
  options.enumerable     - export as enumerable property
  options.dontCallGetSet - prevent calling a getter on target
  options.name           - the .name of the function if it does not match the key
*/
var _export = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global$r;
  } else if (STATIC) {
    target = global$r[TARGET] || defineGlobalProperty(TARGET, {});
  } else {
    target = (global$r[TARGET] || {}).prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.dontCallGetSet) {
      descriptor = getOwnPropertyDescriptor$2(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced$2(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty == typeof targetProperty) continue;
      copyConstructorProperties$1(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || targetProperty && targetProperty.sham) {
      createNonEnumerableProperty$3(sourceProperty, 'sham', true);
    }
    defineBuiltIn$8(target, key, sourceProperty, options);
  }
};

var uncurryThis$b = functionUncurryThis;
var aCallable$7 = aCallable$9;
var NATIVE_BIND$1 = functionBindNative;
var bind$8 = uncurryThis$b(uncurryThis$b.bind);

// optional / simple context binding
var functionBindContext = function (fn, that) {
  aCallable$7(fn);
  return that === undefined ? fn : NATIVE_BIND$1 ? bind$8(fn, that) : function /* ...args */
  () {
    return fn.apply(that, arguments);
  };
};

var classof$9 = classofRaw$1;

// `IsArray` abstract operation
// https://tc39.es/ecma262/#sec-isarray
// eslint-disable-next-line es-x/no-array-isarray -- safe
var isArray$2 = Array.isArray || function isArray(argument) {
  return classof$9(argument) == 'Array';
};

var wellKnownSymbol$f = wellKnownSymbol$h;
var TO_STRING_TAG$3 = wellKnownSymbol$f('toStringTag');
var test = {};
test[TO_STRING_TAG$3] = 'z';
var toStringTagSupport = String(test) === '[object z]';

var global$q = global$K;
var TO_STRING_TAG_SUPPORT$2 = toStringTagSupport;
var isCallable$c = isCallable$n;
var classofRaw = classofRaw$1;
var wellKnownSymbol$e = wellKnownSymbol$h;
var TO_STRING_TAG$2 = wellKnownSymbol$e('toStringTag');
var Object$2 = global$q.Object;

// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () {
  return arguments;
}()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) {/* empty */}
};

// getting tag from ES6+ `Object.prototype.toString`
var classof$8 = TO_STRING_TAG_SUPPORT$2 ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
  // @@toStringTag case
  : typeof (tag = tryGet(O = Object$2(it), TO_STRING_TAG$2)) == 'string' ? tag
  // builtinTag case
  : CORRECT_ARGUMENTS ? classofRaw(O)
  // ES3 arguments fallback
  : (result = classofRaw(O)) == 'Object' && isCallable$c(O.callee) ? 'Arguments' : result;
};

var uncurryThis$a = functionUncurryThis;
var fails$a = fails$j;
var isCallable$b = isCallable$n;
var classof$7 = classof$8;
var getBuiltIn$6 = getBuiltIn$a;
var inspectSource$1 = inspectSource$4;
var noop$2 = function () {/* empty */};
var empty = [];
var construct = getBuiltIn$6('Reflect', 'construct');
var constructorRegExp = /^\s*(?:class|function)\b/;
var exec = uncurryThis$a(constructorRegExp.exec);
var INCORRECT_TO_STRING = !constructorRegExp.exec(noop$2);
var isConstructorModern = function isConstructor(argument) {
  if (!isCallable$b(argument)) return false;
  try {
    construct(noop$2, empty, argument);
    return true;
  } catch (error) {
    return false;
  }
};
var isConstructorLegacy = function isConstructor(argument) {
  if (!isCallable$b(argument)) return false;
  switch (classof$7(argument)) {
    case 'AsyncFunction':
    case 'GeneratorFunction':
    case 'AsyncGeneratorFunction':
      return false;
  }
  try {
    // we can't check .prototype since constructors produced by .bind haven't it
    // `Function#toString` throws on some built-it function in some legacy engines
    // (for example, `DOMQuad` and similar in FF41-)
    return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource$1(argument));
  } catch (error) {
    return true;
  }
};
isConstructorLegacy.sham = true;

// `IsConstructor` abstract operation
// https://tc39.es/ecma262/#sec-isconstructor
var isConstructor$3 = !construct || fails$a(function () {
  var called;
  return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function () {
    called = true;
  }) || called;
}) ? isConstructorLegacy : isConstructorModern;

var global$p = global$K;
var isArray$1 = isArray$2;
var isConstructor$2 = isConstructor$3;
var isObject$8 = isObject$e;
var wellKnownSymbol$d = wellKnownSymbol$h;
var SPECIES$3 = wellKnownSymbol$d('species');
var Array$3 = global$p.Array;

// a part of `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
var arraySpeciesConstructor$1 = function (originalArray) {
  var C;
  if (isArray$1(originalArray)) {
    C = originalArray.constructor;
    // cross-realm fallback
    if (isConstructor$2(C) && (C === Array$3 || isArray$1(C.prototype))) C = undefined;else if (isObject$8(C)) {
      C = C[SPECIES$3];
      if (C === null) C = undefined;
    }
  }
  return C === undefined ? Array$3 : C;
};

var arraySpeciesConstructor = arraySpeciesConstructor$1;

// `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
var arraySpeciesCreate$1 = function (originalArray, length) {
  return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
};

var bind$7 = functionBindContext;
var uncurryThis$9 = functionUncurryThis;
var IndexedObject$1 = indexedObject;
var toObject$3 = toObject$5;
var lengthOfArrayLike$3 = lengthOfArrayLike$5;
var arraySpeciesCreate = arraySpeciesCreate$1;
var push$1 = uncurryThis$9([].push);

// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation
var createMethod$1 = function (TYPE) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var IS_FILTER_REJECT = TYPE == 7;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  return function ($this, callbackfn, that, specificCreate) {
    var O = toObject$3($this);
    var self = IndexedObject$1(O);
    var boundFunction = bind$7(callbackfn, that);
    var length = lengthOfArrayLike$3(self);
    var index = 0;
    var create = specificCreate || arraySpeciesCreate;
    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;
    var value, result;
    for (; length > index; index++) if (NO_HOLES || index in self) {
      value = self[index];
      result = boundFunction(value, index, O);
      if (TYPE) {
        if (IS_MAP) target[index] = result; // map
        else if (result) switch (TYPE) {
          case 3:
            return true;
          // some
          case 5:
            return value;
          // find
          case 6:
            return index;
          // findIndex
          case 2:
            push$1(target, value);
          // filter
        } else switch (TYPE) {
          case 4:
            return false;
          // every
          case 7:
            push$1(target, value);
          // filterReject
        }
      }
    }

    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};
var arrayIteration = {
  // `Array.prototype.forEach` method
  // https://tc39.es/ecma262/#sec-array.prototype.foreach
  forEach: createMethod$1(0),
  // `Array.prototype.map` method
  // https://tc39.es/ecma262/#sec-array.prototype.map
  map: createMethod$1(1),
  // `Array.prototype.filter` method
  // https://tc39.es/ecma262/#sec-array.prototype.filter
  filter: createMethod$1(2),
  // `Array.prototype.some` method
  // https://tc39.es/ecma262/#sec-array.prototype.some
  some: createMethod$1(3),
  // `Array.prototype.every` method
  // https://tc39.es/ecma262/#sec-array.prototype.every
  every: createMethod$1(4),
  // `Array.prototype.find` method
  // https://tc39.es/ecma262/#sec-array.prototype.find
  find: createMethod$1(5),
  // `Array.prototype.findIndex` method
  // https://tc39.es/ecma262/#sec-array.prototype.findIndex
  findIndex: createMethod$1(6),
  // `Array.prototype.filterReject` method
  // https://github.com/tc39/proposal-array-filtering
  filterReject: createMethod$1(7)
};

var objectDefineProperties = {};

var internalObjectKeys = objectKeysInternal;
var enumBugKeys$1 = enumBugKeys$3;

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
// eslint-disable-next-line es-x/no-object-keys -- safe
var objectKeys$2 = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys$1);
};

var DESCRIPTORS$4 = descriptors;
var V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;
var definePropertyModule$2 = objectDefineProperty;
var anObject$8 = anObject$b;
var toIndexedObject$2 = toIndexedObject$6;
var objectKeys$1 = objectKeys$2;

// `Object.defineProperties` method
// https://tc39.es/ecma262/#sec-object.defineproperties
// eslint-disable-next-line es-x/no-object-defineproperties -- safe
objectDefineProperties.f = DESCRIPTORS$4 && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject$8(O);
  var props = toIndexedObject$2(Properties);
  var keys = objectKeys$1(Properties);
  var length = keys.length;
  var index = 0;
  var key;
  while (length > index) definePropertyModule$2.f(O, key = keys[index++], props[key]);
  return O;
};

var getBuiltIn$5 = getBuiltIn$a;
var html$2 = getBuiltIn$5('document', 'documentElement');

/* global ActiveXObject -- old IE, WSH */

var anObject$7 = anObject$b;
var definePropertiesModule = objectDefineProperties;
var enumBugKeys = enumBugKeys$3;
var hiddenKeys$1 = hiddenKeys$5;
var html$1 = html$2;
var documentCreateElement = documentCreateElement$1;
var sharedKey$1 = sharedKey$3;
var GT = '>';
var LT = '<';
var PROTOTYPE = 'prototype';
var SCRIPT = 'script';
var IE_PROTO$1 = sharedKey$1('IE_PROTO');
var EmptyConstructor = function () {/* empty */};
var scriptTag = function (content) {
  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
};

// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
var NullProtoObjectViaActiveX = function (activeXDocument) {
  activeXDocument.write(scriptTag(''));
  activeXDocument.close();
  var temp = activeXDocument.parentWindow.Object;
  activeXDocument = null; // avoid memory leak
  return temp;
};

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var NullProtoObjectViaIFrame = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var JS = 'java' + SCRIPT + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html$1.appendChild(iframe);
  // https://github.com/zloirock/core-js/issues/475
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag('document.F=Object'));
  iframeDocument.close();
  return iframeDocument.F;
};

// Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug
var activeXDocument;
var NullProtoObject = function () {
  try {
    activeXDocument = new ActiveXObject('htmlfile');
  } catch (error) {/* ignore */}
  NullProtoObject = typeof document != 'undefined' ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) // old IE
  : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument); // WSH
  var length = enumBugKeys.length;
  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
  return NullProtoObject();
};
hiddenKeys$1[IE_PROTO$1] = true;

// `Object.create` method
// https://tc39.es/ecma262/#sec-object.create
// eslint-disable-next-line es-x/no-object-create -- safe
var objectCreate = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    EmptyConstructor[PROTOTYPE] = anObject$7(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO$1] = O;
  } else result = NullProtoObject();
  return Properties === undefined ? result : definePropertiesModule.f(result, Properties);
};

var wellKnownSymbol$c = wellKnownSymbol$h;
var create$3 = objectCreate;
var defineProperty$5 = objectDefineProperty.f;
var UNSCOPABLES = wellKnownSymbol$c('unscopables');
var ArrayPrototype$1 = Array.prototype;

// Array.prototype[@@unscopables]
// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
if (ArrayPrototype$1[UNSCOPABLES] == undefined) {
  defineProperty$5(ArrayPrototype$1, UNSCOPABLES, {
    configurable: true,
    value: create$3(null)
  });
}

// add a key to Array.prototype[@@unscopables]
var addToUnscopables$3 = function (key) {
  ArrayPrototype$1[UNSCOPABLES][key] = true;
};

var $$n = _export;
var $find = arrayIteration.find;
var addToUnscopables$2 = addToUnscopables$3;
var FIND = 'find';
var SKIPS_HOLES$1 = true;

// Shouldn't skip holes
if (FIND in []) Array(1)[FIND](function () {
  SKIPS_HOLES$1 = false;
});

// `Array.prototype.find` method
// https://tc39.es/ecma262/#sec-array.prototype.find
$$n({
  target: 'Array',
  proto: true,
  forced: SKIPS_HOLES$1
}, {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables$2(FIND);

var global$o = global$K;
var uncurryThis$8 = functionUncurryThis;
var entryUnbind$3 = function (CONSTRUCTOR, METHOD) {
  return uncurryThis$8(global$o[CONSTRUCTOR].prototype[METHOD]);
};

var entryUnbind$2 = entryUnbind$3;
entryUnbind$2('Array', 'find');

var $$m = _export;
var $findIndex = arrayIteration.findIndex;
var addToUnscopables$1 = addToUnscopables$3;
var FIND_INDEX = 'findIndex';
var SKIPS_HOLES = true;

// Shouldn't skip holes
if (FIND_INDEX in []) Array(1)[FIND_INDEX](function () {
  SKIPS_HOLES = false;
});

// `Array.prototype.findIndex` method
// https://tc39.es/ecma262/#sec-array.prototype.findindex
$$m({
  target: 'Array',
  proto: true,
  forced: SKIPS_HOLES
}, {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
    return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables$1(FIND_INDEX);

var entryUnbind$1 = entryUnbind$3;
entryUnbind$1('Array', 'findIndex');

var global$n = global$K;
var classof$6 = classof$8;
var String$3 = global$n.String;
var toString$5 = function (argument) {
  if (classof$6(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');
  return String$3(argument);
};

var uncurryThis$7 = functionUncurryThis;
var toIntegerOrInfinity = toIntegerOrInfinity$3;
var toString$4 = toString$5;
var requireObjectCoercible$1 = requireObjectCoercible$4;
var charAt$1 = uncurryThis$7(''.charAt);
var charCodeAt = uncurryThis$7(''.charCodeAt);
var stringSlice$1 = uncurryThis$7(''.slice);
var createMethod = function (CONVERT_TO_STRING) {
  return function ($this, pos) {
    var S = toString$4(requireObjectCoercible$1($this));
    var position = toIntegerOrInfinity(pos);
    var size = S.length;
    var first, second;
    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
    first = charCodeAt(S, position);
    return first < 0xD800 || first > 0xDBFF || position + 1 === size || (second = charCodeAt(S, position + 1)) < 0xDC00 || second > 0xDFFF ? CONVERT_TO_STRING ? charAt$1(S, position) : first : CONVERT_TO_STRING ? stringSlice$1(S, position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
  };
};
var stringMultibyte = {
  // `String.prototype.codePointAt` method
  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
  codeAt: createMethod(false),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: createMethod(true)
};

var fails$9 = fails$j;
var correctPrototypeGetter = !fails$9(function () {
  function F() {/* empty */}
  F.prototype.constructor = null;
  // eslint-disable-next-line es-x/no-object-getprototypeof -- required for testing
  return Object.getPrototypeOf(new F()) !== F.prototype;
});

var global$m = global$K;
var hasOwn$3 = hasOwnProperty_1;
var isCallable$a = isCallable$n;
var toObject$2 = toObject$5;
var sharedKey = sharedKey$3;
var CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;
var IE_PROTO = sharedKey('IE_PROTO');
var Object$1 = global$m.Object;
var ObjectPrototype = Object$1.prototype;

// `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof
var objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER ? Object$1.getPrototypeOf : function (O) {
  var object = toObject$2(O);
  if (hasOwn$3(object, IE_PROTO)) return object[IE_PROTO];
  var constructor = object.constructor;
  if (isCallable$a(constructor) && object instanceof constructor) {
    return constructor.prototype;
  }
  return object instanceof Object$1 ? ObjectPrototype : null;
};

var fails$8 = fails$j;
var isCallable$9 = isCallable$n;
var getPrototypeOf$2 = objectGetPrototypeOf;
var defineBuiltIn$7 = defineBuiltIn$9;
var wellKnownSymbol$b = wellKnownSymbol$h;
var ITERATOR$4 = wellKnownSymbol$b('iterator');
var BUGGY_SAFARI_ITERATORS$1 = false;

// `%IteratorPrototype%` object
// https://tc39.es/ecma262/#sec-%iteratorprototype%-object
var IteratorPrototype$2, PrototypeOfArrayIteratorPrototype, arrayIterator;

/* eslint-disable es-x/no-array-prototype-keys -- safe */
if ([].keys) {
  arrayIterator = [].keys();
  // Safari 8 has buggy iterators w/o `next`
  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS$1 = true;else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf$2(getPrototypeOf$2(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype$2 = PrototypeOfArrayIteratorPrototype;
  }
}
var NEW_ITERATOR_PROTOTYPE = IteratorPrototype$2 == undefined || fails$8(function () {
  var test = {};
  // FF44- legacy iterators case
  return IteratorPrototype$2[ITERATOR$4].call(test) !== test;
});
if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype$2 = {};

// `%IteratorPrototype%[@@iterator]()` method
// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator
if (!isCallable$9(IteratorPrototype$2[ITERATOR$4])) {
  defineBuiltIn$7(IteratorPrototype$2, ITERATOR$4, function () {
    return this;
  });
}
var iteratorsCore = {
  IteratorPrototype: IteratorPrototype$2,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1
};

var defineProperty$4 = objectDefineProperty.f;
var hasOwn$2 = hasOwnProperty_1;
var wellKnownSymbol$a = wellKnownSymbol$h;
var TO_STRING_TAG$1 = wellKnownSymbol$a('toStringTag');
var setToStringTag$4 = function (target, TAG, STATIC) {
  if (target && !STATIC) target = target.prototype;
  if (target && !hasOwn$2(target, TO_STRING_TAG$1)) {
    defineProperty$4(target, TO_STRING_TAG$1, {
      configurable: true,
      value: TAG
    });
  }
};

var iterators = {};

var IteratorPrototype$1 = iteratorsCore.IteratorPrototype;
var create$2 = objectCreate;
var createPropertyDescriptor$3 = createPropertyDescriptor$6;
var setToStringTag$3 = setToStringTag$4;
var Iterators$4 = iterators;
var returnThis$1 = function () {
  return this;
};
var createIteratorConstructor$1 = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
  var TO_STRING_TAG = NAME + ' Iterator';
  IteratorConstructor.prototype = create$2(IteratorPrototype$1, {
    next: createPropertyDescriptor$3(+!ENUMERABLE_NEXT, next)
  });
  setToStringTag$3(IteratorConstructor, TO_STRING_TAG, false);
  Iterators$4[TO_STRING_TAG] = returnThis$1;
  return IteratorConstructor;
};

var global$l = global$K;
var isCallable$8 = isCallable$n;
var String$2 = global$l.String;
var TypeError$8 = global$l.TypeError;
var aPossiblePrototype$1 = function (argument) {
  if (typeof argument == 'object' || isCallable$8(argument)) return argument;
  throw TypeError$8("Can't set " + String$2(argument) + ' as a prototype');
};

/* eslint-disable no-proto -- safe */

var uncurryThis$6 = functionUncurryThis;
var anObject$6 = anObject$b;
var aPossiblePrototype = aPossiblePrototype$1;

// `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
// eslint-disable-next-line es-x/no-object-setprototypeof -- safe
var objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;
  try {
    // eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
    setter = uncurryThis$6(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set);
    setter(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) {/* empty */}
  return function setPrototypeOf(O, proto) {
    anObject$6(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER) setter(O, proto);else O.__proto__ = proto;
    return O;
  };
}() : undefined);

var $$l = _export;
var call$c = functionCall;
var FunctionName = functionName;
var isCallable$7 = isCallable$n;
var createIteratorConstructor = createIteratorConstructor$1;
var getPrototypeOf$1 = objectGetPrototypeOf;
var setPrototypeOf$3 = objectSetPrototypeOf;
var setToStringTag$2 = setToStringTag$4;
var createNonEnumerableProperty$2 = createNonEnumerableProperty$6;
var defineBuiltIn$6 = defineBuiltIn$9;
var wellKnownSymbol$9 = wellKnownSymbol$h;
var Iterators$3 = iterators;
var IteratorsCore = iteratorsCore;
var PROPER_FUNCTION_NAME = FunctionName.PROPER;
var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
var IteratorPrototype = IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR$3 = wellKnownSymbol$9('iterator');
var KEYS = 'keys';
var VALUES = 'values';
var ENTRIES = 'entries';
var returnThis = function () {
  return this;
};
var defineIterator$3 = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
  createIteratorConstructor(IteratorConstructor, NAME, next);
  var getIterationMethod = function (KIND) {
    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
    switch (KIND) {
      case KEYS:
        return function keys() {
          return new IteratorConstructor(this, KIND);
        };
      case VALUES:
        return function values() {
          return new IteratorConstructor(this, KIND);
        };
      case ENTRIES:
        return function entries() {
          return new IteratorConstructor(this, KIND);
        };
    }
    return function () {
      return new IteratorConstructor(this);
    };
  };
  var TO_STRING_TAG = NAME + ' Iterator';
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR$3] || IterablePrototype['@@iterator'] || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY;

  // fix native
  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf$1(anyNativeIterator.call(new Iterable()));
    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
      if (getPrototypeOf$1(CurrentIteratorPrototype) !== IteratorPrototype) {
        if (setPrototypeOf$3) {
          setPrototypeOf$3(CurrentIteratorPrototype, IteratorPrototype);
        } else if (!isCallable$7(CurrentIteratorPrototype[ITERATOR$3])) {
          defineBuiltIn$6(CurrentIteratorPrototype, ITERATOR$3, returnThis);
        }
      }
      // Set @@toStringTag to native iterators
      setToStringTag$2(CurrentIteratorPrototype, TO_STRING_TAG, true);
    }
  }

  // fix Array.prototype.{ values, @@iterator }.name in V8 / FF
  if (PROPER_FUNCTION_NAME && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    if (CONFIGURABLE_FUNCTION_NAME) {
      createNonEnumerableProperty$2(IterablePrototype, 'name', VALUES);
    } else {
      INCORRECT_VALUES_NAME = true;
      defaultIterator = function values() {
        return call$c(nativeIterator, this);
      };
    }
  }

  // export additional methods
  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED) for (KEY in methods) {
      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
        defineBuiltIn$6(IterablePrototype, KEY, methods[KEY]);
      }
    } else $$l({
      target: NAME,
      proto: true,
      forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME
    }, methods);
  }

  // define iterator
  if (IterablePrototype[ITERATOR$3] !== defaultIterator) {
    defineBuiltIn$6(IterablePrototype, ITERATOR$3, defaultIterator, {
      name: DEFAULT
    });
  }
  Iterators$3[NAME] = defaultIterator;
  return methods;
};

var charAt = stringMultibyte.charAt;
var toString$3 = toString$5;
var InternalStateModule$3 = internalState;
var defineIterator$2 = defineIterator$3;
var STRING_ITERATOR = 'String Iterator';
var setInternalState$3 = InternalStateModule$3.set;
var getInternalState$1 = InternalStateModule$3.getterFor(STRING_ITERATOR);

// `String.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-string.prototype-@@iterator
defineIterator$2(String, 'String', function (iterated) {
  setInternalState$3(this, {
    type: STRING_ITERATOR,
    string: toString$3(iterated),
    index: 0
  });
  // `%StringIteratorPrototype%.next` method
  // https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
}, function next() {
  var state = getInternalState$1(this);
  var string = state.string;
  var index = state.index;
  var point;
  if (index >= string.length) return {
    value: undefined,
    done: true
  };
  point = charAt(string, index);
  state.index += point.length;
  return {
    value: point,
    done: false
  };
});

var call$b = functionCall;
var anObject$5 = anObject$b;
var getMethod$1 = getMethod$3;
var iteratorClose$2 = function (iterator, kind, value) {
  var innerResult, innerError;
  anObject$5(iterator);
  try {
    innerResult = getMethod$1(iterator, 'return');
    if (!innerResult) {
      if (kind === 'throw') throw value;
      return value;
    }
    innerResult = call$b(innerResult, iterator);
  } catch (error) {
    innerError = true;
    innerResult = error;
  }
  if (kind === 'throw') throw value;
  if (innerError) throw innerResult;
  anObject$5(innerResult);
  return value;
};

var anObject$4 = anObject$b;
var iteratorClose$1 = iteratorClose$2;

// call something on iterator step with safe closing on error
var callWithSafeIterationClosing$1 = function (iterator, fn, value, ENTRIES) {
  try {
    return ENTRIES ? fn(anObject$4(value)[0], value[1]) : fn(value);
  } catch (error) {
    iteratorClose$1(iterator, 'throw', error);
  }
};

var wellKnownSymbol$8 = wellKnownSymbol$h;
var Iterators$2 = iterators;
var ITERATOR$2 = wellKnownSymbol$8('iterator');
var ArrayPrototype = Array.prototype;

// check on default Array iterator
var isArrayIteratorMethod$2 = function (it) {
  return it !== undefined && (Iterators$2.Array === it || ArrayPrototype[ITERATOR$2] === it);
};

var toPropertyKey = toPropertyKey$3;
var definePropertyModule$1 = objectDefineProperty;
var createPropertyDescriptor$2 = createPropertyDescriptor$6;
var createProperty$2 = function (object, key, value) {
  var propertyKey = toPropertyKey(key);
  if (propertyKey in object) definePropertyModule$1.f(object, propertyKey, createPropertyDescriptor$2(0, value));else object[propertyKey] = value;
};

var classof$5 = classof$8;
var getMethod = getMethod$3;
var Iterators$1 = iterators;
var wellKnownSymbol$7 = wellKnownSymbol$h;
var ITERATOR$1 = wellKnownSymbol$7('iterator');
var getIteratorMethod$3 = function (it) {
  if (it != undefined) return getMethod(it, ITERATOR$1) || getMethod(it, '@@iterator') || Iterators$1[classof$5(it)];
};

var global$k = global$K;
var call$a = functionCall;
var aCallable$6 = aCallable$9;
var anObject$3 = anObject$b;
var tryToString$2 = tryToString$4;
var getIteratorMethod$2 = getIteratorMethod$3;
var TypeError$7 = global$k.TypeError;
var getIterator$2 = function (argument, usingIterator) {
  var iteratorMethod = arguments.length < 2 ? getIteratorMethod$2(argument) : usingIterator;
  if (aCallable$6(iteratorMethod)) return anObject$3(call$a(iteratorMethod, argument));
  throw TypeError$7(tryToString$2(argument) + ' is not iterable');
};

var global$j = global$K;
var bind$6 = functionBindContext;
var call$9 = functionCall;
var toObject$1 = toObject$5;
var callWithSafeIterationClosing = callWithSafeIterationClosing$1;
var isArrayIteratorMethod$1 = isArrayIteratorMethod$2;
var isConstructor$1 = isConstructor$3;
var lengthOfArrayLike$2 = lengthOfArrayLike$5;
var createProperty$1 = createProperty$2;
var getIterator$1 = getIterator$2;
var getIteratorMethod$1 = getIteratorMethod$3;
var Array$2 = global$j.Array;

// `Array.from` method implementation
// https://tc39.es/ecma262/#sec-array.from
var arrayFrom = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
  var O = toObject$1(arrayLike);
  var IS_CONSTRUCTOR = isConstructor$1(this);
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
  var mapping = mapfn !== undefined;
  if (mapping) mapfn = bind$6(mapfn, argumentsLength > 2 ? arguments[2] : undefined);
  var iteratorMethod = getIteratorMethod$1(O);
  var index = 0;
  var length, result, step, iterator, next, value;
  // if the target is not iterable or it's an array with the default iterator - use a simple case
  if (iteratorMethod && !(this == Array$2 && isArrayIteratorMethod$1(iteratorMethod))) {
    iterator = getIterator$1(O, iteratorMethod);
    next = iterator.next;
    result = IS_CONSTRUCTOR ? new this() : [];
    for (; !(step = call$9(next, iterator)).done; index++) {
      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
      createProperty$1(result, index, value);
    }
  } else {
    length = lengthOfArrayLike$2(O);
    result = IS_CONSTRUCTOR ? new this(length) : Array$2(length);
    for (; length > index; index++) {
      value = mapping ? mapfn(O[index], index) : O[index];
      createProperty$1(result, index, value);
    }
  }
  result.length = index;
  return result;
};

var wellKnownSymbol$6 = wellKnownSymbol$h;
var ITERATOR = wellKnownSymbol$6('iterator');
var SAFE_CLOSING = false;
try {
  var called = 0;
  var iteratorWithReturn = {
    next: function () {
      return {
        done: !!called++
      };
    },
    'return': function () {
      SAFE_CLOSING = true;
    }
  };
  iteratorWithReturn[ITERATOR] = function () {
    return this;
  };
  // eslint-disable-next-line es-x/no-array-from, no-throw-literal -- required for testing
  Array.from(iteratorWithReturn, function () {
    throw 2;
  });
} catch (error) {/* empty */}
var checkCorrectnessOfIteration$3 = function (exec, SKIP_CLOSING) {
  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
  var ITERATION_SUPPORT = false;
  try {
    var object = {};
    object[ITERATOR] = function () {
      return {
        next: function () {
          return {
            done: ITERATION_SUPPORT = true
          };
        }
      };
    };
    exec(object);
  } catch (error) {/* empty */}
  return ITERATION_SUPPORT;
};

var $$k = _export;
var from = arrayFrom;
var checkCorrectnessOfIteration$2 = checkCorrectnessOfIteration$3;
var INCORRECT_ITERATION = !checkCorrectnessOfIteration$2(function (iterable) {
  // eslint-disable-next-line es-x/no-array-from -- required for testing
  Array.from(iterable);
});

// `Array.from` method
// https://tc39.es/ecma262/#sec-array.from
$$k({
  target: 'Array',
  stat: true,
  forced: INCORRECT_ITERATION
}, {
  from: from
});

var global$i = global$K;
var path$5 = global$i;

var path$4 = path$5;
path$4.Array.from;

var toIndexedObject$1 = toIndexedObject$6;
var addToUnscopables = addToUnscopables$3;
var Iterators = iterators;
var InternalStateModule$2 = internalState;
var defineProperty$3 = objectDefineProperty.f;
var defineIterator$1 = defineIterator$3;
var DESCRIPTORS$3 = descriptors;
var ARRAY_ITERATOR = 'Array Iterator';
var setInternalState$2 = InternalStateModule$2.set;
var getInternalState = InternalStateModule$2.getterFor(ARRAY_ITERATOR);

// `Array.prototype.entries` method
// https://tc39.es/ecma262/#sec-array.prototype.entries
// `Array.prototype.keys` method
// https://tc39.es/ecma262/#sec-array.prototype.keys
// `Array.prototype.values` method
// https://tc39.es/ecma262/#sec-array.prototype.values
// `Array.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-array.prototype-@@iterator
// `CreateArrayIterator` internal method
// https://tc39.es/ecma262/#sec-createarrayiterator
defineIterator$1(Array, 'Array', function (iterated, kind) {
  setInternalState$2(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject$1(iterated),
    // target
    index: 0,
    // next index
    kind: kind // kind
  });
  // `%ArrayIteratorPrototype%.next` method
  // https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
}, function () {
  var state = getInternalState(this);
  var target = state.target;
  var kind = state.kind;
  var index = state.index++;
  if (!target || index >= target.length) {
    state.target = undefined;
    return {
      value: undefined,
      done: true
    };
  }
  if (kind == 'keys') return {
    value: index,
    done: false
  };
  if (kind == 'values') return {
    value: target[index],
    done: false
  };
  return {
    value: [index, target[index]],
    done: false
  };
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values%
// https://tc39.es/ecma262/#sec-createunmappedargumentsobject
// https://tc39.es/ecma262/#sec-createmappedargumentsobject
var values = Iterators.Arguments = Iterators.Array;

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

// V8 ~ Chrome 45- bug
if (DESCRIPTORS$3 && values.name !== 'values') try {
  defineProperty$3(values, 'name', {
    value: 'values'
  });
} catch (error) {/* empty */}

var internalMetadata = {exports: {}};

var objectGetOwnPropertyNamesExternal = {};

var global$h = global$K;
var toAbsoluteIndex = toAbsoluteIndex$2;
var lengthOfArrayLike$1 = lengthOfArrayLike$5;
var createProperty = createProperty$2;
var Array$1 = global$h.Array;
var max = Math.max;
var arraySliceSimple = function (O, start, end) {
  var length = lengthOfArrayLike$1(O);
  var k = toAbsoluteIndex(start, length);
  var fin = toAbsoluteIndex(end === undefined ? length : end, length);
  var result = Array$1(max(fin - k, 0));
  for (var n = 0; k < fin; k++, n++) createProperty(result, n, O[k]);
  result.length = n;
  return result;
};

/* eslint-disable es-x/no-object-getownpropertynames -- safe */

var classof$4 = classofRaw$1;
var toIndexedObject = toIndexedObject$6;
var $getOwnPropertyNames = objectGetOwnPropertyNames.f;
var arraySlice$2 = arraySliceSimple;
var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
var getWindowNames = function (it) {
  try {
    return $getOwnPropertyNames(it);
  } catch (error) {
    return arraySlice$2(windowNames);
  }
};

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
objectGetOwnPropertyNamesExternal.f = function getOwnPropertyNames(it) {
  return windowNames && classof$4(it) == 'Window' ? getWindowNames(it) : $getOwnPropertyNames(toIndexedObject(it));
};

// FF26- bug: ArrayBuffers are non-extensible, but Object.isExtensible does not report it
var fails$7 = fails$j;
var arrayBufferNonExtensible = fails$7(function () {
  if (typeof ArrayBuffer == 'function') {
    var buffer = new ArrayBuffer(8);
    // eslint-disable-next-line es-x/no-object-isextensible, es-x/no-object-defineproperty -- safe
    if (Object.isExtensible(buffer)) Object.defineProperty(buffer, 'a', {
      value: 8
    });
  }
});

var fails$6 = fails$j;
var isObject$7 = isObject$e;
var classof$3 = classofRaw$1;
var ARRAY_BUFFER_NON_EXTENSIBLE = arrayBufferNonExtensible;

// eslint-disable-next-line es-x/no-object-isextensible -- safe
var $isExtensible = Object.isExtensible;
var FAILS_ON_PRIMITIVES = fails$6(function () {
  $isExtensible(1);
});

// `Object.isExtensible` method
// https://tc39.es/ecma262/#sec-object.isextensible
var objectIsExtensible = FAILS_ON_PRIMITIVES || ARRAY_BUFFER_NON_EXTENSIBLE ? function isExtensible(it) {
  if (!isObject$7(it)) return false;
  if (ARRAY_BUFFER_NON_EXTENSIBLE && classof$3(it) == 'ArrayBuffer') return false;
  return $isExtensible ? $isExtensible(it) : true;
} : $isExtensible;

var fails$5 = fails$j;
var freezing = !fails$5(function () {
  // eslint-disable-next-line es-x/no-object-isextensible, es-x/no-object-preventextensions -- required for testing
  return Object.isExtensible(Object.preventExtensions({}));
});

var $$j = _export;
var uncurryThis$5 = functionUncurryThis;
var hiddenKeys = hiddenKeys$5;
var isObject$6 = isObject$e;
var hasOwn$1 = hasOwnProperty_1;
var defineProperty$2 = objectDefineProperty.f;
var getOwnPropertyNamesModule = objectGetOwnPropertyNames;
var getOwnPropertyNamesExternalModule = objectGetOwnPropertyNamesExternal;
var isExtensible = objectIsExtensible;
var uid = uid$3;
var FREEZING = freezing;
var REQUIRED = false;
var METADATA = uid('meta');
var id = 0;
var setMetadata = function (it) {
  defineProperty$2(it, METADATA, {
    value: {
      objectID: 'O' + id++,
      // object ID
      weakData: {} // weak collections IDs
    }
  });
};

var fastKey$1 = function (it, create) {
  // return a primitive with prefix
  if (!isObject$6(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!hasOwn$1(it, METADATA)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMetadata(it);
    // return object ID
  }
  return it[METADATA].objectID;
};
var getWeakData = function (it, create) {
  if (!hasOwn$1(it, METADATA)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMetadata(it);
    // return the store of weak collections IDs
  }
  return it[METADATA].weakData;
};

// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZING && REQUIRED && isExtensible(it) && !hasOwn$1(it, METADATA)) setMetadata(it);
  return it;
};
var enable = function () {
  meta.enable = function () {/* empty */};
  REQUIRED = true;
  var getOwnPropertyNames = getOwnPropertyNamesModule.f;
  var splice = uncurryThis$5([].splice);
  var test = {};
  test[METADATA] = 1;

  // prevent exposing of metadata key
  if (getOwnPropertyNames(test).length) {
    getOwnPropertyNamesModule.f = function (it) {
      var result = getOwnPropertyNames(it);
      for (var i = 0, length = result.length; i < length; i++) {
        if (result[i] === METADATA) {
          splice(result, i, 1);
          break;
        }
      }
      return result;
    };
    $$j({
      target: 'Object',
      stat: true,
      forced: true
    }, {
      getOwnPropertyNames: getOwnPropertyNamesExternalModule.f
    });
  }
};
var meta = internalMetadata.exports = {
  enable: enable,
  fastKey: fastKey$1,
  getWeakData: getWeakData,
  onFreeze: onFreeze
};
hiddenKeys[METADATA] = true;

var global$g = global$K;
var bind$5 = functionBindContext;
var call$8 = functionCall;
var anObject$2 = anObject$b;
var tryToString$1 = tryToString$4;
var isArrayIteratorMethod = isArrayIteratorMethod$2;
var lengthOfArrayLike = lengthOfArrayLike$5;
var isPrototypeOf$2 = objectIsPrototypeOf;
var getIterator = getIterator$2;
var getIteratorMethod = getIteratorMethod$3;
var iteratorClose = iteratorClose$2;
var TypeError$6 = global$g.TypeError;
var Result = function (stopped, result) {
  this.stopped = stopped;
  this.result = result;
};
var ResultPrototype = Result.prototype;
var iterate$7 = function (iterable, unboundFunction, options) {
  var that = options && options.that;
  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
  var INTERRUPTED = !!(options && options.INTERRUPTED);
  var fn = bind$5(unboundFunction, that);
  var iterator, iterFn, index, length, result, next, step;
  var stop = function (condition) {
    if (iterator) iteratorClose(iterator, 'normal', condition);
    return new Result(true, condition);
  };
  var callFn = function (value) {
    if (AS_ENTRIES) {
      anObject$2(value);
      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
    }
    return INTERRUPTED ? fn(value, stop) : fn(value);
  };
  if (IS_ITERATOR) {
    iterator = iterable;
  } else {
    iterFn = getIteratorMethod(iterable);
    if (!iterFn) throw TypeError$6(tryToString$1(iterable) + ' is not iterable');
    // optimisation for array iterators
    if (isArrayIteratorMethod(iterFn)) {
      for (index = 0, length = lengthOfArrayLike(iterable); length > index; index++) {
        result = callFn(iterable[index]);
        if (result && isPrototypeOf$2(ResultPrototype, result)) return result;
      }
      return new Result(false);
    }
    iterator = getIterator(iterable, iterFn);
  }
  next = iterator.next;
  while (!(step = call$8(next, iterator)).done) {
    try {
      result = callFn(step.value);
    } catch (error) {
      iteratorClose(iterator, 'throw', error);
    }
    if (typeof result == 'object' && result && isPrototypeOf$2(ResultPrototype, result)) return result;
  }
  return new Result(false);
};

var global$f = global$K;
var isPrototypeOf$1 = objectIsPrototypeOf;
var TypeError$5 = global$f.TypeError;
var anInstance$3 = function (it, Prototype) {
  if (isPrototypeOf$1(Prototype, it)) return it;
  throw TypeError$5('Incorrect invocation');
};

var isCallable$6 = isCallable$n;
var isObject$5 = isObject$e;
var setPrototypeOf$2 = objectSetPrototypeOf;

// makes subclassing work correct for wrapped built-ins
var inheritIfRequired$1 = function ($this, dummy, Wrapper) {
  var NewTarget, NewTargetPrototype;
  if (
  // it can work only with native `setPrototypeOf`
  setPrototypeOf$2 &&
  // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
  isCallable$6(NewTarget = dummy.constructor) && NewTarget !== Wrapper && isObject$5(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype) setPrototypeOf$2($this, NewTargetPrototype);
  return $this;
};

var $$i = _export;
var global$e = global$K;
var uncurryThis$4 = functionUncurryThis;
var isForced$1 = isForced_1;
var defineBuiltIn$5 = defineBuiltIn$9;
var InternalMetadataModule = internalMetadata.exports;
var iterate$6 = iterate$7;
var anInstance$2 = anInstance$3;
var isCallable$5 = isCallable$n;
var isObject$4 = isObject$e;
var fails$4 = fails$j;
var checkCorrectnessOfIteration$1 = checkCorrectnessOfIteration$3;
var setToStringTag$1 = setToStringTag$4;
var inheritIfRequired = inheritIfRequired$1;
var collection$2 = function (CONSTRUCTOR_NAME, wrapper, common) {
  var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;
  var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;
  var ADDER = IS_MAP ? 'set' : 'add';
  var NativeConstructor = global$e[CONSTRUCTOR_NAME];
  var NativePrototype = NativeConstructor && NativeConstructor.prototype;
  var Constructor = NativeConstructor;
  var exported = {};
  var fixMethod = function (KEY) {
    var uncurriedNativeMethod = uncurryThis$4(NativePrototype[KEY]);
    defineBuiltIn$5(NativePrototype, KEY, KEY == 'add' ? function add(value) {
      uncurriedNativeMethod(this, value === 0 ? 0 : value);
      return this;
    } : KEY == 'delete' ? function (key) {
      return IS_WEAK && !isObject$4(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
    } : KEY == 'get' ? function get(key) {
      return IS_WEAK && !isObject$4(key) ? undefined : uncurriedNativeMethod(this, key === 0 ? 0 : key);
    } : KEY == 'has' ? function has(key) {
      return IS_WEAK && !isObject$4(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
    } : function set(key, value) {
      uncurriedNativeMethod(this, key === 0 ? 0 : key, value);
      return this;
    });
  };
  var REPLACE = isForced$1(CONSTRUCTOR_NAME, !isCallable$5(NativeConstructor) || !(IS_WEAK || NativePrototype.forEach && !fails$4(function () {
    new NativeConstructor().entries().next();
  })));
  if (REPLACE) {
    // create collection constructor
    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
    InternalMetadataModule.enable();
  } else if (isForced$1(CONSTRUCTOR_NAME, true)) {
    var instance = new Constructor();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~ Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails$4(function () {
      instance.has(1);
    });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    // eslint-disable-next-line no-new -- required for testing
    var ACCEPT_ITERABLES = checkCorrectnessOfIteration$1(function (iterable) {
      new NativeConstructor(iterable);
    });
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails$4(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new NativeConstructor();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });
    if (!ACCEPT_ITERABLES) {
      Constructor = wrapper(function (dummy, iterable) {
        anInstance$2(dummy, NativePrototype);
        var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
        if (iterable != undefined) iterate$6(iterable, that[ADDER], {
          that: that,
          AS_ENTRIES: IS_MAP
        });
        return that;
      });
      Constructor.prototype = NativePrototype;
      NativePrototype.constructor = Constructor;
    }
    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);

    // weak collections should not contains .clear method
    if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;
  }
  exported[CONSTRUCTOR_NAME] = Constructor;
  $$i({
    global: true,
    constructor: true,
    forced: Constructor != NativeConstructor
  }, exported);
  setToStringTag$1(Constructor, CONSTRUCTOR_NAME);
  if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);
  return Constructor;
};

var defineBuiltIn$4 = defineBuiltIn$9;
var defineBuiltIns$1 = function (target, src, options) {
  for (var key in src) defineBuiltIn$4(target, key, src[key], options);
  return target;
};

var getBuiltIn$4 = getBuiltIn$a;
var definePropertyModule = objectDefineProperty;
var wellKnownSymbol$5 = wellKnownSymbol$h;
var DESCRIPTORS$2 = descriptors;
var SPECIES$2 = wellKnownSymbol$5('species');
var setSpecies$2 = function (CONSTRUCTOR_NAME) {
  var Constructor = getBuiltIn$4(CONSTRUCTOR_NAME);
  var defineProperty = definePropertyModule.f;
  if (DESCRIPTORS$2 && Constructor && !Constructor[SPECIES$2]) {
    defineProperty(Constructor, SPECIES$2, {
      configurable: true,
      get: function () {
        return this;
      }
    });
  }
};

var defineProperty$1 = objectDefineProperty.f;
var create$1 = objectCreate;
var defineBuiltIns = defineBuiltIns$1;
var bind$4 = functionBindContext;
var anInstance$1 = anInstance$3;
var iterate$5 = iterate$7;
var defineIterator = defineIterator$3;
var setSpecies$1 = setSpecies$2;
var DESCRIPTORS$1 = descriptors;
var fastKey = internalMetadata.exports.fastKey;
var InternalStateModule$1 = internalState;
var setInternalState$1 = InternalStateModule$1.set;
var internalStateGetterFor = InternalStateModule$1.getterFor;
var collectionStrong$2 = {
  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
    var Constructor = wrapper(function (that, iterable) {
      anInstance$1(that, Prototype);
      setInternalState$1(that, {
        type: CONSTRUCTOR_NAME,
        index: create$1(null),
        first: undefined,
        last: undefined,
        size: 0
      });
      if (!DESCRIPTORS$1) that.size = 0;
      if (iterable != undefined) iterate$5(iterable, that[ADDER], {
        that: that,
        AS_ENTRIES: IS_MAP
      });
    });
    var Prototype = Constructor.prototype;
    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);
    var define = function (that, key, value) {
      var state = getInternalState(that);
      var entry = getEntry(that, key);
      var previous, index;
      // change existing entry
      if (entry) {
        entry.value = value;
        // create new entry
      } else {
        state.last = entry = {
          index: index = fastKey(key, true),
          key: key,
          value: value,
          previous: previous = state.last,
          next: undefined,
          removed: false
        };
        if (!state.first) state.first = entry;
        if (previous) previous.next = entry;
        if (DESCRIPTORS$1) state.size++;else that.size++;
        // add to index
        if (index !== 'F') state.index[index] = entry;
      }
      return that;
    };
    var getEntry = function (that, key) {
      var state = getInternalState(that);
      // fast case
      var index = fastKey(key);
      var entry;
      if (index !== 'F') return state.index[index];
      // frozen object case
      for (entry = state.first; entry; entry = entry.next) {
        if (entry.key == key) return entry;
      }
    };
    defineBuiltIns(Prototype, {
      // `{ Map, Set }.prototype.clear()` methods
      // https://tc39.es/ecma262/#sec-map.prototype.clear
      // https://tc39.es/ecma262/#sec-set.prototype.clear
      clear: function clear() {
        var that = this;
        var state = getInternalState(that);
        var data = state.index;
        var entry = state.first;
        while (entry) {
          entry.removed = true;
          if (entry.previous) entry.previous = entry.previous.next = undefined;
          delete data[entry.index];
          entry = entry.next;
        }
        state.first = state.last = undefined;
        if (DESCRIPTORS$1) state.size = 0;else that.size = 0;
      },
      // `{ Map, Set }.prototype.delete(key)` methods
      // https://tc39.es/ecma262/#sec-map.prototype.delete
      // https://tc39.es/ecma262/#sec-set.prototype.delete
      'delete': function (key) {
        var that = this;
        var state = getInternalState(that);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.next;
          var prev = entry.previous;
          delete state.index[entry.index];
          entry.removed = true;
          if (prev) prev.next = next;
          if (next) next.previous = prev;
          if (state.first == entry) state.first = next;
          if (state.last == entry) state.last = prev;
          if (DESCRIPTORS$1) state.size--;else that.size--;
        }
        return !!entry;
      },
      // `{ Map, Set }.prototype.forEach(callbackfn, thisArg = undefined)` methods
      // https://tc39.es/ecma262/#sec-map.prototype.foreach
      // https://tc39.es/ecma262/#sec-set.prototype.foreach
      forEach: function forEach(callbackfn /* , that = undefined */) {
        var state = getInternalState(this);
        var boundFunction = bind$4(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
        var entry;
        while (entry = entry ? entry.next : state.first) {
          boundFunction(entry.value, entry.key, this);
          // revert to the last existing entry
          while (entry && entry.removed) entry = entry.previous;
        }
      },
      // `{ Map, Set}.prototype.has(key)` methods
      // https://tc39.es/ecma262/#sec-map.prototype.has
      // https://tc39.es/ecma262/#sec-set.prototype.has
      has: function has(key) {
        return !!getEntry(this, key);
      }
    });
    defineBuiltIns(Prototype, IS_MAP ? {
      // `Map.prototype.get(key)` method
      // https://tc39.es/ecma262/#sec-map.prototype.get
      get: function get(key) {
        var entry = getEntry(this, key);
        return entry && entry.value;
      },
      // `Map.prototype.set(key, value)` method
      // https://tc39.es/ecma262/#sec-map.prototype.set
      set: function set(key, value) {
        return define(this, key === 0 ? 0 : key, value);
      }
    } : {
      // `Set.prototype.add(value)` method
      // https://tc39.es/ecma262/#sec-set.prototype.add
      add: function add(value) {
        return define(this, value = value === 0 ? 0 : value, value);
      }
    });
    if (DESCRIPTORS$1) defineProperty$1(Prototype, 'size', {
      get: function () {
        return getInternalState(this).size;
      }
    });
    return Constructor;
  },
  setStrong: function (Constructor, CONSTRUCTOR_NAME, IS_MAP) {
    var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';
    var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
    var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);
    // `{ Map, Set }.prototype.{ keys, values, entries, @@iterator }()` methods
    // https://tc39.es/ecma262/#sec-map.prototype.entries
    // https://tc39.es/ecma262/#sec-map.prototype.keys
    // https://tc39.es/ecma262/#sec-map.prototype.values
    // https://tc39.es/ecma262/#sec-map.prototype-@@iterator
    // https://tc39.es/ecma262/#sec-set.prototype.entries
    // https://tc39.es/ecma262/#sec-set.prototype.keys
    // https://tc39.es/ecma262/#sec-set.prototype.values
    // https://tc39.es/ecma262/#sec-set.prototype-@@iterator
    defineIterator(Constructor, CONSTRUCTOR_NAME, function (iterated, kind) {
      setInternalState$1(this, {
        type: ITERATOR_NAME,
        target: iterated,
        state: getInternalCollectionState(iterated),
        kind: kind,
        last: undefined
      });
    }, function () {
      var state = getInternalIteratorState(this);
      var kind = state.kind;
      var entry = state.last;
      // revert to the last existing entry
      while (entry && entry.removed) entry = entry.previous;
      // get next entry
      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
        // or finish the iteration
        state.target = undefined;
        return {
          value: undefined,
          done: true
        };
      }
      // return step by kind
      if (kind == 'keys') return {
        value: entry.key,
        done: false
      };
      if (kind == 'values') return {
        value: entry.value,
        done: false
      };
      return {
        value: [entry.key, entry.value],
        done: false
      };
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // `{ Map, Set }.prototype[@@species]` accessors
    // https://tc39.es/ecma262/#sec-get-map-@@species
    // https://tc39.es/ecma262/#sec-get-set-@@species
    setSpecies$1(CONSTRUCTOR_NAME);
  }
};

var collection$1 = collection$2;
var collectionStrong$1 = collectionStrong$2;

// `Map` constructor
// https://tc39.es/ecma262/#sec-map-objects
collection$1('Map', function (init) {
  return function Map() {
    return init(this, arguments.length ? arguments[0] : undefined);
  };
}, collectionStrong$1);

var TO_STRING_TAG_SUPPORT$1 = toStringTagSupport;
var classof$2 = classof$8;

// `Object.prototype.toString` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.tostring
var objectToString = TO_STRING_TAG_SUPPORT$1 ? {}.toString : function toString() {
  return '[object ' + classof$2(this) + ']';
};

var TO_STRING_TAG_SUPPORT = toStringTagSupport;
var defineBuiltIn$3 = defineBuiltIn$9;
var toString$2 = objectToString;

// `Object.prototype.toString` method
// https://tc39.es/ecma262/#sec-object.prototype.tostring
if (!TO_STRING_TAG_SUPPORT) {
  defineBuiltIn$3(Object.prototype, 'toString', toString$2, {
    unsafe: true
  });
}

var path$3 = path$5;
path$3.Map;

var DESCRIPTORS = descriptors;
var uncurryThis$3 = functionUncurryThis;
var call$7 = functionCall;
var fails$3 = fails$j;
var objectKeys = objectKeys$2;
var getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;
var propertyIsEnumerableModule = objectPropertyIsEnumerable;
var toObject = toObject$5;
var IndexedObject = indexedObject;

// eslint-disable-next-line es-x/no-object-assign -- safe
var $assign = Object.assign;
// eslint-disable-next-line es-x/no-object-defineproperty -- required for testing
var defineProperty = Object.defineProperty;
var concat = uncurryThis$3([].concat);

// `Object.assign` method
// https://tc39.es/ecma262/#sec-object.assign
var objectAssign = !$assign || fails$3(function () {
  // should have correct order of operations (Edge bug)
  if (DESCRIPTORS && $assign({
    b: 1
  }, $assign(defineProperty({}, 'a', {
    enumerable: true,
    get: function () {
      defineProperty(this, 'b', {
        value: 3,
        enumerable: false
      });
    }
  }), {
    b: 2
  })).b !== 1) return true;
  // should work with symbols and should have deterministic property order (V8 bug)
  var A = {};
  var B = {};
  // eslint-disable-next-line es-x/no-symbol -- safe
  var symbol = Symbol();
  var alphabet = 'abcdefghijklmnopqrst';
  A[symbol] = 7;
  alphabet.split('').forEach(function (chr) {
    B[chr] = chr;
  });
  return $assign({}, A)[symbol] != 7 || objectKeys($assign({}, B)).join('') != alphabet;
}) ? function assign(target, source) {
  // eslint-disable-line no-unused-vars -- required for `.length`
  var T = toObject(target);
  var argumentsLength = arguments.length;
  var index = 1;
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  var propertyIsEnumerable = propertyIsEnumerableModule.f;
  while (argumentsLength > index) {
    var S = IndexedObject(arguments[index++]);
    var keys = getOwnPropertySymbols ? concat(objectKeys(S), getOwnPropertySymbols(S)) : objectKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS || call$7(propertyIsEnumerable, S, key)) T[key] = S[key];
    }
  }
  return T;
} : $assign;

var $$h = _export;
var assign$1 = objectAssign;

// `Object.assign` method
// https://tc39.es/ecma262/#sec-object.assign
// eslint-disable-next-line es-x/no-object-assign -- required for testing
$$h({
  target: 'Object',
  stat: true,
  arity: 2,
  forced: Object.assign !== assign$1
}, {
  assign: assign$1
});

var path$2 = path$5;
path$2.Object.assign;

var uncurryThis$2 = functionUncurryThis;
var $Error = Error;
var replace = uncurryThis$2(''.replace);
var TEST = function (arg) {
  return String($Error(arg).stack);
}('zxcasd');
var V8_OR_CHAKRA_STACK_ENTRY = /\n\s*at [^:]*:[^\n]*/;
var IS_V8_OR_CHAKRA_STACK = V8_OR_CHAKRA_STACK_ENTRY.test(TEST);
var clearErrorStack$1 = function (stack, dropEntries) {
  if (IS_V8_OR_CHAKRA_STACK && typeof stack == 'string' && !$Error.prepareStackTrace) {
    while (dropEntries--) stack = replace(stack, V8_OR_CHAKRA_STACK_ENTRY, '');
  }
  return stack;
};

var isObject$3 = isObject$e;
var createNonEnumerableProperty$1 = createNonEnumerableProperty$6;

// `InstallErrorCause` abstract operation
// https://tc39.es/proposal-error-cause/#sec-errorobjects-install-error-cause
var installErrorCause$1 = function (O, options) {
  if (isObject$3(options) && 'cause' in options) {
    createNonEnumerableProperty$1(O, 'cause', options.cause);
  }
};

var toString$1 = toString$5;
var normalizeStringArgument$1 = function (argument, $default) {
  return argument === undefined ? arguments.length < 2 ? '' : $default : toString$1(argument);
};

var fails$2 = fails$j;
var createPropertyDescriptor$1 = createPropertyDescriptor$6;
var errorStackInstallable = !fails$2(function () {
  var error = Error('a');
  if (!('stack' in error)) return true;
  // eslint-disable-next-line es-x/no-object-defineproperty -- safe
  Object.defineProperty(error, 'stack', createPropertyDescriptor$1(1, 7));
  return error.stack !== 7;
});

var $$g = _export;
var global$d = global$K;
var isPrototypeOf = objectIsPrototypeOf;
var getPrototypeOf = objectGetPrototypeOf;
var setPrototypeOf$1 = objectSetPrototypeOf;
var copyConstructorProperties = copyConstructorProperties$2;
var create = objectCreate;
var createNonEnumerableProperty = createNonEnumerableProperty$6;
var createPropertyDescriptor = createPropertyDescriptor$6;
var clearErrorStack = clearErrorStack$1;
var installErrorCause = installErrorCause$1;
var iterate$4 = iterate$7;
var normalizeStringArgument = normalizeStringArgument$1;
var wellKnownSymbol$4 = wellKnownSymbol$h;
var ERROR_STACK_INSTALLABLE = errorStackInstallable;
var TO_STRING_TAG = wellKnownSymbol$4('toStringTag');
var Error$1 = global$d.Error;
var push = [].push;
var $AggregateError = function AggregateError(errors, message /* , options */) {
  var options = arguments.length > 2 ? arguments[2] : undefined;
  var isInstance = isPrototypeOf(AggregateErrorPrototype, this);
  var that;
  if (setPrototypeOf$1) {
    that = setPrototypeOf$1(new Error$1(), isInstance ? getPrototypeOf(this) : AggregateErrorPrototype);
  } else {
    that = isInstance ? this : create(AggregateErrorPrototype);
    createNonEnumerableProperty(that, TO_STRING_TAG, 'Error');
  }
  if (message !== undefined) createNonEnumerableProperty(that, 'message', normalizeStringArgument(message));
  if (ERROR_STACK_INSTALLABLE) createNonEnumerableProperty(that, 'stack', clearErrorStack(that.stack, 1));
  installErrorCause(that, options);
  var errorsArray = [];
  iterate$4(errors, push, {
    that: errorsArray
  });
  createNonEnumerableProperty(that, 'errors', errorsArray);
  return that;
};
if (setPrototypeOf$1) setPrototypeOf$1($AggregateError, Error$1);else copyConstructorProperties($AggregateError, Error$1, {
  name: true
});
var AggregateErrorPrototype = $AggregateError.prototype = create(Error$1.prototype, {
  constructor: createPropertyDescriptor(1, $AggregateError),
  message: createPropertyDescriptor(1, ''),
  name: createPropertyDescriptor(1, 'AggregateError')
});

// `AggregateError` constructor
// https://tc39.es/ecma262/#sec-aggregate-error-constructor
$$g({
  global: true,
  constructor: true,
  arity: 2
}, {
  AggregateError: $AggregateError
});

var classof$1 = classofRaw$1;
var global$c = global$K;
var engineIsNode = classof$1(global$c.process) == 'process';

var global$b = global$K;
var isConstructor = isConstructor$3;
var tryToString = tryToString$4;
var TypeError$4 = global$b.TypeError;

// `Assert: IsConstructor(argument) is true`
var aConstructor$1 = function (argument) {
  if (isConstructor(argument)) return argument;
  throw TypeError$4(tryToString(argument) + ' is not a constructor');
};

var anObject$1 = anObject$b;
var aConstructor = aConstructor$1;
var wellKnownSymbol$3 = wellKnownSymbol$h;
var SPECIES$1 = wellKnownSymbol$3('species');

// `SpeciesConstructor` abstract operation
// https://tc39.es/ecma262/#sec-speciesconstructor
var speciesConstructor$2 = function (O, defaultConstructor) {
  var C = anObject$1(O).constructor;
  var S;
  return C === undefined || (S = anObject$1(C)[SPECIES$1]) == undefined ? defaultConstructor : aConstructor(S);
};

var NATIVE_BIND = functionBindNative;
var FunctionPrototype = Function.prototype;
var apply$1 = FunctionPrototype.apply;
var call$6 = FunctionPrototype.call;

// eslint-disable-next-line es-x/no-reflect -- safe
var functionApply = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND ? call$6.bind(apply$1) : function () {
  return call$6.apply(apply$1, arguments);
});

var uncurryThis$1 = functionUncurryThis;
var arraySlice$1 = uncurryThis$1([].slice);

var global$a = global$K;
var TypeError$3 = global$a.TypeError;
var validateArgumentsLength$1 = function (passed, required) {
  if (passed < required) throw TypeError$3('Not enough arguments');
  return passed;
};

var userAgent$3 = engineUserAgent;
var engineIsIos = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent$3);

var global$9 = global$K;
var apply = functionApply;
var bind$3 = functionBindContext;
var isCallable$4 = isCallable$n;
var hasOwn = hasOwnProperty_1;
var fails$1 = fails$j;
var html = html$2;
var arraySlice = arraySlice$1;
var createElement$1 = documentCreateElement$1;
var validateArgumentsLength = validateArgumentsLength$1;
var IS_IOS$1 = engineIsIos;
var IS_NODE$2 = engineIsNode;
var set = global$9.setImmediate;
var clear = global$9.clearImmediate;
var process$2 = global$9.process;
var Dispatch = global$9.Dispatch;
var Function$1 = global$9.Function;
var MessageChannel = global$9.MessageChannel;
var String$1 = global$9.String;
var counter = 0;
var queue$1 = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var location$1, defer, channel, port;
try {
  // Deno throws a ReferenceError on `location` access without `--location` flag
  location$1 = global$9.location;
} catch (error) {/* empty */}
var run = function (id) {
  if (hasOwn(queue$1, id)) {
    var fn = queue$1[id];
    delete queue$1[id];
    fn();
  }
};
var runner = function (id) {
  return function () {
    run(id);
  };
};
var listener = function (event) {
  run(event.data);
};
var post = function (id) {
  // old engines have not location.origin
  global$9.postMessage(String$1(id), location$1.protocol + '//' + location$1.host);
};

// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!set || !clear) {
  set = function setImmediate(handler) {
    validateArgumentsLength(arguments.length, 1);
    var fn = isCallable$4(handler) ? handler : Function$1(handler);
    var args = arraySlice(arguments, 1);
    queue$1[++counter] = function () {
      apply(fn, undefined, args);
    };
    defer(counter);
    return counter;
  };
  clear = function clearImmediate(id) {
    delete queue$1[id];
  };
  // Node.js 0.8-
  if (IS_NODE$2) {
    defer = function (id) {
      process$2.nextTick(runner(id));
    };
    // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(runner(id));
    };
    // Browsers with MessageChannel, includes WebWorkers
    // except iOS - https://github.com/zloirock/core-js/issues/624
  } else if (MessageChannel && !IS_IOS$1) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = bind$3(port.postMessage, port);
    // Browsers with postMessage, skip WebWorkers
    // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global$9.addEventListener && isCallable$4(global$9.postMessage) && !global$9.importScripts && location$1 && location$1.protocol !== 'file:' && !fails$1(post)) {
    defer = post;
    global$9.addEventListener('message', listener, false);
    // IE8-
  } else if (ONREADYSTATECHANGE in createElement$1('script')) {
    defer = function (id) {
      html.appendChild(createElement$1('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run(id);
      };
    };
    // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(runner(id), 0);
    };
  }
}
var task$1 = {
  set: set,
  clear: clear
};

var userAgent$2 = engineUserAgent;
var global$8 = global$K;
var engineIsIosPebble = /ipad|iphone|ipod/i.test(userAgent$2) && global$8.Pebble !== undefined;

var userAgent$1 = engineUserAgent;
var engineIsWebosWebkit = /web0s(?!.*chrome)/i.test(userAgent$1);

var global$7 = global$K;
var bind$2 = functionBindContext;
var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
var macrotask = task$1.set;
var IS_IOS = engineIsIos;
var IS_IOS_PEBBLE = engineIsIosPebble;
var IS_WEBOS_WEBKIT = engineIsWebosWebkit;
var IS_NODE$1 = engineIsNode;
var MutationObserver$1 = global$7.MutationObserver || global$7.WebKitMutationObserver;
var document$2 = global$7.document;
var process$1 = global$7.process;
var Promise$2 = global$7.Promise;
// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`
var queueMicrotaskDescriptor = getOwnPropertyDescriptor$1(global$7, 'queueMicrotask');
var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;
var flush, head, last, notify$1, toggle, node, promise, then;

// modern engines have queueMicrotask method
if (!queueMicrotask) {
  flush = function () {
    var parent, fn;
    if (IS_NODE$1 && (parent = process$1.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (error) {
        if (head) notify$1();else last = undefined;
        throw error;
      }
    }
    last = undefined;
    if (parent) parent.enter();
  };

  // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
  // also except WebOS Webkit https://github.com/zloirock/core-js/issues/898
  if (!IS_IOS && !IS_NODE$1 && !IS_WEBOS_WEBKIT && MutationObserver$1 && document$2) {
    toggle = true;
    node = document$2.createTextNode('');
    new MutationObserver$1(flush).observe(node, {
      characterData: true
    });
    notify$1 = function () {
      node.data = toggle = !toggle;
    };
    // environments with maybe non-completely correct, but existent Promise
  } else if (!IS_IOS_PEBBLE && Promise$2 && Promise$2.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    promise = Promise$2.resolve(undefined);
    // workaround of WebKit ~ iOS Safari 10.1 bug
    promise.constructor = Promise$2;
    then = bind$2(promise.then, promise);
    notify$1 = function () {
      then(flush);
    };
    // Node.js without promises
  } else if (IS_NODE$1) {
    notify$1 = function () {
      process$1.nextTick(flush);
    };
    // for other environments - macrotask based on:
    // - setImmediate
    // - MessageChannel
    // - window.postMessage
    // - onreadystatechange
    // - setTimeout
  } else {
    // strange IE + webpack dev server bug - use .bind(global)
    macrotask = bind$2(macrotask, global$7);
    notify$1 = function () {
      macrotask(flush);
    };
  }
}
var microtask$1 = queueMicrotask || function (fn) {
  var task = {
    fn: fn,
    next: undefined
  };
  if (last) last.next = task;
  if (!head) {
    head = task;
    notify$1();
  }
  last = task;
};

var global$6 = global$K;
var hostReportErrors$1 = function (a, b) {
  var console = global$6.console;
  if (console && console.error) {
    arguments.length == 1 ? console.error(a) : console.error(a, b);
  }
};

var perform$5 = function (exec) {
  try {
    return {
      error: false,
      value: exec()
    };
  } catch (error) {
    return {
      error: true,
      value: error
    };
  }
};

var Queue$1 = function () {
  this.head = null;
  this.tail = null;
};
Queue$1.prototype = {
  add: function (item) {
    var entry = {
      item: item,
      next: null
    };
    if (this.head) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
  },
  get: function () {
    var entry = this.head;
    if (entry) {
      this.head = entry.next;
      if (this.tail === entry) this.tail = null;
      return entry.item;
    }
  }
};
var queue = Queue$1;

var global$5 = global$K;
var promiseNativeConstructor = global$5.Promise;

var engineIsBrowser = typeof window == 'object' && typeof Deno != 'object';

var global$4 = global$K;
var NativePromiseConstructor$4 = promiseNativeConstructor;
var isCallable$3 = isCallable$n;
var isForced = isForced_1;
var inspectSource = inspectSource$4;
var wellKnownSymbol$2 = wellKnownSymbol$h;
var IS_BROWSER = engineIsBrowser;
var V8_VERSION = engineV8Version;
NativePromiseConstructor$4 && NativePromiseConstructor$4.prototype;
var SPECIES = wellKnownSymbol$2('species');
var SUBCLASSING = false;
var NATIVE_PROMISE_REJECTION_EVENT$1 = isCallable$3(global$4.PromiseRejectionEvent);
var FORCED_PROMISE_CONSTRUCTOR$5 = isForced('Promise', function () {
  var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(NativePromiseConstructor$4);
  var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(NativePromiseConstructor$4);
  // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
  // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
  // We can't detect it synchronously, so just check versions
  if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66) return true;
  // We can't use @@species feature detection in V8 since it causes
  // deoptimization and performance degradation
  // https://github.com/zloirock/core-js/issues/679
  if (V8_VERSION >= 51 && /native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) return false;
  // Detect correctness of subclassing with @@species support
  var promise = new NativePromiseConstructor$4(function (resolve) {
    resolve(1);
  });
  var FakePromise = function (exec) {
    exec(function () {/* empty */}, function () {/* empty */});
  };
  var constructor = promise.constructor = {};
  constructor[SPECIES] = FakePromise;
  SUBCLASSING = promise.then(function () {/* empty */}) instanceof FakePromise;
  if (!SUBCLASSING) return true;
  // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test
  return !GLOBAL_CORE_JS_PROMISE && IS_BROWSER && !NATIVE_PROMISE_REJECTION_EVENT$1;
});
var promiseConstructorDetection = {
  CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR$5,
  REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT$1,
  SUBCLASSING: SUBCLASSING
};

var newPromiseCapability$2 = {};

var aCallable$5 = aCallable$9;
var PromiseCapability = function (C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aCallable$5(resolve);
  this.reject = aCallable$5(reject);
};

// `NewPromiseCapability` abstract operation
// https://tc39.es/ecma262/#sec-newpromisecapability
newPromiseCapability$2.f = function (C) {
  return new PromiseCapability(C);
};

var $$f = _export;
var IS_NODE = engineIsNode;
var global$3 = global$K;
var call$5 = functionCall;
var defineBuiltIn$2 = defineBuiltIn$9;
var setPrototypeOf = objectSetPrototypeOf;
var setToStringTag = setToStringTag$4;
var setSpecies = setSpecies$2;
var aCallable$4 = aCallable$9;
var isCallable$2 = isCallable$n;
var isObject$2 = isObject$e;
var anInstance = anInstance$3;
var speciesConstructor$1 = speciesConstructor$2;
var task = task$1.set;
var microtask = microtask$1;
var hostReportErrors = hostReportErrors$1;
var perform$4 = perform$5;
var Queue = queue;
var InternalStateModule = internalState;
var NativePromiseConstructor$3 = promiseNativeConstructor;
var PromiseConstructorDetection = promiseConstructorDetection;
var newPromiseCapabilityModule$5 = newPromiseCapability$2;
var PROMISE = 'Promise';
var FORCED_PROMISE_CONSTRUCTOR$4 = PromiseConstructorDetection.CONSTRUCTOR;
var NATIVE_PROMISE_REJECTION_EVENT = PromiseConstructorDetection.REJECTION_EVENT;
var NATIVE_PROMISE_SUBCLASSING = PromiseConstructorDetection.SUBCLASSING;
var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
var setInternalState = InternalStateModule.set;
var NativePromisePrototype$2 = NativePromiseConstructor$3 && NativePromiseConstructor$3.prototype;
var PromiseConstructor = NativePromiseConstructor$3;
var PromisePrototype = NativePromisePrototype$2;
var TypeError$2 = global$3.TypeError;
var document$1 = global$3.document;
var process = global$3.process;
var newPromiseCapability$1 = newPromiseCapabilityModule$5.f;
var newGenericPromiseCapability = newPromiseCapability$1;
var DISPATCH_EVENT = !!(document$1 && document$1.createEvent && global$3.dispatchEvent);
var UNHANDLED_REJECTION = 'unhandledrejection';
var REJECTION_HANDLED = 'rejectionhandled';
var PENDING = 0;
var FULFILLED = 1;
var REJECTED = 2;
var HANDLED = 1;
var UNHANDLED = 2;
var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;

// helpers
var isThenable = function (it) {
  var then;
  return isObject$2(it) && isCallable$2(then = it.then) ? then : false;
};
var callReaction = function (reaction, state) {
  var value = state.value;
  var ok = state.state == FULFILLED;
  var handler = ok ? reaction.ok : reaction.fail;
  var resolve = reaction.resolve;
  var reject = reaction.reject;
  var domain = reaction.domain;
  var result, then, exited;
  try {
    if (handler) {
      if (!ok) {
        if (state.rejection === UNHANDLED) onHandleUnhandled(state);
        state.rejection = HANDLED;
      }
      if (handler === true) result = value;else {
        if (domain) domain.enter();
        result = handler(value); // can throw
        if (domain) {
          domain.exit();
          exited = true;
        }
      }
      if (result === reaction.promise) {
        reject(TypeError$2('Promise-chain cycle'));
      } else if (then = isThenable(result)) {
        call$5(then, result, resolve, reject);
      } else resolve(result);
    } else reject(value);
  } catch (error) {
    if (domain && !exited) domain.exit();
    reject(error);
  }
};
var notify = function (state, isReject) {
  if (state.notified) return;
  state.notified = true;
  microtask(function () {
    var reactions = state.reactions;
    var reaction;
    while (reaction = reactions.get()) {
      callReaction(reaction, state);
    }
    state.notified = false;
    if (isReject && !state.rejection) onUnhandled(state);
  });
};
var dispatchEvent$2 = function (name, promise, reason) {
  var event, handler;
  if (DISPATCH_EVENT) {
    event = document$1.createEvent('Event');
    event.promise = promise;
    event.reason = reason;
    event.initEvent(name, false, true);
    global$3.dispatchEvent(event);
  } else event = {
    promise: promise,
    reason: reason
  };
  if (!NATIVE_PROMISE_REJECTION_EVENT && (handler = global$3['on' + name])) handler(event);else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
};
var onUnhandled = function (state) {
  call$5(task, global$3, function () {
    var promise = state.facade;
    var value = state.value;
    var IS_UNHANDLED = isUnhandled(state);
    var result;
    if (IS_UNHANDLED) {
      result = perform$4(function () {
        if (IS_NODE) {
          process.emit('unhandledRejection', value, promise);
        } else dispatchEvent$2(UNHANDLED_REJECTION, promise, value);
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
      if (result.error) throw result.value;
    }
  });
};
var isUnhandled = function (state) {
  return state.rejection !== HANDLED && !state.parent;
};
var onHandleUnhandled = function (state) {
  call$5(task, global$3, function () {
    var promise = state.facade;
    if (IS_NODE) {
      process.emit('rejectionHandled', promise);
    } else dispatchEvent$2(REJECTION_HANDLED, promise, state.value);
  });
};
var bind$1 = function (fn, state, unwrap) {
  return function (value) {
    fn(state, value, unwrap);
  };
};
var internalReject = function (state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  state.value = value;
  state.state = REJECTED;
  notify(state, true);
};
var internalResolve = function (state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  try {
    if (state.facade === value) throw TypeError$2("Promise can't be resolved itself");
    var then = isThenable(value);
    if (then) {
      microtask(function () {
        var wrapper = {
          done: false
        };
        try {
          call$5(then, value, bind$1(internalResolve, wrapper, state), bind$1(internalReject, wrapper, state));
        } catch (error) {
          internalReject(wrapper, error, state);
        }
      });
    } else {
      state.value = value;
      state.state = FULFILLED;
      notify(state, false);
    }
  } catch (error) {
    internalReject({
      done: false
    }, error, state);
  }
};

// constructor polyfill
if (FORCED_PROMISE_CONSTRUCTOR$4) {
  // 25.4.3.1 Promise(executor)
  PromiseConstructor = function Promise(executor) {
    anInstance(this, PromisePrototype);
    aCallable$4(executor);
    call$5(Internal, this);
    var state = getInternalPromiseState(this);
    try {
      executor(bind$1(internalResolve, state), bind$1(internalReject, state));
    } catch (error) {
      internalReject(state, error);
    }
  };
  PromisePrototype = PromiseConstructor.prototype;

  // eslint-disable-next-line no-unused-vars -- required for `.length`
  Internal = function Promise(executor) {
    setInternalState(this, {
      type: PROMISE,
      done: false,
      notified: false,
      parent: false,
      reactions: new Queue(),
      rejection: false,
      state: PENDING,
      value: undefined
    });
  };

  // `Promise.prototype.then` method
  // https://tc39.es/ecma262/#sec-promise.prototype.then
  Internal.prototype = defineBuiltIn$2(PromisePrototype, 'then', function then(onFulfilled, onRejected) {
    var state = getInternalPromiseState(this);
    var reaction = newPromiseCapability$1(speciesConstructor$1(this, PromiseConstructor));
    state.parent = true;
    reaction.ok = isCallable$2(onFulfilled) ? onFulfilled : true;
    reaction.fail = isCallable$2(onRejected) && onRejected;
    reaction.domain = IS_NODE ? process.domain : undefined;
    if (state.state == PENDING) state.reactions.add(reaction);else microtask(function () {
      callReaction(reaction, state);
    });
    return reaction.promise;
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    var state = getInternalPromiseState(promise);
    this.promise = promise;
    this.resolve = bind$1(internalResolve, state);
    this.reject = bind$1(internalReject, state);
  };
  newPromiseCapabilityModule$5.f = newPromiseCapability$1 = function (C) {
    return C === PromiseConstructor || C === PromiseWrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
  };
  if (isCallable$2(NativePromiseConstructor$3) && NativePromisePrototype$2 !== Object.prototype) {
    nativeThen = NativePromisePrototype$2.then;
    if (!NATIVE_PROMISE_SUBCLASSING) {
      // make `Promise#then` return a polyfilled `Promise` for native promise-based APIs
      defineBuiltIn$2(NativePromisePrototype$2, 'then', function then(onFulfilled, onRejected) {
        var that = this;
        return new PromiseConstructor(function (resolve, reject) {
          call$5(nativeThen, that, resolve, reject);
        }).then(onFulfilled, onRejected);
        // https://github.com/zloirock/core-js/issues/640
      }, {
        unsafe: true
      });
    }

    // make `.constructor === Promise` work for native promise-based APIs
    try {
      delete NativePromisePrototype$2.constructor;
    } catch (error) {/* empty */}

    // make `instanceof Promise` work for native promise-based APIs
    if (setPrototypeOf) {
      setPrototypeOf(NativePromisePrototype$2, PromisePrototype);
    }
  }
}
$$f({
  global: true,
  constructor: true,
  wrap: true,
  forced: FORCED_PROMISE_CONSTRUCTOR$4
}, {
  Promise: PromiseConstructor
});
setToStringTag(PromiseConstructor, PROMISE, false);
setSpecies(PROMISE);

var NativePromiseConstructor$2 = promiseNativeConstructor;
var checkCorrectnessOfIteration = checkCorrectnessOfIteration$3;
var FORCED_PROMISE_CONSTRUCTOR$3 = promiseConstructorDetection.CONSTRUCTOR;
var promiseStaticsIncorrectIteration = FORCED_PROMISE_CONSTRUCTOR$3 || !checkCorrectnessOfIteration(function (iterable) {
  NativePromiseConstructor$2.all(iterable).then(undefined, function () {/* empty */});
});

var $$e = _export;
var call$4 = functionCall;
var aCallable$3 = aCallable$9;
var newPromiseCapabilityModule$4 = newPromiseCapability$2;
var perform$3 = perform$5;
var iterate$3 = iterate$7;
var PROMISE_STATICS_INCORRECT_ITERATION$1 = promiseStaticsIncorrectIteration;

// `Promise.all` method
// https://tc39.es/ecma262/#sec-promise.all
$$e({
  target: 'Promise',
  stat: true,
  forced: PROMISE_STATICS_INCORRECT_ITERATION$1
}, {
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapabilityModule$4.f(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform$3(function () {
      var $promiseResolve = aCallable$3(C.resolve);
      var values = [];
      var counter = 0;
      var remaining = 1;
      iterate$3(iterable, function (promise) {
        var index = counter++;
        var alreadyCalled = false;
        remaining++;
        call$4($promiseResolve, C, promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.error) reject(result.value);
    return capability.promise;
  }
});

var $$d = _export;
var FORCED_PROMISE_CONSTRUCTOR$2 = promiseConstructorDetection.CONSTRUCTOR;
var NativePromiseConstructor$1 = promiseNativeConstructor;
var getBuiltIn$3 = getBuiltIn$a;
var isCallable$1 = isCallable$n;
var defineBuiltIn$1 = defineBuiltIn$9;
var NativePromisePrototype$1 = NativePromiseConstructor$1 && NativePromiseConstructor$1.prototype;

// `Promise.prototype.catch` method
// https://tc39.es/ecma262/#sec-promise.prototype.catch
$$d({
  target: 'Promise',
  proto: true,
  forced: FORCED_PROMISE_CONSTRUCTOR$2,
  real: true
}, {
  'catch': function (onRejected) {
    return this.then(undefined, onRejected);
  }
});

// makes sure that native promise-based APIs `Promise#catch` properly works with patched `Promise#then`
if (isCallable$1(NativePromiseConstructor$1)) {
  var method$1 = getBuiltIn$3('Promise').prototype['catch'];
  if (NativePromisePrototype$1['catch'] !== method$1) {
    defineBuiltIn$1(NativePromisePrototype$1, 'catch', method$1, {
      unsafe: true
    });
  }
}

var $$c = _export;
var call$3 = functionCall;
var aCallable$2 = aCallable$9;
var newPromiseCapabilityModule$3 = newPromiseCapability$2;
var perform$2 = perform$5;
var iterate$2 = iterate$7;
var PROMISE_STATICS_INCORRECT_ITERATION = promiseStaticsIncorrectIteration;

// `Promise.race` method
// https://tc39.es/ecma262/#sec-promise.race
$$c({
  target: 'Promise',
  stat: true,
  forced: PROMISE_STATICS_INCORRECT_ITERATION
}, {
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapabilityModule$3.f(C);
    var reject = capability.reject;
    var result = perform$2(function () {
      var $promiseResolve = aCallable$2(C.resolve);
      iterate$2(iterable, function (promise) {
        call$3($promiseResolve, C, promise).then(capability.resolve, reject);
      });
    });
    if (result.error) reject(result.value);
    return capability.promise;
  }
});

var $$b = _export;
var call$2 = functionCall;
var newPromiseCapabilityModule$2 = newPromiseCapability$2;
var FORCED_PROMISE_CONSTRUCTOR$1 = promiseConstructorDetection.CONSTRUCTOR;

// `Promise.reject` method
// https://tc39.es/ecma262/#sec-promise.reject
$$b({
  target: 'Promise',
  stat: true,
  forced: FORCED_PROMISE_CONSTRUCTOR$1
}, {
  reject: function reject(r) {
    var capability = newPromiseCapabilityModule$2.f(this);
    call$2(capability.reject, undefined, r);
    return capability.promise;
  }
});

var anObject = anObject$b;
var isObject$1 = isObject$e;
var newPromiseCapability = newPromiseCapability$2;
var promiseResolve$2 = function (C, x) {
  anObject(C);
  if (isObject$1(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};

var $$a = _export;
var getBuiltIn$2 = getBuiltIn$a;
var FORCED_PROMISE_CONSTRUCTOR = promiseConstructorDetection.CONSTRUCTOR;
var promiseResolve$1 = promiseResolve$2;
getBuiltIn$2('Promise');

// `Promise.resolve` method
// https://tc39.es/ecma262/#sec-promise.resolve
$$a({
  target: 'Promise',
  stat: true,
  forced: FORCED_PROMISE_CONSTRUCTOR
}, {
  resolve: function resolve(x) {
    return promiseResolve$1(this, x);
  }
});

var $$9 = _export;
var call$1 = functionCall;
var aCallable$1 = aCallable$9;
var newPromiseCapabilityModule$1 = newPromiseCapability$2;
var perform$1 = perform$5;
var iterate$1 = iterate$7;

// `Promise.allSettled` method
// https://tc39.es/ecma262/#sec-promise.allsettled
$$9({
  target: 'Promise',
  stat: true
}, {
  allSettled: function allSettled(iterable) {
    var C = this;
    var capability = newPromiseCapabilityModule$1.f(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform$1(function () {
      var promiseResolve = aCallable$1(C.resolve);
      var values = [];
      var counter = 0;
      var remaining = 1;
      iterate$1(iterable, function (promise) {
        var index = counter++;
        var alreadyCalled = false;
        remaining++;
        call$1(promiseResolve, C, promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[index] = {
            status: 'fulfilled',
            value: value
          };
          --remaining || resolve(values);
        }, function (error) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[index] = {
            status: 'rejected',
            reason: error
          };
          --remaining || resolve(values);
        });
      });
      --remaining || resolve(values);
    });
    if (result.error) reject(result.value);
    return capability.promise;
  }
});

var $$8 = _export;
var call = functionCall;
var aCallable = aCallable$9;
var getBuiltIn$1 = getBuiltIn$a;
var newPromiseCapabilityModule = newPromiseCapability$2;
var perform = perform$5;
var iterate = iterate$7;
var PROMISE_ANY_ERROR = 'No one promise resolved';

// `Promise.any` method
// https://tc39.es/ecma262/#sec-promise.any
$$8({
  target: 'Promise',
  stat: true
}, {
  any: function any(iterable) {
    var C = this;
    var AggregateError = getBuiltIn$1('AggregateError');
    var capability = newPromiseCapabilityModule.f(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var promiseResolve = aCallable(C.resolve);
      var errors = [];
      var counter = 0;
      var remaining = 1;
      var alreadyResolved = false;
      iterate(iterable, function (promise) {
        var index = counter++;
        var alreadyRejected = false;
        remaining++;
        call(promiseResolve, C, promise).then(function (value) {
          if (alreadyRejected || alreadyResolved) return;
          alreadyResolved = true;
          resolve(value);
        }, function (error) {
          if (alreadyRejected || alreadyResolved) return;
          alreadyRejected = true;
          errors[index] = error;
          --remaining || reject(new AggregateError(errors, PROMISE_ANY_ERROR));
        });
      });
      --remaining || reject(new AggregateError(errors, PROMISE_ANY_ERROR));
    });
    if (result.error) reject(result.value);
    return capability.promise;
  }
});

var $$7 = _export;
var NativePromiseConstructor = promiseNativeConstructor;
var fails = fails$j;
var getBuiltIn = getBuiltIn$a;
var isCallable = isCallable$n;
var speciesConstructor = speciesConstructor$2;
var promiseResolve = promiseResolve$2;
var defineBuiltIn = defineBuiltIn$9;
var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;

// Safari bug https://bugs.webkit.org/show_bug.cgi?id=200829
var NON_GENERIC = !!NativePromiseConstructor && fails(function () {
  // eslint-disable-next-line unicorn/no-thenable -- required for testing
  NativePromisePrototype['finally'].call({
    then: function () {/* empty */}
  }, function () {/* empty */});
});

// `Promise.prototype.finally` method
// https://tc39.es/ecma262/#sec-promise.prototype.finally
$$7({
  target: 'Promise',
  proto: true,
  real: true,
  forced: NON_GENERIC
}, {
  'finally': function (onFinally) {
    var C = speciesConstructor(this, getBuiltIn('Promise'));
    var isFunction = isCallable(onFinally);
    return this.then(isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () {
        return x;
      });
    } : onFinally, isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () {
        throw e;
      });
    } : onFinally);
  }
});

// makes sure that native promise-based APIs `Promise#finally` properly works with patched `Promise#then`
if (isCallable(NativePromiseConstructor)) {
  var method = getBuiltIn('Promise').prototype['finally'];
  if (NativePromisePrototype['finally'] !== method) {
    defineBuiltIn(NativePromisePrototype, 'finally', method, {
      unsafe: true
    });
  }
}

var path$1 = path$5;
path$1.Promise;

var collection = collection$2;
var collectionStrong = collectionStrong$2;

// `Set` constructor
// https://tc39.es/ecma262/#sec-set-objects
collection('Set', function (init) {
  return function Set() {
    return init(this, arguments.length ? arguments[0] : undefined);
  };
}, collectionStrong);

var path = path$5;
path.Set;

var isObject = isObject$e;
var classof = classofRaw$1;
var wellKnownSymbol$1 = wellKnownSymbol$h;
var MATCH$1 = wellKnownSymbol$1('match');

// `IsRegExp` abstract operation
// https://tc39.es/ecma262/#sec-isregexp
var isRegexp = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH$1]) !== undefined ? !!isRegExp : classof(it) == 'RegExp');
};

var global$2 = global$K;
var isRegExp = isRegexp;
var TypeError$1 = global$2.TypeError;
var notARegexp = function (it) {
  if (isRegExp(it)) {
    throw TypeError$1("The method doesn't accept regular expressions");
  }
  return it;
};

var wellKnownSymbol = wellKnownSymbol$h;
var MATCH = wellKnownSymbol('match');
var correctIsRegexpLogic = function (METHOD_NAME) {
  var regexp = /./;
  try {
    '/./'[METHOD_NAME](regexp);
  } catch (error1) {
    try {
      regexp[MATCH] = false;
      return '/./'[METHOD_NAME](regexp);
    } catch (error2) {/* empty */}
  }
  return false;
};

var $$6 = _export;
var uncurryThis = functionUncurryThis;
var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
var toLength = toLength$2;
var toString = toString$5;
var notARegExp = notARegexp;
var requireObjectCoercible = requireObjectCoercible$4;
var correctIsRegExpLogic = correctIsRegexpLogic;

// eslint-disable-next-line es-x/no-string-prototype-startswith -- safe
var un$StartsWith = uncurryThis(''.startsWith);
var stringSlice = uncurryThis(''.slice);
var min = Math.min;
var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic('startsWith');
// https://github.com/zloirock/core-js/pull/702
var MDN_POLYFILL_BUG = !CORRECT_IS_REGEXP_LOGIC && !!function () {
  var descriptor = getOwnPropertyDescriptor(String.prototype, 'startsWith');
  return descriptor && !descriptor.writable;
}();

// `String.prototype.startsWith` method
// https://tc39.es/ecma262/#sec-string.prototype.startswith
$$6({
  target: 'String',
  proto: true,
  forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC
}, {
  startsWith: function startsWith(searchString /* , position = 0 */) {
    var that = toString(requireObjectCoercible(this));
    notARegExp(searchString);
    var index = toLength(min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = toString(searchString);
    return un$StartsWith ? un$StartsWith(that, search, index) : stringSlice(that, index, index + search.length) === search;
  }
});

var entryUnbind = entryUnbind$3;
entryUnbind('String', 'startsWith');

// element-closest | CC0-1.0 | github.com/jonathantneal/closest

(function (ElementProto) {
  if (typeof ElementProto.matches !== 'function') {
    ElementProto.matches = ElementProto.msMatchesSelector || ElementProto.mozMatchesSelector || ElementProto.webkitMatchesSelector || function matches(selector) {
      var element = this;
      var elements = (element.document || element.ownerDocument).querySelectorAll(selector);
      var index = 0;
      while (elements[index] && elements[index] !== element) {
        ++index;
      }
      return Boolean(elements[index]);
    };
  }
  if (typeof ElementProto.closest !== 'function') {
    ElementProto.closest = function closest(selector) {
      var element = this;
      while (element && element.nodeType === 1) {
        if (element.matches(selector)) {
          return element;
        }
        element = element.parentNode;
      }
      return null;
    };
  }
})(window.Element.prototype);

if (window.MutationObserver) {
  var element = document.createElement("div");
  element.innerHTML = "<div><div></div></div>";
  new MutationObserver(function (mutations, observer) {
    observer.disconnect();
    if (mutations[0] && mutations[0].type == "childList" && mutations[0].removedNodes[0].childNodes.length == 0) {
      var prototype = HTMLElement.prototype;
      var descriptor = Object.getOwnPropertyDescriptor(prototype, "innerHTML");
      if (descriptor && descriptor.set) {
        Object.defineProperty(prototype, "innerHTML", {
          set: function (value) {
            while (this.lastChild) this.removeChild(this.lastChild);
            descriptor.set.call(this, value);
          }
        });
      }
    }
  }).observe(element, {
    childList: true,
    subtree: true
  });
  element.innerHTML = "";
}

var passiveSupported = false;
var onceSupported = false;
function noop$1() {}
try {
  var options = Object.create({}, {
    passive: {
      get: function () {
        passiveSupported = true;
      }
    },
    once: {
      get: function () {
        onceSupported = true;
      }
    }
  });
  window.addEventListener('test', noop$1, options);
  window.removeEventListener('test', noop$1, options);
} catch (e) {/* */}
var enhance = function enhance(proto) {
  var originalAddEventListener = proto.addEventListener;
  var originalRemoveEventListener = proto.removeEventListener;
  var listeners = new WeakMap();
  proto.addEventListener = function (name, originalCallback, optionsOrCapture) {
    if (optionsOrCapture === undefined || optionsOrCapture === true || optionsOrCapture === false || !originalCallback || typeof originalCallback !== 'function' && typeof originalCallback !== 'object') {
      return originalAddEventListener.call(this, name, originalCallback, optionsOrCapture);
    }
    var callback = typeof originalCallback !== 'function' && typeof originalCallback.handleEvent === 'function' ? originalCallback.handleEvent.bind(originalCallback) : originalCallback;
    var options = typeof optionsOrCapture === 'boolean' ? {
      capture: optionsOrCapture
    } : optionsOrCapture || {};
    var passive = Boolean(options.passive);
    var once = Boolean(options.once);
    var capture = Boolean(options.capture);
    var oldCallback = callback;
    if (!onceSupported && once) {
      callback = function (event) {
        this.removeEventListener(name, originalCallback, options);
        oldCallback.call(this, event);
      };
    }
    if (!passiveSupported && passive) {
      callback = function (event) {
        event.preventDefault = noop$1;
        oldCallback.call(this, event);
      };
    }
    if (!listeners.has(this)) listeners.set(this, new WeakMap());
    var elementMap = listeners.get(this);
    if (!elementMap.has(originalCallback)) elementMap.set(originalCallback, []);
    var optionsOctal = passive * 1 + once * 2 + capture * 4;
    elementMap.get(originalCallback)[optionsOctal] = callback;
    originalAddEventListener.call(this, name, callback, capture);
  };
  proto.removeEventListener = function (name, originalCallback, optionsOrCapture) {
    var capture = Boolean(typeof optionsOrCapture === 'object' ? optionsOrCapture.capture : optionsOrCapture);
    var elementMap = listeners.get(this);
    if (!elementMap) return originalRemoveEventListener.call(this, name, originalCallback, optionsOrCapture);
    var callbacks = elementMap.get(originalCallback);
    if (!callbacks) return originalRemoveEventListener.call(this, name, originalCallback, optionsOrCapture);
    for (var optionsOctal in callbacks) {
      var callbackIsCapture = Boolean(optionsOctal & 4);
      if (callbackIsCapture !== capture) continue; // when unbinding, capture is the only option that counts
      originalRemoveEventListener.call(this, name, callbacks[optionsOctal], callbackIsCapture);
    }
  };
};
if (!passiveSupported || !onceSupported) {
  if (typeof EventTarget !== 'undefined') {
    enhance(EventTarget.prototype);
  } else {
    enhance(Text.prototype);
    enhance(HTMLElement.prototype);
    enhance(HTMLDocument.prototype);
    enhance(Window.prototype);
    enhance(XMLHttpRequest.prototype);
  }
}

if (typeof SVGElement.prototype.contains != "function") {
  SVGElement.prototype.contains = function (node) {
    return this === node || this.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY;
  };
}

/**
 * @this {Promise}
 */
function finallyConstructor(callback) {
  var constructor = this.constructor;
  return this.then(function (value) {
    // @ts-ignore
    return constructor.resolve(callback()).then(function () {
      return value;
    });
  }, function (reason) {
    // @ts-ignore
    return constructor.resolve(callback()).then(function () {
      // @ts-ignore
      return constructor.reject(reason);
    });
  });
}

function allSettled(arr) {
  var P = this;
  return new P(function (resolve, reject) {
    if (!(arr && typeof arr.length !== 'undefined')) {
      return reject(new TypeError(typeof arr + ' ' + arr + ' is not iterable(cannot read property Symbol(Symbol.iterator))'));
    }
    var args = Array.prototype.slice.call(arr);
    if (args.length === 0) return resolve([]);
    var remaining = args.length;
    function res(i, val) {
      if (val && (typeof val === 'object' || typeof val === 'function')) {
        var then = val.then;
        if (typeof then === 'function') {
          then.call(val, function (val) {
            res(i, val);
          }, function (e) {
            args[i] = {
              status: 'rejected',
              reason: e
            };
            if (--remaining === 0) {
              resolve(args);
            }
          });
          return;
        }
      }
      args[i] = {
        status: 'fulfilled',
        value: val
      };
      if (--remaining === 0) {
        resolve(args);
      }
    }
    for (var i = 0; i < args.length; i++) {
      res(i, args[i]);
    }
  });
}

// Store setTimeout reference so promise-polyfill will be unaffected by
// other code modifying setTimeout (like sinon.useFakeTimers())
var setTimeoutFunc = setTimeout;
function isArray(x) {
  return Boolean(x && typeof x.length !== 'undefined');
}
function noop() {}

// Polyfill for Function.prototype.bind
function bind(fn, thisArg) {
  return function () {
    fn.apply(thisArg, arguments);
  };
}

/**
 * @constructor
 * @param {Function} fn
 */
function Promise$1(fn) {
  if (!(this instanceof Promise$1)) throw new TypeError('Promises must be constructed via new');
  if (typeof fn !== 'function') throw new TypeError('not a function');
  /** @type {!number} */
  this._state = 0;
  /** @type {!boolean} */
  this._handled = false;
  /** @type {Promise|undefined} */
  this._value = undefined;
  /** @type {!Array<!Function>} */
  this._deferreds = [];
  doResolve(fn, this);
}
function handle(self, deferred) {
  while (self._state === 3) {
    self = self._value;
  }
  if (self._state === 0) {
    self._deferreds.push(deferred);
    return;
  }
  self._handled = true;
  Promise$1._immediateFn(function () {
    var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
    if (cb === null) {
      (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
      return;
    }
    var ret;
    try {
      ret = cb(self._value);
    } catch (e) {
      reject(deferred.promise, e);
      return;
    }
    resolve(deferred.promise, ret);
  });
}
function resolve(self, newValue) {
  try {
    // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
    if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');
    if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
      var then = newValue.then;
      if (newValue instanceof Promise$1) {
        self._state = 3;
        self._value = newValue;
        finale(self);
        return;
      } else if (typeof then === 'function') {
        doResolve(bind(then, newValue), self);
        return;
      }
    }
    self._state = 1;
    self._value = newValue;
    finale(self);
  } catch (e) {
    reject(self, e);
  }
}
function reject(self, newValue) {
  self._state = 2;
  self._value = newValue;
  finale(self);
}
function finale(self) {
  if (self._state === 2 && self._deferreds.length === 0) {
    Promise$1._immediateFn(function () {
      if (!self._handled) {
        Promise$1._unhandledRejectionFn(self._value);
      }
    });
  }
  for (var i = 0, len = self._deferreds.length; i < len; i++) {
    handle(self, self._deferreds[i]);
  }
  self._deferreds = null;
}

/**
 * @constructor
 */
function Handler(onFulfilled, onRejected, promise) {
  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
  this.onRejected = typeof onRejected === 'function' ? onRejected : null;
  this.promise = promise;
}

/**
 * Take a potentially misbehaving resolver function and make sure
 * onFulfilled and onRejected are only called once.
 *
 * Makes no guarantees about asynchrony.
 */
function doResolve(fn, self) {
  var done = false;
  try {
    fn(function (value) {
      if (done) return;
      done = true;
      resolve(self, value);
    }, function (reason) {
      if (done) return;
      done = true;
      reject(self, reason);
    });
  } catch (ex) {
    if (done) return;
    done = true;
    reject(self, ex);
  }
}
Promise$1.prototype['catch'] = function (onRejected) {
  return this.then(null, onRejected);
};
Promise$1.prototype.then = function (onFulfilled, onRejected) {
  // @ts-ignore
  var prom = new this.constructor(noop);
  handle(this, new Handler(onFulfilled, onRejected, prom));
  return prom;
};
Promise$1.prototype['finally'] = finallyConstructor;
Promise$1.all = function (arr) {
  return new Promise$1(function (resolve, reject) {
    if (!isArray(arr)) {
      return reject(new TypeError('Promise.all accepts an array'));
    }
    var args = Array.prototype.slice.call(arr);
    if (args.length === 0) return resolve([]);
    var remaining = args.length;
    function res(i, val) {
      try {
        if (val && (typeof val === 'object' || typeof val === 'function')) {
          var then = val.then;
          if (typeof then === 'function') {
            then.call(val, function (val) {
              res(i, val);
            }, reject);
            return;
          }
        }
        args[i] = val;
        if (--remaining === 0) {
          resolve(args);
        }
      } catch (ex) {
        reject(ex);
      }
    }
    for (var i = 0; i < args.length; i++) {
      res(i, args[i]);
    }
  });
};
Promise$1.allSettled = allSettled;
Promise$1.resolve = function (value) {
  if (value && typeof value === 'object' && value.constructor === Promise$1) {
    return value;
  }
  return new Promise$1(function (resolve) {
    resolve(value);
  });
};
Promise$1.reject = function (value) {
  return new Promise$1(function (resolve, reject) {
    reject(value);
  });
};
Promise$1.race = function (arr) {
  return new Promise$1(function (resolve, reject) {
    if (!isArray(arr)) {
      return reject(new TypeError('Promise.race accepts an array'));
    }
    for (var i = 0, len = arr.length; i < len; i++) {
      Promise$1.resolve(arr[i]).then(resolve, reject);
    }
  });
};

// Use polyfill for setImmediate for performance gains
Promise$1._immediateFn =
// @ts-ignore
typeof setImmediate === 'function' && function (fn) {
  // @ts-ignore
  setImmediate(fn);
} || function (fn) {
  setTimeoutFunc(fn, 0);
};
Promise$1._unhandledRejectionFn = function _unhandledRejectionFn(err) {
  if (typeof console !== 'undefined' && console) {
    console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
  }
};

/** @suppress {undefinedVars} */
var globalNS = function () {
  // the only reliable means to get the global object is
  // `Function('return this')()`
  // However, this causes CSP violations in Chrome apps.
  if (typeof self !== 'undefined') {
    return self;
  }
  if (typeof window !== 'undefined') {
    return window;
  }
  if (typeof global !== 'undefined') {
    return global;
  }
  throw new Error('unable to locate global object');
}();

// Expose the polyfill if Promise is undefined or set to a
// non-function value. The latter can be due to a named HTMLElement
// being exposed by browsers for legacy reasons.
// https://github.com/taylorhakes/promise-polyfill/issues/114
if (typeof globalNS['Promise'] !== 'function') {
  globalNS['Promise'] = Promise$1;
} else {
  if (!globalNS.Promise.prototype['finally']) {
    globalNS.Promise.prototype['finally'] = finallyConstructor;
  }
  if (!globalNS.Promise.allSettled) {
    globalNS.Promise.allSettled = allSettled;
  }
}

var global$1 = typeof globalThis !== 'undefined' && globalThis || typeof self !== 'undefined' && self || typeof global$1 !== 'undefined' && global$1;
var support = {
  searchParams: 'URLSearchParams' in global$1,
  iterable: 'Symbol' in global$1 && 'iterator' in Symbol,
  blob: 'FileReader' in global$1 && 'Blob' in global$1 && function () {
    try {
      new Blob();
      return true;
    } catch (e) {
      return false;
    }
  }(),
  formData: 'FormData' in global$1,
  arrayBuffer: 'ArrayBuffer' in global$1
};
function isDataView(obj) {
  return obj && DataView.prototype.isPrototypeOf(obj);
}
if (support.arrayBuffer) {
  var viewClasses = ['[object Int8Array]', '[object Uint8Array]', '[object Uint8ClampedArray]', '[object Int16Array]', '[object Uint16Array]', '[object Int32Array]', '[object Uint32Array]', '[object Float32Array]', '[object Float64Array]'];
  var isArrayBufferView = ArrayBuffer.isView || function (obj) {
    return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
  };
}
function normalizeName(name) {
  if (typeof name !== 'string') {
    name = String(name);
  }
  if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === '') {
    throw new TypeError('Invalid character in header field name: "' + name + '"');
  }
  return name.toLowerCase();
}
function normalizeValue(value) {
  if (typeof value !== 'string') {
    value = String(value);
  }
  return value;
}

// Build a destructive iterator for the value list
function iteratorFor(items) {
  var iterator = {
    next: function () {
      var value = items.shift();
      return {
        done: value === undefined,
        value: value
      };
    }
  };
  if (support.iterable) {
    iterator[Symbol.iterator] = function () {
      return iterator;
    };
  }
  return iterator;
}
function Headers$1(headers) {
  this.map = {};
  if (headers instanceof Headers$1) {
    headers.forEach(function (value, name) {
      this.append(name, value);
    }, this);
  } else if (Array.isArray(headers)) {
    headers.forEach(function (header) {
      this.append(header[0], header[1]);
    }, this);
  } else if (headers) {
    Object.getOwnPropertyNames(headers).forEach(function (name) {
      this.append(name, headers[name]);
    }, this);
  }
}
Headers$1.prototype.append = function (name, value) {
  name = normalizeName(name);
  value = normalizeValue(value);
  var oldValue = this.map[name];
  this.map[name] = oldValue ? oldValue + ', ' + value : value;
};
Headers$1.prototype['delete'] = function (name) {
  delete this.map[normalizeName(name)];
};
Headers$1.prototype.get = function (name) {
  name = normalizeName(name);
  return this.has(name) ? this.map[name] : null;
};
Headers$1.prototype.has = function (name) {
  return this.map.hasOwnProperty(normalizeName(name));
};
Headers$1.prototype.set = function (name, value) {
  this.map[normalizeName(name)] = normalizeValue(value);
};
Headers$1.prototype.forEach = function (callback, thisArg) {
  for (var name in this.map) {
    if (this.map.hasOwnProperty(name)) {
      callback.call(thisArg, this.map[name], name, this);
    }
  }
};
Headers$1.prototype.keys = function () {
  var items = [];
  this.forEach(function (value, name) {
    items.push(name);
  });
  return iteratorFor(items);
};
Headers$1.prototype.values = function () {
  var items = [];
  this.forEach(function (value) {
    items.push(value);
  });
  return iteratorFor(items);
};
Headers$1.prototype.entries = function () {
  var items = [];
  this.forEach(function (value, name) {
    items.push([name, value]);
  });
  return iteratorFor(items);
};
if (support.iterable) {
  Headers$1.prototype[Symbol.iterator] = Headers$1.prototype.entries;
}
function consumed(body) {
  if (body.bodyUsed) {
    return Promise.reject(new TypeError('Already read'));
  }
  body.bodyUsed = true;
}
function fileReaderReady(reader) {
  return new Promise(function (resolve, reject) {
    reader.onload = function () {
      resolve(reader.result);
    };
    reader.onerror = function () {
      reject(reader.error);
    };
  });
}
function readBlobAsArrayBuffer(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  reader.readAsArrayBuffer(blob);
  return promise;
}
function readBlobAsText(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  reader.readAsText(blob);
  return promise;
}
function readArrayBufferAsText(buf) {
  var view = new Uint8Array(buf);
  var chars = new Array(view.length);
  for (var i = 0; i < view.length; i++) {
    chars[i] = String.fromCharCode(view[i]);
  }
  return chars.join('');
}
function bufferClone(buf) {
  if (buf.slice) {
    return buf.slice(0);
  } else {
    var view = new Uint8Array(buf.byteLength);
    view.set(new Uint8Array(buf));
    return view.buffer;
  }
}
function Body() {
  this.bodyUsed = false;
  this._initBody = function (body) {
    /*
      fetch-mock wraps the Response object in an ES6 Proxy to
      provide useful test harness features such as flush. However, on
      ES5 browsers without fetch or Proxy support pollyfills must be used;
      the proxy-pollyfill is unable to proxy an attribute unless it exists
      on the object before the Proxy is created. This change ensures
      Response.bodyUsed exists on the instance, while maintaining the
      semantic of setting Request.bodyUsed in the constructor before
      _initBody is called.
    */
    this.bodyUsed = this.bodyUsed;
    this._bodyInit = body;
    if (!body) {
      this._bodyText = '';
    } else if (typeof body === 'string') {
      this._bodyText = body;
    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
      this._bodyBlob = body;
    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
      this._bodyFormData = body;
    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
      this._bodyText = body.toString();
    } else if (support.arrayBuffer && support.blob && isDataView(body)) {
      this._bodyArrayBuffer = bufferClone(body.buffer);
      // IE 10-11 can't handle a DataView body.
      this._bodyInit = new Blob([this._bodyArrayBuffer]);
    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
      this._bodyArrayBuffer = bufferClone(body);
    } else {
      this._bodyText = body = Object.prototype.toString.call(body);
    }
    if (!this.headers.get('content-type')) {
      if (typeof body === 'string') {
        this.headers.set('content-type', 'text/plain;charset=UTF-8');
      } else if (this._bodyBlob && this._bodyBlob.type) {
        this.headers.set('content-type', this._bodyBlob.type);
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
      }
    }
  };
  if (support.blob) {
    this.blob = function () {
      var rejected = consumed(this);
      if (rejected) {
        return rejected;
      }
      if (this._bodyBlob) {
        return Promise.resolve(this._bodyBlob);
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(new Blob([this._bodyArrayBuffer]));
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as blob');
      } else {
        return Promise.resolve(new Blob([this._bodyText]));
      }
    };
    this.arrayBuffer = function () {
      if (this._bodyArrayBuffer) {
        var isConsumed = consumed(this);
        if (isConsumed) {
          return isConsumed;
        }
        if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
          return Promise.resolve(this._bodyArrayBuffer.buffer.slice(this._bodyArrayBuffer.byteOffset, this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength));
        } else {
          return Promise.resolve(this._bodyArrayBuffer);
        }
      } else {
        return this.blob().then(readBlobAsArrayBuffer);
      }
    };
  }
  this.text = function () {
    var rejected = consumed(this);
    if (rejected) {
      return rejected;
    }
    if (this._bodyBlob) {
      return readBlobAsText(this._bodyBlob);
    } else if (this._bodyArrayBuffer) {
      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
    } else if (this._bodyFormData) {
      throw new Error('could not read FormData body as text');
    } else {
      return Promise.resolve(this._bodyText);
    }
  };
  if (support.formData) {
    this.formData = function () {
      return this.text().then(decode);
    };
  }
  this.json = function () {
    return this.text().then(JSON.parse);
  };
  return this;
}

// HTTP methods whose capitalization should be normalized
var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];
function normalizeMethod(method) {
  var upcased = method.toUpperCase();
  return methods.indexOf(upcased) > -1 ? upcased : method;
}
function Request(input, options) {
  if (!(this instanceof Request)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  }
  options = options || {};
  var body = options.body;
  if (input instanceof Request) {
    if (input.bodyUsed) {
      throw new TypeError('Already read');
    }
    this.url = input.url;
    this.credentials = input.credentials;
    if (!options.headers) {
      this.headers = new Headers$1(input.headers);
    }
    this.method = input.method;
    this.mode = input.mode;
    this.signal = input.signal;
    if (!body && input._bodyInit != null) {
      body = input._bodyInit;
      input.bodyUsed = true;
    }
  } else {
    this.url = String(input);
  }
  this.credentials = options.credentials || this.credentials || 'same-origin';
  if (options.headers || !this.headers) {
    this.headers = new Headers$1(options.headers);
  }
  this.method = normalizeMethod(options.method || this.method || 'GET');
  this.mode = options.mode || this.mode || null;
  this.signal = options.signal || this.signal;
  this.referrer = null;
  if ((this.method === 'GET' || this.method === 'HEAD') && body) {
    throw new TypeError('Body not allowed for GET or HEAD requests');
  }
  this._initBody(body);
  if (this.method === 'GET' || this.method === 'HEAD') {
    if (options.cache === 'no-store' || options.cache === 'no-cache') {
      // Search for a '_' parameter in the query string
      var reParamSearch = /([?&])_=[^&]*/;
      if (reParamSearch.test(this.url)) {
        // If it already exists then set the value with the current time
        this.url = this.url.replace(reParamSearch, '$1_=' + new Date().getTime());
      } else {
        // Otherwise add a new '_' parameter to the end with the current time
        var reQueryString = /\?/;
        this.url += (reQueryString.test(this.url) ? '&' : '?') + '_=' + new Date().getTime();
      }
    }
  }
}
Request.prototype.clone = function () {
  return new Request(this, {
    body: this._bodyInit
  });
};
function decode(body) {
  var form = new FormData();
  body.trim().split('&').forEach(function (bytes) {
    if (bytes) {
      var split = bytes.split('=');
      var name = split.shift().replace(/\+/g, ' ');
      var value = split.join('=').replace(/\+/g, ' ');
      form.append(decodeURIComponent(name), decodeURIComponent(value));
    }
  });
  return form;
}
function parseHeaders(rawHeaders) {
  var headers = new Headers$1();
  // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
  // https://tools.ietf.org/html/rfc7230#section-3.2
  var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
  // Avoiding split via regex to work around a common IE11 bug with the core-js 3.6.0 regex polyfill
  // https://github.com/github/fetch/issues/748
  // https://github.com/zloirock/core-js/issues/751
  preProcessedHeaders.split('\r').map(function (header) {
    return header.indexOf('\n') === 0 ? header.substr(1, header.length) : header;
  }).forEach(function (line) {
    var parts = line.split(':');
    var key = parts.shift().trim();
    if (key) {
      var value = parts.join(':').trim();
      headers.append(key, value);
    }
  });
  return headers;
}
Body.call(Request.prototype);
function Response$1(bodyInit, options) {
  if (!(this instanceof Response$1)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  }
  if (!options) {
    options = {};
  }
  this.type = 'default';
  this.status = options.status === undefined ? 200 : options.status;
  this.ok = this.status >= 200 && this.status < 300;
  this.statusText = options.statusText === undefined ? '' : '' + options.statusText;
  this.headers = new Headers$1(options.headers);
  this.url = options.url || '';
  this._initBody(bodyInit);
}
Body.call(Response$1.prototype);
Response$1.prototype.clone = function () {
  return new Response$1(this._bodyInit, {
    status: this.status,
    statusText: this.statusText,
    headers: new Headers$1(this.headers),
    url: this.url
  });
};
Response$1.error = function () {
  var response = new Response$1(null, {
    status: 0,
    statusText: ''
  });
  response.type = 'error';
  return response;
};
var redirectStatuses = [301, 302, 303, 307, 308];
Response$1.redirect = function (url, status) {
  if (redirectStatuses.indexOf(status) === -1) {
    throw new RangeError('Invalid status code');
  }
  return new Response$1(null, {
    status: status,
    headers: {
      location: url
    }
  });
};
var DOMException$1 = global$1.DOMException;
try {
  new DOMException$1();
} catch (err) {
  DOMException$1 = function (message, name) {
    this.message = message;
    this.name = name;
    var error = Error(message);
    this.stack = error.stack;
  };
  DOMException$1.prototype = Object.create(Error.prototype);
  DOMException$1.prototype.constructor = DOMException$1;
}
function fetch$2(input, init) {
  return new Promise(function (resolve, reject) {
    var request = new Request(input, init);
    if (request.signal && request.signal.aborted) {
      return reject(new DOMException$1('Aborted', 'AbortError'));
    }
    var xhr = new XMLHttpRequest();
    function abortXhr() {
      xhr.abort();
    }
    xhr.onload = function () {
      var options = {
        status: xhr.status,
        statusText: xhr.statusText,
        headers: parseHeaders(xhr.getAllResponseHeaders() || '')
      };
      options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
      var body = 'response' in xhr ? xhr.response : xhr.responseText;
      setTimeout(function () {
        resolve(new Response$1(body, options));
      }, 0);
    };
    xhr.onerror = function () {
      setTimeout(function () {
        reject(new TypeError('Network request failed'));
      }, 0);
    };
    xhr.ontimeout = function () {
      setTimeout(function () {
        reject(new TypeError('Network request failed'));
      }, 0);
    };
    xhr.onabort = function () {
      setTimeout(function () {
        reject(new DOMException$1('Aborted', 'AbortError'));
      }, 0);
    };
    function fixUrl(url) {
      try {
        return url === '' && global$1.location.href ? global$1.location.href : url;
      } catch (e) {
        return url;
      }
    }
    xhr.open(request.method, fixUrl(request.url), true);
    if (request.credentials === 'include') {
      xhr.withCredentials = true;
    } else if (request.credentials === 'omit') {
      xhr.withCredentials = false;
    }
    if ('responseType' in xhr) {
      if (support.blob) {
        xhr.responseType = 'blob';
      } else if (support.arrayBuffer && request.headers.get('Content-Type') && request.headers.get('Content-Type').indexOf('application/octet-stream') !== -1) {
        xhr.responseType = 'arraybuffer';
      }
    }
    if (init && typeof init.headers === 'object' && !(init.headers instanceof Headers$1)) {
      Object.getOwnPropertyNames(init.headers).forEach(function (name) {
        xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
      });
    } else {
      request.headers.forEach(function (value, name) {
        xhr.setRequestHeader(name, value);
      });
    }
    if (request.signal) {
      request.signal.addEventListener('abort', abortXhr);
      xhr.onreadystatechange = function () {
        // DONE (success or failure)
        if (xhr.readyState === 4) {
          request.signal.removeEventListener('abort', abortXhr);
        }
      };
    }
    xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
  });
}
fetch$2.polyfill = true;
if (!global$1.fetch) {
  global$1.fetch = fetch$2;
  global$1.Headers = Headers$1;
  global$1.Request = Request;
  global$1.Response = Response$1;
}

/*
Stimulus 3.0.1
Copyright © 2021 Basecamp, LLC
 */
class EventListener {
  constructor(eventTarget, eventName, eventOptions) {
    this.eventTarget = eventTarget;
    this.eventName = eventName;
    this.eventOptions = eventOptions;
    this.unorderedBindings = new Set();
  }
  connect() {
    this.eventTarget.addEventListener(this.eventName, this, this.eventOptions);
  }
  disconnect() {
    this.eventTarget.removeEventListener(this.eventName, this, this.eventOptions);
  }
  bindingConnected(binding) {
    this.unorderedBindings.add(binding);
  }
  bindingDisconnected(binding) {
    this.unorderedBindings.delete(binding);
  }
  handleEvent(event) {
    const extendedEvent = extendEvent(event);
    for (const binding of this.bindings) {
      if (extendedEvent.immediatePropagationStopped) {
        break;
      } else {
        binding.handleEvent(extendedEvent);
      }
    }
  }
  get bindings() {
    return Array.from(this.unorderedBindings).sort((left, right) => {
      const leftIndex = left.index,
        rightIndex = right.index;
      return leftIndex < rightIndex ? -1 : leftIndex > rightIndex ? 1 : 0;
    });
  }
}
function extendEvent(event) {
  if ("immediatePropagationStopped" in event) {
    return event;
  } else {
    const {
      stopImmediatePropagation
    } = event;
    return Object.assign(event, {
      immediatePropagationStopped: false,
      stopImmediatePropagation() {
        this.immediatePropagationStopped = true;
        stopImmediatePropagation.call(this);
      }
    });
  }
}
class Dispatcher {
  constructor(application) {
    this.application = application;
    this.eventListenerMaps = new Map();
    this.started = false;
  }
  start() {
    if (!this.started) {
      this.started = true;
      this.eventListeners.forEach(eventListener => eventListener.connect());
    }
  }
  stop() {
    if (this.started) {
      this.started = false;
      this.eventListeners.forEach(eventListener => eventListener.disconnect());
    }
  }
  get eventListeners() {
    return Array.from(this.eventListenerMaps.values()).reduce((listeners, map) => listeners.concat(Array.from(map.values())), []);
  }
  bindingConnected(binding) {
    this.fetchEventListenerForBinding(binding).bindingConnected(binding);
  }
  bindingDisconnected(binding) {
    this.fetchEventListenerForBinding(binding).bindingDisconnected(binding);
  }
  handleError(error, message, detail = {}) {
    this.application.handleError(error, `Error ${message}`, detail);
  }
  fetchEventListenerForBinding(binding) {
    const {
      eventTarget,
      eventName,
      eventOptions
    } = binding;
    return this.fetchEventListener(eventTarget, eventName, eventOptions);
  }
  fetchEventListener(eventTarget, eventName, eventOptions) {
    const eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget);
    const cacheKey = this.cacheKey(eventName, eventOptions);
    let eventListener = eventListenerMap.get(cacheKey);
    if (!eventListener) {
      eventListener = this.createEventListener(eventTarget, eventName, eventOptions);
      eventListenerMap.set(cacheKey, eventListener);
    }
    return eventListener;
  }
  createEventListener(eventTarget, eventName, eventOptions) {
    const eventListener = new EventListener(eventTarget, eventName, eventOptions);
    if (this.started) {
      eventListener.connect();
    }
    return eventListener;
  }
  fetchEventListenerMapForEventTarget(eventTarget) {
    let eventListenerMap = this.eventListenerMaps.get(eventTarget);
    if (!eventListenerMap) {
      eventListenerMap = new Map();
      this.eventListenerMaps.set(eventTarget, eventListenerMap);
    }
    return eventListenerMap;
  }
  cacheKey(eventName, eventOptions) {
    const parts = [eventName];
    Object.keys(eventOptions).sort().forEach(key => {
      parts.push(`${eventOptions[key] ? "" : "!"}${key}`);
    });
    return parts.join(":");
  }
}
const descriptorPattern = /^((.+?)(@(window|document))?->)?(.+?)(#([^:]+?))(:(.+))?$/;
function parseActionDescriptorString(descriptorString) {
  const source = descriptorString.trim();
  const matches = source.match(descriptorPattern) || [];
  return {
    eventTarget: parseEventTarget(matches[4]),
    eventName: matches[2],
    eventOptions: matches[9] ? parseEventOptions(matches[9]) : {},
    identifier: matches[5],
    methodName: matches[7]
  };
}
function parseEventTarget(eventTargetName) {
  if (eventTargetName == "window") {
    return window;
  } else if (eventTargetName == "document") {
    return document;
  }
}
function parseEventOptions(eventOptions) {
  return eventOptions.split(":").reduce((options, token) => Object.assign(options, {
    [token.replace(/^!/, "")]: !/^!/.test(token)
  }), {});
}
function stringifyEventTarget(eventTarget) {
  if (eventTarget == window) {
    return "window";
  } else if (eventTarget == document) {
    return "document";
  }
}
function camelize(value) {
  return value.replace(/(?:[_-])([a-z0-9])/g, (_, char) => char.toUpperCase());
}
function capitalize(value) {
  return value.charAt(0).toUpperCase() + value.slice(1);
}
function dasherize(value) {
  return value.replace(/([A-Z])/g, (_, char) => `-${char.toLowerCase()}`);
}
function tokenize(value) {
  return value.match(/[^\s]+/g) || [];
}
class Action {
  constructor(element, index, descriptor) {
    this.element = element;
    this.index = index;
    this.eventTarget = descriptor.eventTarget || element;
    this.eventName = descriptor.eventName || getDefaultEventNameForElement(element) || error("missing event name");
    this.eventOptions = descriptor.eventOptions || {};
    this.identifier = descriptor.identifier || error("missing identifier");
    this.methodName = descriptor.methodName || error("missing method name");
  }
  static forToken(token) {
    return new this(token.element, token.index, parseActionDescriptorString(token.content));
  }
  toString() {
    const eventNameSuffix = this.eventTargetName ? `@${this.eventTargetName}` : "";
    return `${this.eventName}${eventNameSuffix}->${this.identifier}#${this.methodName}`;
  }
  get params() {
    if (this.eventTarget instanceof Element) {
      return this.getParamsFromEventTargetAttributes(this.eventTarget);
    } else {
      return {};
    }
  }
  getParamsFromEventTargetAttributes(eventTarget) {
    const params = {};
    const pattern = new RegExp(`^data-${this.identifier}-(.+)-param$`);
    const attributes = Array.from(eventTarget.attributes);
    attributes.forEach(({
      name,
      value
    }) => {
      const match = name.match(pattern);
      const key = match && match[1];
      if (key) {
        Object.assign(params, {
          [camelize(key)]: typecast(value)
        });
      }
    });
    return params;
  }
  get eventTargetName() {
    return stringifyEventTarget(this.eventTarget);
  }
}
const defaultEventNames = {
  "a": e => "click",
  "button": e => "click",
  "form": e => "submit",
  "details": e => "toggle",
  "input": e => e.getAttribute("type") == "submit" ? "click" : "input",
  "select": e => "change",
  "textarea": e => "input"
};
function getDefaultEventNameForElement(element) {
  const tagName = element.tagName.toLowerCase();
  if (tagName in defaultEventNames) {
    return defaultEventNames[tagName](element);
  }
}
function error(message) {
  throw new Error(message);
}
function typecast(value) {
  try {
    return JSON.parse(value);
  } catch (o_O) {
    return value;
  }
}
class Binding {
  constructor(context, action) {
    this.context = context;
    this.action = action;
  }
  get index() {
    return this.action.index;
  }
  get eventTarget() {
    return this.action.eventTarget;
  }
  get eventOptions() {
    return this.action.eventOptions;
  }
  get identifier() {
    return this.context.identifier;
  }
  handleEvent(event) {
    if (this.willBeInvokedByEvent(event)) {
      this.invokeWithEvent(event);
    }
  }
  get eventName() {
    return this.action.eventName;
  }
  get method() {
    const method = this.controller[this.methodName];
    if (typeof method == "function") {
      return method;
    }
    throw new Error(`Action "${this.action}" references undefined method "${this.methodName}"`);
  }
  invokeWithEvent(event) {
    const {
      target,
      currentTarget
    } = event;
    try {
      const {
        params
      } = this.action;
      const actionEvent = Object.assign(event, {
        params
      });
      this.method.call(this.controller, actionEvent);
      this.context.logDebugActivity(this.methodName, {
        event,
        target,
        currentTarget,
        action: this.methodName
      });
    } catch (error) {
      const {
        identifier,
        controller,
        element,
        index
      } = this;
      const detail = {
        identifier,
        controller,
        element,
        index,
        event
      };
      this.context.handleError(error, `invoking action "${this.action}"`, detail);
    }
  }
  willBeInvokedByEvent(event) {
    const eventTarget = event.target;
    if (this.element === eventTarget) {
      return true;
    } else if (eventTarget instanceof Element && this.element.contains(eventTarget)) {
      return this.scope.containsElement(eventTarget);
    } else {
      return this.scope.containsElement(this.action.element);
    }
  }
  get controller() {
    return this.context.controller;
  }
  get methodName() {
    return this.action.methodName;
  }
  get element() {
    return this.scope.element;
  }
  get scope() {
    return this.context.scope;
  }
}
class ElementObserver {
  constructor(element, delegate) {
    this.mutationObserverInit = {
      attributes: true,
      childList: true,
      subtree: true
    };
    this.element = element;
    this.started = false;
    this.delegate = delegate;
    this.elements = new Set();
    this.mutationObserver = new MutationObserver(mutations => this.processMutations(mutations));
  }
  start() {
    if (!this.started) {
      this.started = true;
      this.mutationObserver.observe(this.element, this.mutationObserverInit);
      this.refresh();
    }
  }
  pause(callback) {
    if (this.started) {
      this.mutationObserver.disconnect();
      this.started = false;
    }
    callback();
    if (!this.started) {
      this.mutationObserver.observe(this.element, this.mutationObserverInit);
      this.started = true;
    }
  }
  stop() {
    if (this.started) {
      this.mutationObserver.takeRecords();
      this.mutationObserver.disconnect();
      this.started = false;
    }
  }
  refresh() {
    if (this.started) {
      const matches = new Set(this.matchElementsInTree());
      for (const element of Array.from(this.elements)) {
        if (!matches.has(element)) {
          this.removeElement(element);
        }
      }
      for (const element of Array.from(matches)) {
        this.addElement(element);
      }
    }
  }
  processMutations(mutations) {
    if (this.started) {
      for (const mutation of mutations) {
        this.processMutation(mutation);
      }
    }
  }
  processMutation(mutation) {
    if (mutation.type == "attributes") {
      this.processAttributeChange(mutation.target, mutation.attributeName);
    } else if (mutation.type == "childList") {
      this.processRemovedNodes(mutation.removedNodes);
      this.processAddedNodes(mutation.addedNodes);
    }
  }
  processAttributeChange(node, attributeName) {
    const element = node;
    if (this.elements.has(element)) {
      if (this.delegate.elementAttributeChanged && this.matchElement(element)) {
        this.delegate.elementAttributeChanged(element, attributeName);
      } else {
        this.removeElement(element);
      }
    } else if (this.matchElement(element)) {
      this.addElement(element);
    }
  }
  processRemovedNodes(nodes) {
    for (const node of Array.from(nodes)) {
      const element = this.elementFromNode(node);
      if (element) {
        this.processTree(element, this.removeElement);
      }
    }
  }
  processAddedNodes(nodes) {
    for (const node of Array.from(nodes)) {
      const element = this.elementFromNode(node);
      if (element && this.elementIsActive(element)) {
        this.processTree(element, this.addElement);
      }
    }
  }
  matchElement(element) {
    return this.delegate.matchElement(element);
  }
  matchElementsInTree(tree = this.element) {
    return this.delegate.matchElementsInTree(tree);
  }
  processTree(tree, processor) {
    for (const element of this.matchElementsInTree(tree)) {
      processor.call(this, element);
    }
  }
  elementFromNode(node) {
    if (node.nodeType == Node.ELEMENT_NODE) {
      return node;
    }
  }
  elementIsActive(element) {
    if (element.isConnected != this.element.isConnected) {
      return false;
    } else {
      return this.element.contains(element);
    }
  }
  addElement(element) {
    if (!this.elements.has(element)) {
      if (this.elementIsActive(element)) {
        this.elements.add(element);
        if (this.delegate.elementMatched) {
          this.delegate.elementMatched(element);
        }
      }
    }
  }
  removeElement(element) {
    if (this.elements.has(element)) {
      this.elements.delete(element);
      if (this.delegate.elementUnmatched) {
        this.delegate.elementUnmatched(element);
      }
    }
  }
}
class AttributeObserver {
  constructor(element, attributeName, delegate) {
    this.attributeName = attributeName;
    this.delegate = delegate;
    this.elementObserver = new ElementObserver(element, this);
  }
  get element() {
    return this.elementObserver.element;
  }
  get selector() {
    return `[${this.attributeName}]`;
  }
  start() {
    this.elementObserver.start();
  }
  pause(callback) {
    this.elementObserver.pause(callback);
  }
  stop() {
    this.elementObserver.stop();
  }
  refresh() {
    this.elementObserver.refresh();
  }
  get started() {
    return this.elementObserver.started;
  }
  matchElement(element) {
    return element.hasAttribute(this.attributeName);
  }
  matchElementsInTree(tree) {
    const match = this.matchElement(tree) ? [tree] : [];
    const matches = Array.from(tree.querySelectorAll(this.selector));
    return match.concat(matches);
  }
  elementMatched(element) {
    if (this.delegate.elementMatchedAttribute) {
      this.delegate.elementMatchedAttribute(element, this.attributeName);
    }
  }
  elementUnmatched(element) {
    if (this.delegate.elementUnmatchedAttribute) {
      this.delegate.elementUnmatchedAttribute(element, this.attributeName);
    }
  }
  elementAttributeChanged(element, attributeName) {
    if (this.delegate.elementAttributeValueChanged && this.attributeName == attributeName) {
      this.delegate.elementAttributeValueChanged(element, attributeName);
    }
  }
}
class StringMapObserver {
  constructor(element, delegate) {
    this.element = element;
    this.delegate = delegate;
    this.started = false;
    this.stringMap = new Map();
    this.mutationObserver = new MutationObserver(mutations => this.processMutations(mutations));
  }
  start() {
    if (!this.started) {
      this.started = true;
      this.mutationObserver.observe(this.element, {
        attributes: true,
        attributeOldValue: true
      });
      this.refresh();
    }
  }
  stop() {
    if (this.started) {
      this.mutationObserver.takeRecords();
      this.mutationObserver.disconnect();
      this.started = false;
    }
  }
  refresh() {
    if (this.started) {
      for (const attributeName of this.knownAttributeNames) {
        this.refreshAttribute(attributeName, null);
      }
    }
  }
  processMutations(mutations) {
    if (this.started) {
      for (const mutation of mutations) {
        this.processMutation(mutation);
      }
    }
  }
  processMutation(mutation) {
    const attributeName = mutation.attributeName;
    if (attributeName) {
      this.refreshAttribute(attributeName, mutation.oldValue);
    }
  }
  refreshAttribute(attributeName, oldValue) {
    const key = this.delegate.getStringMapKeyForAttribute(attributeName);
    if (key != null) {
      if (!this.stringMap.has(attributeName)) {
        this.stringMapKeyAdded(key, attributeName);
      }
      const value = this.element.getAttribute(attributeName);
      if (this.stringMap.get(attributeName) != value) {
        this.stringMapValueChanged(value, key, oldValue);
      }
      if (value == null) {
        const oldValue = this.stringMap.get(attributeName);
        this.stringMap.delete(attributeName);
        if (oldValue) this.stringMapKeyRemoved(key, attributeName, oldValue);
      } else {
        this.stringMap.set(attributeName, value);
      }
    }
  }
  stringMapKeyAdded(key, attributeName) {
    if (this.delegate.stringMapKeyAdded) {
      this.delegate.stringMapKeyAdded(key, attributeName);
    }
  }
  stringMapValueChanged(value, key, oldValue) {
    if (this.delegate.stringMapValueChanged) {
      this.delegate.stringMapValueChanged(value, key, oldValue);
    }
  }
  stringMapKeyRemoved(key, attributeName, oldValue) {
    if (this.delegate.stringMapKeyRemoved) {
      this.delegate.stringMapKeyRemoved(key, attributeName, oldValue);
    }
  }
  get knownAttributeNames() {
    return Array.from(new Set(this.currentAttributeNames.concat(this.recordedAttributeNames)));
  }
  get currentAttributeNames() {
    return Array.from(this.element.attributes).map(attribute => attribute.name);
  }
  get recordedAttributeNames() {
    return Array.from(this.stringMap.keys());
  }
}
function add(map, key, value) {
  fetch$1(map, key).add(value);
}
function del(map, key, value) {
  fetch$1(map, key).delete(value);
  prune(map, key);
}
function fetch$1(map, key) {
  let values = map.get(key);
  if (!values) {
    values = new Set();
    map.set(key, values);
  }
  return values;
}
function prune(map, key) {
  const values = map.get(key);
  if (values != null && values.size == 0) {
    map.delete(key);
  }
}
class Multimap {
  constructor() {
    this.valuesByKey = new Map();
  }
  get keys() {
    return Array.from(this.valuesByKey.keys());
  }
  get values() {
    const sets = Array.from(this.valuesByKey.values());
    return sets.reduce((values, set) => values.concat(Array.from(set)), []);
  }
  get size() {
    const sets = Array.from(this.valuesByKey.values());
    return sets.reduce((size, set) => size + set.size, 0);
  }
  add(key, value) {
    add(this.valuesByKey, key, value);
  }
  delete(key, value) {
    del(this.valuesByKey, key, value);
  }
  has(key, value) {
    const values = this.valuesByKey.get(key);
    return values != null && values.has(value);
  }
  hasKey(key) {
    return this.valuesByKey.has(key);
  }
  hasValue(value) {
    const sets = Array.from(this.valuesByKey.values());
    return sets.some(set => set.has(value));
  }
  getValuesForKey(key) {
    const values = this.valuesByKey.get(key);
    return values ? Array.from(values) : [];
  }
  getKeysForValue(value) {
    return Array.from(this.valuesByKey).filter(([key, values]) => values.has(value)).map(([key, values]) => key);
  }
}
class TokenListObserver {
  constructor(element, attributeName, delegate) {
    this.attributeObserver = new AttributeObserver(element, attributeName, this);
    this.delegate = delegate;
    this.tokensByElement = new Multimap();
  }
  get started() {
    return this.attributeObserver.started;
  }
  start() {
    this.attributeObserver.start();
  }
  pause(callback) {
    this.attributeObserver.pause(callback);
  }
  stop() {
    this.attributeObserver.stop();
  }
  refresh() {
    this.attributeObserver.refresh();
  }
  get element() {
    return this.attributeObserver.element;
  }
  get attributeName() {
    return this.attributeObserver.attributeName;
  }
  elementMatchedAttribute(element) {
    this.tokensMatched(this.readTokensForElement(element));
  }
  elementAttributeValueChanged(element) {
    const [unmatchedTokens, matchedTokens] = this.refreshTokensForElement(element);
    this.tokensUnmatched(unmatchedTokens);
    this.tokensMatched(matchedTokens);
  }
  elementUnmatchedAttribute(element) {
    this.tokensUnmatched(this.tokensByElement.getValuesForKey(element));
  }
  tokensMatched(tokens) {
    tokens.forEach(token => this.tokenMatched(token));
  }
  tokensUnmatched(tokens) {
    tokens.forEach(token => this.tokenUnmatched(token));
  }
  tokenMatched(token) {
    this.delegate.tokenMatched(token);
    this.tokensByElement.add(token.element, token);
  }
  tokenUnmatched(token) {
    this.delegate.tokenUnmatched(token);
    this.tokensByElement.delete(token.element, token);
  }
  refreshTokensForElement(element) {
    const previousTokens = this.tokensByElement.getValuesForKey(element);
    const currentTokens = this.readTokensForElement(element);
    const firstDifferingIndex = zip(previousTokens, currentTokens).findIndex(([previousToken, currentToken]) => !tokensAreEqual(previousToken, currentToken));
    if (firstDifferingIndex == -1) {
      return [[], []];
    } else {
      return [previousTokens.slice(firstDifferingIndex), currentTokens.slice(firstDifferingIndex)];
    }
  }
  readTokensForElement(element) {
    const attributeName = this.attributeName;
    const tokenString = element.getAttribute(attributeName) || "";
    return parseTokenString(tokenString, element, attributeName);
  }
}
function parseTokenString(tokenString, element, attributeName) {
  return tokenString.trim().split(/\s+/).filter(content => content.length).map((content, index) => ({
    element,
    attributeName,
    content,
    index
  }));
}
function zip(left, right) {
  const length = Math.max(left.length, right.length);
  return Array.from({
    length
  }, (_, index) => [left[index], right[index]]);
}
function tokensAreEqual(left, right) {
  return left && right && left.index == right.index && left.content == right.content;
}
class ValueListObserver {
  constructor(element, attributeName, delegate) {
    this.tokenListObserver = new TokenListObserver(element, attributeName, this);
    this.delegate = delegate;
    this.parseResultsByToken = new WeakMap();
    this.valuesByTokenByElement = new WeakMap();
  }
  get started() {
    return this.tokenListObserver.started;
  }
  start() {
    this.tokenListObserver.start();
  }
  stop() {
    this.tokenListObserver.stop();
  }
  refresh() {
    this.tokenListObserver.refresh();
  }
  get element() {
    return this.tokenListObserver.element;
  }
  get attributeName() {
    return this.tokenListObserver.attributeName;
  }
  tokenMatched(token) {
    const {
      element
    } = token;
    const {
      value
    } = this.fetchParseResultForToken(token);
    if (value) {
      this.fetchValuesByTokenForElement(element).set(token, value);
      this.delegate.elementMatchedValue(element, value);
    }
  }
  tokenUnmatched(token) {
    const {
      element
    } = token;
    const {
      value
    } = this.fetchParseResultForToken(token);
    if (value) {
      this.fetchValuesByTokenForElement(element).delete(token);
      this.delegate.elementUnmatchedValue(element, value);
    }
  }
  fetchParseResultForToken(token) {
    let parseResult = this.parseResultsByToken.get(token);
    if (!parseResult) {
      parseResult = this.parseToken(token);
      this.parseResultsByToken.set(token, parseResult);
    }
    return parseResult;
  }
  fetchValuesByTokenForElement(element) {
    let valuesByToken = this.valuesByTokenByElement.get(element);
    if (!valuesByToken) {
      valuesByToken = new Map();
      this.valuesByTokenByElement.set(element, valuesByToken);
    }
    return valuesByToken;
  }
  parseToken(token) {
    try {
      const value = this.delegate.parseValueForToken(token);
      return {
        value
      };
    } catch (error) {
      return {
        error
      };
    }
  }
}
class BindingObserver {
  constructor(context, delegate) {
    this.context = context;
    this.delegate = delegate;
    this.bindingsByAction = new Map();
  }
  start() {
    if (!this.valueListObserver) {
      this.valueListObserver = new ValueListObserver(this.element, this.actionAttribute, this);
      this.valueListObserver.start();
    }
  }
  stop() {
    if (this.valueListObserver) {
      this.valueListObserver.stop();
      delete this.valueListObserver;
      this.disconnectAllActions();
    }
  }
  get element() {
    return this.context.element;
  }
  get identifier() {
    return this.context.identifier;
  }
  get actionAttribute() {
    return this.schema.actionAttribute;
  }
  get schema() {
    return this.context.schema;
  }
  get bindings() {
    return Array.from(this.bindingsByAction.values());
  }
  connectAction(action) {
    const binding = new Binding(this.context, action);
    this.bindingsByAction.set(action, binding);
    this.delegate.bindingConnected(binding);
  }
  disconnectAction(action) {
    const binding = this.bindingsByAction.get(action);
    if (binding) {
      this.bindingsByAction.delete(action);
      this.delegate.bindingDisconnected(binding);
    }
  }
  disconnectAllActions() {
    this.bindings.forEach(binding => this.delegate.bindingDisconnected(binding));
    this.bindingsByAction.clear();
  }
  parseValueForToken(token) {
    const action = Action.forToken(token);
    if (action.identifier == this.identifier) {
      return action;
    }
  }
  elementMatchedValue(element, action) {
    this.connectAction(action);
  }
  elementUnmatchedValue(element, action) {
    this.disconnectAction(action);
  }
}
class ValueObserver {
  constructor(context, receiver) {
    this.context = context;
    this.receiver = receiver;
    this.stringMapObserver = new StringMapObserver(this.element, this);
    this.valueDescriptorMap = this.controller.valueDescriptorMap;
    this.invokeChangedCallbacksForDefaultValues();
  }
  start() {
    this.stringMapObserver.start();
  }
  stop() {
    this.stringMapObserver.stop();
  }
  get element() {
    return this.context.element;
  }
  get controller() {
    return this.context.controller;
  }
  getStringMapKeyForAttribute(attributeName) {
    if (attributeName in this.valueDescriptorMap) {
      return this.valueDescriptorMap[attributeName].name;
    }
  }
  stringMapKeyAdded(key, attributeName) {
    const descriptor = this.valueDescriptorMap[attributeName];
    if (!this.hasValue(key)) {
      this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), descriptor.writer(descriptor.defaultValue));
    }
  }
  stringMapValueChanged(value, name, oldValue) {
    const descriptor = this.valueDescriptorNameMap[name];
    if (value === null) return;
    if (oldValue === null) {
      oldValue = descriptor.writer(descriptor.defaultValue);
    }
    this.invokeChangedCallback(name, value, oldValue);
  }
  stringMapKeyRemoved(key, attributeName, oldValue) {
    const descriptor = this.valueDescriptorNameMap[key];
    if (this.hasValue(key)) {
      this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), oldValue);
    } else {
      this.invokeChangedCallback(key, descriptor.writer(descriptor.defaultValue), oldValue);
    }
  }
  invokeChangedCallbacksForDefaultValues() {
    for (const {
      key,
      name,
      defaultValue,
      writer
    } of this.valueDescriptors) {
      if (defaultValue != undefined && !this.controller.data.has(key)) {
        this.invokeChangedCallback(name, writer(defaultValue), undefined);
      }
    }
  }
  invokeChangedCallback(name, rawValue, rawOldValue) {
    const changedMethodName = `${name}Changed`;
    const changedMethod = this.receiver[changedMethodName];
    if (typeof changedMethod == "function") {
      const descriptor = this.valueDescriptorNameMap[name];
      const value = descriptor.reader(rawValue);
      let oldValue = rawOldValue;
      if (rawOldValue) {
        oldValue = descriptor.reader(rawOldValue);
      }
      changedMethod.call(this.receiver, value, oldValue);
    }
  }
  get valueDescriptors() {
    const {
      valueDescriptorMap
    } = this;
    return Object.keys(valueDescriptorMap).map(key => valueDescriptorMap[key]);
  }
  get valueDescriptorNameMap() {
    const descriptors = {};
    Object.keys(this.valueDescriptorMap).forEach(key => {
      const descriptor = this.valueDescriptorMap[key];
      descriptors[descriptor.name] = descriptor;
    });
    return descriptors;
  }
  hasValue(attributeName) {
    const descriptor = this.valueDescriptorNameMap[attributeName];
    const hasMethodName = `has${capitalize(descriptor.name)}`;
    return this.receiver[hasMethodName];
  }
}
class TargetObserver {
  constructor(context, delegate) {
    this.context = context;
    this.delegate = delegate;
    this.targetsByName = new Multimap();
  }
  start() {
    if (!this.tokenListObserver) {
      this.tokenListObserver = new TokenListObserver(this.element, this.attributeName, this);
      this.tokenListObserver.start();
    }
  }
  stop() {
    if (this.tokenListObserver) {
      this.disconnectAllTargets();
      this.tokenListObserver.stop();
      delete this.tokenListObserver;
    }
  }
  tokenMatched({
    element,
    content: name
  }) {
    if (this.scope.containsElement(element)) {
      this.connectTarget(element, name);
    }
  }
  tokenUnmatched({
    element,
    content: name
  }) {
    this.disconnectTarget(element, name);
  }
  connectTarget(element, name) {
    var _a;
    if (!this.targetsByName.has(name, element)) {
      this.targetsByName.add(name, element);
      (_a = this.tokenListObserver) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.targetConnected(element, name));
    }
  }
  disconnectTarget(element, name) {
    var _a;
    if (this.targetsByName.has(name, element)) {
      this.targetsByName.delete(name, element);
      (_a = this.tokenListObserver) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.targetDisconnected(element, name));
    }
  }
  disconnectAllTargets() {
    for (const name of this.targetsByName.keys) {
      for (const element of this.targetsByName.getValuesForKey(name)) {
        this.disconnectTarget(element, name);
      }
    }
  }
  get attributeName() {
    return `data-${this.context.identifier}-target`;
  }
  get element() {
    return this.context.element;
  }
  get scope() {
    return this.context.scope;
  }
}
class Context {
  constructor(module, scope) {
    this.logDebugActivity = (functionName, detail = {}) => {
      const {
        identifier,
        controller,
        element
      } = this;
      detail = Object.assign({
        identifier,
        controller,
        element
      }, detail);
      this.application.logDebugActivity(this.identifier, functionName, detail);
    };
    this.module = module;
    this.scope = scope;
    this.controller = new module.controllerConstructor(this);
    this.bindingObserver = new BindingObserver(this, this.dispatcher);
    this.valueObserver = new ValueObserver(this, this.controller);
    this.targetObserver = new TargetObserver(this, this);
    try {
      this.controller.initialize();
      this.logDebugActivity("initialize");
    } catch (error) {
      this.handleError(error, "initializing controller");
    }
  }
  connect() {
    this.bindingObserver.start();
    this.valueObserver.start();
    this.targetObserver.start();
    try {
      this.controller.connect();
      this.logDebugActivity("connect");
    } catch (error) {
      this.handleError(error, "connecting controller");
    }
  }
  disconnect() {
    try {
      this.controller.disconnect();
      this.logDebugActivity("disconnect");
    } catch (error) {
      this.handleError(error, "disconnecting controller");
    }
    this.targetObserver.stop();
    this.valueObserver.stop();
    this.bindingObserver.stop();
  }
  get application() {
    return this.module.application;
  }
  get identifier() {
    return this.module.identifier;
  }
  get schema() {
    return this.application.schema;
  }
  get dispatcher() {
    return this.application.dispatcher;
  }
  get element() {
    return this.scope.element;
  }
  get parentElement() {
    return this.element.parentElement;
  }
  handleError(error, message, detail = {}) {
    const {
      identifier,
      controller,
      element
    } = this;
    detail = Object.assign({
      identifier,
      controller,
      element
    }, detail);
    this.application.handleError(error, `Error ${message}`, detail);
  }
  targetConnected(element, name) {
    this.invokeControllerMethod(`${name}TargetConnected`, element);
  }
  targetDisconnected(element, name) {
    this.invokeControllerMethod(`${name}TargetDisconnected`, element);
  }
  invokeControllerMethod(methodName, ...args) {
    const controller = this.controller;
    if (typeof controller[methodName] == "function") {
      controller[methodName](...args);
    }
  }
}
function readInheritableStaticArrayValues(constructor, propertyName) {
  const ancestors = getAncestorsForConstructor(constructor);
  return Array.from(ancestors.reduce((values, constructor) => {
    getOwnStaticArrayValues(constructor, propertyName).forEach(name => values.add(name));
    return values;
  }, new Set()));
}
function readInheritableStaticObjectPairs(constructor, propertyName) {
  const ancestors = getAncestorsForConstructor(constructor);
  return ancestors.reduce((pairs, constructor) => {
    pairs.push(...getOwnStaticObjectPairs(constructor, propertyName));
    return pairs;
  }, []);
}
function getAncestorsForConstructor(constructor) {
  const ancestors = [];
  while (constructor) {
    ancestors.push(constructor);
    constructor = Object.getPrototypeOf(constructor);
  }
  return ancestors.reverse();
}
function getOwnStaticArrayValues(constructor, propertyName) {
  const definition = constructor[propertyName];
  return Array.isArray(definition) ? definition : [];
}
function getOwnStaticObjectPairs(constructor, propertyName) {
  const definition = constructor[propertyName];
  return definition ? Object.keys(definition).map(key => [key, definition[key]]) : [];
}
function bless(constructor) {
  return shadow(constructor, getBlessedProperties(constructor));
}
function shadow(constructor, properties) {
  const shadowConstructor = extend$2(constructor);
  const shadowProperties = getShadowProperties(constructor.prototype, properties);
  Object.defineProperties(shadowConstructor.prototype, shadowProperties);
  return shadowConstructor;
}
function getBlessedProperties(constructor) {
  const blessings = readInheritableStaticArrayValues(constructor, "blessings");
  return blessings.reduce((blessedProperties, blessing) => {
    const properties = blessing(constructor);
    for (const key in properties) {
      const descriptor = blessedProperties[key] || {};
      blessedProperties[key] = Object.assign(descriptor, properties[key]);
    }
    return blessedProperties;
  }, {});
}
function getShadowProperties(prototype, properties) {
  return getOwnKeys(properties).reduce((shadowProperties, key) => {
    const descriptor = getShadowedDescriptor(prototype, properties, key);
    if (descriptor) {
      Object.assign(shadowProperties, {
        [key]: descriptor
      });
    }
    return shadowProperties;
  }, {});
}
function getShadowedDescriptor(prototype, properties, key) {
  const shadowingDescriptor = Object.getOwnPropertyDescriptor(prototype, key);
  const shadowedByValue = shadowingDescriptor && "value" in shadowingDescriptor;
  if (!shadowedByValue) {
    const descriptor = Object.getOwnPropertyDescriptor(properties, key).value;
    if (shadowingDescriptor) {
      descriptor.get = shadowingDescriptor.get || descriptor.get;
      descriptor.set = shadowingDescriptor.set || descriptor.set;
    }
    return descriptor;
  }
}
const getOwnKeys = (() => {
  if (typeof Object.getOwnPropertySymbols == "function") {
    return object => [...Object.getOwnPropertyNames(object), ...Object.getOwnPropertySymbols(object)];
  } else {
    return Object.getOwnPropertyNames;
  }
})();
const extend$2 = (() => {
  function extendWithReflect(constructor) {
    function extended() {
      return Reflect.construct(constructor, arguments, new.target);
    }
    extended.prototype = Object.create(constructor.prototype, {
      constructor: {
        value: extended
      }
    });
    Reflect.setPrototypeOf(extended, constructor);
    return extended;
  }
  function testReflectExtension() {
    const a = function () {
      this.a.call(this);
    };
    const b = extendWithReflect(a);
    b.prototype.a = function () {};
    return new b();
  }
  try {
    testReflectExtension();
    return extendWithReflect;
  } catch (error) {
    return constructor => class extended extends constructor {};
  }
})();
function blessDefinition(definition) {
  return {
    identifier: definition.identifier,
    controllerConstructor: bless(definition.controllerConstructor)
  };
}
class Module {
  constructor(application, definition) {
    this.application = application;
    this.definition = blessDefinition(definition);
    this.contextsByScope = new WeakMap();
    this.connectedContexts = new Set();
  }
  get identifier() {
    return this.definition.identifier;
  }
  get controllerConstructor() {
    return this.definition.controllerConstructor;
  }
  get contexts() {
    return Array.from(this.connectedContexts);
  }
  connectContextForScope(scope) {
    const context = this.fetchContextForScope(scope);
    this.connectedContexts.add(context);
    context.connect();
  }
  disconnectContextForScope(scope) {
    const context = this.contextsByScope.get(scope);
    if (context) {
      this.connectedContexts.delete(context);
      context.disconnect();
    }
  }
  fetchContextForScope(scope) {
    let context = this.contextsByScope.get(scope);
    if (!context) {
      context = new Context(this, scope);
      this.contextsByScope.set(scope, context);
    }
    return context;
  }
}
class ClassMap {
  constructor(scope) {
    this.scope = scope;
  }
  has(name) {
    return this.data.has(this.getDataKey(name));
  }
  get(name) {
    return this.getAll(name)[0];
  }
  getAll(name) {
    const tokenString = this.data.get(this.getDataKey(name)) || "";
    return tokenize(tokenString);
  }
  getAttributeName(name) {
    return this.data.getAttributeNameForKey(this.getDataKey(name));
  }
  getDataKey(name) {
    return `${name}-class`;
  }
  get data() {
    return this.scope.data;
  }
}
class DataMap {
  constructor(scope) {
    this.scope = scope;
  }
  get element() {
    return this.scope.element;
  }
  get identifier() {
    return this.scope.identifier;
  }
  get(key) {
    const name = this.getAttributeNameForKey(key);
    return this.element.getAttribute(name);
  }
  set(key, value) {
    const name = this.getAttributeNameForKey(key);
    this.element.setAttribute(name, value);
    return this.get(key);
  }
  has(key) {
    const name = this.getAttributeNameForKey(key);
    return this.element.hasAttribute(name);
  }
  delete(key) {
    if (this.has(key)) {
      const name = this.getAttributeNameForKey(key);
      this.element.removeAttribute(name);
      return true;
    } else {
      return false;
    }
  }
  getAttributeNameForKey(key) {
    return `data-${this.identifier}-${dasherize(key)}`;
  }
}
class Guide {
  constructor(logger) {
    this.warnedKeysByObject = new WeakMap();
    this.logger = logger;
  }
  warn(object, key, message) {
    let warnedKeys = this.warnedKeysByObject.get(object);
    if (!warnedKeys) {
      warnedKeys = new Set();
      this.warnedKeysByObject.set(object, warnedKeys);
    }
    if (!warnedKeys.has(key)) {
      warnedKeys.add(key);
      this.logger.warn(message, object);
    }
  }
}
function attributeValueContainsToken(attributeName, token) {
  return `[${attributeName}~="${token}"]`;
}
class TargetSet {
  constructor(scope) {
    this.scope = scope;
  }
  get element() {
    return this.scope.element;
  }
  get identifier() {
    return this.scope.identifier;
  }
  get schema() {
    return this.scope.schema;
  }
  has(targetName) {
    return this.find(targetName) != null;
  }
  find(...targetNames) {
    return targetNames.reduce((target, targetName) => target || this.findTarget(targetName) || this.findLegacyTarget(targetName), undefined);
  }
  findAll(...targetNames) {
    return targetNames.reduce((targets, targetName) => [...targets, ...this.findAllTargets(targetName), ...this.findAllLegacyTargets(targetName)], []);
  }
  findTarget(targetName) {
    const selector = this.getSelectorForTargetName(targetName);
    return this.scope.findElement(selector);
  }
  findAllTargets(targetName) {
    const selector = this.getSelectorForTargetName(targetName);
    return this.scope.findAllElements(selector);
  }
  getSelectorForTargetName(targetName) {
    const attributeName = this.schema.targetAttributeForScope(this.identifier);
    return attributeValueContainsToken(attributeName, targetName);
  }
  findLegacyTarget(targetName) {
    const selector = this.getLegacySelectorForTargetName(targetName);
    return this.deprecate(this.scope.findElement(selector), targetName);
  }
  findAllLegacyTargets(targetName) {
    const selector = this.getLegacySelectorForTargetName(targetName);
    return this.scope.findAllElements(selector).map(element => this.deprecate(element, targetName));
  }
  getLegacySelectorForTargetName(targetName) {
    const targetDescriptor = `${this.identifier}.${targetName}`;
    return attributeValueContainsToken(this.schema.targetAttribute, targetDescriptor);
  }
  deprecate(element, targetName) {
    if (element) {
      const {
        identifier
      } = this;
      const attributeName = this.schema.targetAttribute;
      const revisedAttributeName = this.schema.targetAttributeForScope(identifier);
      this.guide.warn(element, `target:${targetName}`, `Please replace ${attributeName}="${identifier}.${targetName}" with ${revisedAttributeName}="${targetName}". ` + `The ${attributeName} attribute is deprecated and will be removed in a future version of Stimulus.`);
    }
    return element;
  }
  get guide() {
    return this.scope.guide;
  }
}
class Scope {
  constructor(schema, element, identifier, logger) {
    this.targets = new TargetSet(this);
    this.classes = new ClassMap(this);
    this.data = new DataMap(this);
    this.containsElement = element => {
      return element.closest(this.controllerSelector) === this.element;
    };
    this.schema = schema;
    this.element = element;
    this.identifier = identifier;
    this.guide = new Guide(logger);
  }
  findElement(selector) {
    return this.element.matches(selector) ? this.element : this.queryElements(selector).find(this.containsElement);
  }
  findAllElements(selector) {
    return [...(this.element.matches(selector) ? [this.element] : []), ...this.queryElements(selector).filter(this.containsElement)];
  }
  queryElements(selector) {
    return Array.from(this.element.querySelectorAll(selector));
  }
  get controllerSelector() {
    return attributeValueContainsToken(this.schema.controllerAttribute, this.identifier);
  }
}
class ScopeObserver {
  constructor(element, schema, delegate) {
    this.element = element;
    this.schema = schema;
    this.delegate = delegate;
    this.valueListObserver = new ValueListObserver(this.element, this.controllerAttribute, this);
    this.scopesByIdentifierByElement = new WeakMap();
    this.scopeReferenceCounts = new WeakMap();
  }
  start() {
    this.valueListObserver.start();
  }
  stop() {
    this.valueListObserver.stop();
  }
  get controllerAttribute() {
    return this.schema.controllerAttribute;
  }
  parseValueForToken(token) {
    const {
      element,
      content: identifier
    } = token;
    const scopesByIdentifier = this.fetchScopesByIdentifierForElement(element);
    let scope = scopesByIdentifier.get(identifier);
    if (!scope) {
      scope = this.delegate.createScopeForElementAndIdentifier(element, identifier);
      scopesByIdentifier.set(identifier, scope);
    }
    return scope;
  }
  elementMatchedValue(element, value) {
    const referenceCount = (this.scopeReferenceCounts.get(value) || 0) + 1;
    this.scopeReferenceCounts.set(value, referenceCount);
    if (referenceCount == 1) {
      this.delegate.scopeConnected(value);
    }
  }
  elementUnmatchedValue(element, value) {
    const referenceCount = this.scopeReferenceCounts.get(value);
    if (referenceCount) {
      this.scopeReferenceCounts.set(value, referenceCount - 1);
      if (referenceCount == 1) {
        this.delegate.scopeDisconnected(value);
      }
    }
  }
  fetchScopesByIdentifierForElement(element) {
    let scopesByIdentifier = this.scopesByIdentifierByElement.get(element);
    if (!scopesByIdentifier) {
      scopesByIdentifier = new Map();
      this.scopesByIdentifierByElement.set(element, scopesByIdentifier);
    }
    return scopesByIdentifier;
  }
}
class Router {
  constructor(application) {
    this.application = application;
    this.scopeObserver = new ScopeObserver(this.element, this.schema, this);
    this.scopesByIdentifier = new Multimap();
    this.modulesByIdentifier = new Map();
  }
  get element() {
    return this.application.element;
  }
  get schema() {
    return this.application.schema;
  }
  get logger() {
    return this.application.logger;
  }
  get controllerAttribute() {
    return this.schema.controllerAttribute;
  }
  get modules() {
    return Array.from(this.modulesByIdentifier.values());
  }
  get contexts() {
    return this.modules.reduce((contexts, module) => contexts.concat(module.contexts), []);
  }
  start() {
    this.scopeObserver.start();
  }
  stop() {
    this.scopeObserver.stop();
  }
  loadDefinition(definition) {
    this.unloadIdentifier(definition.identifier);
    const module = new Module(this.application, definition);
    this.connectModule(module);
  }
  unloadIdentifier(identifier) {
    const module = this.modulesByIdentifier.get(identifier);
    if (module) {
      this.disconnectModule(module);
    }
  }
  getContextForElementAndIdentifier(element, identifier) {
    const module = this.modulesByIdentifier.get(identifier);
    if (module) {
      return module.contexts.find(context => context.element == element);
    }
  }
  handleError(error, message, detail) {
    this.application.handleError(error, message, detail);
  }
  createScopeForElementAndIdentifier(element, identifier) {
    return new Scope(this.schema, element, identifier, this.logger);
  }
  scopeConnected(scope) {
    this.scopesByIdentifier.add(scope.identifier, scope);
    const module = this.modulesByIdentifier.get(scope.identifier);
    if (module) {
      module.connectContextForScope(scope);
    }
  }
  scopeDisconnected(scope) {
    this.scopesByIdentifier.delete(scope.identifier, scope);
    const module = this.modulesByIdentifier.get(scope.identifier);
    if (module) {
      module.disconnectContextForScope(scope);
    }
  }
  connectModule(module) {
    this.modulesByIdentifier.set(module.identifier, module);
    const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);
    scopes.forEach(scope => module.connectContextForScope(scope));
  }
  disconnectModule(module) {
    this.modulesByIdentifier.delete(module.identifier);
    const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);
    scopes.forEach(scope => module.disconnectContextForScope(scope));
  }
}
const defaultSchema = {
  controllerAttribute: "data-controller",
  actionAttribute: "data-action",
  targetAttribute: "data-target",
  targetAttributeForScope: identifier => `data-${identifier}-target`
};
class Application {
  constructor(element = document.documentElement, schema = defaultSchema) {
    this.logger = console;
    this.debug = false;
    this.logDebugActivity = (identifier, functionName, detail = {}) => {
      if (this.debug) {
        this.logFormattedMessage(identifier, functionName, detail);
      }
    };
    this.element = element;
    this.schema = schema;
    this.dispatcher = new Dispatcher(this);
    this.router = new Router(this);
  }
  static start(element, schema) {
    const application = new Application(element, schema);
    application.start();
    return application;
  }
  async start() {
    await domReady();
    this.logDebugActivity("application", "starting");
    this.dispatcher.start();
    this.router.start();
    this.logDebugActivity("application", "start");
  }
  stop() {
    this.logDebugActivity("application", "stopping");
    this.dispatcher.stop();
    this.router.stop();
    this.logDebugActivity("application", "stop");
  }
  register(identifier, controllerConstructor) {
    if (controllerConstructor.shouldLoad) {
      this.load({
        identifier,
        controllerConstructor
      });
    }
  }
  load(head, ...rest) {
    const definitions = Array.isArray(head) ? head : [head, ...rest];
    definitions.forEach(definition => this.router.loadDefinition(definition));
  }
  unload(head, ...rest) {
    const identifiers = Array.isArray(head) ? head : [head, ...rest];
    identifiers.forEach(identifier => this.router.unloadIdentifier(identifier));
  }
  get controllers() {
    return this.router.contexts.map(context => context.controller);
  }
  getControllerForElementAndIdentifier(element, identifier) {
    const context = this.router.getContextForElementAndIdentifier(element, identifier);
    return context ? context.controller : null;
  }
  handleError(error, message, detail) {
    var _a;
    this.logger.error(`%s\n\n%o\n\n%o`, message, error, detail);
    (_a = window.onerror) === null || _a === void 0 ? void 0 : _a.call(window, message, "", 0, 0, error);
  }
  logFormattedMessage(identifier, functionName, detail = {}) {
    detail = Object.assign({
      application: this
    }, detail);
    this.logger.groupCollapsed(`${identifier} #${functionName}`);
    this.logger.log("details:", Object.assign({}, detail));
    this.logger.groupEnd();
  }
}
function domReady() {
  return new Promise(resolve => {
    if (document.readyState == "loading") {
      document.addEventListener("DOMContentLoaded", () => resolve());
    } else {
      resolve();
    }
  });
}
function ClassPropertiesBlessing(constructor) {
  const classes = readInheritableStaticArrayValues(constructor, "classes");
  return classes.reduce((properties, classDefinition) => {
    return Object.assign(properties, propertiesForClassDefinition(classDefinition));
  }, {});
}
function propertiesForClassDefinition(key) {
  return {
    [`${key}Class`]: {
      get() {
        const {
          classes
        } = this;
        if (classes.has(key)) {
          return classes.get(key);
        } else {
          const attribute = classes.getAttributeName(key);
          throw new Error(`Missing attribute "${attribute}"`);
        }
      }
    },
    [`${key}Classes`]: {
      get() {
        return this.classes.getAll(key);
      }
    },
    [`has${capitalize(key)}Class`]: {
      get() {
        return this.classes.has(key);
      }
    }
  };
}
function TargetPropertiesBlessing(constructor) {
  const targets = readInheritableStaticArrayValues(constructor, "targets");
  return targets.reduce((properties, targetDefinition) => {
    return Object.assign(properties, propertiesForTargetDefinition(targetDefinition));
  }, {});
}
function propertiesForTargetDefinition(name) {
  return {
    [`${name}Target`]: {
      get() {
        const target = this.targets.find(name);
        if (target) {
          return target;
        } else {
          throw new Error(`Missing target element "${name}" for "${this.identifier}" controller`);
        }
      }
    },
    [`${name}Targets`]: {
      get() {
        return this.targets.findAll(name);
      }
    },
    [`has${capitalize(name)}Target`]: {
      get() {
        return this.targets.has(name);
      }
    }
  };
}
function ValuePropertiesBlessing(constructor) {
  const valueDefinitionPairs = readInheritableStaticObjectPairs(constructor, "values");
  const propertyDescriptorMap = {
    valueDescriptorMap: {
      get() {
        return valueDefinitionPairs.reduce((result, valueDefinitionPair) => {
          const valueDescriptor = parseValueDefinitionPair(valueDefinitionPair);
          const attributeName = this.data.getAttributeNameForKey(valueDescriptor.key);
          return Object.assign(result, {
            [attributeName]: valueDescriptor
          });
        }, {});
      }
    }
  };
  return valueDefinitionPairs.reduce((properties, valueDefinitionPair) => {
    return Object.assign(properties, propertiesForValueDefinitionPair(valueDefinitionPair));
  }, propertyDescriptorMap);
}
function propertiesForValueDefinitionPair(valueDefinitionPair) {
  const definition = parseValueDefinitionPair(valueDefinitionPair);
  const {
    key,
    name,
    reader: read,
    writer: write
  } = definition;
  return {
    [name]: {
      get() {
        const value = this.data.get(key);
        if (value !== null) {
          return read(value);
        } else {
          return definition.defaultValue;
        }
      },
      set(value) {
        if (value === undefined) {
          this.data.delete(key);
        } else {
          this.data.set(key, write(value));
        }
      }
    },
    [`has${capitalize(name)}`]: {
      get() {
        return this.data.has(key) || definition.hasCustomDefaultValue;
      }
    }
  };
}
function parseValueDefinitionPair([token, typeDefinition]) {
  return valueDescriptorForTokenAndTypeDefinition(token, typeDefinition);
}
function parseValueTypeConstant(constant) {
  switch (constant) {
    case Array:
      return "array";
    case Boolean:
      return "boolean";
    case Number:
      return "number";
    case Object:
      return "object";
    case String:
      return "string";
  }
}
function parseValueTypeDefault(defaultValue) {
  switch (typeof defaultValue) {
    case "boolean":
      return "boolean";
    case "number":
      return "number";
    case "string":
      return "string";
  }
  if (Array.isArray(defaultValue)) return "array";
  if (Object.prototype.toString.call(defaultValue) === "[object Object]") return "object";
}
function parseValueTypeObject(typeObject) {
  const typeFromObject = parseValueTypeConstant(typeObject.type);
  if (typeFromObject) {
    const defaultValueType = parseValueTypeDefault(typeObject.default);
    if (typeFromObject !== defaultValueType) {
      throw new Error(`Type "${typeFromObject}" must match the type of the default value. Given default value: "${typeObject.default}" as "${defaultValueType}"`);
    }
    return typeFromObject;
  }
}
function parseValueTypeDefinition(typeDefinition) {
  const typeFromObject = parseValueTypeObject(typeDefinition);
  const typeFromDefaultValue = parseValueTypeDefault(typeDefinition);
  const typeFromConstant = parseValueTypeConstant(typeDefinition);
  const type = typeFromObject || typeFromDefaultValue || typeFromConstant;
  if (type) return type;
  throw new Error(`Unknown value type "${typeDefinition}"`);
}
function defaultValueForDefinition(typeDefinition) {
  const constant = parseValueTypeConstant(typeDefinition);
  if (constant) return defaultValuesByType[constant];
  const defaultValue = typeDefinition.default;
  if (defaultValue !== undefined) return defaultValue;
  return typeDefinition;
}
function valueDescriptorForTokenAndTypeDefinition(token, typeDefinition) {
  const key = `${dasherize(token)}-value`;
  const type = parseValueTypeDefinition(typeDefinition);
  return {
    type,
    key,
    name: camelize(key),
    get defaultValue() {
      return defaultValueForDefinition(typeDefinition);
    },
    get hasCustomDefaultValue() {
      return parseValueTypeDefault(typeDefinition) !== undefined;
    },
    reader: readers[type],
    writer: writers[type] || writers.default
  };
}
const defaultValuesByType = {
  get array() {
    return [];
  },
  boolean: false,
  number: 0,
  get object() {
    return {};
  },
  string: ""
};
const readers = {
  array(value) {
    const array = JSON.parse(value);
    if (!Array.isArray(array)) {
      throw new TypeError("Expected array");
    }
    return array;
  },
  boolean(value) {
    return !(value == "0" || value == "false");
  },
  number(value) {
    return Number(value);
  },
  object(value) {
    const object = JSON.parse(value);
    if (object === null || typeof object != "object" || Array.isArray(object)) {
      throw new TypeError("Expected object");
    }
    return object;
  },
  string(value) {
    return value;
  }
};
const writers = {
  default: writeString,
  array: writeJSON,
  object: writeJSON
};
function writeJSON(value) {
  return JSON.stringify(value);
}
function writeString(value) {
  return `${value}`;
}
class Controller {
  constructor(context) {
    this.context = context;
  }
  static get shouldLoad() {
    return true;
  }
  get application() {
    return this.context.application;
  }
  get scope() {
    return this.context.scope;
  }
  get element() {
    return this.scope.element;
  }
  get identifier() {
    return this.scope.identifier;
  }
  get targets() {
    return this.scope.targets;
  }
  get classes() {
    return this.scope.classes;
  }
  get data() {
    return this.scope.data;
  }
  initialize() {}
  connect() {}
  disconnect() {}
  dispatch(eventName, {
    target = this.element,
    detail = {},
    prefix = this.identifier,
    bubbles = true,
    cancelable = true
  } = {}) {
    const type = prefix ? `${prefix}:${eventName}` : eventName;
    const event = new CustomEvent(type, {
      detail,
      bubbles,
      cancelable
    });
    target.dispatchEvent(event);
    return event;
  }
}
Controller.blessings = [ClassPropertiesBlessing, TargetPropertiesBlessing, ValuePropertiesBlessing];
Controller.targets = [];
Controller.values = {};

var application = Application.start();

// Configure Stimulus development experience
application.warnings = true;
application.debug = false;
window.Stimulus = application;

function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) {
      _defineProperty$x(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _classCallCheck$x(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$x(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass$x(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$x(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$x(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _defineProperty$x(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _inherits$w(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf$w(subClass, superClass);
}
function _getPrototypeOf$w(o) {
  _getPrototypeOf$w = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$w(o);
}
function _setPrototypeOf$w(o, p) {
  _setPrototypeOf$w = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf$w(o, p);
}
function _isNativeReflectConstruct$w() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _assertThisInitialized$w(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _possibleConstructorReturn$w(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$w(self);
}
function _createSuper$w(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$w();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$w(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$w(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$w(this, result);
  };
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$1(arr);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _unsupportedIterableToArray$1(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$1(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);
}
function _arrayLikeToArray$1(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}

var $$5 = window.$;

// Used when a table has toggleable rows (initially hidden rows that can be toggled open
// to see e.g. notes or extended details) and each master row and its toggleable sibling are
// nested in a tbody (this is valid HTML) - ie there are probably two trs per tbody, and the last
// one is toggleable. If you need anyting more complex you'll need to clone or adapt this
// controller
var _default$z = /*#__PURE__*/function (_Controller) {
  _inherits$w(_default, _Controller);
  var _super = _createSuper$w(_default);
  function _default() {
    _classCallCheck$x(this, _default);
    return _super.apply(this, arguments);
  }
  _createClass$x(_default, [{
    key: "row",
    value:
    // This handler toggles the last tr in the current tbody. We use multiple tbodys in each table
    // to make toggling like this simpler, and to group the related (visible and toggleable) rows
    // together.
    function row(event) {
      event.preventDefault;
      var tbody = event.target.closest("tbody");
      tbody.classList.toggle("toggleable--open");
      // Update masonry - TODO: move to a module
      $$5(".mgrid > .row").masonry("layout");
    }

    // Toggle the last tr in each tbody in the current table.
    // The link that triggers this event will most likelt be a double chevron icon
    // sitting in a thead.
  }, {
    key: "table",
    value: function table(event) {
      event.preventDefault;
      var table = event.target.closest("table");
      var thead = event.target.closest("thead");
      // Use an Array rather a NodeList here as IE does not support NodeList.forEach
      var tbodies = Array.prototype.slice.call(table.querySelectorAll("tbody"));
      var hide = thead.classList.contains("toggleable--open");
      thead.classList.toggle("toggleable--open");
      tbodies.forEach(function (tbody) {
        tbody.classList.toggle("toggleable--open", !hide);
      });
      // Update masonry - TODO: move to a module
      $$5(".mgrid > .row").masonry("layout");
    }
  }]);
  return _default;
}(Controller);

/*  Single use controller only for the Dietetic Clinic Visit */
var _default$y = /*#__PURE__*/function (_Controller) {
  _inherits$w(_default, _Controller);
  var _super = _createSuper$w(_default);
  function _default() {
    _classCallCheck$x(this, _default);
    return _super.apply(this, arguments);
  }
  _createClass$x(_default, [{
    key: "initialize",
    value: function initialize() {
      this.calculate = this.calculate.bind(this);
    }
  }, {
    key: "connect",
    value: function connect() {
      // As the weight and the height are outside the scope of the controller
      // -> grab them directly
      this.weightElement = document.querySelector(this.weightSelectorValue);
      this.heightElement = document.querySelector(this.heightSelectorValue);
      this.heightElement.addEventListener("input", this.calculate);
      this.weightElement.addEventListener("input", this.calculate);
      this.calculate();
    }
  }, {
    key: "disconnect",
    value: function disconnect() {
      this.heightElement.removeEventListener("input", this.calculate);
      this.weightElement.removeEventListener("input", this.calculate);
    }
  }, {
    key: "calculate",
    value: function calculate() {
      var weight = this.weightElement.value;
      var height = this.heightElement.value;
      var value = weight && height ? (Math.round(weight / height / height * 10) / 10).toFixed(1) : "";
      this.outputTarget.innerText = value;
    }
  }]);
  return _default;
}(Controller);
_defineProperty$x(_default$y, "targets", ["output"]);
_defineProperty$x(_default$y, "values", {
  weightSelector: String,
  heightSelector: String
});

/*  Single use controller only for the Dietetic Clinic Visit */
var _default$x = /*#__PURE__*/function (_Controller) {
  _inherits$w(_default, _Controller);
  var _super = _createSuper$w(_default);
  function _default() {
    _classCallCheck$x(this, _default);
    return _super.apply(this, arguments);
  }
  _createClass$x(_default, [{
    key: "initialize",
    value: function initialize() {
      this.calculate = this.calculate.bind(this);
    }
  }, {
    key: "connect",
    value: function connect() {
      // As weight is outside the scope of the controller
      // -> grab directly
      this.weightElement = document.querySelector(this.weightSelectorValue);
      this.weightElement.addEventListener("input", this.calculate);
      this.calculate();
    }
  }, {
    key: "disconnect",
    value: function disconnect() {
      this.weightElement.removeEventListener("input", this.calculate);
    }
  }, {
    key: "calculate",
    value: function calculate() {
      var weight = this.weightElement.value;
      var previousWeight = this.previousWeightTarget.value;
      var value = weight && previousWeight ? Math.round((weight - previousWeight) / previousWeight * 100 * 10) / 10 + "%" : "";
      this.outputTarget.innerText = value;
    }
  }]);
  return _default;
}(Controller);
_defineProperty$x(_default$x, "targets", ["previousWeight", "output"]);
_defineProperty$x(_default$x, "values", {
  weightSelector: String
});

/*  Single use controller only for the Dietetic Clinic Visit */
var _default$w = /*#__PURE__*/function (_Controller) {
  _inherits$w(_default, _Controller);
  var _super = _createSuper$w(_default);
  function _default() {
    _classCallCheck$x(this, _default);
    return _super.apply(this, arguments);
  }
  _createClass$x(_default, [{
    key: "initialize",
    value: function initialize() {
      this.calculate = this.calculate.bind(this);
    }
  }, {
    key: "connect",
    value: function connect() {
      // As weight is outside the scope of the controller
      // -> grab directly
      this.idealBodyWeightElement = document.querySelector("#clinic_visit_document_ideal_body_weight");
      this.idealBodyWeightElement.addEventListener("input", this.calculate);
      this.calculate();
    }
  }, {
    key: "disconnect",
    value: function disconnect() {
      this.idealBodyWeightElement.removeEventListener("input", this.calculate);
    }
  }, {
    key: "calculate",
    value: function calculate() {
      var weight = this.idealBodyWeightElement.value;
      var proteinIntake = this.proteinIntakeTarget.value;
      var value = weight && proteinIntake ? Math.round(proteinIntake / weight * 10) / 10 + " g/day/kg" : "";
      this.outputTarget.innerText = value;
    }
  }]);
  return _default;
}(Controller);
_defineProperty$x(_default$w, "targets", ["proteinIntake", "output"]);

var $$4 = window.$;
var _default$v = /*#__PURE__*/function (_Controller) {
  _inherits$w(_default, _Controller);
  var _super = _createSuper$w(_default);
  function _default() {
    _classCallCheck$x(this, _default);
    return _super.apply(this, arguments);
  }
  _createClass$x(_default, [{
    key: "toggleAdministered",
    value: function toggleAdministered() {
      var checked = event.target.value == "true";
      this.containerTarget.classList.toggle("administered", checked);
      this.containerTarget.classList.toggle("not-administered", !checked);
      this.containerTarget.classList.remove("undecided");
      // The rest of this actions are using jQuery for now.
      $$4(".authentication", this.containerTarget).toggle(checked);
      $$4(".authentication", this.containerTarget).toggleClass("disabled-with-faded-overlay", !checked);
      $$4(".reason-why-not-administered", this.containerTarget).toggle(!checked);
      $$4("#btn_save_and_witness_later").toggle(checked);
    }
  }]);
  return _default;
}(Controller);
_defineProperty$x(_default$v, "targets", ["container", "radio"]);

var Rails$3 = window.Rails;

// Handles the modal dialog used for presenting Home Delivery print options to
// the user. Used on the prescrptions page.
var _default$u = /*#__PURE__*/function (_Controller) {
  _inherits$w(_default, _Controller);
  var _super = _createSuper$w(_default);
  function _default() {
    _classCallCheck$x(this, _default);
    return _super.apply(this, arguments);
  }
  _createClass$x(_default, [{
    key: "refreshForm",
    value:
    // Submit and re-display the form when 'drug type' or 'prescription duration'
    // dropdowns are changed
    function refreshForm() {
      Rails$3.fire(this.formTarget, "submit");
    }

    // When the user has clicked Print (launching the PDF in a new tab), hide
    // the Print button and display content which asks whether printing was
    // successful or not. Click one of these 2 buttons will dismiss the modal.
    // FYI if they say Yes (printing was a success) the home delivery
    // event (the object 'behind' our modal form) is updated with printed=true.
  }, {
    key: "askForPrintFeedback",
    value: function askForPrintFeedback() {
      this.printOptionsTarget.classList.toggle("visuallyhidden");
      this.printFeedbackTarget.classList.toggle("visuallyhidden");
    }
  }]);
  return _default;
}(Controller);
_defineProperty$x(_default$u, "targets", ["form", "printOptions", "printFeedback"]);

var $$3 = window.$;
var _default$t = /*#__PURE__*/function (_Controller) {
  _inherits$w(_default, _Controller);
  var _super = _createSuper$w(_default);
  function _default() {
    _classCallCheck$x(this, _default);
    return _super.apply(this, arguments);
  }
  _createClass$x(_default, [{
    key: "insert",
    value: function insert(event) {
      // TODO: set up the trix editor in each page as data-target="snippets.trix"
      var modal = $$3("#snippets-modal");
      var snippetBody = $$3(event.target).parent().closest("tr").find(".body").html();
      var trix = document.querySelector("trix-editor");
      trix.editor.insertHTML(snippetBody);
      $$3(modal).foundation("reveal", "close");
    }
  }]);
  return _default;
}(Controller);

var $$2 = window.$;
var _default$s = /*#__PURE__*/function (_Controller) {
  _inherits$w(_default, _Controller);
  var _super = _createSuper$w(_default);
  function _default() {
    _classCallCheck$x(this, _default);
    return _super.apply(this, arguments);
  }
  _createClass$x(_default, [{
    key: "initInsertEventNotesIntoTrixEditor",
    value: function initInsertEventNotesIntoTrixEditor(event) {
      event.preventDefault();
      var notes = $$2(event.target).data("notes");
      if (notes && this.trix) {
        this.trix.insertHTML(notes);
      } else {
        alert("There are no notes to insert");
      }
    }
  }, {
    key: "trix",
    get: function get() {
      return this.trixTarget.editor;
    }
  }]);
  return _default;
}(Controller);
_defineProperty$x(_default$s, "targets", ["trix"]);

// Handles the modal dialog used for presenting Home Delivery print options to
// the user. Used on the prescrptions page.
var _default$r = /*#__PURE__*/function (_Controller) {
  _inherits$w(_default, _Controller);
  var _super = _createSuper$w(_default);
  function _default() {
    _classCallCheck$x(this, _default);
    return _super.apply(this, arguments);
  }
  _createClass$x(_default, [{
    key: "connect",
    value: function connect() {
      var radio_value = this.providersTarget.querySelector("input:checked").value;
      this.toggleDeliveryDatesVisibility(radio_value);
    }
  }, {
    key: "toggleDeliveryDates",
    value: function toggleDeliveryDates(event) {
      this.toggleDeliveryDatesVisibility(event.target.value);
    }
  }, {
    key: "toggleDeliveryDatesVisibility",
    value: function toggleDeliveryDatesVisibility(radio_value) {
      if (radio_value == "home_delivery") {
        this.homeDeliveryDatesTarget.style.display = "block";
      } else {
        this.homeDeliveryDatesTarget.style.display = "none";
      }
    }
  }]);
  return _default;
}(Controller);
_defineProperty$x(_default$r, "targets", ["homeDeliveryDates", "providers"]);

/*! (c) Andrea Giammarchi - ISC */
var self$1 = {};
try {
  (function (URLSearchParams, plus) {
    if (new URLSearchParams('q=%2B').get('q') !== plus || new URLSearchParams({
      q: plus
    }).get('q') !== plus || new URLSearchParams([['q', plus]]).get('q') !== plus || new URLSearchParams('q=\n').toString() !== 'q=%0A' || new URLSearchParams({
      q: ' &'
    }).toString() !== 'q=+%26' || new URLSearchParams({
      q: '%zx'
    }).toString() !== 'q=%25zx') throw URLSearchParams;
    self$1.URLSearchParams = URLSearchParams;
  })(URLSearchParams, '+');
} catch (URLSearchParams) {
  (function (Object, String, isArray) {

    var create = Object.create;
    var defineProperty = Object.defineProperty;
    var find = /[!'\(\)~]|%20|%00/g;
    var findPercentSign = /%(?![0-9a-fA-F]{2})/g;
    var plus = /\+/g;
    var replace = {
      '!': '%21',
      "'": '%27',
      '(': '%28',
      ')': '%29',
      '~': '%7E',
      '%20': '+',
      '%00': '\x00'
    };
    var proto = {
      append: function (key, value) {
        appendTo(this._ungap, key, value);
      },
      delete: function (key) {
        delete this._ungap[key];
      },
      get: function (key) {
        return this.has(key) ? this._ungap[key][0] : null;
      },
      getAll: function (key) {
        return this.has(key) ? this._ungap[key].slice(0) : [];
      },
      has: function (key) {
        return key in this._ungap;
      },
      set: function (key, value) {
        this._ungap[key] = [String(value)];
      },
      forEach: function (callback, thisArg) {
        var self = this;
        for (var key in self._ungap) self._ungap[key].forEach(invoke, key);
        function invoke(value) {
          callback.call(thisArg, value, String(key), self);
        }
      },
      toJSON: function () {
        return {};
      },
      toString: function () {
        var query = [];
        for (var key in this._ungap) {
          var encoded = encode(key);
          for (var i = 0, value = this._ungap[key]; i < value.length; i++) {
            query.push(encoded + '=' + encode(value[i]));
          }
        }
        return query.join('&');
      }
    };
    for (var key in proto) defineProperty(URLSearchParams.prototype, key, {
      configurable: true,
      writable: true,
      value: proto[key]
    });
    self$1.URLSearchParams = URLSearchParams;
    function URLSearchParams(query) {
      var dict = create(null);
      defineProperty(this, '_ungap', {
        value: dict
      });
      switch (true) {
        case !query:
          break;
        case typeof query === 'string':
          if (query.charAt(0) === '?') {
            query = query.slice(1);
          }
          for (var pairs = query.split('&'), i = 0, length = pairs.length; i < length; i++) {
            var value = pairs[i];
            var index = value.indexOf('=');
            if (-1 < index) {
              appendTo(dict, decode(value.slice(0, index)), decode(value.slice(index + 1)));
            } else if (value.length) {
              appendTo(dict, decode(value), '');
            }
          }
          break;
        case isArray(query):
          for (var i = 0, length = query.length; i < length; i++) {
            var value = query[i];
            appendTo(dict, value[0], value[1]);
          }
          break;
        case 'forEach' in query:
          query.forEach(addEach, dict);
          break;
        default:
          for (var key in query) appendTo(dict, key, query[key]);
      }
    }
    function addEach(value, key) {
      appendTo(this, key, value);
    }
    function appendTo(dict, key, value) {
      var res = isArray(value) ? value.join(',') : value;
      if (key in dict) dict[key].push(res);else dict[key] = [res];
    }
    function decode(str) {
      return decodeURIComponent(str.replace(findPercentSign, '%25').replace(plus, ' '));
    }
    function encode(str) {
      return encodeURIComponent(str).replace(find, replacer);
    }
    function replacer(match) {
      return replace[match];
    }
  })(Object, String, Array.isArray);
}
(function (URLSearchParamsProto) {
  var iterable = false;
  try {
    iterable = !!Symbol.iterator;
  } catch (o_O) {}

  /* istanbul ignore else */
  if (!('forEach' in URLSearchParamsProto)) {
    URLSearchParamsProto.forEach = function forEach(callback, thisArg) {
      var self = this;
      var names = Object.create(null);
      this.toString().replace(/=[\s\S]*?(?:&|$)/g, '=').split('=').forEach(function (name) {
        if (!name.length || name in names) return;
        (names[name] = self.getAll(name)).forEach(function (value) {
          callback.call(thisArg, value, name, self);
        });
      });
    };
  }

  /* istanbul ignore else */
  if (!('keys' in URLSearchParamsProto)) {
    URLSearchParamsProto.keys = function keys() {
      return iterator(this, function (value, key) {
        this.push(key);
      });
    };
  }

  /* istanbul ignore else */
  if (!('values' in URLSearchParamsProto)) {
    URLSearchParamsProto.values = function values() {
      return iterator(this, function (value, key) {
        this.push(value);
      });
    };
  }

  /* istanbul ignore else */
  if (!('entries' in URLSearchParamsProto)) {
    URLSearchParamsProto.entries = function entries() {
      return iterator(this, function (value, key) {
        this.push([key, value]);
      });
    };
  }

  /* istanbul ignore else */
  if (iterable && !(Symbol.iterator in URLSearchParamsProto)) {
    URLSearchParamsProto[Symbol.iterator] = URLSearchParamsProto.entries;
  }

  /* istanbul ignore else */
  if (!('sort' in URLSearchParamsProto)) {
    URLSearchParamsProto.sort = function sort() {
      var entries = this.entries(),
        entry = entries.next(),
        done = entry.done,
        keys = [],
        values = Object.create(null),
        i,
        key,
        value;
      while (!done) {
        value = entry.value;
        key = value[0];
        keys.push(key);
        if (!(key in values)) {
          values[key] = [];
        }
        values[key].push(value[1]);
        entry = entries.next();
        done = entry.done;
      }
      // not the champion in efficiency
      // but these two bits just do the job
      keys.sort();
      for (i = 0; i < keys.length; i++) {
        this.delete(keys[i]);
      }
      for (i = 0; i < keys.length; i++) {
        key = keys[i];
        this.append(key, values[key].shift());
      }
    };
  }
  function iterator(self, callback) {
    var items = [];
    self.forEach(callback, items);
    /* istanbul ignore next */
    return iterable ? items[Symbol.iterator]() : {
      next: function () {
        var value = items.shift();
        return {
          done: value === void 0,
          value: value
        };
      }
    };
  }

  /* istanbul ignore next */
  (function (Object) {
    var dP = Object.defineProperty,
      gOPD = Object.getOwnPropertyDescriptor,
      createSearchParamsPollute = function (search) {
        function append(name, value) {
          URLSearchParamsProto.append.call(this, name, value);
          name = this.toString();
          search.set.call(this._usp, name ? '?' + name : '');
        }
        function del(name) {
          URLSearchParamsProto.delete.call(this, name);
          name = this.toString();
          search.set.call(this._usp, name ? '?' + name : '');
        }
        function set(name, value) {
          URLSearchParamsProto.set.call(this, name, value);
          name = this.toString();
          search.set.call(this._usp, name ? '?' + name : '');
        }
        return function (sp, value) {
          sp.append = append;
          sp.delete = del;
          sp.set = set;
          return dP(sp, '_usp', {
            configurable: true,
            writable: true,
            value: value
          });
        };
      },
      createSearchParamsCreate = function (polluteSearchParams) {
        return function (obj, sp) {
          dP(obj, '_searchParams', {
            configurable: true,
            writable: true,
            value: polluteSearchParams(sp, obj)
          });
          return sp;
        };
      },
      updateSearchParams = function (sp) {
        var append = sp.append;
        sp.append = URLSearchParamsProto.append;
        URLSearchParams.call(sp, sp._usp.search.slice(1));
        sp.append = append;
      },
      verifySearchParams = function (obj, Class) {
        if (!(obj instanceof Class)) throw new TypeError("'searchParams' accessed on an object that " + "does not implement interface " + Class.name);
      },
      upgradeClass = function (Class) {
        var ClassProto = Class.prototype,
          searchParams = gOPD(ClassProto, 'searchParams'),
          href = gOPD(ClassProto, 'href'),
          search = gOPD(ClassProto, 'search'),
          createSearchParams;
        if (!searchParams && search && search.set) {
          createSearchParams = createSearchParamsCreate(createSearchParamsPollute(search));
          Object.defineProperties(ClassProto, {
            href: {
              get: function () {
                return href.get.call(this);
              },
              set: function (value) {
                var sp = this._searchParams;
                href.set.call(this, value);
                if (sp) updateSearchParams(sp);
              }
            },
            search: {
              get: function () {
                return search.get.call(this);
              },
              set: function (value) {
                var sp = this._searchParams;
                search.set.call(this, value);
                if (sp) updateSearchParams(sp);
              }
            },
            searchParams: {
              get: function () {
                verifySearchParams(this, Class);
                return this._searchParams || createSearchParams(this, new URLSearchParams(this.search.slice(1)));
              },
              set: function (sp) {
                verifySearchParams(this, Class);
                createSearchParams(this, sp);
              }
            }
          });
        }
      };
    try {
      upgradeClass(HTMLAnchorElement);
      if (/^function|object$/.test(typeof URL) && URL.prototype) upgradeClass(URL);
    } catch (meh) {}
  })(Object);
})(self$1.URLSearchParams.prototype);
var URLSearchParams$1 = self$1.URLSearchParams;

var highcharts = {exports: {}};

/*
 Highcharts JS v10.1.0 (2022-04-29)

 (c) 2009-2021 Torstein Honsi

 License: www.highcharts.com/license
*/

(function (module) {
	(function (U, K) {
	  module.exports ? (K["default"] = K, module.exports = U.document ? K(U) : K) : (U.Highcharts && U.Highcharts.error(16, !0), U.Highcharts = K(U));
	})("undefined" !== typeof window ? window : commonjsGlobal, function (U) {
	  function K(a, C, f, H) {
	    a.hasOwnProperty(C) || (a[C] = H.apply(null, f), "function" === typeof CustomEvent && U.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", {
	      detail: {
	        path: C,
	        module: a[C]
	      }
	    })));
	  }
	  var f = {};
	  K(f, "Core/Globals.js", [], function () {
	    var a;
	    (function (a) {
	      a.SVG_NS = "http://www.w3.org/2000/svg";
	      a.product = "Highcharts";
	      a.version = "10.1.0";
	      a.win = "undefined" !== typeof U ? U : {};
	      a.doc = a.win.document;
	      a.svg = a.doc && a.doc.createElementNS && !!a.doc.createElementNS(a.SVG_NS, "svg").createSVGRect;
	      a.userAgent = a.win.navigator && a.win.navigator.userAgent || "";
	      a.isChrome = -1 !== a.userAgent.indexOf("Chrome");
	      a.isFirefox = -1 !== a.userAgent.indexOf("Firefox");
	      a.isMS = /(edge|msie|trident)/i.test(a.userAgent) && !a.win.opera;
	      a.isSafari = !a.isChrome && -1 !== a.userAgent.indexOf("Safari");
	      a.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(a.userAgent);
	      a.isWebKit = -1 !== a.userAgent.indexOf("AppleWebKit");
	      a.deg2rad = 2 * Math.PI / 360;
	      a.hasBidiBug = a.isFirefox && 4 > parseInt(a.userAgent.split("Firefox/")[1], 10);
	      a.hasTouch = !!a.win.TouchEvent;
	      a.marginNames = ["plotTop", "marginRight", "marginBottom", "plotLeft"];
	      a.noop = function () {};
	      a.supportsPassiveEvents = function () {
	        var f = !1;
	        if (!a.isMS) {
	          var C = Object.defineProperty({}, "passive", {
	            get: function () {
	              f = !0;
	            }
	          });
	          a.win.addEventListener && a.win.removeEventListener && (a.win.addEventListener("testPassive", a.noop, C), a.win.removeEventListener("testPassive", a.noop, C));
	        }
	        return f;
	      }();
	      a.charts = [];
	      a.dateFormats = {};
	      a.seriesTypes = {};
	      a.symbolSizes = {};
	      a.chartCount = 0;
	    })(a || (a = {}));
	    return a;
	  });
	  K(f, "Core/Utilities.js", [f["Core/Globals.js"]], function (a) {
	    function f(d, r, h, l) {
	      var v = r ? "Highcharts error" : "Highcharts warning";
	      32 === d && (d = v + ": Deprecated member");
	      var m = n(d),
	        c = m ? v + " #" + d + ": www.highcharts.com/errors/" + d + "/" : d.toString();
	      if ("undefined" !== typeof l) {
	        var q = "";
	        m && (c += "?");
	        y(l, function (b, d) {
	          q += "\n - " + d + ": " + b;
	          m && (c += encodeURI(d) + "=" + encodeURI(b));
	        });
	        c += q;
	      }
	      z(a, "displayError", {
	        chart: h,
	        code: d,
	        message: c,
	        params: l
	      }, function () {
	        if (r) throw Error(c);
	        b.console && -1 === f.messages.indexOf(c) && console.warn(c);
	      });
	      f.messages.push(c);
	    }
	    function B(b, d) {
	      var v = {};
	      y(b, function (r, h) {
	        if (I(b[h], !0) && !b.nodeType && d[h]) r = B(b[h], d[h]), Object.keys(r).length && (v[h] = r);else if (I(b[h]) || b[h] !== d[h] || h in b && !(h in d)) v[h] = b[h];
	      });
	      return v;
	    }
	    function H(b, d) {
	      return parseInt(b, d || 10);
	    }
	    function w(b) {
	      return "string" === typeof b;
	    }
	    function E(b) {
	      b = Object.prototype.toString.call(b);
	      return "[object Array]" === b || "[object Array Iterator]" === b;
	    }
	    function I(b, d) {
	      return !!b && "object" === typeof b && (!d || !E(b));
	    }
	    function A(b) {
	      return I(b) && "number" === typeof b.nodeType;
	    }
	    function u(b) {
	      var d = b && b.constructor;
	      return !(!I(b, !0) || A(b) || !d || !d.name || "Object" === d.name);
	    }
	    function n(b) {
	      return "number" === typeof b && !isNaN(b) && Infinity > b && -Infinity < b;
	    }
	    function k(b) {
	      return "undefined" !== typeof b && null !== b;
	    }
	    function e(b, d, h) {
	      var v = w(d) && !k(h),
	        r,
	        l = function (d, h) {
	          k(d) ? b.setAttribute(h, d) : v ? (r = b.getAttribute(h)) || "class" !== h || (r = b.getAttribute(h + "Name")) : b.removeAttribute(h);
	        };
	      w(d) ? l(h, d) : y(d, l);
	      return r;
	    }
	    function c(b, d) {
	      var v;
	      b || (b = {});
	      for (v in d) b[v] = d[v];
	      return b;
	    }
	    function p() {
	      for (var b = arguments, d = b.length, h = 0; h < d; h++) {
	        var l = b[h];
	        if ("undefined" !== typeof l && null !== l) return l;
	      }
	    }
	    function g(b, d) {
	      a.isMS && !a.svg && d && k(d.opacity) && (d.filter = "alpha(opacity=" + 100 * d.opacity + ")");
	      c(b.style, d);
	    }
	    function t(b) {
	      return Math.pow(10, Math.floor(Math.log(b) / Math.LN10));
	    }
	    function q(b, d) {
	      return 1E14 < b ? b : parseFloat(b.toPrecision(d || 14));
	    }
	    function F(d, r, h) {
	      var v = a.getStyle || F;
	      if ("width" === r) return r = Math.min(d.offsetWidth, d.scrollWidth), h = d.getBoundingClientRect && d.getBoundingClientRect().width, h < r && h >= r - 1 && (r = Math.floor(h)), Math.max(0, r - (v(d, "padding-left", !0) || 0) - (v(d, "padding-right", !0) || 0));
	      if ("height" === r) return Math.max(0, Math.min(d.offsetHeight, d.scrollHeight) - (v(d, "padding-top", !0) || 0) - (v(d, "padding-bottom", !0) || 0));
	      b.getComputedStyle || f(27, !0);
	      if (d = b.getComputedStyle(d, void 0)) {
	        var l = d.getPropertyValue(r);
	        p(h, "opacity" !== r) && (l = H(l));
	      }
	      return l;
	    }
	    function y(b, d, h) {
	      for (var v in b) Object.hasOwnProperty.call(b, v) && d.call(h || b[v], b[v], v, b);
	    }
	    function x(b, d, h) {
	      function v(d, J) {
	        var v = b.removeEventListener || a.removeEventListenerPolyfill;
	        v && v.call(b, d, J, !1);
	      }
	      function r(r) {
	        var J;
	        if (b.nodeName) {
	          if (d) {
	            var L = {};
	            L[d] = !0;
	          } else L = r;
	          y(L, function (b, d) {
	            if (r[d]) for (J = r[d].length; J--;) v(d, r[d][J].fn);
	          });
	        }
	      }
	      var l = "function" === typeof b && b.prototype || b;
	      if (Object.hasOwnProperty.call(l, "hcEvents")) {
	        var m = l.hcEvents;
	        d ? (l = m[d] || [], h ? (m[d] = l.filter(function (b) {
	          return h !== b.fn;
	        }), v(d, h)) : (r(m), m[d] = [])) : (r(m), delete l.hcEvents);
	      }
	    }
	    function z(b, d, l, m) {
	      l = l || {};
	      if (h.createEvent && (b.dispatchEvent || b.fireEvent && b !== a)) {
	        var v = h.createEvent("Events");
	        v.initEvent(d, !0, !0);
	        l = c(v, l);
	        b.dispatchEvent ? b.dispatchEvent(l) : b.fireEvent(d, l);
	      } else if (b.hcEvents) {
	        l.target || c(l, {
	          preventDefault: function () {
	            l.defaultPrevented = !0;
	          },
	          target: b,
	          type: d
	        });
	        v = [];
	        for (var r = b, q = !1; r.hcEvents;) Object.hasOwnProperty.call(r, "hcEvents") && r.hcEvents[d] && (v.length && (q = !0), v.unshift.apply(v, r.hcEvents[d])), r = Object.getPrototypeOf(r);
	        q && v.sort(function (b, d) {
	          return b.order - d.order;
	        });
	        v.forEach(function (d) {
	          !1 === d.fn.call(b, l) && l.preventDefault();
	        });
	      }
	      m && !l.defaultPrevented && m.call(b, l);
	    }
	    var m = a.charts,
	      h = a.doc,
	      b = a.win;
	    (f || (f = {})).messages = [];
	    Math.easeInOutSine = function (b) {
	      return -.5 * (Math.cos(Math.PI * b) - 1);
	    };
	    var l = Array.prototype.find ? function (b, d) {
	      return b.find(d);
	    } : function (b, d) {
	      var v,
	        r = b.length;
	      for (v = 0; v < r; v++) if (d(b[v], v)) return b[v];
	    };
	    y({
	      map: "map",
	      each: "forEach",
	      grep: "filter",
	      reduce: "reduce",
	      some: "some"
	    }, function (b, d) {
	      a[d] = function (v) {
	        var r;
	        f(32, !1, void 0, (r = {}, r["Highcharts." + d] = "use Array." + b, r));
	        return Array.prototype[b].apply(v, [].slice.call(arguments, 1));
	      };
	    });
	    var d,
	      D = function () {
	        var b = Math.random().toString(36).substring(2, 9) + "-",
	          r = 0;
	        return function () {
	          return "highcharts-" + (d ? "" : b) + r++;
	        };
	      }();
	    b.jQuery && (b.jQuery.fn.highcharts = function () {
	      var b = [].slice.call(arguments);
	      if (this[0]) return b[0] ? (new a[w(b[0]) ? b.shift() : "Chart"](this[0], b[0], b[1]), this) : m[e(this[0], "data-highcharts-chart")];
	    });
	    l = {
	      addEvent: function (b, d, h, l) {
	        void 0 === l && (l = {});
	        var r = "function" === typeof b && b.prototype || b;
	        Object.hasOwnProperty.call(r, "hcEvents") || (r.hcEvents = {});
	        r = r.hcEvents;
	        a.Point && b instanceof a.Point && b.series && b.series.chart && (b.series.chart.runTrackerClick = !0);
	        var v = b.addEventListener || a.addEventListenerPolyfill;
	        v && v.call(b, d, h, a.supportsPassiveEvents ? {
	          passive: void 0 === l.passive ? -1 !== d.indexOf("touch") : l.passive,
	          capture: !1
	        } : !1);
	        r[d] || (r[d] = []);
	        r[d].push({
	          fn: h,
	          order: "number" === typeof l.order ? l.order : Infinity
	        });
	        r[d].sort(function (b, d) {
	          return b.order - d.order;
	        });
	        return function () {
	          x(b, d, h);
	        };
	      },
	      arrayMax: function (b) {
	        for (var d = b.length, v = b[0]; d--;) b[d] > v && (v = b[d]);
	        return v;
	      },
	      arrayMin: function (b) {
	        for (var d = b.length, v = b[0]; d--;) b[d] < v && (v = b[d]);
	        return v;
	      },
	      attr: e,
	      clamp: function (b, d, h) {
	        return b > d ? b < h ? b : h : d;
	      },
	      cleanRecursively: B,
	      clearTimeout: function (b) {
	        k(b) && clearTimeout(b);
	      },
	      correctFloat: q,
	      createElement: function (b, d, l, m, q) {
	        b = h.createElement(b);
	        d && c(b, d);
	        q && g(b, {
	          padding: "0",
	          border: "none",
	          margin: "0"
	        });
	        l && g(b, l);
	        m && m.appendChild(b);
	        return b;
	      },
	      css: g,
	      defined: k,
	      destroyObjectProperties: function (b, d) {
	        y(b, function (r, v) {
	          r && r !== d && r.destroy && r.destroy();
	          delete b[v];
	        });
	      },
	      discardElement: function (b) {
	        b && b.parentElement && b.parentElement.removeChild(b);
	      },
	      erase: function (b, d) {
	        for (var r = b.length; r--;) if (b[r] === d) {
	          b.splice(r, 1);
	          break;
	        }
	      },
	      error: f,
	      extend: c,
	      extendClass: function (b, d) {
	        var r = function () {};
	        r.prototype = new b();
	        c(r.prototype, d);
	        return r;
	      },
	      find: l,
	      fireEvent: z,
	      getMagnitude: t,
	      getNestedProperty: function (d, r) {
	        for (d = d.split("."); d.length && k(r);) {
	          var h = d.shift();
	          if ("undefined" === typeof h || "__proto__" === h) return;
	          r = r[h];
	          if (!k(r) || "function" === typeof r || "number" === typeof r.nodeType || r === b) return;
	        }
	        return r;
	      },
	      getStyle: F,
	      inArray: function (b, d, h) {
	        f(32, !1, void 0, {
	          "Highcharts.inArray": "use Array.indexOf"
	        });
	        return d.indexOf(b, h);
	      },
	      isArray: E,
	      isClass: u,
	      isDOMElement: A,
	      isFunction: function (b) {
	        return "function" === typeof b;
	      },
	      isNumber: n,
	      isObject: I,
	      isString: w,
	      keys: function (b) {
	        f(32, !1, void 0, {
	          "Highcharts.keys": "use Object.keys"
	        });
	        return Object.keys(b);
	      },
	      merge: function () {
	        var b,
	          d = arguments,
	          h = {},
	          l = function (b, d) {
	            "object" !== typeof b && (b = {});
	            y(d, function (r, J) {
	              "__proto__" !== J && "constructor" !== J && (!I(r, !0) || u(r) || A(r) ? b[J] = d[J] : b[J] = l(b[J] || {}, r));
	            });
	            return b;
	          };
	        !0 === d[0] && (h = d[1], d = Array.prototype.slice.call(d, 2));
	        var m = d.length;
	        for (b = 0; b < m; b++) h = l(h, d[b]);
	        return h;
	      },
	      normalizeTickInterval: function (b, d, h, l, m) {
	        var r = b;
	        h = p(h, t(b));
	        var v = b / h;
	        d || (d = m ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], !1 === l && (1 === h ? d = d.filter(function (b) {
	          return 0 === b % 1;
	        }) : .1 >= h && (d = [1 / h])));
	        for (l = 0; l < d.length && !(r = d[l], m && r * h >= b || !m && v <= (d[l] + (d[l + 1] || d[l])) / 2); l++);
	        return r = q(r * h, -Math.round(Math.log(.001) / Math.LN10));
	      },
	      objectEach: y,
	      offset: function (d) {
	        var r = h.documentElement;
	        d = d.parentElement || d.parentNode ? d.getBoundingClientRect() : {
	          top: 0,
	          left: 0,
	          width: 0,
	          height: 0
	        };
	        return {
	          top: d.top + (b.pageYOffset || r.scrollTop) - (r.clientTop || 0),
	          left: d.left + (b.pageXOffset || r.scrollLeft) - (r.clientLeft || 0),
	          width: d.width,
	          height: d.height
	        };
	      },
	      pad: function (b, d, h) {
	        return Array((d || 2) + 1 - String(b).replace("-", "").length).join(h || "0") + b;
	      },
	      pick: p,
	      pInt: H,
	      relativeLength: function (b, d, h) {
	        return /%$/.test(b) ? d * parseFloat(b) / 100 + (h || 0) : parseFloat(b);
	      },
	      removeEvent: x,
	      splat: function (b) {
	        return E(b) ? b : [b];
	      },
	      stableSort: function (b, d) {
	        var h = b.length,
	          r,
	          l;
	        for (l = 0; l < h; l++) b[l].safeI = l;
	        b.sort(function (b, h) {
	          r = d(b, h);
	          return 0 === r ? b.safeI - h.safeI : r;
	        });
	        for (l = 0; l < h; l++) delete b[l].safeI;
	      },
	      syncTimeout: function (b, d, h) {
	        if (0 < d) return setTimeout(b, d, h);
	        b.call(0, h);
	        return -1;
	      },
	      timeUnits: {
	        millisecond: 1,
	        second: 1E3,
	        minute: 6E4,
	        hour: 36E5,
	        day: 864E5,
	        week: 6048E5,
	        month: 24192E5,
	        year: 314496E5
	      },
	      uniqueKey: D,
	      useSerialIds: function (b) {
	        return d = p(b, d);
	      },
	      wrap: function (b, d, h) {
	        var l = b[d];
	        b[d] = function () {
	          var b = Array.prototype.slice.call(arguments),
	            d = arguments,
	            r = this;
	          r.proceed = function () {
	            l.apply(r, arguments.length ? arguments : d);
	          };
	          b.unshift(l);
	          b = h.apply(this, b);
	          r.proceed = null;
	          return b;
	        };
	      }
	    };
	    return l;
	  });
	  K(f, "Core/Chart/ChartDefaults.js", [], function () {
	    return {
	      alignThresholds: !1,
	      panning: {
	        enabled: !1,
	        type: "x"
	      },
	      styledMode: !1,
	      borderRadius: 0,
	      colorCount: 10,
	      allowMutatingData: !0,
	      defaultSeriesType: "line",
	      ignoreHiddenSeries: !0,
	      spacing: [10, 10, 15, 10],
	      resetZoomButton: {
	        theme: {
	          zIndex: 6
	        },
	        position: {
	          align: "right",
	          x: -10,
	          y: 10
	        }
	      },
	      zoomBySingleTouch: !1,
	      width: null,
	      height: null,
	      borderColor: "#335cad",
	      backgroundColor: "#ffffff",
	      plotBorderColor: "#cccccc"
	    };
	  });
	  K(f, "Core/Color/Color.js", [f["Core/Globals.js"], f["Core/Utilities.js"]], function (a, f) {
	    var C = f.isNumber,
	      H = f.merge,
	      w = f.pInt;
	    f = function () {
	      function f(C) {
	        this.rgba = [NaN, NaN, NaN, NaN];
	        this.input = C;
	        var A = a.Color;
	        if (A && A !== f) return new A(C);
	        if (!(this instanceof f)) return new f(C);
	        this.init(C);
	      }
	      f.parse = function (a) {
	        return a ? new f(a) : f.None;
	      };
	      f.prototype.init = function (a) {
	        var A;
	        if ("object" === typeof a && "undefined" !== typeof a.stops) this.stops = a.stops.map(function (e) {
	          return new f(e[1]);
	        });else if ("string" === typeof a) {
	          this.input = a = f.names[a.toLowerCase()] || a;
	          if ("#" === a.charAt(0)) {
	            var u = a.length;
	            var n = parseInt(a.substr(1), 16);
	            7 === u ? A = [(n & 16711680) >> 16, (n & 65280) >> 8, n & 255, 1] : 4 === u && (A = [(n & 3840) >> 4 | (n & 3840) >> 8, (n & 240) >> 4 | n & 240, (n & 15) << 4 | n & 15, 1]);
	          }
	          if (!A) for (n = f.parsers.length; n-- && !A;) {
	            var k = f.parsers[n];
	            (u = k.regex.exec(a)) && (A = k.parse(u));
	          }
	        }
	        A && (this.rgba = A);
	      };
	      f.prototype.get = function (a) {
	        var A = this.input,
	          u = this.rgba;
	        if ("object" === typeof A && "undefined" !== typeof this.stops) {
	          var n = H(A);
	          n.stops = [].slice.call(n.stops);
	          this.stops.forEach(function (k, e) {
	            n.stops[e] = [n.stops[e][0], k.get(a)];
	          });
	          return n;
	        }
	        return u && C(u[0]) ? "rgb" === a || !a && 1 === u[3] ? "rgb(" + u[0] + "," + u[1] + "," + u[2] + ")" : "a" === a ? "" + u[3] : "rgba(" + u.join(",") + ")" : A;
	      };
	      f.prototype.brighten = function (a) {
	        var A = this.rgba;
	        if (this.stops) this.stops.forEach(function (n) {
	          n.brighten(a);
	        });else if (C(a) && 0 !== a) for (var u = 0; 3 > u; u++) A[u] += w(255 * a), 0 > A[u] && (A[u] = 0), 255 < A[u] && (A[u] = 255);
	        return this;
	      };
	      f.prototype.setOpacity = function (a) {
	        this.rgba[3] = a;
	        return this;
	      };
	      f.prototype.tweenTo = function (a, A) {
	        var u = this.rgba,
	          n = a.rgba;
	        if (!C(u[0]) || !C(n[0])) return a.input || "none";
	        a = 1 !== n[3] || 1 !== u[3];
	        return (a ? "rgba(" : "rgb(") + Math.round(n[0] + (u[0] - n[0]) * (1 - A)) + "," + Math.round(n[1] + (u[1] - n[1]) * (1 - A)) + "," + Math.round(n[2] + (u[2] - n[2]) * (1 - A)) + (a ? "," + (n[3] + (u[3] - n[3]) * (1 - A)) : "") + ")";
	      };
	      f.names = {
	        white: "#ffffff",
	        black: "#000000"
	      };
	      f.parsers = [{
	        regex: /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,
	        parse: function (a) {
	          return [w(a[1]), w(a[2]), w(a[3]), parseFloat(a[4], 10)];
	        }
	      }, {
	        regex: /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/,
	        parse: function (a) {
	          return [w(a[1]), w(a[2]), w(a[3]), 1];
	        }
	      }];
	      f.None = new f("");
	      return f;
	    }();
	    return f;
	  });
	  K(f, "Core/Color/Palettes.js", [], function () {
	    return {
	      colors: "#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1".split(" ")
	    };
	  });
	  K(f, "Core/Time.js", [f["Core/Globals.js"], f["Core/Utilities.js"]], function (a, f) {
	    var C = a.win,
	      H = f.defined,
	      w = f.error,
	      E = f.extend,
	      I = f.isObject,
	      A = f.merge,
	      u = f.objectEach,
	      n = f.pad,
	      k = f.pick,
	      e = f.splat,
	      c = f.timeUnits,
	      p = a.isSafari && C.Intl && C.Intl.DateTimeFormat.prototype.formatRange,
	      g = a.isSafari && C.Intl && !C.Intl.DateTimeFormat.prototype.formatRange;
	    f = function () {
	      function t(c) {
	        this.options = {};
	        this.variableTimezone = this.useUTC = !1;
	        this.Date = C.Date;
	        this.getTimezoneOffset = this.timezoneOffsetFunction();
	        this.update(c);
	      }
	      t.prototype.get = function (c, e) {
	        if (this.variableTimezone || this.timezoneOffset) {
	          var q = e.getTime(),
	            p = q - this.getTimezoneOffset(e);
	          e.setTime(p);
	          c = e["getUTC" + c]();
	          e.setTime(q);
	          return c;
	        }
	        return this.useUTC ? e["getUTC" + c]() : e["get" + c]();
	      };
	      t.prototype.set = function (c, e, g) {
	        if (this.variableTimezone || this.timezoneOffset) {
	          if ("Milliseconds" === c || "Seconds" === c || "Minutes" === c && 0 === this.getTimezoneOffset(e) % 36E5) return e["setUTC" + c](g);
	          var q = this.getTimezoneOffset(e);
	          q = e.getTime() - q;
	          e.setTime(q);
	          e["setUTC" + c](g);
	          c = this.getTimezoneOffset(e);
	          q = e.getTime() + c;
	          return e.setTime(q);
	        }
	        return this.useUTC || p && "FullYear" === c ? e["setUTC" + c](g) : e["set" + c](g);
	      };
	      t.prototype.update = function (c) {
	        var e = k(c && c.useUTC, !0);
	        this.options = c = A(!0, this.options || {}, c);
	        this.Date = c.Date || C.Date || Date;
	        this.timezoneOffset = (this.useUTC = e) && c.timezoneOffset;
	        this.getTimezoneOffset = this.timezoneOffsetFunction();
	        this.variableTimezone = e && !(!c.getTimezoneOffset && !c.timezone);
	      };
	      t.prototype.makeTime = function (c, e, p, t, z, m) {
	        if (this.useUTC) {
	          var h = this.Date.UTC.apply(0, arguments);
	          var b = this.getTimezoneOffset(h);
	          h += b;
	          var l = this.getTimezoneOffset(h);
	          b !== l ? h += l - b : b - 36E5 !== this.getTimezoneOffset(h - 36E5) || g || (h -= 36E5);
	        } else h = new this.Date(c, e, k(p, 1), k(t, 0), k(z, 0), k(m, 0)).getTime();
	        return h;
	      };
	      t.prototype.timezoneOffsetFunction = function () {
	        var c = this,
	          e = this.options,
	          p = e.getTimezoneOffset,
	          g = e.moment || C.moment;
	        if (!this.useUTC) return function (c) {
	          return 6E4 * new Date(c.toString()).getTimezoneOffset();
	        };
	        if (e.timezone) {
	          if (g) return function (c) {
	            return 6E4 * -g.tz(c, e.timezone).utcOffset();
	          };
	          w(25);
	        }
	        return this.useUTC && p ? function (c) {
	          return 6E4 * p(c.valueOf());
	        } : function () {
	          return 6E4 * (c.timezoneOffset || 0);
	        };
	      };
	      t.prototype.dateFormat = function (c, e, p) {
	        if (!H(e) || isNaN(e)) return a.defaultOptions.lang && a.defaultOptions.lang.invalidDate || "";
	        c = k(c, "%Y-%m-%d %H:%M:%S");
	        var q = this,
	          g = new this.Date(e),
	          m = this.get("Hours", g),
	          h = this.get("Day", g),
	          b = this.get("Date", g),
	          l = this.get("Month", g),
	          d = this.get("FullYear", g),
	          D = a.defaultOptions.lang,
	          v = D && D.weekdays,
	          r = D && D.shortWeekdays;
	        g = E({
	          a: r ? r[h] : v[h].substr(0, 3),
	          A: v[h],
	          d: n(b),
	          e: n(b, 2, " "),
	          w: h,
	          b: D.shortMonths[l],
	          B: D.months[l],
	          m: n(l + 1),
	          o: l + 1,
	          y: d.toString().substr(2, 2),
	          Y: d,
	          H: n(m),
	          k: m,
	          I: n(m % 12 || 12),
	          l: m % 12 || 12,
	          M: n(this.get("Minutes", g)),
	          p: 12 > m ? "AM" : "PM",
	          P: 12 > m ? "am" : "pm",
	          S: n(g.getSeconds()),
	          L: n(Math.floor(e % 1E3), 3)
	        }, a.dateFormats);
	        u(g, function (b, d) {
	          for (; -1 !== c.indexOf("%" + d);) c = c.replace("%" + d, "function" === typeof b ? b.call(q, e) : b);
	        });
	        return p ? c.substr(0, 1).toUpperCase() + c.substr(1) : c;
	      };
	      t.prototype.resolveDTLFormat = function (c) {
	        return I(c, !0) ? c : (c = e(c), {
	          main: c[0],
	          from: c[1],
	          to: c[2]
	        });
	      };
	      t.prototype.getTimeTicks = function (e, g, p, t) {
	        var q = this,
	          m = [],
	          h = {},
	          b = new q.Date(g),
	          l = e.unitRange,
	          d = e.count || 1,
	          D;
	        t = k(t, 1);
	        if (H(g)) {
	          q.set("Milliseconds", b, l >= c.second ? 0 : d * Math.floor(q.get("Milliseconds", b) / d));
	          l >= c.second && q.set("Seconds", b, l >= c.minute ? 0 : d * Math.floor(q.get("Seconds", b) / d));
	          l >= c.minute && q.set("Minutes", b, l >= c.hour ? 0 : d * Math.floor(q.get("Minutes", b) / d));
	          l >= c.hour && q.set("Hours", b, l >= c.day ? 0 : d * Math.floor(q.get("Hours", b) / d));
	          l >= c.day && q.set("Date", b, l >= c.month ? 1 : Math.max(1, d * Math.floor(q.get("Date", b) / d)));
	          if (l >= c.month) {
	            q.set("Month", b, l >= c.year ? 0 : d * Math.floor(q.get("Month", b) / d));
	            var v = q.get("FullYear", b);
	          }
	          l >= c.year && q.set("FullYear", b, v - v % d);
	          l === c.week && (v = q.get("Day", b), q.set("Date", b, q.get("Date", b) - v + t + (v < t ? -7 : 0)));
	          v = q.get("FullYear", b);
	          t = q.get("Month", b);
	          var r = q.get("Date", b),
	            y = q.get("Hours", b);
	          g = b.getTime();
	          !q.variableTimezone && q.useUTC || !H(p) || (D = p - g > 4 * c.month || q.getTimezoneOffset(g) !== q.getTimezoneOffset(p));
	          g = b.getTime();
	          for (b = 1; g < p;) m.push(g), g = l === c.year ? q.makeTime(v + b * d, 0) : l === c.month ? q.makeTime(v, t + b * d) : !D || l !== c.day && l !== c.week ? D && l === c.hour && 1 < d ? q.makeTime(v, t, r, y + b * d) : g + l * d : q.makeTime(v, t, r + b * d * (l === c.day ? 1 : 7)), b++;
	          m.push(g);
	          l <= c.hour && 1E4 > m.length && m.forEach(function (b) {
	            0 === b % 18E5 && "000000000" === q.dateFormat("%H%M%S%L", b) && (h[b] = "day");
	          });
	        }
	        m.info = E(e, {
	          higherRanks: h,
	          totalRange: l * d
	        });
	        return m;
	      };
	      t.prototype.getDateFormat = function (e, g, p, t) {
	        var q = this.dateFormat("%m-%d %H:%M:%S.%L", g),
	          m = {
	            millisecond: 15,
	            second: 12,
	            minute: 9,
	            hour: 6,
	            day: 3
	          },
	          h = "millisecond";
	        for (b in c) {
	          if (e === c.week && +this.dateFormat("%w", g) === p && "00:00:00.000" === q.substr(6)) {
	            var b = "week";
	            break;
	          }
	          if (c[b] > e) {
	            b = h;
	            break;
	          }
	          if (m[b] && q.substr(m[b]) !== "01-01 00:00:00.000".substr(m[b])) break;
	          "week" !== b && (h = b);
	        }
	        if (b) var l = this.resolveDTLFormat(t[b]).main;
	        return l;
	      };
	      return t;
	    }();
	    return f;
	  });
	  K(f, "Core/DefaultOptions.js", [f["Core/Chart/ChartDefaults.js"], f["Core/Color/Color.js"], f["Core/Globals.js"], f["Core/Color/Palettes.js"], f["Core/Time.js"], f["Core/Utilities.js"]], function (a, f, B, H, w, E) {
	    f = f.parse;
	    var C = E.merge,
	      A = {
	        colors: H.colors,
	        symbols: ["circle", "diamond", "square", "triangle", "triangle-down"],
	        lang: {
	          loading: "Loading...",
	          months: "January February March April May June July August September October November December".split(" "),
	          shortMonths: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),
	          weekdays: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),
	          decimalPoint: ".",
	          numericSymbols: "kMGTPE".split(""),
	          resetZoom: "Reset zoom",
	          resetZoomTitle: "Reset zoom level 1:1",
	          thousandsSep: " "
	        },
	        global: {},
	        time: {
	          Date: void 0,
	          getTimezoneOffset: void 0,
	          timezone: void 0,
	          timezoneOffset: 0,
	          useUTC: !0
	        },
	        chart: a,
	        title: {
	          text: "Chart title",
	          align: "center",
	          margin: 15,
	          widthAdjust: -44
	        },
	        subtitle: {
	          text: "",
	          align: "center",
	          widthAdjust: -44
	        },
	        caption: {
	          margin: 15,
	          text: "",
	          align: "left",
	          verticalAlign: "bottom"
	        },
	        plotOptions: {},
	        labels: {
	          style: {
	            position: "absolute",
	            color: "#333333"
	          }
	        },
	        legend: {
	          enabled: !0,
	          align: "center",
	          alignColumns: !0,
	          className: "highcharts-no-tooltip",
	          layout: "horizontal",
	          labelFormatter: function () {
	            return this.name;
	          },
	          borderColor: "#999999",
	          borderRadius: 0,
	          navigation: {
	            activeColor: "#003399",
	            inactiveColor: "#cccccc"
	          },
	          itemStyle: {
	            color: "#333333",
	            cursor: "pointer",
	            fontSize: "12px",
	            fontWeight: "bold",
	            textOverflow: "ellipsis"
	          },
	          itemHoverStyle: {
	            color: "#000000"
	          },
	          itemHiddenStyle: {
	            color: "#cccccc"
	          },
	          shadow: !1,
	          itemCheckboxStyle: {
	            position: "absolute",
	            width: "13px",
	            height: "13px"
	          },
	          squareSymbol: !0,
	          symbolPadding: 5,
	          verticalAlign: "bottom",
	          x: 0,
	          y: 0,
	          title: {
	            style: {
	              fontWeight: "bold"
	            }
	          }
	        },
	        loading: {
	          labelStyle: {
	            fontWeight: "bold",
	            position: "relative",
	            top: "45%"
	          },
	          style: {
	            position: "absolute",
	            backgroundColor: "#ffffff",
	            opacity: .5,
	            textAlign: "center"
	          }
	        },
	        tooltip: {
	          enabled: !0,
	          animation: B.svg,
	          borderRadius: 3,
	          dateTimeLabelFormats: {
	            millisecond: "%A, %b %e, %H:%M:%S.%L",
	            second: "%A, %b %e, %H:%M:%S",
	            minute: "%A, %b %e, %H:%M",
	            hour: "%A, %b %e, %H:%M",
	            day: "%A, %b %e, %Y",
	            week: "Week from %A, %b %e, %Y",
	            month: "%B %Y",
	            year: "%Y"
	          },
	          footerFormat: "",
	          headerShape: "callout",
	          hideDelay: 500,
	          padding: 8,
	          shape: "callout",
	          shared: !1,
	          snap: B.isTouchDevice ? 25 : 10,
	          headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>',
	          pointFormat: '<span style="color:{point.color}">\u25cf</span> {series.name}: <b>{point.y}</b><br/>',
	          backgroundColor: f("#f7f7f7").setOpacity(.85).get(),
	          borderWidth: 1,
	          shadow: !0,
	          stickOnContact: !1,
	          style: {
	            color: "#333333",
	            cursor: "default",
	            fontSize: "12px",
	            whiteSpace: "nowrap"
	          },
	          useHTML: !1
	        },
	        credits: {
	          enabled: !0,
	          href: "https://www.highcharts.com?credits",
	          position: {
	            align: "right",
	            x: -10,
	            verticalAlign: "bottom",
	            y: -5
	          },
	          style: {
	            cursor: "pointer",
	            color: "#999999",
	            fontSize: "9px"
	          },
	          text: "Highcharts.com"
	        }
	      };
	    A.chart.styledMode = !1;
	    var u = new w(C(A.global, A.time));
	    a = {
	      defaultOptions: A,
	      defaultTime: u,
	      getOptions: function () {
	        return A;
	      },
	      setOptions: function (n) {
	        C(!0, A, n);
	        if (n.time || n.global) B.time ? B.time.update(C(A.global, A.time, n.global, n.time)) : B.time = u;
	        return A;
	      }
	    };
	    return a;
	  });
	  K(f, "Core/Animation/Fx.js", [f["Core/Color/Color.js"], f["Core/Globals.js"], f["Core/Utilities.js"]], function (a, f, B) {
	    var C = a.parse,
	      w = f.win,
	      E = B.isNumber,
	      I = B.objectEach;
	    return function () {
	      function a(a, n, k) {
	        this.pos = NaN;
	        this.options = n;
	        this.elem = a;
	        this.prop = k;
	      }
	      a.prototype.dSetter = function () {
	        var a = this.paths,
	          n = a && a[0];
	        a = a && a[1];
	        var k = this.now || 0,
	          e = [];
	        if (1 !== k && n && a) {
	          if (n.length === a.length && 1 > k) for (var c = 0; c < a.length; c++) {
	            for (var p = n[c], g = a[c], t = [], q = 0; q < g.length; q++) {
	              var F = p[q],
	                y = g[q];
	              E(F) && E(y) && ("A" !== g[0] || 4 !== q && 5 !== q) ? t[q] = F + k * (y - F) : t[q] = y;
	            }
	            e.push(t);
	          } else e = a;
	        } else e = this.toD || [];
	        this.elem.attr("d", e, void 0, !0);
	      };
	      a.prototype.update = function () {
	        var a = this.elem,
	          n = this.prop,
	          k = this.now,
	          e = this.options.step;
	        if (this[n + "Setter"]) this[n + "Setter"]();else a.attr ? a.element && a.attr(n, k, null, !0) : a.style[n] = k + this.unit;
	        e && e.call(a, k, this);
	      };
	      a.prototype.run = function (u, n, k) {
	        var e = this,
	          c = e.options,
	          p = function (c) {
	            return p.stopped ? !1 : e.step(c);
	          },
	          g = w.requestAnimationFrame || function (c) {
	            setTimeout(c, 13);
	          },
	          t = function () {
	            for (var c = 0; c < a.timers.length; c++) a.timers[c]() || a.timers.splice(c--, 1);
	            a.timers.length && g(t);
	          };
	        u !== n || this.elem["forceAnimate:" + this.prop] ? (this.startTime = +new Date(), this.start = u, this.end = n, this.unit = k, this.now = this.start, this.pos = 0, p.elem = this.elem, p.prop = this.prop, p() && 1 === a.timers.push(p) && g(t)) : (delete c.curAnim[this.prop], c.complete && 0 === Object.keys(c.curAnim).length && c.complete.call(this.elem));
	      };
	      a.prototype.step = function (a) {
	        var n = +new Date(),
	          k = this.options,
	          e = this.elem,
	          c = k.complete,
	          p = k.duration,
	          g = k.curAnim;
	        if (e.attr && !e.element) a = !1;else if (a || n >= p + this.startTime) {
	          this.now = this.end;
	          this.pos = 1;
	          this.update();
	          var t = g[this.prop] = !0;
	          I(g, function (c) {
	            !0 !== c && (t = !1);
	          });
	          t && c && c.call(e);
	          a = !1;
	        } else this.pos = k.easing((n - this.startTime) / p), this.now = this.start + (this.end - this.start) * this.pos, this.update(), a = !0;
	        return a;
	      };
	      a.prototype.initPath = function (a, n, k) {
	        function e(c, m) {
	          for (; c.length < x;) {
	            var h = c[0],
	              b = m[x - c.length];
	            b && "M" === h[0] && (c[0] = "C" === b[0] ? ["C", h[1], h[2], h[1], h[2], h[1], h[2]] : ["L", h[1], h[2]]);
	            c.unshift(h);
	            t && (h = c.pop(), c.push(c[c.length - 1], h));
	          }
	        }
	        function c(c, m) {
	          for (; c.length < x;) if (m = c[Math.floor(c.length / q) - 1].slice(), "C" === m[0] && (m[1] = m[5], m[2] = m[6]), t) {
	            var h = c[Math.floor(c.length / q)].slice();
	            c.splice(c.length / 2, 0, m, h);
	          } else c.push(m);
	        }
	        var p = a.startX,
	          g = a.endX;
	        k = k.slice();
	        var t = a.isArea,
	          q = t ? 2 : 1;
	        n = n && n.slice();
	        if (!n) return [k, k];
	        if (p && g && g.length) {
	          for (a = 0; a < p.length; a++) if (p[a] === g[0]) {
	            var F = a;
	            break;
	          } else if (p[0] === g[g.length - p.length + a]) {
	            F = a;
	            var y = !0;
	            break;
	          } else if (p[p.length - 1] === g[g.length - p.length + a]) {
	            F = p.length - a;
	            break;
	          }
	          "undefined" === typeof F && (n = []);
	        }
	        if (n.length && E(F)) {
	          var x = k.length + F * q;
	          y ? (e(n, k), c(k, n)) : (e(k, n), c(n, k));
	        }
	        return [n, k];
	      };
	      a.prototype.fillSetter = function () {
	        a.prototype.strokeSetter.apply(this, arguments);
	      };
	      a.prototype.strokeSetter = function () {
	        this.elem.attr(this.prop, C(this.start).tweenTo(C(this.end), this.pos), void 0, !0);
	      };
	      a.timers = [];
	      return a;
	    }();
	  });
	  K(f, "Core/Animation/AnimationUtilities.js", [f["Core/Animation/Fx.js"], f["Core/Utilities.js"]], function (a, f) {
	    function C(c) {
	      return u(c) ? n({
	        duration: 500,
	        defer: 0
	      }, c) : {
	        duration: c ? 500 : 0,
	        defer: 0
	      };
	    }
	    function H(c, e) {
	      for (var g = a.timers.length; g--;) a.timers[g].elem !== c || e && e !== a.timers[g].prop || (a.timers[g].stopped = !0);
	    }
	    var w = f.defined,
	      E = f.getStyle,
	      I = f.isArray,
	      A = f.isNumber,
	      u = f.isObject,
	      n = f.merge,
	      k = f.objectEach,
	      e = f.pick;
	    return {
	      animate: function (c, e, g) {
	        var p,
	          q = "",
	          F,
	          y;
	        if (!u(g)) {
	          var x = arguments;
	          g = {
	            duration: x[2],
	            easing: x[3],
	            complete: x[4]
	          };
	        }
	        A(g.duration) || (g.duration = 400);
	        g.easing = "function" === typeof g.easing ? g.easing : Math[g.easing] || Math.easeInOutSine;
	        g.curAnim = n(e);
	        k(e, function (t, m) {
	          H(c, m);
	          y = new a(c, g, m);
	          F = void 0;
	          "d" === m && I(e.d) ? (y.paths = y.initPath(c, c.pathArray, e.d), y.toD = e.d, p = 0, F = 1) : c.attr ? p = c.attr(m) : (p = parseFloat(E(c, m)) || 0, "opacity" !== m && (q = "px"));
	          F || (F = t);
	          "string" === typeof F && F.match("px") && (F = F.replace(/px/g, ""));
	          y.run(p, F, q);
	        });
	      },
	      animObject: C,
	      getDeferredAnimation: function (c, e, g) {
	        var p = C(e),
	          q = 0,
	          k = 0;
	        (g ? [g] : c.series).forEach(function (c) {
	          c = C(c.options.animation);
	          q = e && w(e.defer) ? p.defer : Math.max(q, c.duration + c.defer);
	          k = Math.min(p.duration, c.duration);
	        });
	        c.renderer.forExport && (q = 0);
	        return {
	          defer: Math.max(0, q - k),
	          duration: Math.min(q, k)
	        };
	      },
	      setAnimation: function (c, p) {
	        p.renderer.globalAnimation = e(c, p.options.chart.animation, !0);
	      },
	      stop: H
	    };
	  });
	  K(f, "Core/Renderer/HTML/AST.js", [f["Core/Globals.js"], f["Core/Utilities.js"]], function (a, f) {
	    var C = a.SVG_NS,
	      H = f.attr,
	      w = f.createElement,
	      E = f.css,
	      I = f.error,
	      A = f.isFunction,
	      u = f.isString,
	      n = f.objectEach,
	      k = f.splat,
	      e = (f = a.win.trustedTypes) && A(f.createPolicy) && f.createPolicy("highcharts", {
	        createHTML: function (c) {
	          return c;
	        }
	      }),
	      c = e ? e.createHTML("") : "";
	    try {
	      var p = !!new DOMParser().parseFromString(c, "text/html");
	    } catch (g) {
	      p = !1;
	    }
	    A = function () {
	      function g(c) {
	        this.nodes = "string" === typeof c ? this.parseMarkup(c) : c;
	      }
	      g.filterUserAttributes = function (c) {
	        n(c, function (e, p) {
	          var q = !0;
	          -1 === g.allowedAttributes.indexOf(p) && (q = !1);
	          -1 !== ["background", "dynsrc", "href", "lowsrc", "src"].indexOf(p) && (q = u(e) && g.allowedReferences.some(function (c) {
	            return 0 === e.indexOf(c);
	          }));
	          q || (I(33, !1, void 0, {
	            "Invalid attribute in config": "" + p
	          }), delete c[p]);
	        });
	        return c;
	      };
	      g.parseStyle = function (c) {
	        return c.split(";").reduce(function (c, e) {
	          e = e.split(":").map(function (c) {
	            return c.trim();
	          });
	          var g = e.shift();
	          g && e.length && (c[g.replace(/-([a-z])/g, function (c) {
	            return c[1].toUpperCase();
	          })] = e.join(":"));
	          return c;
	        }, {});
	      };
	      g.setElementHTML = function (c, e) {
	        c.innerHTML = g.emptyHTML;
	        e && new g(e).addToDOM(c);
	      };
	      g.prototype.addToDOM = function (c) {
	        function e(c, p) {
	          var q;
	          k(c).forEach(function (c) {
	            var m = c.tagName,
	              h = c.textContent ? a.doc.createTextNode(c.textContent) : void 0,
	              b = g.bypassHTMLFiltering;
	            if (m) if ("#text" === m) var l = h;else if (-1 !== g.allowedTags.indexOf(m) || b) {
	              m = a.doc.createElementNS("svg" === m ? C : p.namespaceURI || C, m);
	              var d = c.attributes || {};
	              n(c, function (b, c) {
	                "tagName" !== c && "attributes" !== c && "children" !== c && "style" !== c && "textContent" !== c && (d[c] = b);
	              });
	              H(m, b ? d : g.filterUserAttributes(d));
	              c.style && E(m, c.style);
	              h && m.appendChild(h);
	              e(c.children || [], m);
	              l = m;
	            } else I(33, !1, void 0, {
	              "Invalid tagName in config": m
	            });
	            l && p.appendChild(l);
	            q = l;
	          });
	          return q;
	        }
	        return e(this.nodes, c);
	      };
	      g.prototype.parseMarkup = function (c) {
	        var q = [];
	        c = c.trim().replace(/ style="/g, ' data-style="');
	        if (p) c = new DOMParser().parseFromString(e ? e.createHTML(c) : c, "text/html");else {
	          var k = w("div");
	          k.innerHTML = c;
	          c = {
	            body: k
	          };
	        }
	        var t = function (c, e) {
	          var m = c.nodeName.toLowerCase(),
	            h = {
	              tagName: m
	            };
	          "#text" === m && (h.textContent = c.textContent || "");
	          if (m = c.attributes) {
	            var b = {};
	            [].forEach.call(m, function (d) {
	              "data-style" === d.name ? h.style = g.parseStyle(d.value) : b[d.name] = d.value;
	            });
	            h.attributes = b;
	          }
	          if (c.childNodes.length) {
	            var l = [];
	            [].forEach.call(c.childNodes, function (b) {
	              t(b, l);
	            });
	            l.length && (h.children = l);
	          }
	          e.push(h);
	        };
	        [].forEach.call(c.body.childNodes, function (c) {
	          return t(c, q);
	        });
	        return q;
	      };
	      g.allowedAttributes = "aria-controls aria-describedby aria-expanded aria-haspopup aria-hidden aria-label aria-labelledby aria-live aria-pressed aria-readonly aria-roledescription aria-selected class clip-path color colspan cx cy d dx dy disabled fill height href id in markerHeight markerWidth offset opacity orient padding paddingLeft paddingRight patternUnits r refX refY role scope slope src startOffset stdDeviation stroke stroke-linecap stroke-width style tableValues result rowspan summary target tabindex text-align textAnchor textLength title type valign width x x1 x2 y y1 y2 zIndex".split(" ");
	      g.allowedReferences = "https:// http:// mailto: / ../ ./ #".split(" ");
	      g.allowedTags = "a abbr b br button caption circle clipPath code dd defs div dl dt em feComponentTransfer feFuncA feFuncB feFuncG feFuncR feGaussianBlur feOffset feMerge feMergeNode filter h1 h2 h3 h4 h5 h6 hr i img li linearGradient marker ol p path pattern pre rect small span stop strong style sub sup svg table text thead tbody tspan td th tr u ul #text".split(" ");
	      g.emptyHTML = c;
	      g.bypassHTMLFiltering = !1;
	      return g;
	    }();
	    return A;
	  });
	  K(f, "Core/FormatUtilities.js", [f["Core/DefaultOptions.js"], f["Core/Utilities.js"]], function (a, f) {
	    function C(a, k, e, c) {
	      a = +a || 0;
	      k = +k;
	      var p = H.lang,
	        g = (a.toString().split(".")[1] || "").split("e")[0].length,
	        t = a.toString().split("e"),
	        q = k;
	      if (-1 === k) k = Math.min(g, 20);else if (!I(k)) k = 2;else if (k && t[1] && 0 > t[1]) {
	        var F = k + +t[1];
	        0 <= F ? (t[0] = (+t[0]).toExponential(F).split("e")[0], k = F) : (t[0] = t[0].split(".")[0] || 0, a = 20 > k ? (t[0] * Math.pow(10, t[1])).toFixed(k) : 0, t[1] = 0);
	      }
	      F = (Math.abs(t[1] ? t[0] : a) + Math.pow(10, -Math.max(k, g) - 1)).toFixed(k);
	      g = String(u(F));
	      var y = 3 < g.length ? g.length % 3 : 0;
	      e = A(e, p.decimalPoint);
	      c = A(c, p.thousandsSep);
	      a = (0 > a ? "-" : "") + (y ? g.substr(0, y) + c : "");
	      a = 0 > +t[1] && !q ? "0" : a + g.substr(y).replace(/(\d{3})(?=\d)/g, "$1" + c);
	      k && (a += e + F.slice(-k));
	      t[1] && 0 !== +a && (a += "e" + t[1]);
	      return a;
	    }
	    var H = a.defaultOptions,
	      w = a.defaultTime,
	      E = f.getNestedProperty,
	      I = f.isNumber,
	      A = f.pick,
	      u = f.pInt;
	    return {
	      dateFormat: function (a, k, e) {
	        return w.dateFormat(a, k, e);
	      },
	      format: function (a, k, e) {
	        var c = "{",
	          p = !1,
	          g = /f$/,
	          t = /\.([0-9])/,
	          q = H.lang,
	          F = e && e.time || w;
	        e = e && e.numberFormatter || C;
	        for (var y = []; a;) {
	          var x = a.indexOf(c);
	          if (-1 === x) break;
	          var z = a.slice(0, x);
	          if (p) {
	            z = z.split(":");
	            c = E(z.shift() || "", k);
	            if (z.length && "number" === typeof c) if (z = z.join(":"), g.test(z)) {
	              var m = parseInt((z.match(t) || ["", "-1"])[1], 10);
	              null !== c && (c = e(c, m, q.decimalPoint, -1 < z.indexOf(",") ? q.thousandsSep : ""));
	            } else c = F.dateFormat(z, c);
	            y.push(c);
	          } else y.push(z);
	          a = a.slice(x + 1);
	          c = (p = !p) ? "}" : "{";
	        }
	        y.push(a);
	        return y.join("");
	      },
	      numberFormat: C
	    };
	  });
	  K(f, "Core/Renderer/RendererUtilities.js", [f["Core/Utilities.js"]], function (a) {
	    var f = a.clamp,
	      B = a.pick,
	      H = a.stableSort,
	      w;
	    (function (a) {
	      function C(a, u, n) {
	        var k = a,
	          e = k.reducedLen || u,
	          c = function (c, e) {
	            return (e.rank || 0) - (c.rank || 0);
	          },
	          p = function (c, e) {
	            return c.target - e.target;
	          },
	          g,
	          t = !0,
	          q = [],
	          F = 0;
	        for (g = a.length; g--;) F += a[g].size;
	        if (F > e) {
	          H(a, c);
	          for (F = g = 0; F <= e;) F += a[g].size, g++;
	          q = a.splice(g - 1, a.length);
	        }
	        H(a, p);
	        for (a = a.map(function (c) {
	          return {
	            size: c.size,
	            targets: [c.target],
	            align: B(c.align, .5)
	          };
	        }); t;) {
	          for (g = a.length; g--;) e = a[g], c = (Math.min.apply(0, e.targets) + Math.max.apply(0, e.targets)) / 2, e.pos = f(c - e.size * e.align, 0, u - e.size);
	          g = a.length;
	          for (t = !1; g--;) 0 < g && a[g - 1].pos + a[g - 1].size > a[g].pos && (a[g - 1].size += a[g].size, a[g - 1].targets = a[g - 1].targets.concat(a[g].targets), a[g - 1].align = .5, a[g - 1].pos + a[g - 1].size > u && (a[g - 1].pos = u - a[g - 1].size), a.splice(g, 1), t = !0);
	        }
	        k.push.apply(k, q);
	        g = 0;
	        a.some(function (c) {
	          var e = 0;
	          return (c.targets || []).some(function () {
	            k[g].pos = c.pos + e;
	            if ("undefined" !== typeof n && Math.abs(k[g].pos - k[g].target) > n) return k.slice(0, g + 1).forEach(function (c) {
	              return delete c.pos;
	            }), k.reducedLen = (k.reducedLen || u) - .1 * u, k.reducedLen > .1 * u && C(k, u, n), !0;
	            e += k[g].size;
	            g++;
	            return !1;
	          });
	        });
	        H(k, p);
	        return k;
	      }
	      a.distribute = C;
	    })(w || (w = {}));
	    return w;
	  });
	  K(f, "Core/Renderer/SVG/SVGElement.js", [f["Core/Animation/AnimationUtilities.js"], f["Core/Renderer/HTML/AST.js"], f["Core/Color/Color.js"], f["Core/Globals.js"], f["Core/Utilities.js"]], function (a, f, B, H, w) {
	    var C = a.animate,
	      I = a.animObject,
	      A = a.stop,
	      u = H.deg2rad,
	      n = H.doc,
	      k = H.noop,
	      e = H.svg,
	      c = H.SVG_NS,
	      p = H.win,
	      g = w.addEvent,
	      t = w.attr,
	      q = w.createElement,
	      F = w.css,
	      y = w.defined,
	      x = w.erase,
	      z = w.extend,
	      m = w.fireEvent,
	      h = w.isArray,
	      b = w.isFunction,
	      l = w.isNumber,
	      d = w.isString,
	      D = w.merge,
	      v = w.objectEach,
	      r = w.pick,
	      O = w.pInt,
	      P = w.syncTimeout,
	      S = w.uniqueKey;
	    a = function () {
	      function a() {
	        this.element = void 0;
	        this.onEvents = {};
	        this.opacity = 1;
	        this.renderer = void 0;
	        this.SVG_NS = c;
	        this.symbolCustomAttribs = "x y width height r start end innerR anchorX anchorY rounded".split(" ");
	      }
	      a.prototype._defaultGetter = function (b) {
	        b = r(this[b + "Value"], this[b], this.element ? this.element.getAttribute(b) : null, 0);
	        /^[\-0-9\.]+$/.test(b) && (b = parseFloat(b));
	        return b;
	      };
	      a.prototype._defaultSetter = function (b, d, c) {
	        c.setAttribute(d, b);
	      };
	      a.prototype.add = function (b) {
	        var d = this.renderer,
	          c = this.element;
	        b && (this.parentGroup = b);
	        this.parentInverted = b && b.inverted;
	        "undefined" !== typeof this.textStr && "text" === this.element.nodeName && d.buildText(this);
	        this.added = !0;
	        if (!b || b.handleZ || this.zIndex) var h = this.zIndexSetter();
	        h || (b ? b.element : d.box).appendChild(c);
	        if (this.onAdd) this.onAdd();
	        return this;
	      };
	      a.prototype.addClass = function (b, d) {
	        var c = d ? "" : this.attr("class") || "";
	        b = (b || "").split(/ /g).reduce(function (b, d) {
	          -1 === c.indexOf(d) && b.push(d);
	          return b;
	        }, c ? [c] : []).join(" ");
	        b !== c && this.attr("class", b);
	        return this;
	      };
	      a.prototype.afterSetters = function () {
	        this.doTransform && (this.updateTransform(), this.doTransform = !1);
	      };
	      a.prototype.align = function (b, c, J) {
	        var h = {},
	          l = this.renderer,
	          e = l.alignedObjects,
	          m,
	          a,
	          G;
	        if (b) {
	          if (this.alignOptions = b, this.alignByTranslate = c, !J || d(J)) this.alignTo = m = J || "renderer", x(e, this), e.push(this), J = void 0;
	        } else b = this.alignOptions, c = this.alignByTranslate, m = this.alignTo;
	        J = r(J, l[m], "scrollablePlotBox" === m ? l.plotBox : void 0, l);
	        m = b.align;
	        var v = b.verticalAlign;
	        l = (J.x || 0) + (b.x || 0);
	        e = (J.y || 0) + (b.y || 0);
	        "right" === m ? a = 1 : "center" === m && (a = 2);
	        a && (l += (J.width - (b.width || 0)) / a);
	        h[c ? "translateX" : "x"] = Math.round(l);
	        "bottom" === v ? G = 1 : "middle" === v && (G = 2);
	        G && (e += (J.height - (b.height || 0)) / G);
	        h[c ? "translateY" : "y"] = Math.round(e);
	        this[this.placed ? "animate" : "attr"](h);
	        this.placed = !0;
	        this.alignAttr = h;
	        return this;
	      };
	      a.prototype.alignSetter = function (b) {
	        var d = {
	          left: "start",
	          center: "middle",
	          right: "end"
	        };
	        d[b] && (this.alignValue = b, this.element.setAttribute("text-anchor", d[b]));
	      };
	      a.prototype.animate = function (b, d, c) {
	        var J = this,
	          h = I(r(d, this.renderer.globalAnimation, !0));
	        d = h.defer;
	        r(n.hidden, n.msHidden, n.webkitHidden, !1) && (h.duration = 0);
	        0 !== h.duration ? (c && (h.complete = c), P(function () {
	          J.element && C(J, b, h);
	        }, d)) : (this.attr(b, void 0, c || h.complete), v(b, function (b, d) {
	          h.step && h.step.call(this, b, {
	            prop: d,
	            pos: 1,
	            elem: this
	          });
	        }, this));
	        return this;
	      };
	      a.prototype.applyTextOutline = function (b) {
	        var d = this.element;
	        -1 !== b.indexOf("contrast") && (b = b.replace(/contrast/g, this.renderer.getContrast(d.style.fill)));
	        var J = b.split(" ");
	        b = J[J.length - 1];
	        if ((J = J[0]) && "none" !== J && H.svg) {
	          this.fakeTS = !0;
	          this.ySetter = this.xSetter;
	          J = J.replace(/(^[\d\.]+)(.*?)$/g, function (b, d, c) {
	            return 2 * Number(d) + c;
	          });
	          this.removeTextOutline();
	          var h = n.createElementNS(c, "tspan");
	          t(h, {
	            "class": "highcharts-text-outline",
	            fill: b,
	            stroke: b,
	            "stroke-width": J,
	            "stroke-linejoin": "round"
	          });
	          [].forEach.call(d.childNodes, function (b) {
	            var d = b.cloneNode(!0);
	            d.removeAttribute && ["fill", "stroke", "stroke-width", "stroke"].forEach(function (b) {
	              return d.removeAttribute(b);
	            });
	            h.appendChild(d);
	          });
	          var l = n.createElementNS(c, "tspan");
	          l.textContent = "\u200b";
	          ["x", "y"].forEach(function (b) {
	            var c = d.getAttribute(b);
	            c && l.setAttribute(b, c);
	          });
	          h.appendChild(l);
	          d.insertBefore(h, d.firstChild);
	        }
	      };
	      a.prototype.attr = function (b, d, c, h) {
	        var J = this.element,
	          l = this.symbolCustomAttribs,
	          r,
	          L = this,
	          G,
	          e;
	        if ("string" === typeof b && "undefined" !== typeof d) {
	          var m = b;
	          b = {};
	          b[m] = d;
	        }
	        "string" === typeof b ? L = (this[b + "Getter"] || this._defaultGetter).call(this, b, J) : (v(b, function (d, c) {
	          G = !1;
	          h || A(this, c);
	          this.symbolName && -1 !== l.indexOf(c) && (r || (this.symbolAttr(b), r = !0), G = !0);
	          !this.rotation || "x" !== c && "y" !== c || (this.doTransform = !0);
	          G || (e = this[c + "Setter"] || this._defaultSetter, e.call(this, d, c, J), !this.styledMode && this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(c) && this.updateShadows(c, d, e));
	        }, this), this.afterSetters());
	        c && c.call(this);
	        return L;
	      };
	      a.prototype.clip = function (b) {
	        return this.attr("clip-path", b ? "url(" + this.renderer.url + "#" + b.id + ")" : "none");
	      };
	      a.prototype.crisp = function (b, d) {
	        d = d || b.strokeWidth || 0;
	        var c = Math.round(d) % 2 / 2;
	        b.x = Math.floor(b.x || this.x || 0) + c;
	        b.y = Math.floor(b.y || this.y || 0) + c;
	        b.width = Math.floor((b.width || this.width || 0) - 2 * c);
	        b.height = Math.floor((b.height || this.height || 0) - 2 * c);
	        y(b.strokeWidth) && (b.strokeWidth = d);
	        return b;
	      };
	      a.prototype.complexColor = function (b, d, c) {
	        var J = this.renderer,
	          l,
	          r,
	          e,
	          a,
	          G,
	          g,
	          p,
	          q,
	          k,
	          t,
	          x = [],
	          z;
	        m(this.renderer, "complexColor", {
	          args: arguments
	        }, function () {
	          b.radialGradient ? r = "radialGradient" : b.linearGradient && (r = "linearGradient");
	          if (r) {
	            e = b[r];
	            G = J.gradients;
	            g = b.stops;
	            k = c.radialReference;
	            h(e) && (b[r] = e = {
	              x1: e[0],
	              y1: e[1],
	              x2: e[2],
	              y2: e[3],
	              gradientUnits: "userSpaceOnUse"
	            });
	            "radialGradient" === r && k && !y(e.gradientUnits) && (a = e, e = D(e, J.getRadialAttr(k, a), {
	              gradientUnits: "userSpaceOnUse"
	            }));
	            v(e, function (b, d) {
	              "id" !== d && x.push(d, b);
	            });
	            v(g, function (b) {
	              x.push(b);
	            });
	            x = x.join(",");
	            if (G[x]) t = G[x].attr("id");else {
	              e.id = t = S();
	              var L = G[x] = J.createElement(r).attr(e).add(J.defs);
	              L.radAttr = a;
	              L.stops = [];
	              g.forEach(function (b) {
	                0 === b[1].indexOf("rgba") ? (l = B.parse(b[1]), p = l.get("rgb"), q = l.get("a")) : (p = b[1], q = 1);
	                b = J.createElement("stop").attr({
	                  offset: b[0],
	                  "stop-color": p,
	                  "stop-opacity": q
	                }).add(L);
	                L.stops.push(b);
	              });
	            }
	            z = "url(" + J.url + "#" + t + ")";
	            c.setAttribute(d, z);
	            c.gradient = x;
	            b.toString = function () {
	              return z;
	            };
	          }
	        });
	      };
	      a.prototype.css = function (b) {
	        var d = this.styles,
	          c = {},
	          h = this.element,
	          l = !d;
	        b.color && (b.fill = b.color);
	        d && v(b, function (b, J) {
	          d && d[J] !== b && (c[J] = b, l = !0);
	        });
	        if (l) {
	          d && (b = z(d, c));
	          if (null === b.width || "auto" === b.width) delete this.textWidth;else if ("text" === h.nodeName.toLowerCase() && b.width) var r = this.textWidth = O(b.width);
	          this.styles = b;
	          r && !e && this.renderer.forExport && delete b.width;
	          var m = D(b);
	          h.namespaceURI === this.SVG_NS && ["textOutline", "textOverflow", "width"].forEach(function (b) {
	            return m && delete m[b];
	          });
	          F(h, m);
	          this.added && ("text" === this.element.nodeName && this.renderer.buildText(this), b.textOutline && this.applyTextOutline(b.textOutline));
	        }
	        return this;
	      };
	      a.prototype.dashstyleSetter = function (b) {
	        var d = this["stroke-width"];
	        "inherit" === d && (d = 1);
	        if (b = b && b.toLowerCase()) {
	          var c = b.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(",");
	          for (b = c.length; b--;) c[b] = "" + O(c[b]) * r(d, NaN);
	          b = c.join(",").replace(/NaN/g, "none");
	          this.element.setAttribute("stroke-dasharray", b);
	        }
	      };
	      a.prototype.destroy = function () {
	        var b = this,
	          d = b.element || {},
	          c = b.renderer,
	          h = d.ownerSVGElement,
	          l = c.isSVG && "SPAN" === d.nodeName && b.parentGroup || void 0;
	        d.onclick = d.onmouseout = d.onmouseover = d.onmousemove = d.point = null;
	        A(b);
	        if (b.clipPath && h) {
	          var r = b.clipPath;
	          [].forEach.call(h.querySelectorAll("[clip-path],[CLIP-PATH]"), function (b) {
	            -1 < b.getAttribute("clip-path").indexOf(r.element.id) && b.removeAttribute("clip-path");
	          });
	          b.clipPath = r.destroy();
	        }
	        if (b.stops) {
	          for (h = 0; h < b.stops.length; h++) b.stops[h].destroy();
	          b.stops.length = 0;
	          b.stops = void 0;
	        }
	        b.safeRemoveChild(d);
	        for (c.styledMode || b.destroyShadows(); l && l.div && 0 === l.div.childNodes.length;) d = l.parentGroup, b.safeRemoveChild(l.div), delete l.div, l = d;
	        b.alignTo && x(c.alignedObjects, b);
	        v(b, function (d, c) {
	          b[c] && b[c].parentGroup === b && b[c].destroy && b[c].destroy();
	          delete b[c];
	        });
	      };
	      a.prototype.destroyShadows = function () {
	        (this.shadows || []).forEach(function (b) {
	          this.safeRemoveChild(b);
	        }, this);
	        this.shadows = void 0;
	      };
	      a.prototype.destroyTextPath = function (b, d) {
	        var c = b.getElementsByTagName("text")[0];
	        if (c) {
	          if (c.removeAttribute("dx"), c.removeAttribute("dy"), d.element.setAttribute("id", ""), this.textPathWrapper && c.getElementsByTagName("textPath").length) {
	            for (b = this.textPathWrapper.element.childNodes; b.length;) c.appendChild(b[0]);
	            c.removeChild(this.textPathWrapper.element);
	          }
	        } else if (b.getAttribute("dx") || b.getAttribute("dy")) b.removeAttribute("dx"), b.removeAttribute("dy");
	        this.textPathWrapper && (this.textPathWrapper = this.textPathWrapper.destroy());
	      };
	      a.prototype.dSetter = function (b, d, c) {
	        h(b) && ("string" === typeof b[0] && (b = this.renderer.pathToSegments(b)), this.pathArray = b, b = b.reduce(function (b, d, c) {
	          return d && d.join ? (c ? b + " " : "") + d.join(" ") : (d || "").toString();
	        }, ""));
	        /(NaN| {2}|^$)/.test(b) && (b = "M 0 0");
	        this[d] !== b && (c.setAttribute(d, b), this[d] = b);
	      };
	      a.prototype.fadeOut = function (b) {
	        var d = this;
	        d.animate({
	          opacity: 0
	        }, {
	          duration: r(b, 150),
	          complete: function () {
	            d.attr({
	              y: -9999
	            }).hide();
	          }
	        });
	      };
	      a.prototype.fillSetter = function (b, d, c) {
	        "string" === typeof b ? c.setAttribute(d, b) : b && this.complexColor(b, d, c);
	      };
	      a.prototype.getBBox = function (d, c) {
	        var h = this.alignValue,
	          l = this.element,
	          e = this.renderer,
	          m = this.styles,
	          v = this.textStr,
	          g = e.cache,
	          G = e.cacheKeys,
	          p = l.namespaceURI === this.SVG_NS;
	        c = r(c, this.rotation, 0);
	        var q = e.styledMode ? l && a.prototype.getStyle.call(l, "font-size") : m && m.fontSize,
	          D;
	        if (y(v)) {
	          var k = v.toString();
	          -1 === k.indexOf("<") && (k = k.replace(/[0-9]/g, "0"));
	          k += ["", c, q, this.textWidth, h, m && m.textOverflow, m && m.fontWeight].join();
	        }
	        k && !d && (D = g[k]);
	        if (!D) {
	          if (p || e.forExport) {
	            try {
	              var t = this.fakeTS && function (b) {
	                var d = l.querySelector(".highcharts-text-outline");
	                d && F(d, {
	                  display: b
	                });
	              };
	              b(t) && t("none");
	              D = l.getBBox ? z({}, l.getBBox()) : {
	                width: l.offsetWidth,
	                height: l.offsetHeight
	              };
	              b(t) && t("");
	            } catch (ha) {
	            }
	            if (!D || 0 > D.width) D = {
	              x: 0,
	              y: 0,
	              width: 0,
	              height: 0
	            };
	          } else D = this.htmlGetBBox();
	          if (e.isSVG && (e = D.width, d = D.height, p && (D.height = d = {
	            "11px,17": 14,
	            "13px,20": 16
	          }[(q || "") + "," + Math.round(d)] || d), c)) {
	            p = Number(l.getAttribute("y") || 0) - D.y;
	            h = {
	              right: 1,
	              center: .5
	            }[h || 0] || 0;
	            m = c * u;
	            q = (c - 90) * u;
	            var x = e * Math.cos(m);
	            c = e * Math.sin(m);
	            t = Math.cos(q);
	            m = Math.sin(q);
	            e = D.x + h * (e - x) + p * t;
	            q = e + x;
	            t = q - d * t;
	            x = t - x;
	            p = D.y + p - h * c + p * m;
	            h = p + c;
	            d = h - d * m;
	            c = d - c;
	            D.x = Math.min(e, q, t, x);
	            D.y = Math.min(p, h, d, c);
	            D.width = Math.max(e, q, t, x) - D.x;
	            D.height = Math.max(p, h, d, c) - D.y;
	          }
	          if (k && ("" === v || 0 < D.height)) {
	            for (; 250 < G.length;) delete g[G.shift()];
	            g[k] || G.push(k);
	            g[k] = D;
	          }
	        }
	        return D;
	      };
	      a.prototype.getStyle = function (b) {
	        return p.getComputedStyle(this.element || this, "").getPropertyValue(b);
	      };
	      a.prototype.hasClass = function (b) {
	        return -1 !== ("" + this.attr("class")).split(" ").indexOf(b);
	      };
	      a.prototype.hide = function () {
	        return this.attr({
	          visibility: "hidden"
	        });
	      };
	      a.prototype.htmlGetBBox = function () {
	        return {
	          height: 0,
	          width: 0,
	          x: 0,
	          y: 0
	        };
	      };
	      a.prototype.init = function (b, d) {
	        this.element = "span" === d ? q(d) : n.createElementNS(this.SVG_NS, d);
	        this.renderer = b;
	        m(this, "afterInit");
	      };
	      a.prototype.invert = function (b) {
	        this.inverted = b;
	        this.updateTransform();
	        return this;
	      };
	      a.prototype.on = function (b, d) {
	        var c = this.onEvents;
	        if (c[b]) c[b]();
	        c[b] = g(this.element, b, d);
	        return this;
	      };
	      a.prototype.opacitySetter = function (b, d, c) {
	        this.opacity = b = Number(Number(b).toFixed(3));
	        c.setAttribute(d, b);
	      };
	      a.prototype.removeClass = function (b) {
	        return this.attr("class", ("" + this.attr("class")).replace(d(b) ? new RegExp("(^| )" + b + "( |$)") : b, " ").replace(/ +/g, " ").trim());
	      };
	      a.prototype.removeTextOutline = function () {
	        var b = this.element.querySelector("tspan.highcharts-text-outline");
	        b && this.safeRemoveChild(b);
	      };
	      a.prototype.safeRemoveChild = function (b) {
	        var d = b.parentNode;
	        d && d.removeChild(b);
	      };
	      a.prototype.setRadialReference = function (b) {
	        var d = this.element.gradient && this.renderer.gradients[this.element.gradient];
	        this.element.radialReference = b;
	        d && d.radAttr && d.animate(this.renderer.getRadialAttr(b, d.radAttr));
	        return this;
	      };
	      a.prototype.setTextPath = function (b, d) {
	        var c = this.element,
	          h = this.text ? this.text.element : c,
	          r = {
	            textAnchor: "text-anchor"
	          },
	          e = !1,
	          m = this.textPathWrapper,
	          a = !m;
	        d = D(!0, {
	          enabled: !0,
	          attributes: {
	            dy: -5,
	            startOffset: "50%",
	            textAnchor: "middle"
	          }
	        }, d);
	        var G = f.filterUserAttributes(d.attributes);
	        if (b && d && d.enabled) {
	          m && null === m.element.parentNode ? (a = !0, m = m.destroy()) : m && this.removeTextOutline.call(m.parentGroup);
	          this.options && this.options.padding && (G.dx = -this.options.padding);
	          m || (this.textPathWrapper = m = this.renderer.createElement("textPath"), e = !0);
	          var g = m.element;
	          (d = b.element.getAttribute("id")) || b.element.setAttribute("id", d = S());
	          if (a) for (h.setAttribute("y", 0), l(G.dx) && h.setAttribute("x", -G.dx), b = [].slice.call(h.childNodes), a = 0; a < b.length; a++) {
	            var q = b[a];
	            q.nodeType !== p.Node.TEXT_NODE && "tspan" !== q.nodeName || g.appendChild(q);
	          }
	          e && m && m.add({
	            element: h
	          });
	          g.setAttributeNS("http://www.w3.org/1999/xlink", "href", this.renderer.url + "#" + d);
	          y(G.dy) && (g.parentNode.setAttribute("dy", G.dy), delete G.dy);
	          y(G.dx) && (g.parentNode.setAttribute("dx", G.dx), delete G.dx);
	          v(G, function (b, d) {
	            g.setAttribute(r[d] || d, b);
	          });
	          c.removeAttribute("transform");
	          this.removeTextOutline.call(m);
	          this.text && !this.renderer.styledMode && this.attr({
	            fill: "none",
	            "stroke-width": 0
	          });
	          this.applyTextOutline = this.updateTransform = k;
	        } else m && (delete this.updateTransform, delete this.applyTextOutline, this.destroyTextPath(c, b), this.updateTransform(), this.options && this.options.rotation && this.applyTextOutline(this.options.style.textOutline));
	        return this;
	      };
	      a.prototype.shadow = function (b, d, c) {
	        var h = [],
	          l = this.element,
	          J = this.oldShadowOptions,
	          r = {
	            color: "#000000",
	            offsetX: this.parentInverted ? -1 : 1,
	            offsetY: this.parentInverted ? -1 : 1,
	            opacity: .15,
	            width: 3
	          },
	          e = !1,
	          G;
	        !0 === b ? G = r : "object" === typeof b && (G = z(r, b));
	        G && (G && J && v(G, function (b, d) {
	          b !== J[d] && (e = !0);
	        }), e && this.destroyShadows(), this.oldShadowOptions = G);
	        if (!G) this.destroyShadows();else if (!this.shadows) {
	          var m = G.opacity / G.width;
	          var a = this.parentInverted ? "translate(" + G.offsetY + ", " + G.offsetX + ")" : "translate(" + G.offsetX + ", " + G.offsetY + ")";
	          for (r = 1; r <= G.width; r++) {
	            var g = l.cloneNode(!1);
	            var p = 2 * G.width + 1 - 2 * r;
	            t(g, {
	              stroke: b.color || "#000000",
	              "stroke-opacity": m * r,
	              "stroke-width": p,
	              transform: a,
	              fill: "none"
	            });
	            g.setAttribute("class", (g.getAttribute("class") || "") + " highcharts-shadow");
	            c && (t(g, "height", Math.max(t(g, "height") - p, 0)), g.cutHeight = p);
	            d ? d.element.appendChild(g) : l.parentNode && l.parentNode.insertBefore(g, l);
	            h.push(g);
	          }
	          this.shadows = h;
	        }
	        return this;
	      };
	      a.prototype.show = function (b) {
	        void 0 === b && (b = !0);
	        return this.attr({
	          visibility: b ? "inherit" : "visible"
	        });
	      };
	      a.prototype.strokeSetter = function (b, d, c) {
	        this[d] = b;
	        this.stroke && this["stroke-width"] ? (a.prototype.fillSetter.call(this, this.stroke, "stroke", c), c.setAttribute("stroke-width", this["stroke-width"]), this.hasStroke = !0) : "stroke-width" === d && 0 === b && this.hasStroke ? (c.removeAttribute("stroke"), this.hasStroke = !1) : this.renderer.styledMode && this["stroke-width"] && (c.setAttribute("stroke-width", this["stroke-width"]), this.hasStroke = !0);
	      };
	      a.prototype.strokeWidth = function () {
	        if (!this.renderer.styledMode) return this["stroke-width"] || 0;
	        var b = this.getStyle("stroke-width"),
	          d = 0;
	        if (b.indexOf("px") === b.length - 2) d = O(b);else if ("" !== b) {
	          var h = n.createElementNS(c, "rect");
	          t(h, {
	            width: b,
	            "stroke-width": 0
	          });
	          this.element.parentNode.appendChild(h);
	          d = h.getBBox().width;
	          h.parentNode.removeChild(h);
	        }
	        return d;
	      };
	      a.prototype.symbolAttr = function (b) {
	        var d = this;
	        "x y r start end width height innerR anchorX anchorY clockwise".split(" ").forEach(function (c) {
	          d[c] = r(b[c], d[c]);
	        });
	        d.attr({
	          d: d.renderer.symbols[d.symbolName](d.x, d.y, d.width, d.height, d)
	        });
	      };
	      a.prototype.textSetter = function (b) {
	        b !== this.textStr && (delete this.textPxLength, this.textStr = b, this.added && this.renderer.buildText(this));
	      };
	      a.prototype.titleSetter = function (b) {
	        var d = this.element,
	          c = d.getElementsByTagName("title")[0] || n.createElementNS(this.SVG_NS, "title");
	        d.insertBefore ? d.insertBefore(c, d.firstChild) : d.appendChild(c);
	        c.textContent = String(r(b, "")).replace(/<[^>]*>/g, "").replace(/&lt;/g, "<").replace(/&gt;/g, ">");
	      };
	      a.prototype.toFront = function () {
	        var b = this.element;
	        b.parentNode.appendChild(b);
	        return this;
	      };
	      a.prototype.translate = function (b, d) {
	        return this.attr({
	          translateX: b,
	          translateY: d
	        });
	      };
	      a.prototype.updateShadows = function (b, d, c) {
	        var h = this.shadows;
	        if (h) for (var l = h.length; l--;) c.call(h[l], "height" === b ? Math.max(d - (h[l].cutHeight || 0), 0) : "d" === b ? this.d : d, b, h[l]);
	      };
	      a.prototype.updateTransform = function () {
	        var b = this.scaleX,
	          d = this.scaleY,
	          c = this.inverted,
	          h = this.rotation,
	          l = this.matrix,
	          e = this.element,
	          m = this.translateX || 0,
	          a = this.translateY || 0;
	        c && (m += this.width, a += this.height);
	        m = ["translate(" + m + "," + a + ")"];
	        y(l) && m.push("matrix(" + l.join(",") + ")");
	        c ? m.push("rotate(90) scale(-1,1)") : h && m.push("rotate(" + h + " " + r(this.rotationOriginX, e.getAttribute("x"), 0) + " " + r(this.rotationOriginY, e.getAttribute("y") || 0) + ")");
	        (y(b) || y(d)) && m.push("scale(" + r(b, 1) + " " + r(d, 1) + ")");
	        m.length && e.setAttribute("transform", m.join(" "));
	      };
	      a.prototype.visibilitySetter = function (b, d, c) {
	        "inherit" === b ? c.removeAttribute(d) : this[d] !== b && c.setAttribute(d, b);
	        this[d] = b;
	      };
	      a.prototype.xGetter = function (b) {
	        "circle" === this.element.nodeName && ("x" === b ? b = "cx" : "y" === b && (b = "cy"));
	        return this._defaultGetter(b);
	      };
	      a.prototype.zIndexSetter = function (b, d) {
	        var c = this.renderer,
	          h = this.parentGroup,
	          l = (h || c).element || c.box,
	          r = this.element;
	        c = l === c.box;
	        var e = !1;
	        var m = this.added;
	        var G;
	        y(b) ? (r.setAttribute("data-z-index", b), b = +b, this[d] === b && (m = !1)) : y(this[d]) && r.removeAttribute("data-z-index");
	        this[d] = b;
	        if (m) {
	          (b = this.zIndex) && h && (h.handleZ = !0);
	          d = l.childNodes;
	          for (G = d.length - 1; 0 <= G && !e; G--) {
	            h = d[G];
	            m = h.getAttribute("data-z-index");
	            var a = !y(m);
	            if (h !== r) if (0 > b && a && !c && !G) l.insertBefore(r, d[G]), e = !0;else if (O(m) <= b || a && (!y(b) || 0 <= b)) l.insertBefore(r, d[G + 1] || null), e = !0;
	          }
	          e || (l.insertBefore(r, d[c ? 3 : 0] || null), e = !0);
	        }
	        return e;
	      };
	      return a;
	    }();
	    a.prototype["stroke-widthSetter"] = a.prototype.strokeSetter;
	    a.prototype.yGetter = a.prototype.xGetter;
	    a.prototype.matrixSetter = a.prototype.rotationOriginXSetter = a.prototype.rotationOriginYSetter = a.prototype.rotationSetter = a.prototype.scaleXSetter = a.prototype.scaleYSetter = a.prototype.translateXSetter = a.prototype.translateYSetter = a.prototype.verticalAlignSetter = function (b, d) {
	      this[d] = b;
	      this.doTransform = !0;
	    };
	    return a;
	  });
	  K(f, "Core/Renderer/RendererRegistry.js", [f["Core/Globals.js"]], function (a) {
	    var f;
	    (function (f) {
	      f.rendererTypes = {};
	      var C;
	      f.getRendererType = function (a) {
	        void 0 === a && (a = C);
	        return f.rendererTypes[a] || f.rendererTypes[C];
	      };
	      f.registerRendererType = function (w, B, I) {
	        f.rendererTypes[w] = B;
	        if (!C || I) C = w, a.Renderer = B;
	      };
	    })(f || (f = {}));
	    return f;
	  });
	  K(f, "Core/Renderer/SVG/SVGLabel.js", [f["Core/Renderer/SVG/SVGElement.js"], f["Core/Utilities.js"]], function (a, f) {
	    var C = this && this.__extends || function () {
	        var a = function (k, e) {
	          a = Object.setPrototypeOf || {
	            __proto__: []
	          } instanceof Array && function (c, e) {
	            c.__proto__ = e;
	          } || function (c, e) {
	            for (var a in e) e.hasOwnProperty(a) && (c[a] = e[a]);
	          };
	          return a(k, e);
	        };
	        return function (k, e) {
	          function c() {
	            this.constructor = k;
	          }
	          a(k, e);
	          k.prototype = null === e ? Object.create(e) : (c.prototype = e.prototype, new c());
	        };
	      }(),
	      H = f.defined,
	      w = f.extend,
	      E = f.isNumber,
	      I = f.merge,
	      A = f.pick,
	      u = f.removeEvent;
	    return function (n) {
	      function k(e, c, a, g, t, q, F, y, x, z) {
	        var m = n.call(this) || this;
	        m.paddingLeftSetter = m.paddingSetter;
	        m.paddingRightSetter = m.paddingSetter;
	        m.init(e, "g");
	        m.textStr = c;
	        m.x = a;
	        m.y = g;
	        m.anchorX = q;
	        m.anchorY = F;
	        m.baseline = x;
	        m.className = z;
	        m.addClass("button" === z ? "highcharts-no-tooltip" : "highcharts-label");
	        z && m.addClass("highcharts-" + z);
	        m.text = e.text(void 0, 0, 0, y).attr({
	          zIndex: 1
	        });
	        var h;
	        "string" === typeof t && ((h = /^url\((.*?)\)$/.test(t)) || m.renderer.symbols[t]) && (m.symbolKey = t);
	        m.bBox = k.emptyBBox;
	        m.padding = 3;
	        m.baselineOffset = 0;
	        m.needsBox = e.styledMode || h;
	        m.deferredAttr = {};
	        m.alignFactor = 0;
	        return m;
	      }
	      C(k, n);
	      k.prototype.alignSetter = function (e) {
	        e = {
	          left: 0,
	          center: .5,
	          right: 1
	        }[e];
	        e !== this.alignFactor && (this.alignFactor = e, this.bBox && E(this.xSetting) && this.attr({
	          x: this.xSetting
	        }));
	      };
	      k.prototype.anchorXSetter = function (e, c) {
	        this.anchorX = e;
	        this.boxAttr(c, Math.round(e) - this.getCrispAdjust() - this.xSetting);
	      };
	      k.prototype.anchorYSetter = function (e, c) {
	        this.anchorY = e;
	        this.boxAttr(c, e - this.ySetting);
	      };
	      k.prototype.boxAttr = function (e, c) {
	        this.box ? this.box.attr(e, c) : this.deferredAttr[e] = c;
	      };
	      k.prototype.css = function (e) {
	        if (e) {
	          var c = {};
	          e = I(e);
	          k.textProps.forEach(function (a) {
	            "undefined" !== typeof e[a] && (c[a] = e[a], delete e[a]);
	          });
	          this.text.css(c);
	          var p = ("width" in c);
	          "fontSize" in c || "fontWeight" in c ? this.updateTextPadding() : p && this.updateBoxSize();
	        }
	        return a.prototype.css.call(this, e);
	      };
	      k.prototype.destroy = function () {
	        u(this.element, "mouseenter");
	        u(this.element, "mouseleave");
	        this.text && this.text.destroy();
	        this.box && (this.box = this.box.destroy());
	        a.prototype.destroy.call(this);
	      };
	      k.prototype.fillSetter = function (e, c) {
	        e && (this.needsBox = !0);
	        this.fill = e;
	        this.boxAttr(c, e);
	      };
	      k.prototype.getBBox = function () {
	        this.textStr && 0 === this.bBox.width && 0 === this.bBox.height && this.updateBoxSize();
	        var e = this.padding,
	          c = A(this.paddingLeft, e);
	        return {
	          width: this.width,
	          height: this.height,
	          x: this.bBox.x - c,
	          y: this.bBox.y - e
	        };
	      };
	      k.prototype.getCrispAdjust = function () {
	        return this.renderer.styledMode && this.box ? this.box.strokeWidth() % 2 / 2 : (this["stroke-width"] ? parseInt(this["stroke-width"], 10) : 0) % 2 / 2;
	      };
	      k.prototype.heightSetter = function (e) {
	        this.heightSetting = e;
	      };
	      k.prototype.onAdd = function () {
	        var e = this.textStr;
	        this.text.add(this);
	        this.attr({
	          text: H(e) ? e : "",
	          x: this.x,
	          y: this.y
	        });
	        this.box && H(this.anchorX) && this.attr({
	          anchorX: this.anchorX,
	          anchorY: this.anchorY
	        });
	      };
	      k.prototype.paddingSetter = function (e, c) {
	        E(e) ? e !== this[c] && (this[c] = e, this.updateTextPadding()) : this[c] = void 0;
	      };
	      k.prototype.rSetter = function (e, c) {
	        this.boxAttr(c, e);
	      };
	      k.prototype.shadow = function (e) {
	        e && !this.renderer.styledMode && (this.updateBoxSize(), this.box && this.box.shadow(e));
	        return this;
	      };
	      k.prototype.strokeSetter = function (e, c) {
	        this.stroke = e;
	        this.boxAttr(c, e);
	      };
	      k.prototype["stroke-widthSetter"] = function (e, c) {
	        e && (this.needsBox = !0);
	        this["stroke-width"] = e;
	        this.boxAttr(c, e);
	      };
	      k.prototype["text-alignSetter"] = function (e) {
	        this.textAlign = e;
	      };
	      k.prototype.textSetter = function (e) {
	        "undefined" !== typeof e && this.text.attr({
	          text: e
	        });
	        this.updateTextPadding();
	      };
	      k.prototype.updateBoxSize = function () {
	        var e = this.text.element.style,
	          c = {},
	          a = this.padding,
	          g = this.bBox = E(this.widthSetting) && E(this.heightSetting) && !this.textAlign || !H(this.text.textStr) ? k.emptyBBox : this.text.getBBox();
	        this.width = this.getPaddedWidth();
	        this.height = (this.heightSetting || g.height || 0) + 2 * a;
	        e = this.renderer.fontMetrics(e && e.fontSize, this.text);
	        this.baselineOffset = a + Math.min((this.text.firstLineMetrics || e).b, g.height || Infinity);
	        this.heightSetting && (this.baselineOffset += (this.heightSetting - e.h) / 2);
	        this.needsBox && (this.box || (a = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect(), a.addClass(("button" === this.className ? "" : "highcharts-label-box") + (this.className ? " highcharts-" + this.className + "-box" : "")), a.add(this)), a = this.getCrispAdjust(), c.x = a, c.y = (this.baseline ? -this.baselineOffset : 0) + a, c.width = Math.round(this.width), c.height = Math.round(this.height), this.box.attr(w(c, this.deferredAttr)), this.deferredAttr = {});
	      };
	      k.prototype.updateTextPadding = function () {
	        var e = this.text;
	        this.updateBoxSize();
	        var c = this.baseline ? 0 : this.baselineOffset,
	          a = A(this.paddingLeft, this.padding);
	        H(this.widthSetting) && this.bBox && ("center" === this.textAlign || "right" === this.textAlign) && (a += {
	          center: .5,
	          right: 1
	        }[this.textAlign] * (this.widthSetting - this.bBox.width));
	        if (a !== e.x || c !== e.y) e.attr("x", a), e.hasBoxWidthChanged && (this.bBox = e.getBBox(!0)), "undefined" !== typeof c && e.attr("y", c);
	        e.x = a;
	        e.y = c;
	      };
	      k.prototype.widthSetter = function (e) {
	        this.widthSetting = E(e) ? e : void 0;
	      };
	      k.prototype.getPaddedWidth = function () {
	        var e = this.padding,
	          c = A(this.paddingLeft, e);
	        e = A(this.paddingRight, e);
	        return (this.widthSetting || this.bBox.width || 0) + c + e;
	      };
	      k.prototype.xSetter = function (e) {
	        this.x = e;
	        this.alignFactor && (e -= this.alignFactor * this.getPaddedWidth(), this["forceAnimate:x"] = !0);
	        this.xSetting = Math.round(e);
	        this.attr("translateX", this.xSetting);
	      };
	      k.prototype.ySetter = function (e) {
	        this.ySetting = this.y = Math.round(e);
	        this.attr("translateY", this.ySetting);
	      };
	      k.emptyBBox = {
	        width: 0,
	        height: 0,
	        x: 0,
	        y: 0
	      };
	      k.textProps = "color direction fontFamily fontSize fontStyle fontWeight lineHeight textAlign textDecoration textOutline textOverflow width".split(" ");
	      return k;
	    }(a);
	  });
	  K(f, "Core/Renderer/SVG/Symbols.js", [f["Core/Utilities.js"]], function (a) {
	    function f(a, f, n, k, e) {
	      var c = [];
	      if (e) {
	        var p = e.start || 0,
	          g = I(e.r, n);
	        n = I(e.r, k || n);
	        var t = (e.end || 0) - .001;
	        k = e.innerR;
	        var q = I(e.open, .001 > Math.abs((e.end || 0) - p - 2 * Math.PI)),
	          F = Math.cos(p),
	          y = Math.sin(p),
	          x = Math.cos(t),
	          z = Math.sin(t);
	        p = I(e.longArc, .001 > t - p - Math.PI ? 0 : 1);
	        c.push(["M", a + g * F, f + n * y], ["A", g, n, 0, p, I(e.clockwise, 1), a + g * x, f + n * z]);
	        w(k) && c.push(q ? ["M", a + k * x, f + k * z] : ["L", a + k * x, f + k * z], ["A", k, k, 0, p, w(e.clockwise) ? 1 - e.clockwise : 0, a + k * F, f + k * y]);
	        q || c.push(["Z"]);
	      }
	      return c;
	    }
	    function B(a, f, n, k, e) {
	      return e && e.r ? H(a, f, n, k, e) : [["M", a, f], ["L", a + n, f], ["L", a + n, f + k], ["L", a, f + k], ["Z"]];
	    }
	    function H(a, f, n, k, e) {
	      e = e && e.r || 0;
	      return [["M", a + e, f], ["L", a + n - e, f], ["C", a + n, f, a + n, f, a + n, f + e], ["L", a + n, f + k - e], ["C", a + n, f + k, a + n, f + k, a + n - e, f + k], ["L", a + e, f + k], ["C", a, f + k, a, f + k, a, f + k - e], ["L", a, f + e], ["C", a, f, a, f, a + e, f]];
	    }
	    var w = a.defined,
	      E = a.isNumber,
	      I = a.pick;
	    return {
	      arc: f,
	      callout: function (a, f, n, k, e) {
	        var c = Math.min(e && e.r || 0, n, k),
	          p = c + 6,
	          g = e && e.anchorX;
	        e = e && e.anchorY || 0;
	        var t = H(a, f, n, k, {
	          r: c
	        });
	        if (!E(g)) return t;
	        a + g >= n ? e > f + p && e < f + k - p ? t.splice(3, 1, ["L", a + n, e - 6], ["L", a + n + 6, e], ["L", a + n, e + 6], ["L", a + n, f + k - c]) : t.splice(3, 1, ["L", a + n, k / 2], ["L", g, e], ["L", a + n, k / 2], ["L", a + n, f + k - c]) : 0 >= a + g ? e > f + p && e < f + k - p ? t.splice(7, 1, ["L", a, e + 6], ["L", a - 6, e], ["L", a, e - 6], ["L", a, f + c]) : t.splice(7, 1, ["L", a, k / 2], ["L", g, e], ["L", a, k / 2], ["L", a, f + c]) : e && e > k && g > a + p && g < a + n - p ? t.splice(5, 1, ["L", g + 6, f + k], ["L", g, f + k + 6], ["L", g - 6, f + k], ["L", a + c, f + k]) : e && 0 > e && g > a + p && g < a + n - p && t.splice(1, 1, ["L", g - 6, f], ["L", g, f - 6], ["L", g + 6, f], ["L", n - c, f]);
	        return t;
	      },
	      circle: function (a, u, n, k) {
	        return f(a + n / 2, u + k / 2, n / 2, k / 2, {
	          start: .5 * Math.PI,
	          end: 2.5 * Math.PI,
	          open: !1
	        });
	      },
	      diamond: function (a, f, n, k) {
	        return [["M", a + n / 2, f], ["L", a + n, f + k / 2], ["L", a + n / 2, f + k], ["L", a, f + k / 2], ["Z"]];
	      },
	      rect: B,
	      roundedRect: H,
	      square: B,
	      triangle: function (a, f, n, k) {
	        return [["M", a + n / 2, f], ["L", a + n, f + k], ["L", a, f + k], ["Z"]];
	      },
	      "triangle-down": function (a, f, n, k) {
	        return [["M", a, f], ["L", a + n, f], ["L", a + n / 2, f + k], ["Z"]];
	      }
	    };
	  });
	  K(f, "Core/Renderer/SVG/TextBuilder.js", [f["Core/Renderer/HTML/AST.js"], f["Core/Globals.js"], f["Core/Utilities.js"]], function (a, f, B) {
	    var C = f.doc,
	      w = f.SVG_NS,
	      E = f.win,
	      I = B.attr,
	      A = B.extend,
	      u = B.isString,
	      n = B.objectEach,
	      k = B.pick;
	    return function () {
	      function e(c) {
	        var a = c.styles;
	        this.renderer = c.renderer;
	        this.svgElement = c;
	        this.width = c.textWidth;
	        this.textLineHeight = a && a.lineHeight;
	        this.textOutline = a && a.textOutline;
	        this.ellipsis = !(!a || "ellipsis" !== a.textOverflow);
	        this.noWrap = !(!a || "nowrap" !== a.whiteSpace);
	        this.fontSize = a && a.fontSize;
	      }
	      e.prototype.buildSVG = function () {
	        var c = this.svgElement,
	          e = c.element,
	          g = c.renderer,
	          t = k(c.textStr, "").toString(),
	          q = -1 !== t.indexOf("<"),
	          f = e.childNodes;
	        g = this.width && !c.added && g.box;
	        var y = /<br.*?>/g,
	          x = [t, this.ellipsis, this.noWrap, this.textLineHeight, this.textOutline, this.fontSize, this.width].join();
	        if (x !== c.textCache) {
	          c.textCache = x;
	          delete c.actualWidth;
	          for (x = f.length; x--;) e.removeChild(f[x]);
	          q || this.ellipsis || this.width || -1 !== t.indexOf(" ") && (!this.noWrap || y.test(t)) ? "" !== t && (g && g.appendChild(e), t = new a(t), this.modifyTree(t.nodes), t.addToDOM(c.element), this.modifyDOM(), this.ellipsis && -1 !== (e.textContent || "").indexOf("\u2026") && c.attr("title", this.unescapeEntities(c.textStr || "", ["&lt;", "&gt;"])), g && g.removeChild(e)) : e.appendChild(C.createTextNode(this.unescapeEntities(t)));
	          u(this.textOutline) && c.applyTextOutline && c.applyTextOutline(this.textOutline);
	        }
	      };
	      e.prototype.modifyDOM = function () {
	        var c = this,
	          a = this.svgElement,
	          e = I(a.element, "x");
	        a.firstLineMetrics = void 0;
	        for (var k; k = a.element.firstChild;) if (/^[\s\u200B]*$/.test(k.textContent || " ")) a.element.removeChild(k);else break;
	        [].forEach.call(a.element.querySelectorAll("tspan.highcharts-br"), function (g, q) {
	          g.nextSibling && g.previousSibling && (0 === q && 1 === g.previousSibling.nodeType && (a.firstLineMetrics = a.renderer.fontMetrics(void 0, g.previousSibling)), I(g, {
	            dy: c.getLineHeight(g.nextSibling),
	            x: e
	          }));
	        });
	        var q = this.width || 0;
	        if (q) {
	          var f = function (g, k) {
	              var m = g.textContent || "",
	                h = m.replace(/([^\^])-/g, "$1- ").split(" "),
	                b = !c.noWrap && (1 < h.length || 1 < a.element.childNodes.length),
	                l = c.getLineHeight(k),
	                d = 0,
	                D = a.actualWidth;
	              if (c.ellipsis) m && c.truncate(g, m, void 0, 0, Math.max(0, q - parseInt(c.fontSize || 12, 10)), function (b, d) {
	                return b.substring(0, d) + "\u2026";
	              });else if (b) {
	                m = [];
	                for (b = []; k.firstChild && k.firstChild !== g;) b.push(k.firstChild), k.removeChild(k.firstChild);
	                for (; h.length;) h.length && !c.noWrap && 0 < d && (m.push(g.textContent || ""), g.textContent = h.join(" ").replace(/- /g, "-")), c.truncate(g, void 0, h, 0 === d ? D || 0 : 0, q, function (b, d) {
	                  return h.slice(0, d).join(" ").replace(/- /g, "-");
	                }), D = a.actualWidth, d++;
	                b.forEach(function (b) {
	                  k.insertBefore(b, g);
	                });
	                m.forEach(function (b) {
	                  k.insertBefore(C.createTextNode(b), g);
	                  b = C.createElementNS(w, "tspan");
	                  b.textContent = "\u200b";
	                  I(b, {
	                    dy: l,
	                    x: e
	                  });
	                  k.insertBefore(b, g);
	                });
	              }
	            },
	            y = function (c) {
	              [].slice.call(c.childNodes).forEach(function (e) {
	                e.nodeType === E.Node.TEXT_NODE ? f(e, c) : (-1 !== e.className.baseVal.indexOf("highcharts-br") && (a.actualWidth = 0), y(e));
	              });
	            };
	          y(a.element);
	        }
	      };
	      e.prototype.getLineHeight = function (c) {
	        var a;
	        c = c.nodeType === E.Node.TEXT_NODE ? c.parentElement : c;
	        this.renderer.styledMode || (a = c && /(px|em)$/.test(c.style.fontSize) ? c.style.fontSize : this.fontSize || this.renderer.style.fontSize || 12);
	        return this.textLineHeight ? parseInt(this.textLineHeight.toString(), 10) : this.renderer.fontMetrics(a, c || this.svgElement.element).h;
	      };
	      e.prototype.modifyTree = function (c) {
	        var a = this,
	          e = function (g, q) {
	            var k = g.attributes;
	            k = void 0 === k ? {} : k;
	            var p = g.children,
	              t = g.style;
	            t = void 0 === t ? {} : t;
	            var f = g.tagName,
	              m = a.renderer.styledMode;
	            if ("b" === f || "strong" === f) m ? k["class"] = "highcharts-strong" : t.fontWeight = "bold";else if ("i" === f || "em" === f) m ? k["class"] = "highcharts-emphasized" : t.fontStyle = "italic";
	            t && t.color && (t.fill = t.color);
	            "br" === f ? (k["class"] = "highcharts-br", g.textContent = "\u200b", (q = c[q + 1]) && q.textContent && (q.textContent = q.textContent.replace(/^ +/gm, ""))) : "a" === f && p && p.some(function (c) {
	              return "#text" === c.tagName;
	            }) && (g.children = [{
	              children: p,
	              tagName: "tspan"
	            }]);
	            "#text" !== f && "a" !== f && (g.tagName = "tspan");
	            A(g, {
	              attributes: k,
	              style: t
	            });
	            p && p.filter(function (c) {
	              return "#text" !== c.tagName;
	            }).forEach(e);
	          };
	        c.forEach(e);
	      };
	      e.prototype.truncate = function (c, a, e, k, q, f) {
	        var g = this.svgElement,
	          p = g.renderer,
	          t = g.rotation,
	          m = [],
	          h = e ? 1 : 0,
	          b = (a || e || "").length,
	          l = b,
	          d,
	          D = function (b, d) {
	            d = d || b;
	            var h = c.parentNode;
	            if (h && "undefined" === typeof m[d]) if (h.getSubStringLength) try {
	              m[d] = k + h.getSubStringLength(0, e ? d + 1 : d);
	            } catch (S) {
	            } else p.getSpanWidth && (c.textContent = f(a || e, b), m[d] = k + p.getSpanWidth(g, c));
	            return m[d];
	          };
	        g.rotation = 0;
	        var v = D(c.textContent.length);
	        if (k + v > q) {
	          for (; h <= b;) l = Math.ceil((h + b) / 2), e && (d = f(e, l)), v = D(l, d && d.length - 1), h === b ? h = b + 1 : v > q ? b = l - 1 : h = l;
	          0 === b ? c.textContent = "" : a && b === a.length - 1 || (c.textContent = d || f(a || e, l));
	        }
	        e && e.splice(0, l);
	        g.actualWidth = v;
	        g.rotation = t;
	      };
	      e.prototype.unescapeEntities = function (c, a) {
	        n(this.renderer.escapes, function (e, k) {
	          a && -1 !== a.indexOf(e) || (c = c.toString().replace(new RegExp(e, "g"), k));
	        });
	        return c;
	      };
	      return e;
	    }();
	  });
	  K(f, "Core/Renderer/SVG/SVGRenderer.js", [f["Core/Renderer/HTML/AST.js"], f["Core/Color/Color.js"], f["Core/Globals.js"], f["Core/Renderer/RendererRegistry.js"], f["Core/Renderer/SVG/SVGElement.js"], f["Core/Renderer/SVG/SVGLabel.js"], f["Core/Renderer/SVG/Symbols.js"], f["Core/Renderer/SVG/TextBuilder.js"], f["Core/Utilities.js"]], function (a, f, B, H, w, E, I, A, u) {
	    var n = B.charts,
	      k = B.deg2rad,
	      e = B.doc,
	      c = B.isFirefox,
	      p = B.isMS,
	      g = B.isWebKit,
	      t = B.noop,
	      q = B.SVG_NS,
	      F = B.symbolSizes,
	      y = B.win,
	      x = u.addEvent,
	      z = u.attr,
	      m = u.createElement,
	      h = u.css,
	      b = u.defined,
	      l = u.destroyObjectProperties,
	      d = u.extend,
	      D = u.isArray,
	      v = u.isNumber,
	      r = u.isObject,
	      O = u.isString,
	      P = u.merge,
	      S = u.pick,
	      N = u.pInt,
	      C = u.uniqueKey,
	      X;
	    B = function () {
	      function J(b, d, c, h, a, e, l) {
	        this.width = this.url = this.style = this.isSVG = this.imgCount = this.height = this.gradients = this.globalAnimation = this.defs = this.chartIndex = this.cacheKeys = this.cache = this.boxWrapper = this.box = this.alignedObjects = void 0;
	        this.init(b, d, c, h, a, e, l);
	      }
	      J.prototype.init = function (b, d, a, l, r, m, J) {
	        var G = this.createElement("svg").attr({
	            version: "1.1",
	            "class": "highcharts-root"
	          }),
	          L = G.element;
	        J || G.css(this.getStyle(l));
	        b.appendChild(L);
	        z(b, "dir", "ltr");
	        -1 === b.innerHTML.indexOf("xmlns") && z(L, "xmlns", this.SVG_NS);
	        this.isSVG = !0;
	        this.box = L;
	        this.boxWrapper = G;
	        this.alignedObjects = [];
	        this.url = this.getReferenceURL();
	        this.createElement("desc").add().element.appendChild(e.createTextNode("Created with Highcharts 10.1.0"));
	        this.defs = this.createElement("defs").add();
	        this.allowHTML = m;
	        this.forExport = r;
	        this.styledMode = J;
	        this.gradients = {};
	        this.cache = {};
	        this.cacheKeys = [];
	        this.imgCount = 0;
	        this.setSize(d, a, !1);
	        var g;
	        c && b.getBoundingClientRect && (d = function () {
	          h(b, {
	            left: 0,
	            top: 0
	          });
	          g = b.getBoundingClientRect();
	          h(b, {
	            left: Math.ceil(g.left) - g.left + "px",
	            top: Math.ceil(g.top) - g.top + "px"
	          });
	        }, d(), this.unSubPixelFix = x(y, "resize", d));
	      };
	      J.prototype.definition = function (b) {
	        return new a([b]).addToDOM(this.defs.element);
	      };
	      J.prototype.getReferenceURL = function () {
	        if ((c || g) && e.getElementsByTagName("base").length) {
	          if (!b(X)) {
	            var d = C();
	            d = new a([{
	              tagName: "svg",
	              attributes: {
	                width: 8,
	                height: 8
	              },
	              children: [{
	                tagName: "defs",
	                children: [{
	                  tagName: "clipPath",
	                  attributes: {
	                    id: d
	                  },
	                  children: [{
	                    tagName: "rect",
	                    attributes: {
	                      width: 4,
	                      height: 4
	                    }
	                  }]
	                }]
	              }, {
	                tagName: "rect",
	                attributes: {
	                  id: "hitme",
	                  width: 8,
	                  height: 8,
	                  "clip-path": "url(#" + d + ")",
	                  fill: "rgba(0,0,0,0.001)"
	                }
	              }]
	            }]).addToDOM(e.body);
	            h(d, {
	              position: "fixed",
	              top: 0,
	              left: 0,
	              zIndex: 9E5
	            });
	            var l = e.elementFromPoint(6, 6);
	            X = "hitme" === (l && l.id);
	            e.body.removeChild(d);
	          }
	          if (X) return y.location.href.split("#")[0].replace(/<[^>]*>/g, "").replace(/([\('\)])/g, "\\$1").replace(/ /g, "%20");
	        }
	        return "";
	      };
	      J.prototype.getStyle = function (b) {
	        return this.style = d({
	          fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif',
	          fontSize: "12px"
	        }, b);
	      };
	      J.prototype.setStyle = function (b) {
	        this.boxWrapper.css(this.getStyle(b));
	      };
	      J.prototype.isHidden = function () {
	        return !this.boxWrapper.getBBox().width;
	      };
	      J.prototype.destroy = function () {
	        var b = this.defs;
	        this.box = null;
	        this.boxWrapper = this.boxWrapper.destroy();
	        l(this.gradients || {});
	        this.gradients = null;
	        b && (this.defs = b.destroy());
	        this.unSubPixelFix && this.unSubPixelFix();
	        return this.alignedObjects = null;
	      };
	      J.prototype.createElement = function (b) {
	        var d = new this.Element();
	        d.init(this, b);
	        return d;
	      };
	      J.prototype.getRadialAttr = function (b, d) {
	        return {
	          cx: b[0] - b[2] / 2 + (d.cx || 0) * b[2],
	          cy: b[1] - b[2] / 2 + (d.cy || 0) * b[2],
	          r: (d.r || 0) * b[2]
	        };
	      };
	      J.prototype.buildText = function (b) {
	        new A(b).buildSVG();
	      };
	      J.prototype.getContrast = function (b) {
	        b = f.parse(b).rgba;
	        b[0] *= 1;
	        b[1] *= 1.2;
	        b[2] *= .5;
	        return 459 < b[0] + b[1] + b[2] ? "#000000" : "#FFFFFF";
	      };
	      J.prototype.button = function (b, c, h, l, e, m, J, g, v, q) {
	        var G = this.label(b, c, h, v, void 0, void 0, q, void 0, "button"),
	          D = this.styledMode;
	        b = e && e.states || {};
	        e && delete e.states;
	        var L = 0,
	          k = e ? P(e) : {},
	          f = P({
	            color: "#333333",
	            cursor: "pointer",
	            fontWeight: "normal"
	          }, k.style);
	        delete k.style;
	        k = a.filterUserAttributes(k);
	        G.attr(P({
	          padding: 8,
	          r: 2
	        }, k));
	        if (!D) {
	          k = P({
	            fill: "#f7f7f7",
	            stroke: "#cccccc",
	            "stroke-width": 1
	          }, k);
	          m = P(k, {
	            fill: "#e6e6e6"
	          }, a.filterUserAttributes(m || b.hover || {}));
	          var t = m.style;
	          delete m.style;
	          J = P(k, {
	            fill: "#e6ebf5",
	            style: {
	              color: "#000000",
	              fontWeight: "bold"
	            }
	          }, a.filterUserAttributes(J || b.select || {}));
	          var M = J.style;
	          delete J.style;
	          g = P(k, {
	            style: {
	              color: "#cccccc"
	            }
	          }, a.filterUserAttributes(g || b.disabled || {}));
	          var y = g.style;
	          delete g.style;
	        }
	        x(G.element, p ? "mouseover" : "mouseenter", function () {
	          3 !== L && G.setState(1);
	        });
	        x(G.element, p ? "mouseout" : "mouseleave", function () {
	          3 !== L && G.setState(L);
	        });
	        G.setState = function (b) {
	          1 !== b && (G.state = L = b);
	          G.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-" + ["normal", "hover", "pressed", "disabled"][b || 0]);
	          D || (G.attr([k, m, J, g][b || 0]), b = [f, t, M, y][b || 0], r(b) && G.css(b));
	        };
	        D || G.attr(k).css(d({
	          cursor: "default"
	        }, f));
	        return G.on("touchstart", function (b) {
	          return b.stopPropagation();
	        }).on("click", function (b) {
	          3 !== L && l.call(G, b);
	        });
	      };
	      J.prototype.crispLine = function (d, c, h) {
	        void 0 === h && (h = "round");
	        var a = d[0],
	          e = d[1];
	        b(a[1]) && a[1] === e[1] && (a[1] = e[1] = Math[h](a[1]) - c % 2 / 2);
	        b(a[2]) && a[2] === e[2] && (a[2] = e[2] = Math[h](a[2]) + c % 2 / 2);
	        return d;
	      };
	      J.prototype.path = function (b) {
	        var c = this.styledMode ? {} : {
	          fill: "none"
	        };
	        D(b) ? c.d = b : r(b) && d(c, b);
	        return this.createElement("path").attr(c);
	      };
	      J.prototype.circle = function (b, d, c) {
	        b = r(b) ? b : "undefined" === typeof b ? {} : {
	          x: b,
	          y: d,
	          r: c
	        };
	        d = this.createElement("circle");
	        d.xSetter = d.ySetter = function (b, d, c) {
	          c.setAttribute("c" + d, b);
	        };
	        return d.attr(b);
	      };
	      J.prototype.arc = function (b, d, c, a, h, e) {
	        r(b) ? (a = b, d = a.y, c = a.r, b = a.x) : a = {
	          innerR: a,
	          start: h,
	          end: e
	        };
	        b = this.symbol("arc", b, d, c, c, a);
	        b.r = c;
	        return b;
	      };
	      J.prototype.rect = function (b, d, c, a, h, e) {
	        h = r(b) ? b.r : h;
	        var l = this.createElement("rect");
	        b = r(b) ? b : "undefined" === typeof b ? {} : {
	          x: b,
	          y: d,
	          width: Math.max(c, 0),
	          height: Math.max(a, 0)
	        };
	        this.styledMode || ("undefined" !== typeof e && (b["stroke-width"] = e, b = l.crisp(b)), b.fill = "none");
	        h && (b.r = h);
	        l.rSetter = function (b, d, c) {
	          l.r = b;
	          z(c, {
	            rx: b,
	            ry: b
	          });
	        };
	        l.rGetter = function () {
	          return l.r || 0;
	        };
	        return l.attr(b);
	      };
	      J.prototype.setSize = function (b, d, c) {
	        this.width = b;
	        this.height = d;
	        this.boxWrapper.animate({
	          width: b,
	          height: d
	        }, {
	          step: function () {
	            this.attr({
	              viewBox: "0 0 " + this.attr("width") + " " + this.attr("height")
	            });
	          },
	          duration: S(c, !0) ? void 0 : 0
	        });
	        this.alignElements();
	      };
	      J.prototype.g = function (b) {
	        var d = this.createElement("g");
	        return b ? d.attr({
	          "class": "highcharts-" + b
	        }) : d;
	      };
	      J.prototype.image = function (b, d, c, a, h, e) {
	        var l = {
	            preserveAspectRatio: "none"
	          },
	          r = function (b, d) {
	            b.setAttributeNS ? b.setAttributeNS("http://www.w3.org/1999/xlink", "href", d) : b.setAttribute("hc-svg-href", d);
	          };
	        v(d) && (l.x = d);
	        v(c) && (l.y = c);
	        v(a) && (l.width = a);
	        v(h) && (l.height = h);
	        var m = this.createElement("image").attr(l);
	        d = function (d) {
	          r(m.element, b);
	          e.call(m, d);
	        };
	        e ? (r(m.element, "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="), c = new y.Image(), x(c, "load", d), c.src = b, c.complete && d({})) : r(m.element, b);
	        return m;
	      };
	      J.prototype.symbol = function (c, a, l, r, J, G) {
	        var g = this,
	          v = /^url\((.*?)\)$/,
	          q = v.test(c),
	          D = !q && (this.symbols[c] ? c : "circle"),
	          k = D && this.symbols[D],
	          f;
	        if (k) {
	          "number" === typeof a && (f = k.call(this.symbols, Math.round(a || 0), Math.round(l || 0), r || 0, J || 0, G));
	          var p = this.path(f);
	          g.styledMode || p.attr("fill", "none");
	          d(p, {
	            symbolName: D || void 0,
	            x: a,
	            y: l,
	            width: r,
	            height: J
	          });
	          G && d(p, G);
	        } else if (q) {
	          var L = c.match(v)[1];
	          var t = p = this.image(L);
	          t.imgwidth = S(F[L] && F[L].width, G && G.width);
	          t.imgheight = S(F[L] && F[L].height, G && G.height);
	          var y = function (b) {
	            return b.attr({
	              width: b.width,
	              height: b.height
	            });
	          };
	          ["width", "height"].forEach(function (d) {
	            t[d + "Setter"] = function (d, c) {
	              var a = this["img" + c];
	              this[c] = d;
	              b(a) && (G && "within" === G.backgroundSize && this.width && this.height && (a = Math.round(a * Math.min(this.width / this.imgwidth, this.height / this.imgheight))), this.element && this.element.setAttribute(c, a), this.alignByTranslate || (d = ((this[c] || 0) - a) / 2, this.attr("width" === c ? {
	                translateX: d
	              } : {
	                translateY: d
	              })));
	            };
	          });
	          b(a) && t.attr({
	            x: a,
	            y: l
	          });
	          t.isImg = !0;
	          b(t.imgwidth) && b(t.imgheight) ? y(t) : (t.attr({
	            width: 0,
	            height: 0
	          }), m("img", {
	            onload: function () {
	              var b = n[g.chartIndex];
	              0 === this.width && (h(this, {
	                position: "absolute",
	                top: "-999em"
	              }), e.body.appendChild(this));
	              F[L] = {
	                width: this.width,
	                height: this.height
	              };
	              t.imgwidth = this.width;
	              t.imgheight = this.height;
	              t.element && y(t);
	              this.parentNode && this.parentNode.removeChild(this);
	              g.imgCount--;
	              if (!g.imgCount && b && !b.hasLoaded) b.onload();
	            },
	            src: L
	          }), this.imgCount++);
	        }
	        return p;
	      };
	      J.prototype.clipRect = function (b, d, c, a) {
	        var h = C() + "-",
	          l = this.createElement("clipPath").attr({
	            id: h
	          }).add(this.defs);
	        b = this.rect(b, d, c, a, 0).add(l);
	        b.id = h;
	        b.clipPath = l;
	        b.count = 0;
	        return b;
	      };
	      J.prototype.text = function (d, c, a, h) {
	        var l = {};
	        if (h && (this.allowHTML || !this.forExport)) return this.html(d, c, a);
	        l.x = Math.round(c || 0);
	        a && (l.y = Math.round(a));
	        b(d) && (l.text = d);
	        d = this.createElement("text").attr(l);
	        if (!h || this.forExport && !this.allowHTML) d.xSetter = function (b, d, c) {
	          for (var a = c.getElementsByTagName("tspan"), h = c.getAttribute(d), l = 0, e; l < a.length; l++) e = a[l], e.getAttribute(d) === h && e.setAttribute(d, b);
	          c.setAttribute(d, b);
	        };
	        return d;
	      };
	      J.prototype.fontMetrics = function (b, d) {
	        b = !this.styledMode && /px/.test(b) || !y.getComputedStyle ? b || d && d.style && d.style.fontSize || this.style && this.style.fontSize : d && w.prototype.getStyle.call(d, "font-size");
	        b = /px/.test(b) ? N(b) : 12;
	        d = 24 > b ? b + 3 : Math.round(1.2 * b);
	        return {
	          h: d,
	          b: Math.round(.8 * d),
	          f: b
	        };
	      };
	      J.prototype.rotCorr = function (b, d, c) {
	        var a = b;
	        d && c && (a = Math.max(a * Math.cos(d * k), 4));
	        return {
	          x: -b / 3 * Math.sin(d * k),
	          y: a
	        };
	      };
	      J.prototype.pathToSegments = function (b) {
	        for (var d = [], c = [], a = {
	            A: 8,
	            C: 7,
	            H: 2,
	            L: 3,
	            M: 3,
	            Q: 5,
	            S: 5,
	            T: 3,
	            V: 2
	          }, h = 0; h < b.length; h++) O(c[0]) && v(b[h]) && c.length === a[c[0].toUpperCase()] && b.splice(h, 0, c[0].replace("M", "L").replace("m", "l")), "string" === typeof b[h] && (c.length && d.push(c.slice(0)), c.length = 0), c.push(b[h]);
	        d.push(c.slice(0));
	        return d;
	      };
	      J.prototype.label = function (b, d, c, a, h, l, e, r, m) {
	        return new E(this, b, d, c, a, h, l, e, r, m);
	      };
	      J.prototype.alignElements = function () {
	        this.alignedObjects.forEach(function (b) {
	          return b.align();
	        });
	      };
	      return J;
	    }();
	    d(B.prototype, {
	      Element: w,
	      SVG_NS: q,
	      escapes: {
	        "&": "&amp;",
	        "<": "&lt;",
	        ">": "&gt;",
	        "'": "&#39;",
	        '"': "&quot;"
	      },
	      symbols: I,
	      draw: t
	    });
	    H.registerRendererType("svg", B, !0);
	    return B;
	  });
	  K(f, "Core/Renderer/HTML/HTMLElement.js", [f["Core/Globals.js"], f["Core/Renderer/SVG/SVGElement.js"], f["Core/Utilities.js"]], function (a, f, B) {
	    var C = this && this.__extends || function () {
	        var c = function (a, e) {
	          c = Object.setPrototypeOf || {
	            __proto__: []
	          } instanceof Array && function (c, a) {
	            c.__proto__ = a;
	          } || function (c, a) {
	            for (var e in a) a.hasOwnProperty(e) && (c[e] = a[e]);
	          };
	          return c(a, e);
	        };
	        return function (a, e) {
	          function g() {
	            this.constructor = a;
	          }
	          c(a, e);
	          a.prototype = null === e ? Object.create(e) : (g.prototype = e.prototype, new g());
	        };
	      }(),
	      w = a.isFirefox,
	      E = a.isMS,
	      I = a.isWebKit,
	      A = a.win,
	      u = B.css,
	      n = B.defined,
	      k = B.extend,
	      e = B.pick,
	      c = B.pInt;
	    return function (a) {
	      function g() {
	        return null !== a && a.apply(this, arguments) || this;
	      }
	      C(g, a);
	      g.compose = function (c) {
	        if (-1 === g.composedClasses.indexOf(c)) {
	          g.composedClasses.push(c);
	          var a = g.prototype,
	            e = c.prototype;
	          e.getSpanCorrection = a.getSpanCorrection;
	          e.htmlCss = a.htmlCss;
	          e.htmlGetBBox = a.htmlGetBBox;
	          e.htmlUpdateTransform = a.htmlUpdateTransform;
	          e.setSpanRotation = a.setSpanRotation;
	        }
	        return c;
	      };
	      g.prototype.getSpanCorrection = function (c, a, e) {
	        this.xCorr = -c * e;
	        this.yCorr = -a;
	      };
	      g.prototype.htmlCss = function (c) {
	        var a = "SPAN" === this.element.tagName && c && "width" in c,
	          g = e(a && c.width, void 0);
	        if (a) {
	          delete c.width;
	          this.textWidth = g;
	          var f = !0;
	        }
	        c && "ellipsis" === c.textOverflow && (c.whiteSpace = "nowrap", c.overflow = "hidden");
	        this.styles = k(this.styles, c);
	        u(this.element, c);
	        f && this.htmlUpdateTransform();
	        return this;
	      };
	      g.prototype.htmlGetBBox = function () {
	        var c = this.element;
	        return {
	          x: c.offsetLeft,
	          y: c.offsetTop,
	          width: c.offsetWidth,
	          height: c.offsetHeight
	        };
	      };
	      g.prototype.htmlUpdateTransform = function () {
	        if (this.added) {
	          var a = this.renderer,
	            e = this.element,
	            g = this.translateX || 0,
	            k = this.translateY || 0,
	            f = this.x || 0,
	            p = this.y || 0,
	            m = this.textAlign || "left",
	            h = {
	              left: 0,
	              center: .5,
	              right: 1
	            }[m],
	            b = this.styles;
	          b = b && b.whiteSpace;
	          u(e, {
	            marginLeft: g,
	            marginTop: k
	          });
	          !a.styledMode && this.shadows && this.shadows.forEach(function (b) {
	            u(b, {
	              marginLeft: g + 1,
	              marginTop: k + 1
	            });
	          });
	          this.inverted && [].forEach.call(e.childNodes, function (b) {
	            a.invertChild(b, e);
	          });
	          if ("SPAN" === e.tagName) {
	            var l = this.rotation,
	              d = this.textWidth && c(this.textWidth),
	              D = [l, m, e.innerHTML, this.textWidth, this.textAlign].join(),
	              v = void 0;
	            v = !1;
	            if (d !== this.oldTextWidth) {
	              if (this.textPxLength) var r = this.textPxLength;else u(e, {
	                width: "",
	                whiteSpace: b || "nowrap"
	              }), r = e.offsetWidth;
	              (d > this.oldTextWidth || r > d) && (/[ \-]/.test(e.textContent || e.innerText) || "ellipsis" === e.style.textOverflow) && (u(e, {
	                width: r > d || l ? d + "px" : "auto",
	                display: "block",
	                whiteSpace: b || "normal"
	              }), this.oldTextWidth = d, v = !0);
	            }
	            this.hasBoxWidthChanged = v;
	            D !== this.cTT && (v = a.fontMetrics(e.style.fontSize, e).b, !n(l) || l === (this.oldRotation || 0) && m === this.oldAlign || this.setSpanRotation(l, h, v), this.getSpanCorrection(!n(l) && this.textPxLength || e.offsetWidth, v, h, l, m));
	            u(e, {
	              left: f + (this.xCorr || 0) + "px",
	              top: p + (this.yCorr || 0) + "px"
	            });
	            this.cTT = D;
	            this.oldRotation = l;
	            this.oldAlign = m;
	          }
	        } else this.alignOnAdd = !0;
	      };
	      g.prototype.setSpanRotation = function (c, a, e) {
	        var g = {},
	          k = E && !/Edge/.test(A.navigator.userAgent) ? "-ms-transform" : I ? "-webkit-transform" : w ? "MozTransform" : A.opera ? "-o-transform" : void 0;
	        k && (g[k] = g.transform = "rotate(" + c + "deg)", g[k + (w ? "Origin" : "-origin")] = g.transformOrigin = 100 * a + "% " + e + "px", u(this.element, g));
	      };
	      g.composedClasses = [];
	      return g;
	    }(f);
	  });
	  K(f, "Core/Renderer/HTML/HTMLRenderer.js", [f["Core/Renderer/HTML/AST.js"], f["Core/Renderer/SVG/SVGElement.js"], f["Core/Renderer/SVG/SVGRenderer.js"], f["Core/Utilities.js"]], function (a, f, B, H) {
	    var C = this && this.__extends || function () {
	        var a = function (k, e) {
	          a = Object.setPrototypeOf || {
	            __proto__: []
	          } instanceof Array && function (c, a) {
	            c.__proto__ = a;
	          } || function (c, a) {
	            for (var e in a) a.hasOwnProperty(e) && (c[e] = a[e]);
	          };
	          return a(k, e);
	        };
	        return function (k, e) {
	          function c() {
	            this.constructor = k;
	          }
	          a(k, e);
	          k.prototype = null === e ? Object.create(e) : (c.prototype = e.prototype, new c());
	        };
	      }(),
	      E = H.attr,
	      I = H.createElement,
	      A = H.extend,
	      u = H.pick;
	    return function (n) {
	      function k() {
	        return null !== n && n.apply(this, arguments) || this;
	      }
	      C(k, n);
	      k.compose = function (a) {
	        -1 === k.composedClasses.indexOf(a) && (k.composedClasses.push(a), a.prototype.html = k.prototype.html);
	        return a;
	      };
	      k.prototype.html = function (e, c, k) {
	        var g = this.createElement("span"),
	          p = g.element,
	          q = g.renderer,
	          n = q.isSVG,
	          y = function (c, a) {
	            ["opacity", "visibility"].forEach(function (e) {
	              c[e + "Setter"] = function (h, b, l) {
	                var d = c.div ? c.div.style : a;
	                f.prototype[e + "Setter"].call(this, h, b, l);
	                d && (d[b] = h);
	              };
	            });
	            c.addedSetters = !0;
	          };
	        g.textSetter = function (c) {
	          c !== this.textStr && (delete this.bBox, delete this.oldTextWidth, a.setElementHTML(this.element, u(c, "")), this.textStr = c, g.doTransform = !0);
	        };
	        n && y(g, g.element.style);
	        g.xSetter = g.ySetter = g.alignSetter = g.rotationSetter = function (c, a) {
	          "align" === a ? g.alignValue = g.textAlign = c : g[a] = c;
	          g.doTransform = !0;
	        };
	        g.afterSetters = function () {
	          this.doTransform && (this.htmlUpdateTransform(), this.doTransform = !1);
	        };
	        g.attr({
	          text: e,
	          x: Math.round(c),
	          y: Math.round(k)
	        }).css({
	          position: "absolute"
	        });
	        q.styledMode || g.css({
	          fontFamily: this.style.fontFamily,
	          fontSize: this.style.fontSize
	        });
	        p.style.whiteSpace = "nowrap";
	        g.css = g.htmlCss;
	        n && (g.add = function (c) {
	          var a = q.box.parentNode,
	            e = [];
	          if (this.parentGroup = c) {
	            var h = c.div;
	            if (!h) {
	              for (; c;) e.push(c), c = c.parentGroup;
	              e.reverse().forEach(function (b) {
	                function c(d, c) {
	                  b[c] = d;
	                  "translateX" === c ? v.left = d + "px" : v.top = d + "px";
	                  b.doTransform = !0;
	                }
	                var d = E(b.element, "class"),
	                  m = b.styles || {};
	                h = b.div = b.div || I("div", d ? {
	                  className: d
	                } : void 0, {
	                  position: "absolute",
	                  left: (b.translateX || 0) + "px",
	                  top: (b.translateY || 0) + "px",
	                  display: b.display,
	                  opacity: b.opacity,
	                  cursor: m.cursor,
	                  pointerEvents: m.pointerEvents,
	                  visibility: b.visibility
	                }, h || a);
	                var v = h.style;
	                A(b, {
	                  classSetter: function (b) {
	                    return function (d) {
	                      this.element.setAttribute("class", d);
	                      b.className = d;
	                    };
	                  }(h),
	                  on: function () {
	                    e[0].div && g.on.apply({
	                      element: e[0].div,
	                      onEvents: b.onEvents
	                    }, arguments);
	                    return b;
	                  },
	                  translateXSetter: c,
	                  translateYSetter: c
	                });
	                b.addedSetters || y(b);
	              });
	            }
	          } else h = a;
	          h.appendChild(p);
	          g.added = !0;
	          g.alignOnAdd && g.htmlUpdateTransform();
	          return g;
	        });
	        return g;
	      };
	      k.composedClasses = [];
	      return k;
	    }(B);
	  });
	  K(f, "Core/Axis/AxisDefaults.js", [], function () {
	    var a;
	    (function (a) {
	      a.defaultXAxisOptions = {
	        alignTicks: !0,
	        allowDecimals: void 0,
	        panningEnabled: !0,
	        zIndex: 2,
	        zoomEnabled: !0,
	        dateTimeLabelFormats: {
	          millisecond: {
	            main: "%H:%M:%S.%L",
	            range: !1
	          },
	          second: {
	            main: "%H:%M:%S",
	            range: !1
	          },
	          minute: {
	            main: "%H:%M",
	            range: !1
	          },
	          hour: {
	            main: "%H:%M",
	            range: !1
	          },
	          day: {
	            main: "%e. %b"
	          },
	          week: {
	            main: "%e. %b"
	          },
	          month: {
	            main: "%b '%y"
	          },
	          year: {
	            main: "%Y"
	          }
	        },
	        endOnTick: !1,
	        gridLineDashStyle: "Solid",
	        gridZIndex: 1,
	        labels: {
	          autoRotation: void 0,
	          autoRotationLimit: 80,
	          distance: void 0,
	          enabled: !0,
	          indentation: 10,
	          overflow: "justify",
	          padding: 5,
	          reserveSpace: void 0,
	          rotation: void 0,
	          staggerLines: 0,
	          step: 0,
	          useHTML: !1,
	          x: 0,
	          zIndex: 7,
	          style: {
	            color: "#666666",
	            cursor: "default",
	            fontSize: "11px"
	          }
	        },
	        maxPadding: .01,
	        minorGridLineDashStyle: "Solid",
	        minorTickLength: 2,
	        minorTickPosition: "outside",
	        minPadding: .01,
	        offset: void 0,
	        opposite: !1,
	        reversed: void 0,
	        reversedStacks: !1,
	        showEmpty: !0,
	        showFirstLabel: !0,
	        showLastLabel: !0,
	        startOfWeek: 1,
	        startOnTick: !1,
	        tickLength: 10,
	        tickPixelInterval: 100,
	        tickmarkPlacement: "between",
	        tickPosition: "outside",
	        title: {
	          align: "middle",
	          rotation: 0,
	          useHTML: !1,
	          x: 0,
	          y: 0,
	          style: {
	            color: "#666666"
	          }
	        },
	        type: "linear",
	        uniqueNames: !0,
	        visible: !0,
	        minorGridLineColor: "#f2f2f2",
	        minorGridLineWidth: 1,
	        minorTickColor: "#999999",
	        lineColor: "#ccd6eb",
	        lineWidth: 1,
	        gridLineColor: "#e6e6e6",
	        gridLineWidth: void 0,
	        tickColor: "#ccd6eb"
	      };
	      a.defaultYAxisOptions = {
	        reversedStacks: !0,
	        endOnTick: !0,
	        maxPadding: .05,
	        minPadding: .05,
	        tickPixelInterval: 72,
	        showLastLabel: !0,
	        labels: {
	          x: -8
	        },
	        startOnTick: !0,
	        title: {
	          rotation: 270,
	          text: "Values"
	        },
	        stackLabels: {
	          animation: {},
	          allowOverlap: !1,
	          enabled: !1,
	          crop: !0,
	          overflow: "justify",
	          formatter: function () {
	            var a = this.axis.chart.numberFormatter;
	            return a(this.total, -1);
	          },
	          style: {
	            color: "#000000",
	            fontSize: "11px",
	            fontWeight: "bold",
	            textOutline: "1px contrast"
	          }
	        },
	        gridLineWidth: 1,
	        lineWidth: 0
	      };
	      a.defaultLeftAxisOptions = {
	        labels: {
	          x: -15
	        },
	        title: {
	          rotation: 270
	        }
	      };
	      a.defaultRightAxisOptions = {
	        labels: {
	          x: 15
	        },
	        title: {
	          rotation: 90
	        }
	      };
	      a.defaultBottomAxisOptions = {
	        labels: {
	          autoRotation: [-45],
	          x: 0
	        },
	        margin: 15,
	        title: {
	          rotation: 0
	        }
	      };
	      a.defaultTopAxisOptions = {
	        labels: {
	          autoRotation: [-45],
	          x: 0
	        },
	        margin: 15,
	        title: {
	          rotation: 0
	        }
	      };
	    })(a || (a = {}));
	    return a;
	  });
	  K(f, "Core/Foundation.js", [f["Core/Utilities.js"]], function (a) {
	    var f = a.addEvent,
	      B = a.isFunction,
	      H = a.objectEach,
	      w = a.removeEvent,
	      E;
	    (function (a) {
	      a.registerEventOptions = function (a, u) {
	        a.eventOptions = a.eventOptions || {};
	        H(u.events, function (n, k) {
	          a.eventOptions[k] !== n && (a.eventOptions[k] && (w(a, k, a.eventOptions[k]), delete a.eventOptions[k]), B(n) && (a.eventOptions[k] = n, f(a, k, n)));
	        });
	      };
	    })(E || (E = {}));
	    return E;
	  });
	  K(f, "Core/Axis/Tick.js", [f["Core/FormatUtilities.js"], f["Core/Globals.js"], f["Core/Utilities.js"]], function (a, f, B) {
	    var C = f.deg2rad,
	      w = B.clamp,
	      E = B.correctFloat,
	      I = B.defined,
	      A = B.destroyObjectProperties,
	      u = B.extend,
	      n = B.fireEvent,
	      k = B.isNumber,
	      e = B.merge,
	      c = B.objectEach,
	      p = B.pick;
	    f = function () {
	      function g(c, a, e, g, k) {
	        this.isNewLabel = this.isNew = !0;
	        this.axis = c;
	        this.pos = a;
	        this.type = e || "";
	        this.parameters = k || {};
	        this.tickmarkOffset = this.parameters.tickmarkOffset;
	        this.options = this.parameters.options;
	        n(this, "init");
	        e || g || this.addLabel();
	      }
	      g.prototype.addLabel = function () {
	        var c = this,
	          e = c.axis,
	          g = e.options,
	          f = e.chart,
	          x = e.categories,
	          z = e.logarithmic,
	          m = e.names,
	          h = c.pos,
	          b = p(c.options && c.options.labels, g.labels),
	          l = e.tickPositions,
	          d = h === l[0],
	          D = h === l[l.length - 1],
	          v = (!b.step || 1 === b.step) && 1 === e.tickInterval;
	        l = l.info;
	        var r = c.label,
	          O;
	        x = this.parameters.category || (x ? p(x[h], m[h], h) : h);
	        z && k(x) && (x = E(z.lin2log(x)));
	        if (e.dateTime) if (l) {
	          var P = f.time.resolveDTLFormat(g.dateTimeLabelFormats[!g.grid && l.higherRanks[h] || l.unitName]);
	          var S = P.main;
	        } else k(x) && (S = e.dateTime.getXDateFormat(x, g.dateTimeLabelFormats || {}));
	        c.isFirst = d;
	        c.isLast = D;
	        var N = {
	          axis: e,
	          chart: f,
	          dateTimeLabelFormat: S,
	          isFirst: d,
	          isLast: D,
	          pos: h,
	          tick: c,
	          tickPositionInfo: l,
	          value: x
	        };
	        n(this, "labelFormat", N);
	        var C = function (d) {
	          return b.formatter ? b.formatter.call(d, d) : b.format ? (d.text = e.defaultLabelFormatter.call(d), a.format(b.format, d, f)) : e.defaultLabelFormatter.call(d, d);
	        };
	        g = C.call(N, N);
	        var X = P && P.list;
	        c.shortenLabel = X ? function () {
	          for (O = 0; O < X.length; O++) if (u(N, {
	            dateTimeLabelFormat: X[O]
	          }), r.attr({
	            text: C.call(N, N)
	          }), r.getBBox().width < e.getSlotWidth(c) - 2 * b.padding) return;
	          r.attr({
	            text: ""
	          });
	        } : void 0;
	        v && e._addedPlotLB && c.moveLabel(g, b);
	        I(r) || c.movedLabel ? r && r.textStr !== g && !v && (!r.textWidth || b.style.width || r.styles.width || r.css({
	          width: null
	        }), r.attr({
	          text: g
	        }), r.textPxLength = r.getBBox().width) : (c.label = r = c.createLabel({
	          x: 0,
	          y: 0
	        }, g, b), c.rotation = 0);
	      };
	      g.prototype.createLabel = function (c, a, g) {
	        var k = this.axis,
	          f = k.chart;
	        if (c = I(a) && g.enabled ? f.renderer.text(a, c.x, c.y, g.useHTML).add(k.labelGroup) : null) f.styledMode || c.css(e(g.style)), c.textPxLength = c.getBBox().width;
	        return c;
	      };
	      g.prototype.destroy = function () {
	        A(this, this.axis);
	      };
	      g.prototype.getPosition = function (c, a, e, g) {
	        var k = this.axis,
	          f = k.chart,
	          m = g && f.oldChartHeight || f.chartHeight;
	        c = {
	          x: c ? E(k.translate(a + e, null, null, g) + k.transB) : k.left + k.offset + (k.opposite ? (g && f.oldChartWidth || f.chartWidth) - k.right - k.left : 0),
	          y: c ? m - k.bottom + k.offset - (k.opposite ? k.height : 0) : E(m - k.translate(a + e, null, null, g) - k.transB)
	        };
	        c.y = w(c.y, -1E5, 1E5);
	        n(this, "afterGetPosition", {
	          pos: c
	        });
	        return c;
	      };
	      g.prototype.getLabelPosition = function (c, a, e, g, k, f, m, h) {
	        var b = this.axis,
	          l = b.transA,
	          d = b.isLinked && b.linkedParent ? b.linkedParent.reversed : b.reversed,
	          D = b.staggerLines,
	          v = b.tickRotCorr || {
	            x: 0,
	            y: 0
	          },
	          r = g || b.reserveSpaceDefault ? 0 : -b.labelOffset * ("center" === b.labelAlign ? .5 : 1),
	          p = {},
	          q = k.y;
	        I(q) || (q = 0 === b.side ? e.rotation ? -8 : -e.getBBox().height : 2 === b.side ? v.y + 8 : Math.cos(e.rotation * C) * (v.y - e.getBBox(!1, 0).height / 2));
	        c = c + k.x + r + v.x - (f && g ? f * l * (d ? -1 : 1) : 0);
	        a = a + q - (f && !g ? f * l * (d ? 1 : -1) : 0);
	        D && (e = m / (h || 1) % D, b.opposite && (e = D - e - 1), a += b.labelOffset / D * e);
	        p.x = c;
	        p.y = Math.round(a);
	        n(this, "afterGetLabelPosition", {
	          pos: p,
	          tickmarkOffset: f,
	          index: m
	        });
	        return p;
	      };
	      g.prototype.getLabelSize = function () {
	        return this.label ? this.label.getBBox()[this.axis.horiz ? "height" : "width"] : 0;
	      };
	      g.prototype.getMarkPath = function (c, a, e, g, k, f) {
	        return f.crispLine([["M", c, a], ["L", c + (k ? 0 : -e), a + (k ? e : 0)]], g);
	      };
	      g.prototype.handleOverflow = function (c) {
	        var a = this.axis,
	          e = a.options.labels,
	          g = c.x,
	          k = a.chart.chartWidth,
	          f = a.chart.spacing,
	          m = p(a.labelLeft, Math.min(a.pos, f[3]));
	        f = p(a.labelRight, Math.max(a.isRadial ? 0 : a.pos + a.len, k - f[1]));
	        var h = this.label,
	          b = this.rotation,
	          l = {
	            left: 0,
	            center: .5,
	            right: 1
	          }[a.labelAlign || h.attr("align")],
	          d = h.getBBox().width,
	          D = a.getSlotWidth(this),
	          v = {},
	          r = D,
	          n = 1,
	          t;
	        if (b || "justify" !== e.overflow) 0 > b && g - l * d < m ? t = Math.round(g / Math.cos(b * C) - m) : 0 < b && g + l * d > f && (t = Math.round((k - g) / Math.cos(b * C)));else if (k = g + (1 - l) * d, g - l * d < m ? r = c.x + r * (1 - l) - m : k > f && (r = f - c.x + r * l, n = -1), r = Math.min(D, r), r < D && "center" === a.labelAlign && (c.x += n * (D - r - l * (D - Math.min(d, r)))), d > r || a.autoRotation && (h.styles || {}).width) t = r;
	        t && (this.shortenLabel ? this.shortenLabel() : (v.width = Math.floor(t) + "px", (e.style || {}).textOverflow || (v.textOverflow = "ellipsis"), h.css(v)));
	      };
	      g.prototype.moveLabel = function (a, e) {
	        var g = this,
	          k = g.label,
	          f = g.axis,
	          p = f.reversed,
	          m = !1;
	        k && k.textStr === a ? (g.movedLabel = k, m = !0, delete g.label) : c(f.ticks, function (b) {
	          m || b.isNew || b === g || !b.label || b.label.textStr !== a || (g.movedLabel = b.label, m = !0, b.labelPos = g.movedLabel.xy, delete b.label);
	        });
	        if (!m && (g.labelPos || k)) {
	          var h = g.labelPos || k.xy;
	          k = f.horiz ? p ? 0 : f.width + f.left : h.x;
	          f = f.horiz ? h.y : p ? f.width + f.left : 0;
	          g.movedLabel = g.createLabel({
	            x: k,
	            y: f
	          }, a, e);
	          g.movedLabel && g.movedLabel.attr({
	            opacity: 0
	          });
	        }
	      };
	      g.prototype.render = function (c, a, e) {
	        var g = this.axis,
	          k = g.horiz,
	          f = this.pos,
	          m = p(this.tickmarkOffset, g.tickmarkOffset);
	        f = this.getPosition(k, f, m, a);
	        m = f.x;
	        var h = f.y;
	        g = k && m === g.pos + g.len || !k && h === g.pos ? -1 : 1;
	        k = p(e, this.label && this.label.newOpacity, 1);
	        e = p(e, 1);
	        this.isActive = !0;
	        this.renderGridLine(a, e, g);
	        this.renderMark(f, e, g);
	        this.renderLabel(f, a, k, c);
	        this.isNew = !1;
	        n(this, "afterRender");
	      };
	      g.prototype.renderGridLine = function (c, a, e) {
	        var g = this.axis,
	          k = g.options,
	          f = {},
	          m = this.pos,
	          h = this.type,
	          b = p(this.tickmarkOffset, g.tickmarkOffset),
	          l = g.chart.renderer,
	          d = this.gridLine,
	          D = k.gridLineWidth,
	          v = k.gridLineColor,
	          r = k.gridLineDashStyle;
	        "minor" === this.type && (D = k.minorGridLineWidth, v = k.minorGridLineColor, r = k.minorGridLineDashStyle);
	        d || (g.chart.styledMode || (f.stroke = v, f["stroke-width"] = D || 0, f.dashstyle = r), h || (f.zIndex = 1), c && (a = 0), this.gridLine = d = l.path().attr(f).addClass("highcharts-" + (h ? h + "-" : "") + "grid-line").add(g.gridGroup));
	        if (d && (e = g.getPlotLinePath({
	          value: m + b,
	          lineWidth: d.strokeWidth() * e,
	          force: "pass",
	          old: c
	        }))) d[c || this.isNew ? "attr" : "animate"]({
	          d: e,
	          opacity: a
	        });
	      };
	      g.prototype.renderMark = function (c, a, e) {
	        var g = this.axis,
	          k = g.options,
	          f = g.chart.renderer,
	          m = this.type,
	          h = g.tickSize(m ? m + "Tick" : "tick"),
	          b = c.x;
	        c = c.y;
	        var l = p(k["minor" !== m ? "tickWidth" : "minorTickWidth"], !m && g.isXAxis ? 1 : 0);
	        k = k["minor" !== m ? "tickColor" : "minorTickColor"];
	        var d = this.mark,
	          D = !d;
	        h && (g.opposite && (h[0] = -h[0]), d || (this.mark = d = f.path().addClass("highcharts-" + (m ? m + "-" : "") + "tick").add(g.axisGroup), g.chart.styledMode || d.attr({
	          stroke: k,
	          "stroke-width": l
	        })), d[D ? "attr" : "animate"]({
	          d: this.getMarkPath(b, c, h[0], d.strokeWidth() * e, g.horiz, f),
	          opacity: a
	        }));
	      };
	      g.prototype.renderLabel = function (c, a, e, g) {
	        var f = this.axis,
	          q = f.horiz,
	          m = f.options,
	          h = this.label,
	          b = m.labels,
	          l = b.step;
	        f = p(this.tickmarkOffset, f.tickmarkOffset);
	        var d = c.x;
	        c = c.y;
	        var D = !0;
	        h && k(d) && (h.xy = c = this.getLabelPosition(d, c, h, q, b, f, g, l), this.isFirst && !this.isLast && !m.showFirstLabel || this.isLast && !this.isFirst && !m.showLastLabel ? D = !1 : !q || b.step || b.rotation || a || 0 === e || this.handleOverflow(c), l && g % l && (D = !1), D && k(c.y) ? (c.opacity = e, h[this.isNewLabel ? "attr" : "animate"](c).show(!0), this.isNewLabel = !1) : (h.hide(), this.isNewLabel = !0));
	      };
	      g.prototype.replaceMovedLabel = function () {
	        var c = this.label,
	          a = this.axis,
	          e = a.reversed;
	        if (c && !this.isNew) {
	          var g = a.horiz ? e ? a.left : a.width + a.left : c.xy.x;
	          e = a.horiz ? c.xy.y : e ? a.width + a.top : a.top;
	          c.animate({
	            x: g,
	            y: e,
	            opacity: 0
	          }, void 0, c.destroy);
	          delete this.label;
	        }
	        a.isDirty = !0;
	        this.label = this.movedLabel;
	        delete this.movedLabel;
	      };
	      return g;
	    }();
	    return f;
	  });
	  K(f, "Core/Axis/Axis.js", [f["Core/Animation/AnimationUtilities.js"], f["Core/Axis/AxisDefaults.js"], f["Core/Color/Color.js"], f["Core/DefaultOptions.js"], f["Core/Foundation.js"], f["Core/Globals.js"], f["Core/Axis/Tick.js"], f["Core/Utilities.js"]], function (a, f, B, H, w, E, I, A) {
	    var u = a.animObject,
	      n = H.defaultOptions,
	      k = w.registerEventOptions,
	      e = E.deg2rad,
	      c = A.arrayMax,
	      p = A.arrayMin,
	      g = A.clamp,
	      t = A.correctFloat,
	      q = A.defined,
	      F = A.destroyObjectProperties,
	      y = A.erase,
	      x = A.error,
	      z = A.extend,
	      m = A.fireEvent,
	      h = A.isArray,
	      b = A.isNumber,
	      l = A.isString,
	      d = A.merge,
	      D = A.normalizeTickInterval,
	      v = A.objectEach,
	      r = A.pick,
	      O = A.relativeLength,
	      P = A.removeEvent,
	      S = A.splat,
	      N = A.syncTimeout,
	      C = function (b, d) {
	        return D(d, void 0, void 0, r(b.options.allowDecimals, .5 > d || void 0 !== b.tickAmount), !!b.tickAmount);
	      };
	    a = function () {
	      function a(b, d) {
	        this.zoomEnabled = this.width = this.visible = this.userOptions = this.translationSlope = this.transB = this.transA = this.top = this.ticks = this.tickRotCorr = this.tickPositions = this.tickmarkOffset = this.tickInterval = this.tickAmount = this.side = this.series = this.right = this.positiveValuesOnly = this.pos = this.pointRangePadding = this.pointRange = this.plotLinesAndBandsGroups = this.plotLinesAndBands = this.paddedTicks = this.overlap = this.options = this.offset = this.names = this.minPixelPadding = this.minorTicks = this.minorTickInterval = this.min = this.maxLabelLength = this.max = this.len = this.left = this.labelFormatter = this.labelEdge = this.isLinked = this.height = this.hasVisibleSeries = this.hasNames = this.eventOptions = this.coll = this.closestPointRange = this.chart = this.bottom = this.alternateBands = void 0;
	        this.init(b, d);
	      }
	      a.prototype.init = function (d, c) {
	        var a = c.isX;
	        this.chart = d;
	        this.horiz = d.inverted && !this.isZAxis ? !a : a;
	        this.isXAxis = a;
	        this.coll = this.coll || (a ? "xAxis" : "yAxis");
	        m(this, "init", {
	          userOptions: c
	        });
	        this.opposite = r(c.opposite, this.opposite);
	        this.side = r(c.side, this.side, this.horiz ? this.opposite ? 0 : 2 : this.opposite ? 1 : 3);
	        this.setOptions(c);
	        var e = this.options,
	          h = e.labels,
	          l = e.type;
	        this.userOptions = c;
	        this.minPixelPadding = 0;
	        this.reversed = r(e.reversed, this.reversed);
	        this.visible = e.visible;
	        this.zoomEnabled = e.zoomEnabled;
	        this.hasNames = "category" === l || !0 === e.categories;
	        this.categories = e.categories || (this.hasNames ? [] : void 0);
	        this.names || (this.names = [], this.names.keys = {});
	        this.plotLinesAndBandsGroups = {};
	        this.positiveValuesOnly = !!this.logarithmic;
	        this.isLinked = q(e.linkedTo);
	        this.ticks = {};
	        this.labelEdge = [];
	        this.minorTicks = {};
	        this.plotLinesAndBands = [];
	        this.alternateBands = {};
	        this.len = 0;
	        this.minRange = this.userMinRange = e.minRange || e.maxZoom;
	        this.range = e.range;
	        this.offset = e.offset || 0;
	        this.min = this.max = null;
	        c = r(e.crosshair, S(d.options.tooltip.crosshairs)[a ? 0 : 1]);
	        this.crosshair = !0 === c ? {} : c;
	        -1 === d.axes.indexOf(this) && (a ? d.axes.splice(d.xAxis.length, 0, this) : d.axes.push(this), d[this.coll].push(this));
	        this.series = this.series || [];
	        d.inverted && !this.isZAxis && a && "undefined" === typeof this.reversed && (this.reversed = !0);
	        this.labelRotation = b(h.rotation) ? h.rotation : void 0;
	        k(this, e);
	        m(this, "afterInit");
	      };
	      a.prototype.setOptions = function (b) {
	        this.options = d(f.defaultXAxisOptions, "yAxis" === this.coll && f.defaultYAxisOptions, [f.defaultTopAxisOptions, f.defaultRightAxisOptions, f.defaultBottomAxisOptions, f.defaultLeftAxisOptions][this.side], d(n[this.coll], b));
	        m(this, "afterSetOptions", {
	          userOptions: b
	        });
	      };
	      a.prototype.defaultLabelFormatter = function (d) {
	        var c = this.axis;
	        d = this.chart.numberFormatter;
	        var a = b(this.value) ? this.value : NaN,
	          e = c.chart.time,
	          h = this.dateTimeLabelFormat,
	          l = n.lang,
	          g = l.numericSymbols;
	        l = l.numericSymbolMagnitude || 1E3;
	        var r = c.logarithmic ? Math.abs(a) : c.tickInterval,
	          m = g && g.length;
	        if (c.categories) var J = "" + this.value;else if (h) J = e.dateFormat(h, a);else if (m && 1E3 <= r) for (; m-- && "undefined" === typeof J;) c = Math.pow(l, m + 1), r >= c && 0 === 10 * a % c && null !== g[m] && 0 !== a && (J = d(a / c, -1) + g[m]);
	        "undefined" === typeof J && (J = 1E4 <= Math.abs(a) ? d(a, -1) : d(a, -1, void 0, ""));
	        return J;
	      };
	      a.prototype.getSeriesExtremes = function () {
	        var d = this,
	          c = d.chart,
	          a;
	        m(this, "getSeriesExtremes", null, function () {
	          d.hasVisibleSeries = !1;
	          d.dataMin = d.dataMax = d.threshold = null;
	          d.softThreshold = !d.isXAxis;
	          d.stacking && d.stacking.buildStacks();
	          d.series.forEach(function (e) {
	            if (e.visible || !c.options.chart.ignoreHiddenSeries) {
	              var h = e.options,
	                l = h.threshold;
	              d.hasVisibleSeries = !0;
	              d.positiveValuesOnly && 0 >= l && (l = null);
	              if (d.isXAxis) {
	                if (h = e.xData, h.length) {
	                  h = d.logarithmic ? h.filter(d.validatePositiveValue) : h;
	                  a = e.getXExtremes(h);
	                  var g = a.min;
	                  var m = a.max;
	                  b(g) || g instanceof Date || (h = h.filter(b), a = e.getXExtremes(h), g = a.min, m = a.max);
	                  h.length && (d.dataMin = Math.min(r(d.dataMin, g), g), d.dataMax = Math.max(r(d.dataMax, m), m));
	                }
	              } else if (e = e.applyExtremes(), b(e.dataMin) && (g = e.dataMin, d.dataMin = Math.min(r(d.dataMin, g), g)), b(e.dataMax) && (m = e.dataMax, d.dataMax = Math.max(r(d.dataMax, m), m)), q(l) && (d.threshold = l), !h.softThreshold || d.positiveValuesOnly) d.softThreshold = !1;
	            }
	          });
	        });
	        m(this, "afterGetSeriesExtremes");
	      };
	      a.prototype.translate = function (d, c, a, e, h, l) {
	        var g = this.linkedParent || this,
	          m = e && g.old ? g.old.min : g.min,
	          r = g.minPixelPadding;
	        h = (g.isOrdinal || g.brokenAxis && g.brokenAxis.hasBreaks || g.logarithmic && h) && g.lin2val;
	        var k = 1,
	          J = 0;
	        e = e && g.old ? g.old.transA : g.transA;
	        e || (e = g.transA);
	        a && (k *= -1, J = g.len);
	        g.reversed && (k *= -1, J -= k * (g.sector || g.len));
	        c ? (l = (d * k + J - r) / e + m, h && (l = g.lin2val(l))) : (h && (d = g.val2lin(d)), d = k * (d - m) * e, l = b(m) ? (g.isRadial ? d : t(d)) + J + k * r + (b(l) ? e * l : 0) : void 0);
	        return l;
	      };
	      a.prototype.toPixels = function (b, d) {
	        return this.translate(b, !1, !this.horiz, null, !0) + (d ? 0 : this.pos);
	      };
	      a.prototype.toValue = function (b, d) {
	        return this.translate(b - (d ? 0 : this.pos), !0, !this.horiz, null, !0);
	      };
	      a.prototype.getPlotLinePath = function (d) {
	        function c(b, d, c) {
	          if ("pass" !== n && b < d || b > c) n ? b = g(b, d, c) : P = !0;
	          return b;
	        }
	        var a = this,
	          e = a.chart,
	          h = a.left,
	          l = a.top,
	          k = d.old,
	          J = d.value,
	          f = d.lineWidth,
	          v = k && e.oldChartHeight || e.chartHeight,
	          D = k && e.oldChartWidth || e.chartWidth,
	          p = a.transB,
	          q = d.translatedValue,
	          n = d.force,
	          t,
	          z,
	          y,
	          O,
	          P;
	        d = {
	          value: J,
	          lineWidth: f,
	          old: k,
	          force: n,
	          acrossPanes: d.acrossPanes,
	          translatedValue: q
	        };
	        m(this, "getPlotLinePath", d, function (d) {
	          q = r(q, a.translate(J, null, null, k));
	          q = g(q, -1E5, 1E5);
	          t = y = Math.round(q + p);
	          z = O = Math.round(v - q - p);
	          b(q) ? a.horiz ? (z = l, O = v - a.bottom, t = y = c(t, h, h + a.width)) : (t = h, y = D - a.right, z = O = c(z, l, l + a.height)) : (P = !0, n = !1);
	          d.path = P && !n ? null : e.renderer.crispLine([["M", t, z], ["L", y, O]], f || 1);
	        });
	        return d.path;
	      };
	      a.prototype.getLinearTickPositions = function (b, d, c) {
	        var a = t(Math.floor(d / b) * b);
	        c = t(Math.ceil(c / b) * b);
	        var e = [],
	          h;
	        t(a + b) === a && (h = 20);
	        if (this.single) return [d];
	        for (d = a; d <= c;) {
	          e.push(d);
	          d = t(d + b, h);
	          if (d === l) break;
	          var l = d;
	        }
	        return e;
	      };
	      a.prototype.getMinorTickInterval = function () {
	        var b = this.options;
	        return !0 === b.minorTicks ? r(b.minorTickInterval, "auto") : !1 === b.minorTicks ? null : b.minorTickInterval;
	      };
	      a.prototype.getMinorTickPositions = function () {
	        var b = this.options,
	          d = this.tickPositions,
	          c = this.minorTickInterval,
	          a = this.pointRangePadding || 0,
	          e = this.min - a;
	        a = this.max + a;
	        var h = a - e,
	          l = [];
	        if (h && h / c < this.len / 3) {
	          var g = this.logarithmic;
	          if (g) this.paddedTicks.forEach(function (b, d, a) {
	            d && l.push.apply(l, g.getLogTickPositions(c, a[d - 1], a[d], !0));
	          });else if (this.dateTime && "auto" === this.getMinorTickInterval()) l = l.concat(this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(c), e, a, b.startOfWeek));else for (b = e + (d[0] - e) % c; b <= a && b !== l[0]; b += c) l.push(b);
	        }
	        0 !== l.length && this.trimTicks(l);
	        return l;
	      };
	      a.prototype.adjustForMinRange = function () {
	        var b = this.options,
	          d = this.logarithmic,
	          a = this.min,
	          e = this.max,
	          h = 0,
	          l,
	          g,
	          m,
	          k;
	        this.isXAxis && "undefined" === typeof this.minRange && !d && (q(b.min) || q(b.max) || q(b.floor) || q(b.ceiling) ? this.minRange = null : (this.series.forEach(function (b) {
	          m = b.xData;
	          k = b.xIncrement ? 1 : m.length - 1;
	          if (1 < m.length) for (l = k; 0 < l; l--) if (g = m[l] - m[l - 1], !h || g < h) h = g;
	        }), this.minRange = Math.min(5 * h, this.dataMax - this.dataMin)));
	        if (e - a < this.minRange) {
	          var f = this.dataMax - this.dataMin >= this.minRange;
	          var v = this.minRange;
	          var D = (v - e + a) / 2;
	          D = [a - D, r(b.min, a - D)];
	          f && (D[2] = this.logarithmic ? this.logarithmic.log2lin(this.dataMin) : this.dataMin);
	          a = c(D);
	          e = [a + v, r(b.max, a + v)];
	          f && (e[2] = d ? d.log2lin(this.dataMax) : this.dataMax);
	          e = p(e);
	          e - a < v && (D[0] = e - v, D[1] = r(b.min, e - v), a = c(D));
	        }
	        this.min = a;
	        this.max = e;
	      };
	      a.prototype.getClosest = function () {
	        var b;
	        this.categories ? b = 1 : this.series.forEach(function (d) {
	          var c = d.closestPointRange,
	            a = d.visible || !d.chart.options.chart.ignoreHiddenSeries;
	          !d.noSharedTooltip && q(c) && a && (b = q(b) ? Math.min(b, c) : c);
	        });
	        return b;
	      };
	      a.prototype.nameToX = function (b) {
	        var d = h(this.options.categories),
	          c = d ? this.categories : this.names,
	          a = b.options.x;
	        b.series.requireSorting = !1;
	        q(a) || (a = this.options.uniqueNames && c ? d ? c.indexOf(b.name) : r(c.keys[b.name], -1) : b.series.autoIncrement());
	        if (-1 === a) {
	          if (!d && c) var e = c.length;
	        } else e = a;
	        "undefined" !== typeof e && (this.names[e] = b.name, this.names.keys[b.name] = e);
	        return e;
	      };
	      a.prototype.updateNames = function () {
	        var b = this,
	          d = this.names;
	        0 < d.length && (Object.keys(d.keys).forEach(function (b) {
	          delete d.keys[b];
	        }), d.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach(function (d) {
	          d.xIncrement = null;
	          if (!d.points || d.isDirtyData) b.max = Math.max(b.max, d.xData.length - 1), d.processData(), d.generatePoints();
	          d.data.forEach(function (c, a) {
	            if (c && c.options && "undefined" !== typeof c.name) {
	              var e = b.nameToX(c);
	              "undefined" !== typeof e && e !== c.x && (c.x = e, d.xData[a] = e);
	            }
	          });
	        }));
	      };
	      a.prototype.setAxisTranslation = function () {
	        var b = this,
	          d = b.max - b.min,
	          c = b.linkedParent,
	          a = !!b.categories,
	          e = b.isXAxis,
	          h = b.axisPointRange || 0,
	          g = 0,
	          k = 0,
	          f = b.transA;
	        if (e || a || h) {
	          var v = b.getClosest();
	          c ? (g = c.minPointOffset, k = c.pointRangePadding) : b.series.forEach(function (d) {
	            var c = a ? 1 : e ? r(d.options.pointRange, v, 0) : b.axisPointRange || 0,
	              m = d.options.pointPlacement;
	            h = Math.max(h, c);
	            if (!b.single || a) d = d.is("xrange") ? !e : e, g = Math.max(g, d && l(m) ? 0 : c / 2), k = Math.max(k, d && "on" === m ? 0 : c);
	          });
	          c = b.ordinal && b.ordinal.slope && v ? b.ordinal.slope / v : 1;
	          b.minPointOffset = g *= c;
	          b.pointRangePadding = k *= c;
	          b.pointRange = Math.min(h, b.single && a ? 1 : d);
	          e && (b.closestPointRange = v);
	        }
	        b.translationSlope = b.transA = f = b.staticScale || b.len / (d + k || 1);
	        b.transB = b.horiz ? b.left : b.bottom;
	        b.minPixelPadding = f * g;
	        m(this, "afterSetAxisTranslation");
	      };
	      a.prototype.minFromRange = function () {
	        return this.max - this.range;
	      };
	      a.prototype.setTickInterval = function (d) {
	        var c = this.chart,
	          a = this.logarithmic,
	          e = this.options,
	          h = this.isXAxis,
	          l = this.isLinked,
	          g = e.tickPixelInterval,
	          k = this.categories,
	          f = this.softThreshold,
	          v = e.maxPadding,
	          D = e.minPadding,
	          J = b(e.tickInterval) && 0 <= e.tickInterval ? e.tickInterval : void 0,
	          p = b(this.threshold) ? this.threshold : null;
	        this.dateTime || k || l || this.getTickAmount();
	        var n = r(this.userMin, e.min);
	        var z = r(this.userMax, e.max);
	        if (l) {
	          this.linkedParent = c[this.coll][e.linkedTo];
	          var y = this.linkedParent.getExtremes();
	          this.min = r(y.min, y.dataMin);
	          this.max = r(y.max, y.dataMax);
	          e.type !== this.linkedParent.options.type && x(11, 1, c);
	        } else {
	          if (f && q(p)) if (this.dataMin >= p) y = p, D = 0;else if (this.dataMax <= p) {
	            var O = p;
	            v = 0;
	          }
	          this.min = r(n, y, this.dataMin);
	          this.max = r(z, O, this.dataMax);
	        }
	        a && (this.positiveValuesOnly && !d && 0 >= Math.min(this.min, r(this.dataMin, this.min)) && x(10, 1, c), this.min = t(a.log2lin(this.min), 16), this.max = t(a.log2lin(this.max), 16));
	        this.range && q(this.max) && (this.userMin = this.min = n = Math.max(this.dataMin, this.minFromRange()), this.userMax = z = this.max, this.range = null);
	        m(this, "foundExtremes");
	        this.beforePadding && this.beforePadding();
	        this.adjustForMinRange();
	        !(k || this.axisPointRange || this.stacking && this.stacking.usePercentage || l) && q(this.min) && q(this.max) && (c = this.max - this.min) && (!q(n) && D && (this.min -= c * D), !q(z) && v && (this.max += c * v));
	        b(this.userMin) || (b(e.softMin) && e.softMin < this.min && (this.min = n = e.softMin), b(e.floor) && (this.min = Math.max(this.min, e.floor)));
	        b(this.userMax) || (b(e.softMax) && e.softMax > this.max && (this.max = z = e.softMax), b(e.ceiling) && (this.max = Math.min(this.max, e.ceiling)));
	        f && q(this.dataMin) && (p = p || 0, !q(n) && this.min < p && this.dataMin >= p ? this.min = this.options.minRange ? Math.min(p, this.max - this.minRange) : p : !q(z) && this.max > p && this.dataMax <= p && (this.max = this.options.minRange ? Math.max(p, this.min + this.minRange) : p));
	        b(this.min) && b(this.max) && !this.chart.polar && this.min > this.max && (q(this.options.min) ? this.max = this.min : q(this.options.max) && (this.min = this.max));
	        this.tickInterval = this.min === this.max || "undefined" === typeof this.min || "undefined" === typeof this.max ? 1 : l && this.linkedParent && !J && g === this.linkedParent.options.tickPixelInterval ? J = this.linkedParent.tickInterval : r(J, this.tickAmount ? (this.max - this.min) / Math.max(this.tickAmount - 1, 1) : void 0, k ? 1 : (this.max - this.min) * g / Math.max(this.len, g));
	        if (h && !d) {
	          var P = this.min !== (this.old && this.old.min) || this.max !== (this.old && this.old.max);
	          this.series.forEach(function (b) {
	            b.forceCrop = b.forceCropping && b.forceCropping();
	            b.processData(P);
	          });
	          m(this, "postProcessData", {
	            hasExtemesChanged: P
	          });
	        }
	        this.setAxisTranslation();
	        m(this, "initialAxisTranslation");
	        this.pointRange && !J && (this.tickInterval = Math.max(this.pointRange, this.tickInterval));
	        d = r(e.minTickInterval, this.dateTime && !this.series.some(function (b) {
	          return b.noSharedTooltip;
	        }) ? this.closestPointRange : 0);
	        !J && this.tickInterval < d && (this.tickInterval = d);
	        this.dateTime || this.logarithmic || J || (this.tickInterval = C(this, this.tickInterval));
	        this.tickAmount || (this.tickInterval = this.unsquish());
	        this.setTickPositions();
	      };
	      a.prototype.setTickPositions = function () {
	        var b = this.options,
	          d = b.tickPositions,
	          c = this.getMinorTickInterval(),
	          a = this.hasVerticalPanning(),
	          e = "colorAxis" === this.coll,
	          h = (e || !a) && b.startOnTick;
	        a = (e || !a) && b.endOnTick;
	        e = b.tickPositioner;
	        this.tickmarkOffset = this.categories && "between" === b.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0;
	        this.minorTickInterval = "auto" === c && this.tickInterval ? this.tickInterval / 5 : c;
	        this.single = this.min === this.max && q(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || !1 !== b.allowDecimals);
	        this.tickPositions = c = d && d.slice();
	        if (!c) {
	          if (this.ordinal && this.ordinal.positions || !((this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200))) {
	            if (this.dateTime) c = this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(this.tickInterval, b.units), this.min, this.max, b.startOfWeek, this.ordinal && this.ordinal.positions, this.closestPointRange, !0);else if (this.logarithmic) c = this.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max);else for (var l = b = this.tickInterval; l <= 2 * b;) if (c = this.getLinearTickPositions(this.tickInterval, this.min, this.max), this.tickAmount && c.length > this.tickAmount) this.tickInterval = C(this, l *= 1.1);else break;
	          } else c = [this.min, this.max], x(19, !1, this.chart);
	          c.length > this.len && (c = [c[0], c.pop()], c[0] === c[1] && (c.length = 1));
	          this.tickPositions = c;
	          e && (e = e.apply(this, [this.min, this.max])) && (this.tickPositions = c = e);
	        }
	        this.paddedTicks = c.slice(0);
	        this.trimTicks(c, h, a);
	        this.isLinked || (this.single && 2 > c.length && !this.categories && !this.series.some(function (b) {
	          return b.is("heatmap") && "between" === b.options.pointPlacement;
	        }) && (this.min -= .5, this.max += .5), d || e || this.adjustTickAmount());
	        m(this, "afterSetTickPositions");
	      };
	      a.prototype.trimTicks = function (b, d, c) {
	        var a = b[0],
	          e = b[b.length - 1],
	          h = !this.isOrdinal && this.minPointOffset || 0;
	        m(this, "trimTicks");
	        if (!this.isLinked) {
	          if (d && -Infinity !== a) this.min = a;else for (; this.min - h > b[0];) b.shift();
	          if (c) this.max = e;else for (; this.max + h < b[b.length - 1];) b.pop();
	          0 === b.length && q(a) && !this.options.tickPositions && b.push((e + a) / 2);
	        }
	      };
	      a.prototype.alignToOthers = function () {
	        var d = this,
	          c = [this],
	          a = d.options,
	          e = "yAxis" === this.coll && this.chart.options.chart.alignThresholds,
	          h = [],
	          l;
	        d.thresholdAlignment = void 0;
	        if ((!1 !== this.chart.options.chart.alignTicks && a.alignTicks || e) && !1 !== a.startOnTick && !1 !== a.endOnTick && !d.logarithmic) {
	          var g = function (b) {
	              var d = b.options;
	              return [b.horiz ? d.left : d.top, d.width, d.height, d.pane].join();
	            },
	            m = g(this);
	          this.chart[this.coll].forEach(function (b) {
	            var a = b.series;
	            a.length && a.some(function (b) {
	              return b.visible;
	            }) && b !== d && g(b) === m && (l = !0, c.push(b));
	          });
	        }
	        if (l && e) {
	          c.forEach(function (c) {
	            c = c.getThresholdAlignment(d);
	            b(c) && h.push(c);
	          });
	          var r = 1 < h.length ? h.reduce(function (b, d) {
	            return b + d;
	          }, 0) / h.length : void 0;
	          c.forEach(function (b) {
	            b.thresholdAlignment = r;
	          });
	        }
	        return l;
	      };
	      a.prototype.getThresholdAlignment = function (d) {
	        (!b(this.dataMin) || this !== d && this.series.some(function (b) {
	          return b.isDirty || b.isDirtyData;
	        })) && this.getSeriesExtremes();
	        if (b(this.threshold)) return d = g((this.threshold - (this.dataMin || 0)) / ((this.dataMax || 0) - (this.dataMin || 0)), 0, 1), this.options.reversed && (d = 1 - d), d;
	      };
	      a.prototype.getTickAmount = function () {
	        var b = this.options,
	          d = b.tickPixelInterval,
	          c = b.tickAmount;
	        !q(b.tickInterval) && !c && this.len < d && !this.isRadial && !this.logarithmic && b.startOnTick && b.endOnTick && (c = 2);
	        !c && this.alignToOthers() && (c = Math.ceil(this.len / d) + 1);
	        4 > c && (this.finalTickAmt = c, c = 5);
	        this.tickAmount = c;
	      };
	      a.prototype.adjustTickAmount = function () {
	        var d = this,
	          c = d.finalTickAmt,
	          a = d.max,
	          e = d.min,
	          h = d.options,
	          l = d.tickPositions,
	          g = d.tickAmount,
	          m = d.thresholdAlignment,
	          k = l && l.length,
	          f = r(d.threshold, d.softThreshold ? 0 : null);
	        var v = d.tickInterval;
	        if (b(m)) {
	          var D = .5 > m ? Math.ceil(m * (g - 1)) : Math.floor(m * (g - 1));
	          h.reversed && (D = g - 1 - D);
	        }
	        if (d.hasData() && b(e) && b(a)) {
	          m = function () {
	            d.transA *= (k - 1) / (g - 1);
	            d.min = h.startOnTick ? l[0] : Math.min(e, l[0]);
	            d.max = h.endOnTick ? l[l.length - 1] : Math.max(a, l[l.length - 1]);
	          };
	          if (b(D) && b(d.threshold)) {
	            for (; l[D] !== f || l.length !== g || l[0] > e || l[l.length - 1] < a;) {
	              l.length = 0;
	              for (l.push(d.threshold); l.length < g;) void 0 === l[D] || l[D] > d.threshold ? l.unshift(t(l[0] - v)) : l.push(t(l[l.length - 1] + v));
	              if (v > 8 * d.tickInterval) break;
	              v *= 2;
	            }
	            m();
	          } else if (k < g) {
	            for (; l.length < g;) l.length % 2 || e === f ? l.push(t(l[l.length - 1] + v)) : l.unshift(t(l[0] - v));
	            m();
	          }
	          if (q(c)) {
	            for (v = f = l.length; v--;) (3 === c && 1 === v % 2 || 2 >= c && 0 < v && v < f - 1) && l.splice(v, 1);
	            d.finalTickAmt = void 0;
	          }
	        }
	      };
	      a.prototype.setScale = function () {
	        var b = !1,
	          d = !1;
	        this.series.forEach(function (c) {
	          b = b || c.isDirtyData || c.isDirty;
	          d = d || c.xAxis && c.xAxis.isDirty || !1;
	        });
	        this.setAxisSize();
	        var c = this.len !== (this.old && this.old.len);
	        c || b || d || this.isLinked || this.forceRedraw || this.userMin !== (this.old && this.old.userMin) || this.userMax !== (this.old && this.old.userMax) || this.alignToOthers() ? (this.stacking && this.stacking.resetStacks(), this.forceRedraw = !1, this.getSeriesExtremes(), this.setTickInterval(), this.isDirty || (this.isDirty = c || this.min !== (this.old && this.old.min) || this.max !== (this.old && this.old.max))) : this.stacking && this.stacking.cleanStacks();
	        b && this.panningState && (this.panningState.isDirty = !0);
	        m(this, "afterSetScale");
	      };
	      a.prototype.setExtremes = function (b, d, c, a, e) {
	        var h = this,
	          l = h.chart;
	        c = r(c, !0);
	        h.series.forEach(function (b) {
	          delete b.kdTree;
	        });
	        e = z(e, {
	          min: b,
	          max: d
	        });
	        m(h, "setExtremes", e, function () {
	          h.userMin = b;
	          h.userMax = d;
	          h.eventArgs = e;
	          c && l.redraw(a);
	        });
	      };
	      a.prototype.zoom = function (b, d) {
	        var c = this,
	          a = this.dataMin,
	          e = this.dataMax,
	          h = this.options,
	          l = Math.min(a, r(h.min, a)),
	          g = Math.max(e, r(h.max, e));
	        b = {
	          newMin: b,
	          newMax: d
	        };
	        m(this, "zoom", b, function (b) {
	          var d = b.newMin,
	            h = b.newMax;
	          if (d !== c.min || h !== c.max) c.allowZoomOutside || (q(a) && (d < l && (d = l), d > g && (d = g)), q(e) && (h < l && (h = l), h > g && (h = g))), c.displayBtn = "undefined" !== typeof d || "undefined" !== typeof h, c.setExtremes(d, h, !1, void 0, {
	            trigger: "zoom"
	          });
	          b.zoomed = !0;
	        });
	        return b.zoomed;
	      };
	      a.prototype.setAxisSize = function () {
	        var b = this.chart,
	          d = this.options,
	          c = d.offsets || [0, 0, 0, 0],
	          a = this.horiz,
	          e = this.width = Math.round(O(r(d.width, b.plotWidth - c[3] + c[1]), b.plotWidth)),
	          h = this.height = Math.round(O(r(d.height, b.plotHeight - c[0] + c[2]), b.plotHeight)),
	          l = this.top = Math.round(O(r(d.top, b.plotTop + c[0]), b.plotHeight, b.plotTop));
	        d = this.left = Math.round(O(r(d.left, b.plotLeft + c[3]), b.plotWidth, b.plotLeft));
	        this.bottom = b.chartHeight - h - l;
	        this.right = b.chartWidth - e - d;
	        this.len = Math.max(a ? e : h, 0);
	        this.pos = a ? d : l;
	      };
	      a.prototype.getExtremes = function () {
	        var b = this.logarithmic;
	        return {
	          min: b ? t(b.lin2log(this.min)) : this.min,
	          max: b ? t(b.lin2log(this.max)) : this.max,
	          dataMin: this.dataMin,
	          dataMax: this.dataMax,
	          userMin: this.userMin,
	          userMax: this.userMax
	        };
	      };
	      a.prototype.getThreshold = function (b) {
	        var d = this.logarithmic,
	          c = d ? d.lin2log(this.min) : this.min;
	        d = d ? d.lin2log(this.max) : this.max;
	        null === b || -Infinity === b ? b = c : Infinity === b ? b = d : c > b ? b = c : d < b && (b = d);
	        return this.translate(b, 0, 1, 0, 1);
	      };
	      a.prototype.autoLabelAlign = function (b) {
	        var d = (r(b, 0) - 90 * this.side + 720) % 360;
	        b = {
	          align: "center"
	        };
	        m(this, "autoLabelAlign", b, function (b) {
	          15 < d && 165 > d ? b.align = "right" : 195 < d && 345 > d && (b.align = "left");
	        });
	        return b.align;
	      };
	      a.prototype.tickSize = function (b) {
	        var d = this.options,
	          c = r(d["tick" === b ? "tickWidth" : "minorTickWidth"], "tick" === b && this.isXAxis && !this.categories ? 1 : 0),
	          a = d["tick" === b ? "tickLength" : "minorTickLength"];
	        if (c && a) {
	          "inside" === d[b + "Position"] && (a = -a);
	          var e = [a, c];
	        }
	        b = {
	          tickSize: e
	        };
	        m(this, "afterTickSize", b);
	        return b.tickSize;
	      };
	      a.prototype.labelMetrics = function () {
	        var b = this.tickPositions && this.tickPositions[0] || 0;
	        return this.chart.renderer.fontMetrics(this.options.labels.style.fontSize, this.ticks[b] && this.ticks[b].label);
	      };
	      a.prototype.unsquish = function () {
	        var d = this.options.labels,
	          c = this.horiz,
	          a = this.tickInterval,
	          h = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / a),
	          l = d.rotation,
	          g = this.labelMetrics(),
	          m = Math.max(this.max - this.min, 0),
	          k = function (b) {
	            var d = b / (h || 1);
	            d = 1 < d ? Math.ceil(d) : 1;
	            d * a > m && Infinity !== b && Infinity !== h && m && (d = Math.ceil(m / a));
	            return t(d * a);
	          },
	          v = a,
	          f,
	          D,
	          p = Number.MAX_VALUE;
	        if (c) {
	          if (!d.staggerLines && !d.step) if (b(l)) var q = [l];else h < d.autoRotationLimit && (q = d.autoRotation);
	          q && q.forEach(function (b) {
	            if (b === l || b && -90 <= b && 90 >= b) {
	              D = k(Math.abs(g.h / Math.sin(e * b)));
	              var d = D + Math.abs(b / 360);
	              d < p && (p = d, f = b, v = D);
	            }
	          });
	        } else d.step || (v = k(g.h));
	        this.autoRotation = q;
	        this.labelRotation = r(f, b(l) ? l : 0);
	        return v;
	      };
	      a.prototype.getSlotWidth = function (d) {
	        var c = this.chart,
	          a = this.horiz,
	          e = this.options.labels,
	          h = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),
	          l = c.margin[3];
	        if (d && b(d.slotWidth)) return d.slotWidth;
	        if (a && 2 > e.step) return e.rotation ? 0 : (this.staggerLines || 1) * this.len / h;
	        if (!a) {
	          d = e.style.width;
	          if (void 0 !== d) return parseInt(String(d), 10);
	          if (l) return l - c.spacing[3];
	        }
	        return .33 * c.chartWidth;
	      };
	      a.prototype.renderUnsquish = function () {
	        var b = this.chart,
	          d = b.renderer,
	          c = this.tickPositions,
	          a = this.ticks,
	          e = this.options.labels,
	          h = e.style,
	          g = this.horiz,
	          m = this.getSlotWidth(),
	          r = Math.max(1, Math.round(m - 2 * e.padding)),
	          k = {},
	          v = this.labelMetrics(),
	          f = h.textOverflow,
	          D = 0;
	        l(e.rotation) || (k.rotation = e.rotation || 0);
	        c.forEach(function (b) {
	          b = a[b];
	          b.movedLabel && b.replaceMovedLabel();
	          b && b.label && b.label.textPxLength > D && (D = b.label.textPxLength);
	        });
	        this.maxLabelLength = D;
	        if (this.autoRotation) D > r && D > v.h ? k.rotation = this.labelRotation : this.labelRotation = 0;else if (m) {
	          var p = r;
	          if (!f) {
	            var q = "clip";
	            for (r = c.length; !g && r--;) {
	              var n = c[r];
	              if (n = a[n].label) n.styles && "ellipsis" === n.styles.textOverflow ? n.css({
	                textOverflow: "clip"
	              }) : n.textPxLength > m && n.css({
	                width: m + "px"
	              }), n.getBBox().height > this.len / c.length - (v.h - v.f) && (n.specificTextOverflow = "ellipsis");
	            }
	          }
	        }
	        k.rotation && (p = D > .5 * b.chartHeight ? .33 * b.chartHeight : D, f || (q = "ellipsis"));
	        if (this.labelAlign = e.align || this.autoLabelAlign(this.labelRotation)) k.align = this.labelAlign;
	        c.forEach(function (b) {
	          var d = (b = a[b]) && b.label,
	            c = h.width,
	            e = {};
	          d && (d.attr(k), b.shortenLabel ? b.shortenLabel() : p && !c && "nowrap" !== h.whiteSpace && (p < d.textPxLength || "SPAN" === d.element.tagName) ? (e.width = p + "px", f || (e.textOverflow = d.specificTextOverflow || q), d.css(e)) : d.styles && d.styles.width && !e.width && !c && d.css({
	            width: null
	          }), delete d.specificTextOverflow, b.rotation = k.rotation);
	        }, this);
	        this.tickRotCorr = d.rotCorr(v.b, this.labelRotation || 0, 0 !== this.side);
	      };
	      a.prototype.hasData = function () {
	        return this.series.some(function (b) {
	          return b.hasData();
	        }) || this.options.showEmpty && q(this.min) && q(this.max);
	      };
	      a.prototype.addTitle = function (b) {
	        var c = this.chart.renderer,
	          a = this.horiz,
	          e = this.opposite,
	          h = this.options.title,
	          l = this.chart.styledMode,
	          g;
	        this.axisTitle || ((g = h.textAlign) || (g = (a ? {
	          low: "left",
	          middle: "center",
	          high: "right"
	        } : {
	          low: e ? "right" : "left",
	          middle: "center",
	          high: e ? "left" : "right"
	        })[h.align]), this.axisTitle = c.text(h.text || "", 0, 0, h.useHTML).attr({
	          zIndex: 7,
	          rotation: h.rotation,
	          align: g
	        }).addClass("highcharts-axis-title"), l || this.axisTitle.css(d(h.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = !0);
	        l || h.style.width || this.isRadial || this.axisTitle.css({
	          width: this.len + "px"
	        });
	        this.axisTitle[b ? "show" : "hide"](b);
	      };
	      a.prototype.generateTick = function (b) {
	        var d = this.ticks;
	        d[b] ? d[b].addLabel() : d[b] = new I(this, b);
	      };
	      a.prototype.getOffset = function () {
	        var b = this,
	          d = this,
	          c = d.chart,
	          a = d.horiz,
	          e = d.options,
	          h = d.side,
	          l = d.ticks,
	          g = d.tickPositions,
	          k = d.coll,
	          f = d.axisParent,
	          D = c.renderer,
	          p = c.inverted && !d.isZAxis ? [1, 0, 3, 2][h] : h,
	          n = d.hasData(),
	          t = e.title,
	          z = e.labels,
	          y = c.axisOffset;
	        c = c.clipOffset;
	        var O = [-1, 1, 1, -1][h],
	          P = e.className,
	          x,
	          F = 0,
	          fa = 0,
	          ca = 0;
	        d.showAxis = x = n || e.showEmpty;
	        d.staggerLines = d.horiz && z.staggerLines || void 0;
	        if (!d.axisGroup) {
	          var N = function (d, c, a) {
	            return D.g(d).attr({
	              zIndex: a
	            }).addClass("highcharts-" + k.toLowerCase() + c + " " + (b.isRadial ? "highcharts-radial-axis" + c + " " : "") + (P || "")).add(f);
	          };
	          d.gridGroup = N("grid", "-grid", e.gridZIndex);
	          d.axisGroup = N("axis", "", e.zIndex);
	          d.labelGroup = N("axis-labels", "-labels", z.zIndex);
	        }
	        n || d.isLinked ? (g.forEach(function (b) {
	          d.generateTick(b);
	        }), d.renderUnsquish(), d.reserveSpaceDefault = 0 === h || 2 === h || {
	          1: "left",
	          3: "right"
	        }[h] === d.labelAlign, r(z.reserveSpace, "center" === d.labelAlign ? !0 : null, d.reserveSpaceDefault) && g.forEach(function (b) {
	          ca = Math.max(l[b].getLabelSize(), ca);
	        }), d.staggerLines && (ca *= d.staggerLines), d.labelOffset = ca * (d.opposite ? -1 : 1)) : v(l, function (b, d) {
	          b.destroy();
	          delete l[d];
	        });
	        if (t && t.text && !1 !== t.enabled && (d.addTitle(x), x && !1 !== t.reserveSpace)) {
	          d.titleOffset = F = d.axisTitle.getBBox()[a ? "height" : "width"];
	          var u = t.offset;
	          fa = q(u) ? 0 : r(t.margin, a ? 5 : 10);
	        }
	        d.renderLine();
	        d.offset = O * r(e.offset, y[h] ? y[h] + (e.margin || 0) : 0);
	        d.tickRotCorr = d.tickRotCorr || {
	          x: 0,
	          y: 0
	        };
	        t = 0 === h ? -d.labelMetrics().h : 2 === h ? d.tickRotCorr.y : 0;
	        n = Math.abs(ca) + fa;
	        ca && (n = n - t + O * (a ? r(z.y, d.tickRotCorr.y + 8 * O) : z.x));
	        d.axisTitleMargin = r(u, n);
	        d.getMaxLabelDimensions && (d.maxLabelDimensions = d.getMaxLabelDimensions(l, g));
	        "colorAxis" !== k && (a = this.tickSize("tick"), y[h] = Math.max(y[h], (d.axisTitleMargin || 0) + F + O * d.offset, n, g && g.length && a ? a[0] + O * d.offset : 0), e = !d.axisLine || e.offset ? 0 : 2 * Math.floor(d.axisLine.strokeWidth() / 2), c[p] = Math.max(c[p], e));
	        m(this, "afterGetOffset");
	      };
	      a.prototype.getLinePath = function (b) {
	        var d = this.chart,
	          c = this.opposite,
	          a = this.offset,
	          e = this.horiz,
	          h = this.left + (c ? this.width : 0) + a;
	        a = d.chartHeight - this.bottom - (c ? this.height : 0) + a;
	        c && (b *= -1);
	        return d.renderer.crispLine([["M", e ? this.left : h, e ? a : this.top], ["L", e ? d.chartWidth - this.right : h, e ? a : d.chartHeight - this.bottom]], b);
	      };
	      a.prototype.renderLine = function () {
	        this.axisLine || (this.axisLine = this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({
	          stroke: this.options.lineColor,
	          "stroke-width": this.options.lineWidth,
	          zIndex: 7
	        }));
	      };
	      a.prototype.getTitlePosition = function () {
	        var b = this.horiz,
	          d = this.left,
	          c = this.top,
	          a = this.len,
	          e = this.options.title,
	          h = b ? d : c,
	          l = this.opposite,
	          g = this.offset,
	          r = e.x,
	          k = e.y,
	          v = this.axisTitle,
	          f = this.chart.renderer.fontMetrics(e.style.fontSize, v);
	        v = v ? Math.max(v.getBBox(!1, 0).height - f.h - 1, 0) : 0;
	        a = {
	          low: h + (b ? 0 : a),
	          middle: h + a / 2,
	          high: h + (b ? a : 0)
	        }[e.align];
	        d = (b ? c + this.height : d) + (b ? 1 : -1) * (l ? -1 : 1) * (this.axisTitleMargin || 0) + [-v, v, f.f, -v][this.side];
	        b = {
	          x: b ? a + r : d + (l ? this.width : 0) + g + r,
	          y: b ? d + k - (l ? this.height : 0) + g : a + k
	        };
	        m(this, "afterGetTitlePosition", {
	          titlePosition: b
	        });
	        return b;
	      };
	      a.prototype.renderMinorTick = function (b, d) {
	        var c = this.minorTicks;
	        c[b] || (c[b] = new I(this, b, "minor"));
	        d && c[b].isNew && c[b].render(null, !0);
	        c[b].render(null, !1, 1);
	      };
	      a.prototype.renderTick = function (b, d, c) {
	        var a = this.ticks;
	        if (!this.isLinked || b >= this.min && b <= this.max || this.grid && this.grid.isColumn) a[b] || (a[b] = new I(this, b)), c && a[b].isNew && a[b].render(d, !0, -1), a[b].render(d);
	      };
	      a.prototype.render = function () {
	        var d = this,
	          c = d.chart,
	          a = d.logarithmic,
	          e = d.options,
	          h = d.isLinked,
	          l = d.tickPositions,
	          g = d.axisTitle,
	          r = d.ticks,
	          k = d.minorTicks,
	          f = d.alternateBands,
	          D = e.stackLabels,
	          p = e.alternateGridColor,
	          q = d.tickmarkOffset,
	          n = d.axisLine,
	          t = d.showAxis,
	          z = u(c.renderer.globalAnimation),
	          y,
	          O;
	        d.labelEdge.length = 0;
	        d.overlap = !1;
	        [r, k, f].forEach(function (b) {
	          v(b, function (b) {
	            b.isActive = !1;
	          });
	        });
	        if (d.hasData() || h) {
	          var P = d.chart.hasRendered && d.old && b(d.old.min);
	          d.minorTickInterval && !d.categories && d.getMinorTickPositions().forEach(function (b) {
	            d.renderMinorTick(b, P);
	          });
	          l.length && (l.forEach(function (b, c) {
	            d.renderTick(b, c, P);
	          }), q && (0 === d.min || d.single) && (r[-1] || (r[-1] = new I(d, -1, null, !0)), r[-1].render(-1)));
	          p && l.forEach(function (b, e) {
	            O = "undefined" !== typeof l[e + 1] ? l[e + 1] + q : d.max - q;
	            0 === e % 2 && b < d.max && O <= d.max + (c.polar ? -q : q) && (f[b] || (f[b] = new E.PlotLineOrBand(d)), y = b + q, f[b].options = {
	              from: a ? a.lin2log(y) : y,
	              to: a ? a.lin2log(O) : O,
	              color: p,
	              className: "highcharts-alternate-grid"
	            }, f[b].render(), f[b].isActive = !0);
	          });
	          d._addedPlotLB || (d._addedPlotLB = !0, (e.plotLines || []).concat(e.plotBands || []).forEach(function (b) {
	            d.addPlotBandOrLine(b);
	          }));
	        }
	        [r, k, f].forEach(function (b) {
	          var d = [],
	            a = z.duration;
	          v(b, function (b, c) {
	            b.isActive || (b.render(c, !1, 0), b.isActive = !1, d.push(c));
	          });
	          N(function () {
	            for (var c = d.length; c--;) b[d[c]] && !b[d[c]].isActive && (b[d[c]].destroy(), delete b[d[c]]);
	          }, b !== f && c.hasRendered && a ? a : 0);
	        });
	        n && (n[n.isPlaced ? "animate" : "attr"]({
	          d: this.getLinePath(n.strokeWidth())
	        }), n.isPlaced = !0, n[t ? "show" : "hide"](t));
	        g && t && (e = d.getTitlePosition(), g[g.isNew ? "attr" : "animate"](e), g.isNew = !1);
	        D && D.enabled && d.stacking && d.stacking.renderStackTotals();
	        d.old = {
	          len: d.len,
	          max: d.max,
	          min: d.min,
	          transA: d.transA,
	          userMax: d.userMax,
	          userMin: d.userMin
	        };
	        d.isDirty = !1;
	        m(this, "afterRender");
	      };
	      a.prototype.redraw = function () {
	        this.visible && (this.render(), this.plotLinesAndBands.forEach(function (b) {
	          b.render();
	        }));
	        this.series.forEach(function (b) {
	          b.isDirty = !0;
	        });
	      };
	      a.prototype.getKeepProps = function () {
	        return this.keepProps || a.keepProps;
	      };
	      a.prototype.destroy = function (b) {
	        var d = this,
	          c = d.plotLinesAndBands,
	          a = this.eventOptions;
	        m(this, "destroy", {
	          keepEvents: b
	        });
	        b || P(d);
	        [d.ticks, d.minorTicks, d.alternateBands].forEach(function (b) {
	          F(b);
	        });
	        if (c) for (b = c.length; b--;) c[b].destroy();
	        "axisLine axisTitle axisGroup gridGroup labelGroup cross scrollbar".split(" ").forEach(function (b) {
	          d[b] && (d[b] = d[b].destroy());
	        });
	        for (var e in d.plotLinesAndBandsGroups) d.plotLinesAndBandsGroups[e] = d.plotLinesAndBandsGroups[e].destroy();
	        v(d, function (b, c) {
	          -1 === d.getKeepProps().indexOf(c) && delete d[c];
	        });
	        this.eventOptions = a;
	      };
	      a.prototype.drawCrosshair = function (b, d) {
	        var c = this.crosshair,
	          a = r(c && c.snap, !0),
	          e = this.chart,
	          h,
	          l = this.cross;
	        m(this, "drawCrosshair", {
	          e: b,
	          point: d
	        });
	        b || (b = this.cross && this.cross.e);
	        if (c && !1 !== (q(d) || !a)) {
	          a ? q(d) && (h = r("colorAxis" !== this.coll ? d.crosshairPos : null, this.isXAxis ? d.plotX : this.len - d.plotY)) : h = b && (this.horiz ? b.chartX - this.pos : this.len - b.chartY + this.pos);
	          if (q(h)) {
	            var g = {
	              value: d && (this.isXAxis ? d.x : r(d.stackY, d.y)),
	              translatedValue: h
	            };
	            e.polar && z(g, {
	              isCrosshair: !0,
	              chartX: b && b.chartX,
	              chartY: b && b.chartY,
	              point: d
	            });
	            g = this.getPlotLinePath(g) || null;
	          }
	          if (!q(g)) {
	            this.hideCrosshair();
	            return;
	          }
	          a = this.categories && !this.isRadial;
	          l || (this.cross = l = e.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-" + (a ? "category " : "thin ") + (c.className || "")).attr({
	            zIndex: r(c.zIndex, 2)
	          }).add(), e.styledMode || (l.attr({
	            stroke: c.color || (a ? B.parse("#ccd6eb").setOpacity(.25).get() : "#cccccc"),
	            "stroke-width": r(c.width, 1)
	          }).css({
	            "pointer-events": "none"
	          }), c.dashStyle && l.attr({
	            dashstyle: c.dashStyle
	          })));
	          l.show().attr({
	            d: g
	          });
	          a && !c.width && l.attr({
	            "stroke-width": this.transA
	          });
	          this.cross.e = b;
	        } else this.hideCrosshair();
	        m(this, "afterDrawCrosshair", {
	          e: b,
	          point: d
	        });
	      };
	      a.prototype.hideCrosshair = function () {
	        this.cross && this.cross.hide();
	        m(this, "afterHideCrosshair");
	      };
	      a.prototype.hasVerticalPanning = function () {
	        var b = this.chart.options.chart.panning;
	        return !!(b && b.enabled && /y/.test(b.type));
	      };
	      a.prototype.validatePositiveValue = function (d) {
	        return b(d) && 0 < d;
	      };
	      a.prototype.update = function (b, c) {
	        var a = this.chart;
	        b = d(this.userOptions, b);
	        this.destroy(!0);
	        this.init(a, b);
	        a.isDirtyBox = !0;
	        r(c, !0) && a.redraw();
	      };
	      a.prototype.remove = function (b) {
	        for (var d = this.chart, c = this.coll, a = this.series, e = a.length; e--;) a[e] && a[e].remove(!1);
	        y(d.axes, this);
	        y(d[c], this);
	        d[c].forEach(function (b, d) {
	          b.options.index = b.userOptions.index = d;
	        });
	        this.destroy();
	        d.isDirtyBox = !0;
	        r(b, !0) && d.redraw();
	      };
	      a.prototype.setTitle = function (b, d) {
	        this.update({
	          title: b
	        }, d);
	      };
	      a.prototype.setCategories = function (b, d) {
	        this.update({
	          categories: b
	        }, d);
	      };
	      a.defaultOptions = f.defaultXAxisOptions;
	      a.keepProps = "extKey hcEvents names series userMax userMin".split(" ");
	      return a;
	    }();
	    return a;
	  });
	  K(f, "Core/Axis/DateTimeAxis.js", [f["Core/Utilities.js"]], function (a) {
	    var f = a.addEvent,
	      B = a.getMagnitude,
	      H = a.normalizeTickInterval,
	      w = a.timeUnits,
	      E;
	    (function (a) {
	      function A() {
	        return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);
	      }
	      function u(a) {
	        "datetime" !== a.userOptions.type ? this.dateTime = void 0 : this.dateTime || (this.dateTime = new k(this));
	      }
	      var n = [];
	      a.compose = function (a) {
	        -1 === n.indexOf(a) && (n.push(a), a.keepProps.push("dateTime"), a.prototype.getTimeTicks = A, f(a, "init", u));
	        return a;
	      };
	      var k = function () {
	        function a(c) {
	          this.axis = c;
	        }
	        a.prototype.normalizeTimeTickInterval = function (c, a) {
	          var e = a || [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2]], ["week", [1, 2]], ["month", [1, 2, 3, 4, 6]], ["year", null]];
	          a = e[e.length - 1];
	          var k = w[a[0]],
	            f = a[1],
	            p;
	          for (p = 0; p < e.length && !(a = e[p], k = w[a[0]], f = a[1], e[p + 1] && c <= (k * f[f.length - 1] + w[e[p + 1][0]]) / 2); p++);
	          k === w.year && c < 5 * k && (f = [1, 2, 5]);
	          c = H(c / k, f, "year" === a[0] ? Math.max(B(c / k), 1) : 1);
	          return {
	            unitRange: k,
	            count: c,
	            unitName: a[0]
	          };
	        };
	        a.prototype.getXDateFormat = function (c, a) {
	          var e = this.axis;
	          return e.closestPointRange ? e.chart.time.getDateFormat(e.closestPointRange, c, e.options.startOfWeek, a) || a.year : a.day;
	        };
	        return a;
	      }();
	      a.Additions = k;
	    })(E || (E = {}));
	    return E;
	  });
	  K(f, "Core/Axis/LogarithmicAxis.js", [f["Core/Utilities.js"]], function (a) {
	    var f = a.addEvent,
	      B = a.normalizeTickInterval,
	      H = a.pick,
	      w;
	    (function (a) {
	      function w(a) {
	        var e = this.logarithmic;
	        "logarithmic" !== a.userOptions.type ? this.logarithmic = void 0 : e || (this.logarithmic = new n(this));
	      }
	      function A() {
	        var a = this.logarithmic;
	        a && (this.lin2val = function (e) {
	          return a.lin2log(e);
	        }, this.val2lin = function (e) {
	          return a.log2lin(e);
	        });
	      }
	      var u = [];
	      a.compose = function (a) {
	        -1 === u.indexOf(a) && (u.push(a), a.keepProps.push("logarithmic"), f(a, "init", w), f(a, "afterInit", A));
	        return a;
	      };
	      var n = function () {
	        function a(a) {
	          this.axis = a;
	        }
	        a.prototype.getLogTickPositions = function (a, c, k, g) {
	          var e = this.axis,
	            f = e.len,
	            p = e.options,
	            n = [];
	          g || (this.minorAutoInterval = void 0);
	          if (.5 <= a) a = Math.round(a), n = e.getLinearTickPositions(a, c, k);else if (.08 <= a) {
	            var x = Math.floor(c),
	              z,
	              m = p = void 0;
	            for (f = .3 < a ? [1, 2, 4] : .15 < a ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; x < k + 1 && !m; x++) {
	              var h = f.length;
	              for (z = 0; z < h && !m; z++) {
	                var b = this.log2lin(this.lin2log(x) * f[z]);
	                b > c && (!g || p <= k) && "undefined" !== typeof p && n.push(p);
	                p > k && (m = !0);
	                p = b;
	              }
	            }
	          } else c = this.lin2log(c), k = this.lin2log(k), a = g ? e.getMinorTickInterval() : p.tickInterval, a = H("auto" === a ? null : a, this.minorAutoInterval, p.tickPixelInterval / (g ? 5 : 1) * (k - c) / ((g ? f / e.tickPositions.length : f) || 1)), a = B(a), n = e.getLinearTickPositions(a, c, k).map(this.log2lin), g || (this.minorAutoInterval = a / 5);
	          g || (e.tickInterval = a);
	          return n;
	        };
	        a.prototype.lin2log = function (a) {
	          return Math.pow(10, a);
	        };
	        a.prototype.log2lin = function (a) {
	          return Math.log(a) / Math.LN10;
	        };
	        return a;
	      }();
	      a.Additions = n;
	    })(w || (w = {}));
	    return w;
	  });
	  K(f, "Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js", [f["Core/Utilities.js"]], function (a) {
	    var f = a.erase,
	      B = a.extend,
	      H = a.isNumber,
	      w;
	    (function (a) {
	      var w = [],
	        A;
	      a.compose = function (a, k) {
	        A || (A = a);
	        -1 === w.indexOf(k) && (w.push(k), B(k.prototype, u.prototype));
	        return k;
	      };
	      var u = function () {
	        function a() {}
	        a.prototype.getPlotBandPath = function (a, e, c) {
	          void 0 === c && (c = this.options);
	          var k = this.getPlotLinePath({
	              value: e,
	              force: !0,
	              acrossPanes: c.acrossPanes
	            }),
	            g = [],
	            f = this.horiz;
	          e = !H(this.min) || !H(this.max) || a < this.min && e < this.min || a > this.max && e > this.max;
	          a = this.getPlotLinePath({
	            value: a,
	            force: !0,
	            acrossPanes: c.acrossPanes
	          });
	          c = 1;
	          if (a && k) {
	            if (e) {
	              var q = a.toString() === k.toString();
	              c = 0;
	            }
	            for (e = 0; e < a.length; e += 2) {
	              var n = a[e],
	                y = a[e + 1],
	                x = k[e],
	                z = k[e + 1];
	              "M" !== n[0] && "L" !== n[0] || "M" !== y[0] && "L" !== y[0] || "M" !== x[0] && "L" !== x[0] || "M" !== z[0] && "L" !== z[0] || (f && x[1] === n[1] ? (x[1] += c, z[1] += c) : f || x[2] !== n[2] || (x[2] += c, z[2] += c), g.push(["M", n[1], n[2]], ["L", y[1], y[2]], ["L", z[1], z[2]], ["L", x[1], x[2]], ["Z"]));
	              g.isFlat = q;
	            }
	          }
	          return g;
	        };
	        a.prototype.addPlotBand = function (a) {
	          return this.addPlotBandOrLine(a, "plotBands");
	        };
	        a.prototype.addPlotLine = function (a) {
	          return this.addPlotBandOrLine(a, "plotLines");
	        };
	        a.prototype.addPlotBandOrLine = function (a, e) {
	          var c = this,
	            k = this.userOptions,
	            g = new A(this, a);
	          this.visible && (g = g.render());
	          if (g) {
	            this._addedPlotLB || (this._addedPlotLB = !0, (k.plotLines || []).concat(k.plotBands || []).forEach(function (a) {
	              c.addPlotBandOrLine(a);
	            }));
	            if (e) {
	              var f = k[e] || [];
	              f.push(a);
	              k[e] = f;
	            }
	            this.plotLinesAndBands.push(g);
	          }
	          return g;
	        };
	        a.prototype.removePlotBandOrLine = function (a) {
	          var e = this.plotLinesAndBands,
	            c = this.options,
	            k = this.userOptions;
	          if (e) {
	            for (var g = e.length; g--;) e[g].id === a && e[g].destroy();
	            [c.plotLines || [], k.plotLines || [], c.plotBands || [], k.plotBands || []].forEach(function (c) {
	              for (g = c.length; g--;) (c[g] || {}).id === a && f(c, c[g]);
	            });
	          }
	        };
	        a.prototype.removePlotBand = function (a) {
	          this.removePlotBandOrLine(a);
	        };
	        a.prototype.removePlotLine = function (a) {
	          this.removePlotBandOrLine(a);
	        };
	        return a;
	      }();
	    })(w || (w = {}));
	    return w;
	  });
	  K(f, "Core/Axis/PlotLineOrBand/PlotLineOrBand.js", [f["Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js"], f["Core/Utilities.js"]], function (a, f) {
	    var C = f.arrayMax,
	      H = f.arrayMin,
	      w = f.defined,
	      E = f.destroyObjectProperties,
	      I = f.erase,
	      A = f.fireEvent,
	      u = f.merge,
	      n = f.objectEach,
	      k = f.pick;
	    f = function () {
	      function e(c, a) {
	        this.axis = c;
	        a && (this.options = a, this.id = a.id);
	      }
	      e.compose = function (c) {
	        return a.compose(e, c);
	      };
	      e.prototype.render = function () {
	        A(this, "render");
	        var c = this,
	          a = c.axis,
	          e = a.horiz,
	          f = a.logarithmic,
	          q = c.options,
	          F = q.color,
	          y = k(q.zIndex, 0),
	          x = q.events,
	          z = {},
	          m = a.chart.renderer,
	          h = q.label,
	          b = c.label,
	          l = q.to,
	          d = q.from,
	          D = q.value,
	          v = c.svgElem,
	          r = [],
	          O = w(d) && w(l);
	        r = w(D);
	        var P = !v,
	          S = {
	            "class": "highcharts-plot-" + (O ? "band " : "line ") + (q.className || "")
	          },
	          N = O ? "bands" : "lines";
	        f && (d = f.log2lin(d), l = f.log2lin(l), D = f.log2lin(D));
	        a.chart.styledMode || (r ? (S.stroke = F || "#999999", S["stroke-width"] = k(q.width, 1), q.dashStyle && (S.dashstyle = q.dashStyle)) : O && (S.fill = F || "#e6ebf5", q.borderWidth && (S.stroke = q.borderColor, S["stroke-width"] = q.borderWidth)));
	        z.zIndex = y;
	        N += "-" + y;
	        (f = a.plotLinesAndBandsGroups[N]) || (a.plotLinesAndBandsGroups[N] = f = m.g("plot-" + N).attr(z).add());
	        P && (c.svgElem = v = m.path().attr(S).add(f));
	        if (r) r = a.getPlotLinePath({
	          value: D,
	          lineWidth: v.strokeWidth(),
	          acrossPanes: q.acrossPanes
	        });else if (O) r = a.getPlotBandPath(d, l, q);else return;
	        !c.eventsAdded && x && (n(x, function (b, d) {
	          v.on(d, function (b) {
	            x[d].apply(c, [b]);
	          });
	        }), c.eventsAdded = !0);
	        (P || !v.d) && r && r.length ? v.attr({
	          d: r
	        }) : v && (r ? (v.show(), v.animate({
	          d: r
	        })) : v.d && (v.hide(), b && (c.label = b = b.destroy())));
	        h && (w(h.text) || w(h.formatter)) && r && r.length && 0 < a.width && 0 < a.height && !r.isFlat ? (h = u({
	          align: e && O && "center",
	          x: e ? !O && 4 : 10,
	          verticalAlign: !e && O && "middle",
	          y: e ? O ? 16 : 10 : O ? 6 : -4,
	          rotation: e && !O && 90
	        }, h), this.renderLabel(h, r, O, y)) : b && b.hide();
	        return c;
	      };
	      e.prototype.renderLabel = function (c, a, e, f) {
	        var g = this.axis,
	          k = g.chart.renderer,
	          p = this.label;
	        p || (this.label = p = k.text(this.getLabelText(c), 0, 0, c.useHTML).attr({
	          align: c.textAlign || c.align,
	          rotation: c.rotation,
	          "class": "highcharts-plot-" + (e ? "band" : "line") + "-label " + (c.className || ""),
	          zIndex: f
	        }).add(), g.chart.styledMode || p.css(u({
	          textOverflow: "ellipsis"
	        }, c.style)));
	        f = a.xBounds || [a[0][1], a[1][1], e ? a[2][1] : a[0][1]];
	        a = a.yBounds || [a[0][2], a[1][2], e ? a[2][2] : a[0][2]];
	        e = H(f);
	        k = H(a);
	        p.align(c, !1, {
	          x: e,
	          y: k,
	          width: C(f) - e,
	          height: C(a) - k
	        });
	        p.alignValue && "left" !== p.alignValue || p.css({
	          width: (90 === p.rotation ? g.height - (p.alignAttr.y - g.top) : g.width - (p.alignAttr.x - g.left)) + "px"
	        });
	        p.show(!0);
	      };
	      e.prototype.getLabelText = function (a) {
	        return w(a.formatter) ? a.formatter.call(this) : a.text;
	      };
	      e.prototype.destroy = function () {
	        I(this.axis.plotLinesAndBands, this);
	        delete this.axis;
	        E(this);
	      };
	      return e;
	    }();
	    return f;
	  });
	  K(f, "Core/Tooltip.js", [f["Core/FormatUtilities.js"], f["Core/Globals.js"], f["Core/Renderer/RendererUtilities.js"], f["Core/Renderer/RendererRegistry.js"], f["Core/Utilities.js"]], function (a, f, B, H, w) {
	    var C = a.format,
	      I = f.doc,
	      A = B.distribute,
	      u = w.addEvent,
	      n = w.clamp,
	      k = w.css,
	      e = w.defined,
	      c = w.discardElement,
	      p = w.extend,
	      g = w.fireEvent,
	      t = w.isArray,
	      q = w.isNumber,
	      F = w.isString,
	      y = w.merge,
	      x = w.pick,
	      z = w.splat,
	      m = w.syncTimeout;
	    a = function () {
	      function a(b, a) {
	        this.allowShared = !0;
	        this.container = void 0;
	        this.crosshairs = [];
	        this.distance = 0;
	        this.isHidden = !0;
	        this.isSticky = !1;
	        this.now = {};
	        this.options = {};
	        this.outside = !1;
	        this.chart = b;
	        this.init(b, a);
	      }
	      a.prototype.applyFilter = function () {
	        var b = this.chart;
	        b.renderer.definition({
	          tagName: "filter",
	          attributes: {
	            id: "drop-shadow-" + b.index,
	            opacity: .5
	          },
	          children: [{
	            tagName: "feGaussianBlur",
	            attributes: {
	              "in": "SourceAlpha",
	              stdDeviation: 1
	            }
	          }, {
	            tagName: "feOffset",
	            attributes: {
	              dx: 1,
	              dy: 1
	            }
	          }, {
	            tagName: "feComponentTransfer",
	            children: [{
	              tagName: "feFuncA",
	              attributes: {
	                type: "linear",
	                slope: .3
	              }
	            }]
	          }, {
	            tagName: "feMerge",
	            children: [{
	              tagName: "feMergeNode"
	            }, {
	              tagName: "feMergeNode",
	              attributes: {
	                "in": "SourceGraphic"
	              }
	            }]
	          }]
	        });
	      };
	      a.prototype.bodyFormatter = function (b) {
	        return b.map(function (b) {
	          var d = b.series.tooltipOptions;
	          return (d[(b.point.formatPrefix || "point") + "Formatter"] || b.point.tooltipFormatter).call(b.point, d[(b.point.formatPrefix || "point") + "Format"] || "");
	        });
	      };
	      a.prototype.cleanSplit = function (b) {
	        this.chart.series.forEach(function (a) {
	          var d = a && a.tt;
	          d && (!d.isActive || b ? a.tt = d.destroy() : d.isActive = !1);
	        });
	      };
	      a.prototype.defaultFormatter = function (b) {
	        var a = this.points || z(this);
	        var d = [b.tooltipFooterHeaderFormatter(a[0])];
	        d = d.concat(b.bodyFormatter(a));
	        d.push(b.tooltipFooterHeaderFormatter(a[0], !0));
	        return d;
	      };
	      a.prototype.destroy = function () {
	        this.label && (this.label = this.label.destroy());
	        this.split && this.tt && (this.cleanSplit(!0), this.tt = this.tt.destroy());
	        this.renderer && (this.renderer = this.renderer.destroy(), c(this.container));
	        w.clearTimeout(this.hideTimer);
	        w.clearTimeout(this.tooltipTimeout);
	      };
	      a.prototype.getAnchor = function (b, a) {
	        var d = this.chart,
	          c = d.pointer,
	          e = d.inverted,
	          h = d.plotTop,
	          l = d.plotLeft,
	          g,
	          m,
	          f = 0,
	          k = 0;
	        b = z(b);
	        this.followPointer && a ? ("undefined" === typeof a.chartX && (a = c.normalize(a)), c = [a.chartX - l, a.chartY - h]) : b[0].tooltipPos ? c = b[0].tooltipPos : (b.forEach(function (b) {
	          g = b.series.yAxis;
	          m = b.series.xAxis;
	          f += b.plotX || 0;
	          k += b.plotLow ? (b.plotLow + (b.plotHigh || 0)) / 2 : b.plotY || 0;
	          m && g && (e ? (f += h + d.plotHeight - m.len - m.pos, k += l + d.plotWidth - g.len - g.pos) : (f += m.pos - l, k += g.pos - h));
	        }), f /= b.length, k /= b.length, c = [e ? d.plotWidth - k : f, e ? d.plotHeight - f : k], this.shared && 1 < b.length && a && (e ? c[0] = a.chartX - l : c[1] = a.chartY - h));
	        return c.map(Math.round);
	      };
	      a.prototype.getLabel = function () {
	        var b = this,
	          a = this.chart.styledMode,
	          d = this.options,
	          c = this.split && this.allowShared,
	          h = "tooltip" + (e(d.className) ? " " + d.className : ""),
	          g = d.style.pointerEvents || (!this.followPointer && d.stickOnContact ? "auto" : "none"),
	          m = function () {
	            b.inContact = !0;
	          },
	          p = function (d) {
	            var a = b.chart.hoverSeries;
	            b.inContact = b.shouldStickOnContact() && b.chart.pointer.inClass(d.relatedTarget, "highcharts-tooltip");
	            if (!b.inContact && a && a.onMouseOut) a.onMouseOut();
	          },
	          n,
	          q = this.chart.renderer;
	        if (b.label) {
	          var z = !b.label.hasClass("highcharts-label");
	          (c && !z || !c && z) && b.destroy();
	        }
	        if (!this.label) {
	          if (this.outside) {
	            z = this.chart.options.chart.style;
	            var t = H.getRendererType();
	            this.container = n = f.doc.createElement("div");
	            n.className = "highcharts-tooltip-container";
	            k(n, {
	              position: "absolute",
	              top: "1px",
	              pointerEvents: g,
	              zIndex: Math.max(this.options.style.zIndex || 0, (z && z.zIndex || 0) + 3)
	            });
	            u(n, "mouseenter", m);
	            u(n, "mouseleave", p);
	            f.doc.body.appendChild(n);
	            this.renderer = q = new t(n, 0, 0, z, void 0, void 0, q.styledMode);
	          }
	          c ? this.label = q.g(h) : (this.label = q.label("", 0, 0, d.shape, void 0, void 0, d.useHTML, void 0, h).attr({
	            padding: d.padding,
	            r: d.borderRadius
	          }), a || this.label.attr({
	            fill: d.backgroundColor,
	            "stroke-width": d.borderWidth
	          }).css(d.style).css({
	            pointerEvents: g
	          }).shadow(d.shadow));
	          a && d.shadow && (this.applyFilter(), this.label.attr({
	            filter: "url(#drop-shadow-" + this.chart.index + ")"
	          }));
	          if (b.outside && !b.split) {
	            var y = this.label,
	              x = y.xSetter,
	              F = y.ySetter;
	            y.xSetter = function (d) {
	              x.call(y, b.distance);
	              n.style.left = d + "px";
	            };
	            y.ySetter = function (d) {
	              F.call(y, b.distance);
	              n.style.top = d + "px";
	            };
	          }
	          this.label.on("mouseenter", m).on("mouseleave", p).attr({
	            zIndex: 8
	          }).add();
	        }
	        return this.label;
	      };
	      a.prototype.getPosition = function (b, a, d) {
	        var c = this.chart,
	          e = this.distance,
	          h = {},
	          l = c.inverted && d.h || 0,
	          g = this.outside,
	          m = g ? I.documentElement.clientWidth - 2 * e : c.chartWidth,
	          f = g ? Math.max(I.body.scrollHeight, I.documentElement.scrollHeight, I.body.offsetHeight, I.documentElement.offsetHeight, I.documentElement.clientHeight) : c.chartHeight,
	          k = c.pointer.getChartPosition(),
	          p = function (h) {
	            var l = "x" === h;
	            return [h, l ? m : f, l ? b : a].concat(g ? [l ? b * k.scaleX : a * k.scaleY, l ? k.left - e + (d.plotX + c.plotLeft) * k.scaleX : k.top - e + (d.plotY + c.plotTop) * k.scaleY, 0, l ? m : f] : [l ? b : a, l ? d.plotX + c.plotLeft : d.plotY + c.plotTop, l ? c.plotLeft : c.plotTop, l ? c.plotLeft + c.plotWidth : c.plotTop + c.plotHeight]);
	          },
	          n = p("y"),
	          q = p("x"),
	          z;
	        p = !!d.negative;
	        !c.polar && c.hoverSeries && c.hoverSeries.yAxis && c.hoverSeries.yAxis.reversed && (p = !p);
	        var t = !this.followPointer && x(d.ttBelow, !c.inverted === p),
	          y = function (b, d, a, c, m, f, r) {
	            var v = g ? "y" === b ? e * k.scaleY : e * k.scaleX : e,
	              D = (a - c) / 2,
	              G = c < m - e,
	              p = m + e + c < d,
	              n = m - v - a + D;
	            m = m + v - D;
	            if (t && p) h[b] = m;else if (!t && G) h[b] = n;else if (G) h[b] = Math.min(r - c, 0 > n - l ? n : n - l);else if (p) h[b] = Math.max(f, m + l + a > d ? m : m + l);else return !1;
	          },
	          F = function (b, d, a, c, l) {
	            var g;
	            l < e || l > d - e ? g = !1 : h[b] = l < a / 2 ? 1 : l > d - c / 2 ? d - c - 2 : l - a / 2;
	            return g;
	          },
	          G = function (b) {
	            var d = n;
	            n = q;
	            q = d;
	            z = b;
	          },
	          T = function () {
	            !1 !== y.apply(0, n) ? !1 !== F.apply(0, q) || z || (G(!0), T()) : z ? h.x = h.y = 0 : (G(!0), T());
	          };
	        (c.inverted || 1 < this.len) && G();
	        T();
	        return h;
	      };
	      a.prototype.hide = function (b) {
	        var a = this;
	        w.clearTimeout(this.hideTimer);
	        b = x(b, this.options.hideDelay);
	        this.isHidden || (this.hideTimer = m(function () {
	          a.getLabel().fadeOut(b ? void 0 : b);
	          a.isHidden = !0;
	        }, b));
	      };
	      a.prototype.init = function (b, a) {
	        this.chart = b;
	        this.options = a;
	        this.crosshairs = [];
	        this.now = {
	          x: 0,
	          y: 0
	        };
	        this.isHidden = !0;
	        this.split = a.split && !b.inverted && !b.polar;
	        this.shared = a.shared || this.split;
	        this.outside = x(a.outside, !(!b.scrollablePixelsX && !b.scrollablePixelsY));
	      };
	      a.prototype.shouldStickOnContact = function () {
	        return !(this.followPointer || !this.options.stickOnContact);
	      };
	      a.prototype.isStickyOnContact = function () {
	        return !(!this.shouldStickOnContact() || !this.inContact);
	      };
	      a.prototype.move = function (b, a, d, c) {
	        var e = this,
	          h = e.now,
	          l = !1 !== e.options.animation && !e.isHidden && (1 < Math.abs(b - h.x) || 1 < Math.abs(a - h.y)),
	          g = e.followPointer || 1 < e.len;
	        p(h, {
	          x: l ? (2 * h.x + b) / 3 : b,
	          y: l ? (h.y + a) / 2 : a,
	          anchorX: g ? void 0 : l ? (2 * h.anchorX + d) / 3 : d,
	          anchorY: g ? void 0 : l ? (h.anchorY + c) / 2 : c
	        });
	        e.getLabel().attr(h);
	        e.drawTracker();
	        l && (w.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function () {
	          e && e.move(b, a, d, c);
	        }, 32));
	      };
	      a.prototype.refresh = function (b, a) {
	        var d = this.chart,
	          c = this.options,
	          e = z(b),
	          h = e[0],
	          l = [],
	          m = c.formatter || this.defaultFormatter,
	          f = this.shared,
	          k = d.styledMode,
	          p = {};
	        if (c.enabled && h.series) {
	          w.clearTimeout(this.hideTimer);
	          this.allowShared = !(!t(b) && b.series && b.series.noSharedTooltip);
	          this.followPointer = !this.split && h.series.tooltipOptions.followPointer;
	          b = this.getAnchor(b, a);
	          var n = b[0],
	            q = b[1];
	          f && this.allowShared ? (d.pointer.applyInactiveState(e), e.forEach(function (b) {
	            b.setState("hover");
	            l.push(b.getLabelConfig());
	          }), p = {
	            x: h.category,
	            y: h.y
	          }, p.points = l) : p = h.getLabelConfig();
	          this.len = l.length;
	          m = m.call(p, this);
	          f = h.series;
	          this.distance = x(f.tooltipOptions.distance, 16);
	          if (!1 === m) this.hide();else {
	            if (this.split && this.allowShared) this.renderSplit(m, e);else {
	              var y = n,
	                F = q;
	              a && d.pointer.isDirectTouch && (y = a.chartX - d.plotLeft, F = a.chartY - d.plotTop);
	              if (d.polar || !1 === f.options.clip || e.some(function (b) {
	                return b.series.shouldShowTooltip(y, F);
	              })) a = this.getLabel(), c.style.width && !k || a.css({
	                width: this.chart.spacingBox.width + "px"
	              }), a.attr({
	                text: m && m.join ? m.join("") : m
	              }), a.removeClass(/highcharts-color-[\d]+/g).addClass("highcharts-color-" + x(h.colorIndex, f.colorIndex)), k || a.attr({
	                stroke: c.borderColor || h.color || f.color || "#666666"
	              }), this.updatePosition({
	                plotX: n,
	                plotY: q,
	                negative: h.negative,
	                ttBelow: h.ttBelow,
	                h: b[2] || 0
	              });else {
	                this.hide();
	                return;
	              }
	            }
	            this.isHidden && this.label && this.label.attr({
	              opacity: 1
	            }).show();
	            this.isHidden = !1;
	          }
	          g(this, "refresh");
	        }
	      };
	      a.prototype.renderSplit = function (b, a) {
	        function d(b, d, a, e, h) {
	          void 0 === h && (h = !0);
	          a ? (d = Z ? 0 : E, b = n(b - e / 2, M.left, M.right - e - (c.outside ? R : 0))) : (d -= B, b = h ? b - e - C : b + C, b = n(b, h ? b : M.left, M.right));
	          return {
	            x: b,
	            y: d
	          };
	        }
	        var c = this,
	          e = c.chart,
	          h = c.chart,
	          l = h.chartWidth,
	          g = h.chartHeight,
	          m = h.plotHeight,
	          f = h.plotLeft,
	          k = h.plotTop,
	          q = h.pointer,
	          z = h.scrollablePixelsY;
	        z = void 0 === z ? 0 : z;
	        var t = h.scrollablePixelsX,
	          y = h.scrollingContainer;
	        y = void 0 === y ? {
	          scrollLeft: 0,
	          scrollTop: 0
	        } : y;
	        var u = y.scrollLeft;
	        y = y.scrollTop;
	        var w = h.styledMode,
	          C = c.distance,
	          G = c.options,
	          T = c.options.positioner,
	          M = c.outside && "number" !== typeof t ? I.documentElement.getBoundingClientRect() : {
	            left: u,
	            right: u + l,
	            top: y,
	            bottom: y + g
	          },
	          V = c.getLabel(),
	          W = this.renderer || e.renderer,
	          Z = !(!e.xAxis[0] || !e.xAxis[0].opposite);
	        e = q.getChartPosition();
	        var R = e.left;
	        e = e.top;
	        var B = k + y,
	          aa = 0,
	          E = m - z;
	        F(b) && (b = [!1, b]);
	        b = b.slice(0, a.length + 1).reduce(function (b, e, h) {
	          if (!1 !== e && "" !== e) {
	            h = a[h - 1] || {
	              isHeader: !0,
	              plotX: a[0].plotX,
	              plotY: m,
	              series: {}
	            };
	            var l = h.isHeader,
	              g = l ? c : h.series;
	            e = e.toString();
	            var r = g.tt,
	              v = h.isHeader;
	            var D = h.series;
	            var p = "highcharts-color-" + x(h.colorIndex, D.colorIndex, "none");
	            r || (r = {
	              padding: G.padding,
	              r: G.borderRadius
	            }, w || (r.fill = G.backgroundColor, r["stroke-width"] = G.borderWidth), r = W.label("", 0, 0, G[v ? "headerShape" : "shape"], void 0, void 0, G.useHTML).addClass((v ? "highcharts-tooltip-header " : "") + "highcharts-tooltip-box " + p).attr(r).add(V));
	            r.isActive = !0;
	            r.attr({
	              text: e
	            });
	            w || r.css(G.style).shadow(G.shadow).attr({
	              stroke: G.borderColor || h.color || D.color || "#333333"
	            });
	            g = g.tt = r;
	            v = g.getBBox();
	            e = v.width + g.strokeWidth();
	            l && (aa = v.height, E += aa, Z && (B -= aa));
	            D = h.plotX;
	            D = void 0 === D ? 0 : D;
	            p = h.plotY;
	            p = void 0 === p ? 0 : p;
	            r = h.series;
	            if (h.isHeader) {
	              D = f + D;
	              var q = k + m / 2;
	            } else {
	              var z = r.xAxis,
	                fa = r.yAxis;
	              D = z.pos + n(D, -C, z.len + C);
	              r.shouldShowTooltip(0, fa.pos - k + p, {
	                ignoreX: !0
	              }) && (q = fa.pos + p);
	            }
	            D = n(D, M.left - C, M.right + C);
	            "number" === typeof q ? (v = v.height + 1, p = T ? T.call(c, e, v, h) : d(D, q, l, e), b.push({
	              align: T ? 0 : void 0,
	              anchorX: D,
	              anchorY: q,
	              boxWidth: e,
	              point: h,
	              rank: x(p.rank, l ? 1 : 0),
	              size: v,
	              target: p.y,
	              tt: g,
	              x: p.x
	            })) : g.isActive = !1;
	          }
	          return b;
	        }, []);
	        !T && b.some(function (b) {
	          var d = (c.outside ? R : 0) + b.anchorX;
	          return d < M.left && d + b.boxWidth < M.right ? !0 : d < R - M.left + b.boxWidth && M.right - d > d;
	        }) && (b = b.map(function (b) {
	          var a = d(b.anchorX, b.anchorY, b.point.isHeader, b.boxWidth, !1);
	          return p(b, {
	            target: a.y,
	            x: a.x
	          });
	        }));
	        c.cleanSplit();
	        A(b, E);
	        var H = R,
	          ba = R;
	        b.forEach(function (b) {
	          var d = b.x,
	            a = b.boxWidth;
	          b = b.isHeader;
	          b || (c.outside && R + d < H && (H = R + d), !b && c.outside && H + a > ba && (ba = R + d));
	        });
	        b.forEach(function (b) {
	          var d = b.x,
	            a = b.anchorX,
	            e = b.pos,
	            h = b.point.isHeader;
	          e = {
	            visibility: "undefined" === typeof e ? "hidden" : "inherit",
	            x: d,
	            y: e + B,
	            anchorX: a,
	            anchorY: b.anchorY
	          };
	          if (c.outside && d < a) {
	            var l = R - H;
	            0 < l && (h || (e.x = d + l, e.anchorX = a + l), h && (e.x = (ba - H) / 2, e.anchorX = a + l));
	          }
	          b.tt.attr(e);
	        });
	        b = c.container;
	        z = c.renderer;
	        c.outside && b && z && (h = V.getBBox(), z.setSize(h.width + h.x, h.height + h.y, !1), b.style.left = H + "px", b.style.top = e + "px");
	      };
	      a.prototype.drawTracker = function () {
	        if (this.followPointer || !this.options.stickOnContact) this.tracker && this.tracker.destroy();else {
	          var b = this.chart,
	            a = this.label,
	            d = this.shared ? b.hoverPoints : b.hoverPoint;
	          if (a && d) {
	            var c = {
	              x: 0,
	              y: 0,
	              width: 0,
	              height: 0
	            };
	            d = this.getAnchor(d);
	            var e = a.getBBox();
	            d[0] += b.plotLeft - a.translateX;
	            d[1] += b.plotTop - a.translateY;
	            c.x = Math.min(0, d[0]);
	            c.y = Math.min(0, d[1]);
	            c.width = 0 > d[0] ? Math.max(Math.abs(d[0]), e.width - d[0]) : Math.max(Math.abs(d[0]), e.width);
	            c.height = 0 > d[1] ? Math.max(Math.abs(d[1]), e.height - Math.abs(d[1])) : Math.max(Math.abs(d[1]), e.height);
	            this.tracker ? this.tracker.attr(c) : (this.tracker = a.renderer.rect(c).addClass("highcharts-tracker").add(a), b.styledMode || this.tracker.attr({
	              fill: "rgba(0,0,0,0)"
	            }));
	          }
	        }
	      };
	      a.prototype.styledModeFormat = function (b) {
	        return b.replace('style="font-size: 10px"', 'class="highcharts-header"').replace(/style="color:{(point|series)\.color}"/g, 'class="highcharts-color-{$1.colorIndex}"');
	      };
	      a.prototype.tooltipFooterHeaderFormatter = function (b, a) {
	        var d = b.series,
	          c = d.tooltipOptions,
	          e = d.xAxis,
	          h = e && e.dateTime;
	        e = {
	          isFooter: a,
	          labelConfig: b
	        };
	        var l = c.xDateFormat,
	          m = c[a ? "footerFormat" : "headerFormat"];
	        g(this, "headerFormatter", e, function (a) {
	          h && !l && q(b.key) && (l = h.getXDateFormat(b.key, c.dateTimeLabelFormats));
	          h && l && (b.point && b.point.tooltipDateKeys || ["key"]).forEach(function (b) {
	            m = m.replace("{point." + b + "}", "{point." + b + ":" + l + "}");
	          });
	          d.chart.styledMode && (m = this.styledModeFormat(m));
	          a.text = C(m, {
	            point: b,
	            series: d
	          }, this.chart);
	        });
	        return e.text;
	      };
	      a.prototype.update = function (b) {
	        this.destroy();
	        y(!0, this.chart.options.tooltip.userOptions, b);
	        this.init(this.chart, y(!0, this.options, b));
	      };
	      a.prototype.updatePosition = function (b) {
	        var a = this.chart,
	          d = this.options,
	          c = a.pointer,
	          e = this.getLabel();
	        c = c.getChartPosition();
	        var h = (d.positioner || this.getPosition).call(this, e.width, e.height, b),
	          g = b.plotX + a.plotLeft;
	        b = b.plotY + a.plotTop;
	        if (this.outside) {
	          d = d.borderWidth + 2 * this.distance;
	          this.renderer.setSize(e.width + d, e.height + d, !1);
	          if (1 !== c.scaleX || 1 !== c.scaleY) k(this.container, {
	            transform: "scale(" + c.scaleX + ", " + c.scaleY + ")"
	          }), g *= c.scaleX, b *= c.scaleY;
	          g += c.left - h.x;
	          b += c.top - h.y;
	        }
	        this.move(Math.round(h.x), Math.round(h.y || 0), g, b);
	      };
	      return a;
	    }();
	    return a;
	  });
	  K(f, "Core/Series/Point.js", [f["Core/Renderer/HTML/AST.js"], f["Core/Animation/AnimationUtilities.js"], f["Core/DefaultOptions.js"], f["Core/FormatUtilities.js"], f["Core/Utilities.js"]], function (a, f, B, H, w) {
	    var C = f.animObject,
	      I = B.defaultOptions,
	      A = H.format,
	      u = w.addEvent,
	      n = w.defined,
	      k = w.erase,
	      e = w.extend,
	      c = w.fireEvent,
	      p = w.getNestedProperty,
	      g = w.isArray,
	      t = w.isFunction,
	      q = w.isNumber,
	      F = w.isObject,
	      y = w.merge,
	      x = w.objectEach,
	      z = w.pick,
	      m = w.syncTimeout,
	      h = w.removeEvent,
	      b = w.uniqueKey;
	    f = function () {
	      function l() {
	        this.colorIndex = this.category = void 0;
	        this.formatPrefix = "point";
	        this.id = void 0;
	        this.isNull = !1;
	        this.percentage = this.options = this.name = void 0;
	        this.selected = !1;
	        this.total = this.series = void 0;
	        this.visible = !0;
	        this.x = void 0;
	      }
	      l.prototype.animateBeforeDestroy = function () {
	        var b = this,
	          a = {
	            x: b.startXPos,
	            opacity: 0
	          },
	          c = b.getGraphicalProps();
	        c.singular.forEach(function (d) {
	          b[d] = b[d].animate("dataLabel" === d ? {
	            x: b[d].startXPos,
	            y: b[d].startYPos,
	            opacity: 0
	          } : a);
	        });
	        c.plural.forEach(function (d) {
	          b[d].forEach(function (d) {
	            d.element && d.animate(e({
	              x: b.startXPos
	            }, d.startYPos ? {
	              x: d.startXPos,
	              y: d.startYPos
	            } : {}));
	          });
	        });
	      };
	      l.prototype.applyOptions = function (b, a) {
	        var d = this.series,
	          c = d.options.pointValKey || d.pointValKey;
	        b = l.prototype.optionsToObject.call(this, b);
	        e(this, b);
	        this.options = this.options ? e(this.options, b) : b;
	        b.group && delete this.group;
	        b.dataLabels && delete this.dataLabels;
	        c && (this.y = l.prototype.getNestedProperty.call(this, c));
	        this.formatPrefix = (this.isNull = z(this.isValid && !this.isValid(), null === this.x || !q(this.y))) ? "null" : "point";
	        this.selected && (this.state = "select");
	        "name" in this && "undefined" === typeof a && d.xAxis && d.xAxis.hasNames && (this.x = d.xAxis.nameToX(this));
	        "undefined" === typeof this.x && d ? this.x = "undefined" === typeof a ? d.autoIncrement() : a : q(b.x) && d.options.relativeXValue && (this.x = d.autoIncrement(b.x));
	        return this;
	      };
	      l.prototype.destroy = function () {
	        function b() {
	          if (a.graphic || a.dataLabel || a.dataLabels) h(a), a.destroyElements();
	          for (f in a) a[f] = null;
	        }
	        var a = this,
	          c = a.series,
	          e = c.chart;
	        c = c.options.dataSorting;
	        var l = e.hoverPoints,
	          g = C(a.series.chart.renderer.globalAnimation),
	          f;
	        a.legendItem && e.legend.destroyItem(a);
	        l && (a.setState(), k(l, a), l.length || (e.hoverPoints = null));
	        if (a === e.hoverPoint) a.onMouseOut();
	        c && c.enabled ? (this.animateBeforeDestroy(), m(b, g.duration)) : b();
	        e.pointCount--;
	      };
	      l.prototype.destroyElements = function (b) {
	        var d = this;
	        b = d.getGraphicalProps(b);
	        b.singular.forEach(function (b) {
	          d[b] = d[b].destroy();
	        });
	        b.plural.forEach(function (b) {
	          d[b].forEach(function (b) {
	            b.element && b.destroy();
	          });
	          delete d[b];
	        });
	      };
	      l.prototype.firePointEvent = function (b, a, e) {
	        var d = this,
	          h = this.series.options;
	        (h.point.events[b] || d.options && d.options.events && d.options.events[b]) && d.importEvents();
	        "click" === b && h.allowPointSelect && (e = function (b) {
	          d.select && d.select(null, b.ctrlKey || b.metaKey || b.shiftKey);
	        });
	        c(d, b, a, e);
	      };
	      l.prototype.getClassName = function () {
	        return "highcharts-point" + (this.selected ? " highcharts-point-select" : "") + (this.negative ? " highcharts-negative" : "") + (this.isNull ? " highcharts-null-point" : "") + ("undefined" !== typeof this.colorIndex ? " highcharts-color-" + this.colorIndex : "") + (this.options.className ? " " + this.options.className : "") + (this.zone && this.zone.className ? " " + this.zone.className.replace("highcharts-negative", "") : "");
	      };
	      l.prototype.getGraphicalProps = function (b) {
	        var d = this,
	          a = [],
	          c = {
	            singular: [],
	            plural: []
	          },
	          e;
	        b = b || {
	          graphic: 1,
	          dataLabel: 1
	        };
	        b.graphic && a.push("graphic", "upperGraphic", "shadowGroup");
	        b.dataLabel && a.push("dataLabel", "dataLabelUpper", "connector");
	        for (e = a.length; e--;) {
	          var h = a[e];
	          d[h] && c.singular.push(h);
	        }
	        ["dataLabel", "connector"].forEach(function (a) {
	          var e = a + "s";
	          b[a] && d[e] && c.plural.push(e);
	        });
	        return c;
	      };
	      l.prototype.getLabelConfig = function () {
	        return {
	          x: this.category,
	          y: this.y,
	          color: this.color,
	          colorIndex: this.colorIndex,
	          key: this.name || this.category,
	          series: this.series,
	          point: this,
	          percentage: this.percentage,
	          total: this.total || this.stackTotal
	        };
	      };
	      l.prototype.getNestedProperty = function (b) {
	        if (b) return 0 === b.indexOf("custom.") ? p(b, this.options) : this[b];
	      };
	      l.prototype.getZone = function () {
	        var b = this.series,
	          a = b.zones;
	        b = b.zoneAxis || "y";
	        var c,
	          e = 0;
	        for (c = a[e]; this[b] >= c.value;) c = a[++e];
	        this.nonZonedColor || (this.nonZonedColor = this.color);
	        this.color = c && c.color && !this.options.color ? c.color : this.nonZonedColor;
	        return c;
	      };
	      l.prototype.hasNewShapeType = function () {
	        return (this.graphic && (this.graphic.symbolName || this.graphic.element.nodeName)) !== this.shapeType;
	      };
	      l.prototype.init = function (d, a, e) {
	        this.series = d;
	        this.applyOptions(a, e);
	        this.id = n(this.id) ? this.id : b();
	        this.resolveColor();
	        d.chart.pointCount++;
	        c(this, "afterInit");
	        return this;
	      };
	      l.prototype.optionsToObject = function (b) {
	        var d = this.series,
	          a = d.options.keys,
	          c = a || d.pointArrayMap || ["y"],
	          e = c.length,
	          h = {},
	          m = 0,
	          f = 0;
	        if (q(b) || null === b) h[c[0]] = b;else if (g(b)) for (!a && b.length > e && (d = typeof b[0], "string" === d ? h.name = b[0] : "number" === d && (h.x = b[0]), m++); f < e;) a && "undefined" === typeof b[m] || (0 < c[f].indexOf(".") ? l.prototype.setNestedProperty(h, b[m], c[f]) : h[c[f]] = b[m]), m++, f++;else "object" === typeof b && (h = b, b.dataLabels && (d._hasPointLabels = !0), b.marker && (d._hasPointMarkers = !0));
	        return h;
	      };
	      l.prototype.resolveColor = function () {
	        var b = this.series,
	          a = b.chart.styledMode;
	        var c = b.chart.options.chart.colorCount;
	        delete this.nonZonedColor;
	        if (b.options.colorByPoint) {
	          if (!a) {
	            c = b.options.colors || b.chart.options.colors;
	            var e = c[b.colorCounter];
	            c = c.length;
	          }
	          a = b.colorCounter;
	          b.colorCounter++;
	          b.colorCounter === c && (b.colorCounter = 0);
	        } else a || (e = b.color), a = b.colorIndex;
	        this.colorIndex = z(this.options.colorIndex, a);
	        this.color = z(this.options.color, e);
	      };
	      l.prototype.setNestedProperty = function (b, a, c) {
	        c.split(".").reduce(function (b, d, c, e) {
	          b[d] = e.length - 1 === c ? a : F(b[d], !0) ? b[d] : {};
	          return b[d];
	        }, b);
	        return b;
	      };
	      l.prototype.tooltipFormatter = function (b) {
	        var d = this.series,
	          a = d.tooltipOptions,
	          c = z(a.valueDecimals, ""),
	          e = a.valuePrefix || "",
	          h = a.valueSuffix || "";
	        d.chart.styledMode && (b = d.chart.tooltip.styledModeFormat(b));
	        (d.pointArrayMap || ["y"]).forEach(function (d) {
	          d = "{point." + d;
	          if (e || h) b = b.replace(RegExp(d + "}", "g"), e + d + "}" + h);
	          b = b.replace(RegExp(d + "}", "g"), d + ":,." + c + "f}");
	        });
	        return A(b, {
	          point: this,
	          series: this.series
	        }, d.chart);
	      };
	      l.prototype.update = function (b, a, c, e) {
	        function d() {
	          h.applyOptions(b);
	          var d = g && h.hasDummyGraphic;
	          d = null === h.y ? !d : d;
	          g && d && (h.graphic = g.destroy(), delete h.hasDummyGraphic);
	          F(b, !0) && (g && g.element && b && b.marker && "undefined" !== typeof b.marker.symbol && (h.graphic = g.destroy()), b && b.dataLabels && h.dataLabel && (h.dataLabel = h.dataLabel.destroy()), h.connector && (h.connector = h.connector.destroy()));
	          k = h.index;
	          l.updateParallelArrays(h, k);
	          f.data[k] = F(f.data[k], !0) || F(b, !0) ? h.options : z(b, f.data[k]);
	          l.isDirty = l.isDirtyData = !0;
	          !l.fixedBox && l.hasCartesianSeries && (m.isDirtyBox = !0);
	          "point" === f.legendType && (m.isDirtyLegend = !0);
	          a && m.redraw(c);
	        }
	        var h = this,
	          l = h.series,
	          g = h.graphic,
	          m = l.chart,
	          f = l.options,
	          k;
	        a = z(a, !0);
	        !1 === e ? d() : h.firePointEvent("update", {
	          options: b
	        }, d);
	      };
	      l.prototype.remove = function (b, a) {
	        this.series.removePoint(this.series.data.indexOf(this), b, a);
	      };
	      l.prototype.select = function (b, a) {
	        var d = this,
	          c = d.series,
	          e = c.chart;
	        this.selectedStaging = b = z(b, !d.selected);
	        d.firePointEvent(b ? "select" : "unselect", {
	          accumulate: a
	        }, function () {
	          d.selected = d.options.selected = b;
	          c.options.data[c.data.indexOf(d)] = d.options;
	          d.setState(b && "select");
	          a || e.getSelectedPoints().forEach(function (b) {
	            var a = b.series;
	            b.selected && b !== d && (b.selected = b.options.selected = !1, a.options.data[a.data.indexOf(b)] = b.options, b.setState(e.hoverPoints && a.options.inactiveOtherPoints ? "inactive" : ""), b.firePointEvent("unselect"));
	          });
	        });
	        delete this.selectedStaging;
	      };
	      l.prototype.onMouseOver = function (b) {
	        var d = this.series.chart,
	          a = d.pointer;
	        b = b ? a.normalize(b) : a.getChartCoordinatesFromPoint(this, d.inverted);
	        a.runPointActions(b, this);
	      };
	      l.prototype.onMouseOut = function () {
	        var b = this.series.chart;
	        this.firePointEvent("mouseOut");
	        this.series.options.inactiveOtherPoints || (b.hoverPoints || []).forEach(function (b) {
	          b.setState();
	        });
	        b.hoverPoints = b.hoverPoint = null;
	      };
	      l.prototype.importEvents = function () {
	        if (!this.hasImportedEvents) {
	          var b = this,
	            a = y(b.series.options.point, b.options).events;
	          b.events = a;
	          x(a, function (d, a) {
	            t(d) && u(b, a, d);
	          });
	          this.hasImportedEvents = !0;
	        }
	      };
	      l.prototype.setState = function (b, h) {
	        var d = this.series,
	          l = this.state,
	          g = d.options.states[b || "normal"] || {},
	          m = I.plotOptions[d.type].marker && d.options.marker,
	          f = m && !1 === m.enabled,
	          k = m && m.states && m.states[b || "normal"] || {},
	          p = !1 === k.enabled,
	          n = this.marker || {},
	          D = d.chart,
	          y = m && d.markerAttribs,
	          t = d.halo,
	          x,
	          F = d.stateMarkerGraphic;
	        b = b || "";
	        if (!(b === this.state && !h || this.selected && "select" !== b || !1 === g.enabled || b && (p || f && !1 === k.enabled) || b && n.states && n.states[b] && !1 === n.states[b].enabled)) {
	          this.state = b;
	          y && (x = d.markerAttribs(this, b));
	          if (this.graphic && !this.hasDummyGraphic) {
	            l && this.graphic.removeClass("highcharts-point-" + l);
	            b && this.graphic.addClass("highcharts-point-" + b);
	            if (!D.styledMode) {
	              var u = d.pointAttribs(this, b);
	              var G = z(D.options.chart.animation, g.animation);
	              d.options.inactiveOtherPoints && q(u.opacity) && ((this.dataLabels || []).forEach(function (b) {
	                b && b.animate({
	                  opacity: u.opacity
	                }, G);
	              }), this.connector && this.connector.animate({
	                opacity: u.opacity
	              }, G));
	              this.graphic.animate(u, G);
	            }
	            x && this.graphic.animate(x, z(D.options.chart.animation, k.animation, m.animation));
	            F && F.hide();
	          } else {
	            if (b && k) {
	              l = n.symbol || d.symbol;
	              F && F.currentSymbol !== l && (F = F.destroy());
	              if (x) if (F) F[h ? "animate" : "attr"]({
	                x: x.x,
	                y: x.y
	              });else l && (d.stateMarkerGraphic = F = D.renderer.symbol(l, x.x, x.y, x.width, x.height).add(d.markerGroup), F.currentSymbol = l);
	              !D.styledMode && F && "inactive" !== this.state && F.attr(d.pointAttribs(this, b));
	            }
	            F && (F[b && this.isInside ? "show" : "hide"](), F.element.point = this, F.addClass(this.getClassName(), !0));
	          }
	          g = g.halo;
	          x = (F = this.graphic || F) && F.visibility || "inherit";
	          g && g.size && F && "hidden" !== x && !this.isCluster ? (t || (d.halo = t = D.renderer.path().add(F.parentGroup)), t.show()[h ? "animate" : "attr"]({
	            d: this.haloPath(g.size)
	          }), t.attr({
	            "class": "highcharts-halo highcharts-color-" + z(this.colorIndex, d.colorIndex) + (this.className ? " " + this.className : ""),
	            visibility: x,
	            zIndex: -1
	          }), t.point = this, D.styledMode || t.attr(e({
	            fill: this.color || d.color,
	            "fill-opacity": g.opacity
	          }, a.filterUserAttributes(g.attributes || {})))) : t && t.point && t.point.haloPath && t.animate({
	            d: t.point.haloPath(0)
	          }, null, t.hide);
	          c(this, "afterSetState", {
	            state: b
	          });
	        }
	      };
	      l.prototype.haloPath = function (b) {
	        return this.series.chart.renderer.symbols.circle(Math.floor(this.plotX) - b, this.plotY - b, 2 * b, 2 * b);
	      };
	      return l;
	    }();
	    return f;
	  });
	  K(f, "Core/Pointer.js", [f["Core/Color/Color.js"], f["Core/Globals.js"], f["Core/Tooltip.js"], f["Core/Utilities.js"]], function (a, f, B, H) {
	    var w = a.parse,
	      C = f.charts,
	      I = f.noop,
	      A = H.addEvent,
	      u = H.attr,
	      n = H.css,
	      k = H.defined,
	      e = H.extend,
	      c = H.find,
	      p = H.fireEvent,
	      g = H.isNumber,
	      t = H.isObject,
	      q = H.objectEach,
	      F = H.offset,
	      y = H.pick,
	      x = H.splat;
	    a = function () {
	      function a(a, c) {
	        this.lastValidTouch = {};
	        this.pinchDown = [];
	        this.runChartClick = !1;
	        this.eventsToUnbind = [];
	        this.chart = a;
	        this.hasDragged = !1;
	        this.options = c;
	        this.init(a, c);
	      }
	      a.prototype.applyInactiveState = function (a) {
	        var c = [],
	          b;
	        (a || []).forEach(function (a) {
	          b = a.series;
	          c.push(b);
	          b.linkedParent && c.push(b.linkedParent);
	          b.linkedSeries && (c = c.concat(b.linkedSeries));
	          b.navigatorSeries && c.push(b.navigatorSeries);
	        });
	        this.chart.series.forEach(function (b) {
	          -1 === c.indexOf(b) ? b.setState("inactive", !0) : b.options.inactiveOtherPoints && b.setAllPointsToState("inactive");
	        });
	      };
	      a.prototype.destroy = function () {
	        var c = this;
	        this.eventsToUnbind.forEach(function (a) {
	          return a();
	        });
	        this.eventsToUnbind = [];
	        f.chartCount || (a.unbindDocumentMouseUp && (a.unbindDocumentMouseUp = a.unbindDocumentMouseUp()), a.unbindDocumentTouchEnd && (a.unbindDocumentTouchEnd = a.unbindDocumentTouchEnd()));
	        clearInterval(c.tooltipTimeout);
	        q(c, function (a, b) {
	          c[b] = void 0;
	        });
	      };
	      a.prototype.drag = function (a) {
	        var c = this.chart,
	          b = c.options.chart,
	          e = this.zoomHor,
	          d = this.zoomVert,
	          g = c.plotLeft,
	          m = c.plotTop,
	          f = c.plotWidth,
	          k = c.plotHeight,
	          p = this.mouseDownX || 0,
	          n = this.mouseDownY || 0,
	          q = t(b.panning) ? b.panning && b.panning.enabled : b.panning,
	          y = b.panKey && a[b.panKey + "Key"],
	          x = a.chartX,
	          z = a.chartY,
	          F = this.selectionMarker;
	        if (!F || !F.touch) if (x < g ? x = g : x > g + f && (x = g + f), z < m ? z = m : z > m + k && (z = m + k), this.hasDragged = Math.sqrt(Math.pow(p - x, 2) + Math.pow(n - z, 2)), 10 < this.hasDragged) {
	          var u = c.isInsidePlot(p - g, n - m, {
	            visiblePlotOnly: !0
	          });
	          !c.hasCartesianSeries && !c.mapView || !this.zoomX && !this.zoomY || !u || y || F || (this.selectionMarker = F = c.renderer.rect(g, m, e ? 1 : f, d ? 1 : k, 0).attr({
	            "class": "highcharts-selection-marker",
	            zIndex: 7
	          }).add(), c.styledMode || F.attr({
	            fill: b.selectionMarkerFill || w("#335cad").setOpacity(.25).get()
	          }));
	          F && e && (e = x - p, F.attr({
	            width: Math.abs(e),
	            x: (0 < e ? 0 : e) + p
	          }));
	          F && d && (e = z - n, F.attr({
	            height: Math.abs(e),
	            y: (0 < e ? 0 : e) + n
	          }));
	          u && !F && q && c.pan(a, b.panning);
	        }
	      };
	      a.prototype.dragStart = function (a) {
	        var c = this.chart;
	        c.mouseIsDown = a.type;
	        c.cancelClick = !1;
	        c.mouseDownX = this.mouseDownX = a.chartX;
	        c.mouseDownY = this.mouseDownY = a.chartY;
	      };
	      a.prototype.drop = function (a) {
	        var c = this,
	          b = this.chart,
	          l = this.hasPinched;
	        if (this.selectionMarker) {
	          var d = this.selectionMarker,
	            m = d.attr ? d.attr("x") : d.x,
	            f = d.attr ? d.attr("y") : d.y,
	            r = d.attr ? d.attr("width") : d.width,
	            q = d.attr ? d.attr("height") : d.height,
	            t = {
	              originalEvent: a,
	              xAxis: [],
	              yAxis: [],
	              x: m,
	              y: f,
	              width: r,
	              height: q
	            },
	            y = !!b.mapView;
	          if (this.hasDragged || l) b.axes.forEach(function (b) {
	            if (b.zoomEnabled && k(b.min) && (l || c[{
	              xAxis: "zoomX",
	              yAxis: "zoomY"
	            }[b.coll]]) && g(m) && g(f)) {
	              var d = b.horiz,
	                e = "touchend" === a.type ? b.minPixelPadding : 0,
	                h = b.toValue((d ? m : f) + e);
	              d = b.toValue((d ? m + r : f + q) - e);
	              t[b.coll].push({
	                axis: b,
	                min: Math.min(h, d),
	                max: Math.max(h, d)
	              });
	              y = !0;
	            }
	          }), y && p(b, "selection", t, function (d) {
	            b.zoom(e(d, l ? {
	              animation: !1
	            } : null));
	          });
	          g(b.index) && (this.selectionMarker = this.selectionMarker.destroy());
	          l && this.scaleGroups();
	        }
	        b && g(b.index) && (n(b.container, {
	          cursor: b._cursor
	        }), b.cancelClick = 10 < this.hasDragged, b.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = []);
	      };
	      a.prototype.findNearestKDPoint = function (a, c, b) {
	        var e = this.chart,
	          d = e.hoverPoint;
	        e = e.tooltip;
	        if (d && e && e.isStickyOnContact()) return d;
	        var h;
	        a.forEach(function (d) {
	          var a = !(d.noSharedTooltip && c) && 0 > d.options.findNearestPointBy.indexOf("y");
	          d = d.searchPoint(b, a);
	          if ((a = t(d, !0) && d.series) && !(a = !t(h, !0))) {
	            a = h.distX - d.distX;
	            var e = h.dist - d.dist,
	              l = (d.series.group && d.series.group.zIndex) - (h.series.group && h.series.group.zIndex);
	            a = 0 < (0 !== a && c ? a : 0 !== e ? e : 0 !== l ? l : h.series.index > d.series.index ? -1 : 1);
	          }
	          a && (h = d);
	        });
	        return h;
	      };
	      a.prototype.getChartCoordinatesFromPoint = function (a, c) {
	        var b = a.series,
	          e = b.xAxis;
	        b = b.yAxis;
	        var d = a.shapeArgs;
	        if (e && b) {
	          var h = y(a.clientX, a.plotX),
	            m = a.plotY || 0;
	          a.isNode && d && g(d.x) && g(d.y) && (h = d.x, m = d.y);
	          return c ? {
	            chartX: b.len + b.pos - m,
	            chartY: e.len + e.pos - h
	          } : {
	            chartX: h + e.pos,
	            chartY: m + b.pos
	          };
	        }
	        if (d && d.x && d.y) return {
	          chartX: d.x,
	          chartY: d.y
	        };
	      };
	      a.prototype.getChartPosition = function () {
	        if (this.chartPosition) return this.chartPosition;
	        var a = this.chart.container,
	          c = F(a);
	        this.chartPosition = {
	          left: c.left,
	          top: c.top,
	          scaleX: 1,
	          scaleY: 1
	        };
	        var b = a.offsetWidth;
	        a = a.offsetHeight;
	        2 < b && 2 < a && (this.chartPosition.scaleX = c.width / b, this.chartPosition.scaleY = c.height / a);
	        return this.chartPosition;
	      };
	      a.prototype.getCoordinates = function (a) {
	        var c = {
	          xAxis: [],
	          yAxis: []
	        };
	        this.chart.axes.forEach(function (b) {
	          c[b.isXAxis ? "xAxis" : "yAxis"].push({
	            axis: b,
	            value: b.toValue(a[b.horiz ? "chartX" : "chartY"])
	          });
	        });
	        return c;
	      };
	      a.prototype.getHoverData = function (a, e, b, l, d, g) {
	        var h = [];
	        l = !(!l || !a);
	        var m = {
	          chartX: g ? g.chartX : void 0,
	          chartY: g ? g.chartY : void 0,
	          shared: d
	        };
	        p(this, "beforeGetHoverData", m);
	        var f = e && !e.stickyTracking ? [e] : b.filter(function (b) {
	          return m.filter ? m.filter(b) : b.visible && !(!d && b.directTouch) && y(b.options.enableMouseTracking, !0) && b.stickyTracking;
	        });
	        var k = l || !g ? a : this.findNearestKDPoint(f, d, g);
	        e = k && k.series;
	        k && (d && !e.noSharedTooltip ? (f = b.filter(function (b) {
	          return m.filter ? m.filter(b) : b.visible && !(!d && b.directTouch) && y(b.options.enableMouseTracking, !0) && !b.noSharedTooltip;
	        }), f.forEach(function (b) {
	          var d = c(b.points, function (b) {
	            return b.x === k.x && !b.isNull;
	          });
	          t(d) && (b.chart.isBoosting && (d = b.getPoint(d)), h.push(d));
	        })) : h.push(k));
	        m = {
	          hoverPoint: k
	        };
	        p(this, "afterGetHoverData", m);
	        return {
	          hoverPoint: m.hoverPoint,
	          hoverSeries: e,
	          hoverPoints: h
	        };
	      };
	      a.prototype.getPointFromEvent = function (a) {
	        a = a.target;
	        for (var c; a && !c;) c = a.point, a = a.parentNode;
	        return c;
	      };
	      a.prototype.onTrackerMouseOut = function (a) {
	        a = a.relatedTarget || a.toElement;
	        var c = this.chart.hoverSeries;
	        this.isDirectTouch = !1;
	        if (!(!c || !a || c.stickyTracking || this.inClass(a, "highcharts-tooltip") || this.inClass(a, "highcharts-series-" + c.index) && this.inClass(a, "highcharts-tracker"))) c.onMouseOut();
	      };
	      a.prototype.inClass = function (a, c) {
	        for (var b; a;) {
	          if (b = u(a, "class")) {
	            if (-1 !== b.indexOf(c)) return !0;
	            if (-1 !== b.indexOf("highcharts-container")) return !1;
	          }
	          a = a.parentElement;
	        }
	      };
	      a.prototype.init = function (a, c) {
	        this.options = c;
	        this.chart = a;
	        this.runChartClick = !(!c.chart.events || !c.chart.events.click);
	        this.pinchDown = [];
	        this.lastValidTouch = {};
	        B && (a.tooltip = new B(a, c.tooltip), this.followTouchMove = y(c.tooltip.followTouchMove, !0));
	        this.setDOMEvents();
	      };
	      a.prototype.normalize = function (a, c) {
	        var b = a.touches,
	          h = b ? b.length ? b.item(0) : y(b.changedTouches, a.changedTouches)[0] : a;
	        c || (c = this.getChartPosition());
	        b = h.pageX - c.left;
	        h = h.pageY - c.top;
	        b /= c.scaleX;
	        h /= c.scaleY;
	        return e(a, {
	          chartX: Math.round(b),
	          chartY: Math.round(h)
	        });
	      };
	      a.prototype.onContainerClick = function (a) {
	        var c = this.chart,
	          b = c.hoverPoint;
	        a = this.normalize(a);
	        var l = c.plotLeft,
	          d = c.plotTop;
	        c.cancelClick || (b && this.inClass(a.target, "highcharts-tracker") ? (p(b.series, "click", e(a, {
	          point: b
	        })), c.hoverPoint && b.firePointEvent("click", a)) : (e(a, this.getCoordinates(a)), c.isInsidePlot(a.chartX - l, a.chartY - d, {
	          visiblePlotOnly: !0
	        }) && p(c, "click", a)));
	      };
	      a.prototype.onContainerMouseDown = function (a) {
	        var c = 1 === ((a.buttons || a.button) & 1);
	        a = this.normalize(a);
	        if (f.isFirefox && 0 !== a.button) this.onContainerMouseMove(a);
	        if ("undefined" === typeof a.button || c) this.zoomOption(a), c && a.preventDefault && a.preventDefault(), this.dragStart(a);
	      };
	      a.prototype.onContainerMouseLeave = function (c) {
	        var e = C[y(a.hoverChartIndex, -1)],
	          b = this.chart.tooltip;
	        b && b.shouldStickOnContact() && this.inClass(c.relatedTarget, "highcharts-tooltip-container") || (c = this.normalize(c), e && (c.relatedTarget || c.toElement) && (e.pointer.reset(), e.pointer.chartPosition = void 0), b && !b.isHidden && this.reset());
	      };
	      a.prototype.onContainerMouseEnter = function (a) {
	        delete this.chartPosition;
	      };
	      a.prototype.onContainerMouseMove = function (a) {
	        var c = this.chart;
	        a = this.normalize(a);
	        this.setHoverChartIndex();
	        a.preventDefault || (a.returnValue = !1);
	        ("mousedown" === c.mouseIsDown || this.touchSelect(a)) && this.drag(a);
	        c.openMenu || !this.inClass(a.target, "highcharts-tracker") && !c.isInsidePlot(a.chartX - c.plotLeft, a.chartY - c.plotTop, {
	          visiblePlotOnly: !0
	        }) || (this.inClass(a.target, "highcharts-no-tooltip") ? this.reset(!1, 0) : this.runPointActions(a));
	      };
	      a.prototype.onDocumentTouchEnd = function (c) {
	        var e = C[y(a.hoverChartIndex, -1)];
	        e && e.pointer.drop(c);
	      };
	      a.prototype.onContainerTouchMove = function (a) {
	        if (this.touchSelect(a)) this.onContainerMouseMove(a);else this.touch(a);
	      };
	      a.prototype.onContainerTouchStart = function (a) {
	        if (this.touchSelect(a)) this.onContainerMouseDown(a);else this.zoomOption(a), this.touch(a, !0);
	      };
	      a.prototype.onDocumentMouseMove = function (a) {
	        var c = this.chart,
	          b = this.chartPosition;
	        a = this.normalize(a, b);
	        var e = c.tooltip;
	        !b || e && e.isStickyOnContact() || c.isInsidePlot(a.chartX - c.plotLeft, a.chartY - c.plotTop, {
	          visiblePlotOnly: !0
	        }) || this.inClass(a.target, "highcharts-tracker") || this.reset();
	      };
	      a.prototype.onDocumentMouseUp = function (c) {
	        var e = C[y(a.hoverChartIndex, -1)];
	        e && e.pointer.drop(c);
	      };
	      a.prototype.pinch = function (a) {
	        var c = this,
	          b = c.chart,
	          l = c.pinchDown,
	          d = a.touches || [],
	          g = d.length,
	          f = c.lastValidTouch,
	          k = c.hasZoom,
	          m = {},
	          n = 1 === g && (c.inClass(a.target, "highcharts-tracker") && b.runTrackerClick || c.runChartClick),
	          q = {},
	          t = c.selectionMarker;
	        1 < g ? c.initiated = !0 : 1 === g && this.followTouchMove && (c.initiated = !1);
	        k && c.initiated && !n && !1 !== a.cancelable && a.preventDefault();
	        [].map.call(d, function (b) {
	          return c.normalize(b);
	        });
	        "touchstart" === a.type ? ([].forEach.call(d, function (b, a) {
	          l[a] = {
	            chartX: b.chartX,
	            chartY: b.chartY
	          };
	        }), f.x = [l[0].chartX, l[1] && l[1].chartX], f.y = [l[0].chartY, l[1] && l[1].chartY], b.axes.forEach(function (a) {
	          if (a.zoomEnabled) {
	            var d = b.bounds[a.horiz ? "h" : "v"],
	              c = a.minPixelPadding,
	              e = a.toPixels(Math.min(y(a.options.min, a.dataMin), a.dataMin)),
	              h = a.toPixels(Math.max(y(a.options.max, a.dataMax), a.dataMax)),
	              l = Math.max(e, h);
	            d.min = Math.min(a.pos, Math.min(e, h) - c);
	            d.max = Math.max(a.pos + a.len, l + c);
	          }
	        }), c.res = !0) : c.followTouchMove && 1 === g ? this.runPointActions(c.normalize(a)) : l.length && (p(b, "touchpan", {
	          originalEvent: a
	        }, function () {
	          t || (c.selectionMarker = t = e({
	            destroy: I,
	            touch: !0
	          }, b.plotBox));
	          c.pinchTranslate(l, d, m, t, q, f);
	          c.hasPinched = k;
	          c.scaleGroups(m, q);
	        }), c.res && (c.res = !1, this.reset(!1, 0)));
	      };
	      a.prototype.pinchTranslate = function (a, c, b, e, d, g) {
	        this.zoomHor && this.pinchTranslateDirection(!0, a, c, b, e, d, g);
	        this.zoomVert && this.pinchTranslateDirection(!1, a, c, b, e, d, g);
	      };
	      a.prototype.pinchTranslateDirection = function (a, c, b, e, d, g, f, k) {
	        var h = this.chart,
	          l = a ? "x" : "y",
	          m = a ? "X" : "Y",
	          r = "chart" + m,
	          p = a ? "width" : "height",
	          n = h["plot" + (a ? "Left" : "Top")],
	          q = h.inverted,
	          v = h.bounds[a ? "h" : "v"],
	          D = 1 === c.length,
	          t = c[0][r],
	          y = !D && c[1][r];
	        c = function () {
	          "number" === typeof F && 20 < Math.abs(t - y) && (z = k || Math.abs(M - F) / Math.abs(t - y));
	          G = (n - M) / z + t;
	          x = h["plot" + (a ? "Width" : "Height")] / z;
	        };
	        var x,
	          G,
	          z = k || 1,
	          M = b[0][r],
	          F = !D && b[1][r];
	        c();
	        b = G;
	        if (b < v.min) {
	          b = v.min;
	          var u = !0;
	        } else b + x > v.max && (b = v.max - x, u = !0);
	        u ? (M -= .8 * (M - f[l][0]), "number" === typeof F && (F -= .8 * (F - f[l][1])), c()) : f[l] = [M, F];
	        q || (g[l] = G - n, g[p] = x);
	        g = q ? 1 / z : z;
	        d[p] = x;
	        d[l] = b;
	        e[q ? a ? "scaleY" : "scaleX" : "scale" + m] = z;
	        e["translate" + m] = g * n + (M - g * t);
	      };
	      a.prototype.reset = function (a, c) {
	        var b = this.chart,
	          e = b.hoverSeries,
	          d = b.hoverPoint,
	          h = b.hoverPoints,
	          g = b.tooltip,
	          f = g && g.shared ? h : d;
	        a && f && x(f).forEach(function (b) {
	          b.series.isCartesian && "undefined" === typeof b.plotX && (a = !1);
	        });
	        if (a) g && f && x(f).length && (g.refresh(f), g.shared && h ? h.forEach(function (b) {
	          b.setState(b.state, !0);
	          b.series.isCartesian && (b.series.xAxis.crosshair && b.series.xAxis.drawCrosshair(null, b), b.series.yAxis.crosshair && b.series.yAxis.drawCrosshair(null, b));
	        }) : d && (d.setState(d.state, !0), b.axes.forEach(function (b) {
	          b.crosshair && d.series[b.coll] === b && b.drawCrosshair(null, d);
	        })));else {
	          if (d) d.onMouseOut();
	          h && h.forEach(function (b) {
	            b.setState();
	          });
	          if (e) e.onMouseOut();
	          g && g.hide(c);
	          this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove());
	          b.axes.forEach(function (b) {
	            b.hideCrosshair();
	          });
	          this.hoverX = b.hoverPoints = b.hoverPoint = null;
	        }
	      };
	      a.prototype.runPointActions = function (e, h) {
	        var b = this.chart,
	          g = b.tooltip && b.tooltip.options.enabled ? b.tooltip : void 0,
	          d = g ? g.shared : !1,
	          f = h || b.hoverPoint,
	          k = f && f.series || b.hoverSeries;
	        h = this.getHoverData(f, k, b.series, (!e || "touchmove" !== e.type) && (!!h || k && k.directTouch && this.isDirectTouch), d, e);
	        f = h.hoverPoint;
	        k = h.hoverSeries;
	        var m = h.hoverPoints;
	        h = k && k.tooltipOptions.followPointer && !k.tooltipOptions.split;
	        var p = d && k && !k.noSharedTooltip;
	        if (f && (f !== b.hoverPoint || g && g.isHidden)) {
	          (b.hoverPoints || []).forEach(function (b) {
	            -1 === m.indexOf(b) && b.setState();
	          });
	          if (b.hoverSeries !== k) k.onMouseOver();
	          this.applyInactiveState(m);
	          (m || []).forEach(function (b) {
	            b.setState("hover");
	          });
	          b.hoverPoint && b.hoverPoint.firePointEvent("mouseOut");
	          if (!f.series) return;
	          b.hoverPoints = m;
	          b.hoverPoint = f;
	          f.firePointEvent("mouseOver", void 0, function () {
	            g && f && g.refresh(p ? m : f, e);
	          });
	        } else h && g && !g.isHidden && (d = g.getAnchor([{}], e), b.isInsidePlot(d[0], d[1], {
	          visiblePlotOnly: !0
	        }) && g.updatePosition({
	          plotX: d[0],
	          plotY: d[1]
	        }));
	        this.unDocMouseMove || (this.unDocMouseMove = A(b.container.ownerDocument, "mousemove", function (b) {
	          var d = C[a.hoverChartIndex];
	          if (d) d.pointer.onDocumentMouseMove(b);
	        }), this.eventsToUnbind.push(this.unDocMouseMove));
	        b.axes.forEach(function (a) {
	          var d = y((a.crosshair || {}).snap, !0),
	            h;
	          d && ((h = b.hoverPoint) && h.series[a.coll] === a || (h = c(m, function (b) {
	            return b.series && b.series[a.coll] === a;
	          })));
	          h || !d ? a.drawCrosshair(e, h) : a.hideCrosshair();
	        });
	      };
	      a.prototype.scaleGroups = function (a, c) {
	        var b = this.chart;
	        b.series.forEach(function (e) {
	          var d = a || e.getPlotBox();
	          e.group && (e.xAxis && e.xAxis.zoomEnabled || b.mapView) && (e.group.attr(d), e.markerGroup && (e.markerGroup.attr(d), e.markerGroup.clip(c ? b.clipRect : null)), e.dataLabelsGroup && e.dataLabelsGroup.attr(d));
	        });
	        b.clipRect.attr(c || b.clipBox);
	      };
	      a.prototype.setDOMEvents = function () {
	        var c = this,
	          e = this.chart.container,
	          b = e.ownerDocument;
	        e.onmousedown = this.onContainerMouseDown.bind(this);
	        e.onmousemove = this.onContainerMouseMove.bind(this);
	        e.onclick = this.onContainerClick.bind(this);
	        this.eventsToUnbind.push(A(e, "mouseenter", this.onContainerMouseEnter.bind(this)));
	        this.eventsToUnbind.push(A(e, "mouseleave", this.onContainerMouseLeave.bind(this)));
	        a.unbindDocumentMouseUp || (a.unbindDocumentMouseUp = A(b, "mouseup", this.onDocumentMouseUp.bind(this)));
	        for (var g = this.chart.renderTo.parentElement; g && "BODY" !== g.tagName;) this.eventsToUnbind.push(A(g, "scroll", function () {
	          delete c.chartPosition;
	        })), g = g.parentElement;
	        f.hasTouch && (this.eventsToUnbind.push(A(e, "touchstart", this.onContainerTouchStart.bind(this), {
	          passive: !1
	        })), this.eventsToUnbind.push(A(e, "touchmove", this.onContainerTouchMove.bind(this), {
	          passive: !1
	        })), a.unbindDocumentTouchEnd || (a.unbindDocumentTouchEnd = A(b, "touchend", this.onDocumentTouchEnd.bind(this), {
	          passive: !1
	        })));
	      };
	      a.prototype.setHoverChartIndex = function () {
	        var c = this.chart,
	          e = f.charts[y(a.hoverChartIndex, -1)];
	        if (e && e !== c) e.pointer.onContainerMouseLeave({
	          relatedTarget: c.container
	        });
	        e && e.mouseIsDown || (a.hoverChartIndex = c.index);
	      };
	      a.prototype.touch = function (a, c) {
	        var b = this.chart;
	        this.setHoverChartIndex();
	        if (1 === a.touches.length) {
	          if (a = this.normalize(a), (b.isInsidePlot(a.chartX - b.plotLeft, a.chartY - b.plotTop, {
	            visiblePlotOnly: !0
	          })) && !b.openMenu) {
	            c && this.runPointActions(a);
	            if ("touchmove" === a.type) {
	              c = this.pinchDown;
	              var d = c[0] ? 4 <= Math.sqrt(Math.pow(c[0].chartX - a.chartX, 2) + Math.pow(c[0].chartY - a.chartY, 2)) : !1;
	            }
	            y(d, !0) && this.pinch(a);
	          } else c && this.reset();
	        } else 2 === a.touches.length && this.pinch(a);
	      };
	      a.prototype.touchSelect = function (a) {
	        return !(!this.chart.options.chart.zoomBySingleTouch || !a.touches || 1 !== a.touches.length);
	      };
	      a.prototype.zoomOption = function (a) {
	        var c = this.chart,
	          b = c.options.chart;
	        c = c.inverted;
	        var e = b.zoomType || "";
	        /touch/.test(a.type) && (e = y(b.pinchType, e));
	        this.zoomX = a = /x/.test(e);
	        this.zoomY = b = /y/.test(e);
	        this.zoomHor = a && !c || b && c;
	        this.zoomVert = b && !c || a && c;
	        this.hasZoom = a || b;
	      };
	      return a;
	    }();
	    return a;
	  });
	  K(f, "Core/MSPointer.js", [f["Core/Globals.js"], f["Core/Pointer.js"], f["Core/Utilities.js"]], function (a, f, B) {
	    function C() {
	      var a = [];
	      a.item = function (a) {
	        return this[a];
	      };
	      c(g, function (c) {
	        a.push({
	          pageX: c.pageX,
	          pageY: c.pageY,
	          target: c.target
	        });
	      });
	      return a;
	    }
	    function w(a, c, e, g) {
	      var k = I[f.hoverChartIndex || NaN];
	      "touch" !== a.pointerType && a.pointerType !== a.MSPOINTER_TYPE_TOUCH || !k || (k = k.pointer, g(a), k[c]({
	        type: e,
	        target: a.currentTarget,
	        preventDefault: u,
	        touches: C()
	      }));
	    }
	    var E = this && this.__extends || function () {
	        var a = function (c, e) {
	          a = Object.setPrototypeOf || {
	            __proto__: []
	          } instanceof Array && function (a, c) {
	            a.__proto__ = c;
	          } || function (a, c) {
	            for (var e in c) c.hasOwnProperty(e) && (a[e] = c[e]);
	          };
	          return a(c, e);
	        };
	        return function (c, e) {
	          function g() {
	            this.constructor = c;
	          }
	          a(c, e);
	          c.prototype = null === e ? Object.create(e) : (g.prototype = e.prototype, new g());
	        };
	      }(),
	      I = a.charts,
	      A = a.doc,
	      u = a.noop,
	      n = a.win,
	      k = B.addEvent,
	      e = B.css,
	      c = B.objectEach,
	      p = B.removeEvent,
	      g = {},
	      t = !!n.PointerEvent;
	    return function (c) {
	      function f() {
	        return null !== c && c.apply(this, arguments) || this;
	      }
	      E(f, c);
	      f.isRequired = function () {
	        return !(a.hasTouch || !n.PointerEvent && !n.MSPointerEvent);
	      };
	      f.prototype.batchMSEvents = function (a) {
	        a(this.chart.container, t ? "pointerdown" : "MSPointerDown", this.onContainerPointerDown);
	        a(this.chart.container, t ? "pointermove" : "MSPointerMove", this.onContainerPointerMove);
	        a(A, t ? "pointerup" : "MSPointerUp", this.onDocumentPointerUp);
	      };
	      f.prototype.destroy = function () {
	        this.batchMSEvents(p);
	        c.prototype.destroy.call(this);
	      };
	      f.prototype.init = function (a, g) {
	        c.prototype.init.call(this, a, g);
	        this.hasZoom && e(a.container, {
	          "-ms-touch-action": "none",
	          "touch-action": "none"
	        });
	      };
	      f.prototype.onContainerPointerDown = function (a) {
	        w(a, "onContainerTouchStart", "touchstart", function (a) {
	          g[a.pointerId] = {
	            pageX: a.pageX,
	            pageY: a.pageY,
	            target: a.currentTarget
	          };
	        });
	      };
	      f.prototype.onContainerPointerMove = function (a) {
	        w(a, "onContainerTouchMove", "touchmove", function (a) {
	          g[a.pointerId] = {
	            pageX: a.pageX,
	            pageY: a.pageY
	          };
	          g[a.pointerId].target || (g[a.pointerId].target = a.currentTarget);
	        });
	      };
	      f.prototype.onDocumentPointerUp = function (a) {
	        w(a, "onDocumentTouchEnd", "touchend", function (a) {
	          delete g[a.pointerId];
	        });
	      };
	      f.prototype.setDOMEvents = function () {
	        c.prototype.setDOMEvents.call(this);
	        (this.hasZoom || this.followTouchMove) && this.batchMSEvents(k);
	      };
	      return f;
	    }(f);
	  });
	  K(f, "Core/Legend/Legend.js", [f["Core/Animation/AnimationUtilities.js"], f["Core/FormatUtilities.js"], f["Core/Globals.js"], f["Core/Series/Point.js"], f["Core/Renderer/RendererUtilities.js"], f["Core/Utilities.js"]], function (a, f, B, H, w, E) {
	    var C = a.animObject,
	      A = a.setAnimation,
	      u = f.format;
	    a = B.isFirefox;
	    var n = B.marginNames;
	    B = B.win;
	    var k = w.distribute,
	      e = E.addEvent,
	      c = E.createElement,
	      p = E.css,
	      g = E.defined,
	      t = E.discardElement,
	      q = E.find,
	      F = E.fireEvent,
	      y = E.isNumber,
	      x = E.merge,
	      z = E.pick,
	      m = E.relativeLength,
	      h = E.stableSort,
	      b = E.syncTimeout;
	    w = E.wrap;
	    E = function () {
	      function a(b, a) {
	        this.allItems = [];
	        this.contentGroup = this.box = void 0;
	        this.display = !1;
	        this.group = void 0;
	        this.offsetWidth = this.maxLegendWidth = this.maxItemWidth = this.legendWidth = this.legendHeight = this.lastLineHeight = this.lastItemY = this.itemY = this.itemX = this.itemMarginTop = this.itemMarginBottom = this.itemHeight = this.initialItemY = 0;
	        this.options = void 0;
	        this.padding = 0;
	        this.pages = [];
	        this.proximate = !1;
	        this.scrollGroup = void 0;
	        this.widthOption = this.totalItemWidth = this.titleHeight = this.symbolWidth = this.symbolHeight = 0;
	        this.chart = b;
	        this.init(b, a);
	      }
	      a.prototype.init = function (b, a) {
	        this.chart = b;
	        this.setOptions(a);
	        a.enabled && (this.render(), e(this.chart, "endResize", function () {
	          this.legend.positionCheckboxes();
	        }), this.proximate ? this.unchartrender = e(this.chart, "render", function () {
	          this.legend.proximatePositions();
	          this.legend.positionItems();
	        }) : this.unchartrender && this.unchartrender());
	      };
	      a.prototype.setOptions = function (b) {
	        var a = z(b.padding, 8);
	        this.options = b;
	        this.chart.styledMode || (this.itemStyle = b.itemStyle, this.itemHiddenStyle = x(this.itemStyle, b.itemHiddenStyle));
	        this.itemMarginTop = b.itemMarginTop || 0;
	        this.itemMarginBottom = b.itemMarginBottom || 0;
	        this.padding = a;
	        this.initialItemY = a - 5;
	        this.symbolWidth = z(b.symbolWidth, 16);
	        this.pages = [];
	        this.proximate = "proximate" === b.layout && !this.chart.inverted;
	        this.baseline = void 0;
	      };
	      a.prototype.update = function (b, a) {
	        var d = this.chart;
	        this.setOptions(x(!0, this.options, b));
	        this.destroy();
	        d.isDirtyLegend = d.isDirtyBox = !0;
	        z(a, !0) && d.redraw();
	        F(this, "afterUpdate");
	      };
	      a.prototype.colorizeItem = function (b, a) {
	        b.legendGroup[a ? "removeClass" : "addClass"]("highcharts-legend-item-hidden");
	        if (!this.chart.styledMode) {
	          var d = this.options,
	            c = b.legendItem,
	            e = b.legendLine,
	            h = b.legendSymbol,
	            g = this.itemHiddenStyle.color;
	          d = a ? d.itemStyle.color : g;
	          var l = a ? b.color || g : g,
	            f = b.options && b.options.marker,
	            k = {
	              fill: l
	            };
	          c && c.css({
	            fill: d,
	            color: d
	          });
	          e && e.attr({
	            stroke: l
	          });
	          h && (f && h.isMarker && (k = b.pointAttribs(), a || (k.stroke = k.fill = g)), h.attr(k));
	        }
	        F(this, "afterColorizeItem", {
	          item: b,
	          visible: a
	        });
	      };
	      a.prototype.positionItems = function () {
	        this.allItems.forEach(this.positionItem, this);
	        this.chart.isResizing || this.positionCheckboxes();
	      };
	      a.prototype.positionItem = function (b) {
	        var a = this,
	          d = this.options,
	          c = d.symbolPadding,
	          e = !d.rtl,
	          h = b._legendItemPos;
	        d = h[0];
	        h = h[1];
	        var l = b.checkbox,
	          f = b.legendGroup;
	        f && f.element && (c = {
	          translateX: e ? d : this.legendWidth - d - 2 * c - 4,
	          translateY: h
	        }, e = function () {
	          F(a, "afterPositionItem", {
	            item: b
	          });
	        }, g(f.translateY) ? f.animate(c, void 0, e) : (f.attr(c), e()));
	        l && (l.x = d, l.y = h);
	      };
	      a.prototype.destroyItem = function (b) {
	        var a = b.checkbox;
	        ["legendItem", "legendLine", "legendSymbol", "legendGroup"].forEach(function (a) {
	          b[a] && (b[a] = b[a].destroy());
	        });
	        a && t(b.checkbox);
	      };
	      a.prototype.destroy = function () {
	        function b(b) {
	          this[b] && (this[b] = this[b].destroy());
	        }
	        this.getAllItems().forEach(function (a) {
	          ["legendItem", "legendGroup"].forEach(b, a);
	        });
	        "clipRect up down pager nav box title group".split(" ").forEach(b, this);
	        this.display = null;
	      };
	      a.prototype.positionCheckboxes = function () {
	        var b = this.group && this.group.alignAttr,
	          a = this.clipHeight || this.legendHeight,
	          c = this.titleHeight;
	        if (b) {
	          var e = b.translateY;
	          this.allItems.forEach(function (d) {
	            var h = d.checkbox;
	            if (h) {
	              var g = e + c + h.y + (this.scrollOffset || 0) + 3;
	              p(h, {
	                left: b.translateX + d.checkboxOffset + h.x - 20 + "px",
	                top: g + "px",
	                display: this.proximate || g > e - 6 && g < e + a - 6 ? "" : "none"
	              });
	            }
	          }, this);
	        }
	      };
	      a.prototype.renderTitle = function () {
	        var b = this.options,
	          a = this.padding,
	          c = b.title,
	          e = 0;
	        c.text && (this.title || (this.title = this.chart.renderer.label(c.text, a - 3, a - 4, void 0, void 0, void 0, b.useHTML, void 0, "legend-title").attr({
	          zIndex: 1
	        }), this.chart.styledMode || this.title.css(c.style), this.title.add(this.group)), c.width || this.title.css({
	          width: this.maxLegendWidth + "px"
	        }), b = this.title.getBBox(), e = b.height, this.offsetWidth = b.width, this.contentGroup.attr({
	          translateY: e
	        }));
	        this.titleHeight = e;
	      };
	      a.prototype.setText = function (b) {
	        var a = this.options;
	        b.legendItem.attr({
	          text: a.labelFormat ? u(a.labelFormat, b, this.chart) : a.labelFormatter.call(b)
	        });
	      };
	      a.prototype.renderItem = function (b) {
	        var a = this.chart,
	          d = a.renderer,
	          c = this.options,
	          e = this.symbolWidth,
	          h = c.symbolPadding || 0,
	          g = this.itemStyle,
	          l = this.itemHiddenStyle,
	          f = "horizontal" === c.layout ? z(c.itemDistance, 20) : 0,
	          k = !c.rtl,
	          m = !b.series,
	          p = !m && b.series.drawLegendSymbol ? b.series : b,
	          n = p.options,
	          q = this.createCheckboxForItem && n && n.showCheckbox,
	          t = c.useHTML,
	          y = b.options.className,
	          G = b.legendItem;
	        n = e + h + f + (q ? 20 : 0);
	        G || (b.legendGroup = d.g("legend-item").addClass("highcharts-" + p.type + "-series highcharts-color-" + b.colorIndex + (y ? " " + y : "") + (m ? " highcharts-series-" + b.index : "")).attr({
	          zIndex: 1
	        }).add(this.scrollGroup), b.legendItem = G = d.text("", k ? e + h : -h, this.baseline || 0, t), a.styledMode || G.css(x(b.visible ? g : l)), G.attr({
	          align: k ? "left" : "right",
	          zIndex: 2
	        }).add(b.legendGroup), this.baseline || (this.fontMetrics = d.fontMetrics(a.styledMode ? 12 : g.fontSize, G), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, G.attr("y", this.baseline), this.symbolHeight = c.symbolHeight || this.fontMetrics.f, c.squareSymbol && (this.symbolWidth = z(c.symbolWidth, Math.max(this.symbolHeight, 16)), n = this.symbolWidth + h + f + (q ? 20 : 0), k && G.attr("x", this.symbolWidth + h))), p.drawLegendSymbol(this, b), this.setItemEvents && this.setItemEvents(b, G, t));
	        q && !b.checkbox && this.createCheckboxForItem && this.createCheckboxForItem(b);
	        this.colorizeItem(b, b.visible);
	        !a.styledMode && g.width || G.css({
	          width: (c.itemWidth || this.widthOption || a.spacingBox.width) - n + "px"
	        });
	        this.setText(b);
	        a = G.getBBox();
	        d = this.fontMetrics && this.fontMetrics.h || 0;
	        b.itemWidth = b.checkboxOffset = c.itemWidth || b.legendItemWidth || a.width + n;
	        this.maxItemWidth = Math.max(this.maxItemWidth, b.itemWidth);
	        this.totalItemWidth += b.itemWidth;
	        this.itemHeight = b.itemHeight = Math.round(b.legendItemHeight || (a.height > 1.5 * d ? a.height : d));
	      };
	      a.prototype.layoutItem = function (b) {
	        var a = this.options,
	          c = this.padding,
	          d = "horizontal" === a.layout,
	          e = b.itemHeight,
	          h = this.itemMarginBottom,
	          g = this.itemMarginTop,
	          l = d ? z(a.itemDistance, 20) : 0,
	          f = this.maxLegendWidth;
	        a = a.alignColumns && this.totalItemWidth > f ? this.maxItemWidth : b.itemWidth;
	        d && this.itemX - c + a > f && (this.itemX = c, this.lastLineHeight && (this.itemY += g + this.lastLineHeight + h), this.lastLineHeight = 0);
	        this.lastItemY = g + this.itemY + h;
	        this.lastLineHeight = Math.max(e, this.lastLineHeight);
	        b._legendItemPos = [this.itemX, this.itemY];
	        d ? this.itemX += a : (this.itemY += g + e + h, this.lastLineHeight = e);
	        this.offsetWidth = this.widthOption || Math.max((d ? this.itemX - c - (b.checkbox ? 0 : l) : a) + c, this.offsetWidth);
	      };
	      a.prototype.getAllItems = function () {
	        var b = [];
	        this.chart.series.forEach(function (a) {
	          var c = a && a.options;
	          a && z(c.showInLegend, g(c.linkedTo) ? !1 : void 0, !0) && (b = b.concat(a.legendItems || ("point" === c.legendType ? a.data : a)));
	        });
	        F(this, "afterGetAllItems", {
	          allItems: b
	        });
	        return b;
	      };
	      a.prototype.getAlignment = function () {
	        var b = this.options;
	        return this.proximate ? b.align.charAt(0) + "tv" : b.floating ? "" : b.align.charAt(0) + b.verticalAlign.charAt(0) + b.layout.charAt(0);
	      };
	      a.prototype.adjustMargins = function (b, a) {
	        var c = this.chart,
	          d = this.options,
	          e = this.getAlignment();
	        e && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function (h, f) {
	          h.test(e) && !g(b[f]) && (c[n[f]] = Math.max(c[n[f]], c.legend[(f + 1) % 2 ? "legendHeight" : "legendWidth"] + [1, -1, -1, 1][f] * d[f % 2 ? "x" : "y"] + z(d.margin, 12) + a[f] + (c.titleOffset[f] || 0)));
	        });
	      };
	      a.prototype.proximatePositions = function () {
	        var b = this.chart,
	          a = [],
	          c = "left" === this.options.align;
	        this.allItems.forEach(function (d) {
	          var e;
	          var h = c;
	          if (d.yAxis) {
	            d.xAxis.options.reversed && (h = !h);
	            d.points && (e = q(h ? d.points : d.points.slice(0).reverse(), function (b) {
	              return y(b.plotY);
	            }));
	            h = this.itemMarginTop + d.legendItem.getBBox().height + this.itemMarginBottom;
	            var g = d.yAxis.top - b.plotTop;
	            d.visible ? (e = e ? e.plotY : d.yAxis.height, e += g - .3 * h) : e = g + d.yAxis.height;
	            a.push({
	              target: e,
	              size: h,
	              item: d
	            });
	          }
	        }, this);
	        k(a, b.plotHeight).forEach(function (a) {
	          a.item._legendItemPos && (a.item._legendItemPos[1] = b.plotTop - b.spacing[0] + a.pos);
	        });
	      };
	      a.prototype.render = function () {
	        var b = this.chart,
	          a = b.renderer,
	          c = this.options,
	          e = this.padding,
	          g = this.getAllItems(),
	          f = this.group,
	          l = this.box;
	        this.itemX = e;
	        this.itemY = this.initialItemY;
	        this.lastItemY = this.offsetWidth = 0;
	        this.widthOption = m(c.width, b.spacingBox.width - e);
	        var k = b.spacingBox.width - 2 * e - c.x;
	        -1 < ["rm", "lm"].indexOf(this.getAlignment().substring(0, 2)) && (k /= 2);
	        this.maxLegendWidth = this.widthOption || k;
	        f || (this.group = f = a.g("legend").addClass(c.className || "").attr({
	          zIndex: 7
	        }).add(), this.contentGroup = a.g().attr({
	          zIndex: 1
	        }).add(f), this.scrollGroup = a.g().add(this.contentGroup));
	        this.renderTitle();
	        h(g, function (b, a) {
	          return (b.options && b.options.legendIndex || 0) - (a.options && a.options.legendIndex || 0);
	        });
	        c.reversed && g.reverse();
	        this.allItems = g;
	        this.display = k = !!g.length;
	        this.itemHeight = this.totalItemWidth = this.maxItemWidth = this.lastLineHeight = 0;
	        g.forEach(this.renderItem, this);
	        g.forEach(this.layoutItem, this);
	        g = (this.widthOption || this.offsetWidth) + e;
	        var p = this.lastItemY + this.lastLineHeight + this.titleHeight;
	        p = this.handleOverflow(p);
	        p += e;
	        l || (this.box = l = a.rect().addClass("highcharts-legend-box").attr({
	          r: c.borderRadius
	        }).add(f));
	        b.styledMode || l.attr({
	          stroke: c.borderColor,
	          "stroke-width": c.borderWidth || 0,
	          fill: c.backgroundColor || "none"
	        }).shadow(c.shadow);
	        if (0 < g && 0 < p) l[l.placed ? "animate" : "attr"](l.crisp.call({}, {
	          x: 0,
	          y: 0,
	          width: g,
	          height: p
	        }, l.strokeWidth()));
	        l[k ? "show" : "hide"]();
	        b.styledMode && "none" === f.getStyle("display") && (g = p = 0);
	        this.legendWidth = g;
	        this.legendHeight = p;
	        k && this.align();
	        this.proximate || this.positionItems();
	        F(this, "afterRender");
	      };
	      a.prototype.align = function (b) {
	        void 0 === b && (b = this.chart.spacingBox);
	        var a = this.chart,
	          c = this.options,
	          d = b.y;
	        /(lth|ct|rth)/.test(this.getAlignment()) && 0 < a.titleOffset[0] ? d += a.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && 0 < a.titleOffset[2] && (d -= a.titleOffset[2]);
	        d !== b.y && (b = x(b, {
	          y: d
	        }));
	        a.hasRendered || (this.group.placed = !1);
	        this.group.align(x(c, {
	          width: this.legendWidth,
	          height: this.legendHeight,
	          verticalAlign: this.proximate ? "top" : c.verticalAlign
	        }), !0, b);
	      };
	      a.prototype.handleOverflow = function (b) {
	        var a = this,
	          c = this.chart,
	          d = c.renderer,
	          e = this.options,
	          h = e.y,
	          g = "top" === e.verticalAlign,
	          f = this.padding,
	          l = e.maxHeight,
	          k = e.navigation,
	          m = z(k.animation, !0),
	          p = k.arrowSize || 12,
	          n = this.pages,
	          q = this.allItems,
	          t = function (b) {
	            "number" === typeof b ? F.attr({
	              height: b
	            }) : F && (a.clipRect = F.destroy(), a.contentGroup.clip());
	            a.contentGroup.div && (a.contentGroup.div.style.clip = b ? "rect(" + f + "px,9999px," + (f + b) + "px,0)" : "auto");
	          },
	          y = function (b) {
	            a[b] = d.circle(0, 0, 1.3 * p).translate(p / 2, p / 2).add(M);
	            c.styledMode || a[b].attr("fill", "rgba(0,0,0,0.0001)");
	            return a[b];
	          },
	          G,
	          x;
	        h = c.spacingBox.height + (g ? -h : h) - f;
	        var M = this.nav,
	          F = this.clipRect;
	        "horizontal" !== e.layout || "middle" === e.verticalAlign || e.floating || (h /= 2);
	        l && (h = Math.min(h, l));
	        n.length = 0;
	        b && 0 < h && b > h && !1 !== k.enabled ? (this.clipHeight = G = Math.max(h - 20 - this.titleHeight - f, 0), this.currentPage = z(this.currentPage, 1), this.fullHeight = b, q.forEach(function (b, a) {
	          var c = b._legendItemPos[1],
	            d = Math.round(b.legendItem.getBBox().height),
	            e = n.length;
	          if (!e || c - n[e - 1] > G && (x || c) !== n[e - 1]) n.push(x || c), e++;
	          b.pageIx = e - 1;
	          x && (q[a - 1].pageIx = e - 1);
	          a === q.length - 1 && c + d - n[e - 1] > G && d <= G && (n.push(c), b.pageIx = e);
	          c !== x && (x = c);
	        }), F || (F = a.clipRect = d.clipRect(0, f, 9999, 0), a.contentGroup.clip(F)), t(G), M || (this.nav = M = d.g().attr({
	          zIndex: 1
	        }).add(this.group), this.up = d.symbol("triangle", 0, 0, p, p).add(M), y("upTracker").on("click", function () {
	          a.scroll(-1, m);
	        }), this.pager = d.text("", 15, 10).addClass("highcharts-legend-navigation"), !c.styledMode && k.style && this.pager.css(k.style), this.pager.add(M), this.down = d.symbol("triangle-down", 0, 0, p, p).add(M), y("downTracker").on("click", function () {
	          a.scroll(1, m);
	        })), a.scroll(0), b = h) : M && (t(), this.nav = M.destroy(), this.scrollGroup.attr({
	          translateY: 1
	        }), this.clipHeight = 0);
	        return b;
	      };
	      a.prototype.scroll = function (a, c) {
	        var d = this,
	          e = this.chart,
	          h = this.pages,
	          g = h.length,
	          f = this.clipHeight,
	          l = this.options.navigation,
	          k = this.pager,
	          m = this.padding,
	          p = this.currentPage + a;
	        p > g && (p = g);
	        0 < p && ("undefined" !== typeof c && A(c, e), this.nav.attr({
	          translateX: m,
	          translateY: f + this.padding + 7 + this.titleHeight,
	          visibility: "inherit"
	        }), [this.up, this.upTracker].forEach(function (b) {
	          b.attr({
	            "class": 1 === p ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
	          });
	        }), k.attr({
	          text: p + "/" + g
	        }), [this.down, this.downTracker].forEach(function (b) {
	          b.attr({
	            x: 18 + this.pager.getBBox().width,
	            "class": p === g ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
	          });
	        }, this), e.styledMode || (this.up.attr({
	          fill: 1 === p ? l.inactiveColor : l.activeColor
	        }), this.upTracker.css({
	          cursor: 1 === p ? "default" : "pointer"
	        }), this.down.attr({
	          fill: p === g ? l.inactiveColor : l.activeColor
	        }), this.downTracker.css({
	          cursor: p === g ? "default" : "pointer"
	        })), this.scrollOffset = -h[p - 1] + this.initialItemY, this.scrollGroup.animate({
	          translateY: this.scrollOffset
	        }), this.currentPage = p, this.positionCheckboxes(), a = C(z(c, e.renderer.globalAnimation, !0)), b(function () {
	          F(d, "afterScroll", {
	            currentPage: p
	          });
	        }, a.duration));
	      };
	      a.prototype.setItemEvents = function (b, a, c) {
	        var d = this,
	          e = d.chart.renderer.boxWrapper,
	          h = b instanceof H,
	          g = "highcharts-legend-" + (h ? "point" : "series") + "-active",
	          f = d.chart.styledMode,
	          l = function (a) {
	            d.allItems.forEach(function (c) {
	              b !== c && [c].concat(c.linkedSeries || []).forEach(function (b) {
	                b.setState(a, !h);
	              });
	            });
	          };
	        (c ? [a, b.legendSymbol] : [b.legendGroup]).forEach(function (c) {
	          if (c) c.on("mouseover", function () {
	            b.visible && l("inactive");
	            b.setState("hover");
	            b.visible && e.addClass(g);
	            f || a.css(d.options.itemHoverStyle);
	          }).on("mouseout", function () {
	            d.chart.styledMode || a.css(x(b.visible ? d.itemStyle : d.itemHiddenStyle));
	            l("");
	            e.removeClass(g);
	            b.setState();
	          }).on("click", function (a) {
	            var c = function () {
	              b.setVisible && b.setVisible();
	              l(b.visible ? "inactive" : "");
	            };
	            e.removeClass(g);
	            a = {
	              browserEvent: a
	            };
	            b.firePointEvent ? b.firePointEvent("legendItemClick", a, c) : F(b, "legendItemClick", a, c);
	          });
	        });
	      };
	      a.prototype.createCheckboxForItem = function (b) {
	        b.checkbox = c("input", {
	          type: "checkbox",
	          className: "highcharts-legend-checkbox",
	          checked: b.selected,
	          defaultChecked: b.selected
	        }, this.options.itemCheckboxStyle, this.chart.container);
	        e(b.checkbox, "click", function (a) {
	          F(b.series || b, "checkboxClick", {
	            checked: a.target.checked,
	            item: b
	          }, function () {
	            b.select();
	          });
	        });
	      };
	      return a;
	    }();
	    (/Trident\/7\.0/.test(B.navigator && B.navigator.userAgent) || a) && w(E.prototype, "positionItem", function (b, a) {
	      var c = this,
	        d = function () {
	          a._legendItemPos && b.call(c, a);
	        };
	      d();
	      c.bubbleLegend || setTimeout(d);
	    });
	    return E;
	  });
	  K(f, "Core/Series/SeriesRegistry.js", [f["Core/Globals.js"], f["Core/DefaultOptions.js"], f["Core/Series/Point.js"], f["Core/Utilities.js"]], function (a, f, B, H) {
	    var w = f.defaultOptions,
	      C = H.error,
	      I = H.extendClass,
	      A = H.merge,
	      u;
	    (function (f) {
	      function k(a, c) {
	        var e = w.plotOptions || {},
	          g = c.defaultOptions;
	        c.prototype.pointClass || (c.prototype.pointClass = B);
	        c.prototype.type = a;
	        g && (e[a] = g);
	        f.seriesTypes[a] = c;
	      }
	      f.seriesTypes = a.seriesTypes;
	      f.getSeries = function (a, c) {
	        void 0 === c && (c = {});
	        var e = a.options.chart;
	        e = c.type || e.type || e.defaultSeriesType || "";
	        var g = f.seriesTypes[e];
	        f || C(17, !0, a, {
	          missingModuleFor: e
	        });
	        e = new g();
	        "function" === typeof e.init && e.init(a, c);
	        return e;
	      };
	      f.registerSeriesType = k;
	      f.seriesType = function (a, c, p, g, n) {
	        var e = w.plotOptions || {};
	        c = c || "";
	        e[a] = A(e[c], p);
	        k(a, I(f.seriesTypes[c] || function () {}, g));
	        f.seriesTypes[a].prototype.type = a;
	        n && (f.seriesTypes[a].prototype.pointClass = I(B, n));
	        return f.seriesTypes[a];
	      };
	    })(u || (u = {}));
	    return u;
	  });
	  K(f, "Core/Chart/Chart.js", [f["Core/Animation/AnimationUtilities.js"], f["Core/Axis/Axis.js"], f["Core/FormatUtilities.js"], f["Core/Foundation.js"], f["Core/Globals.js"], f["Core/Legend/Legend.js"], f["Core/MSPointer.js"], f["Core/DefaultOptions.js"], f["Core/Pointer.js"], f["Core/Renderer/RendererRegistry.js"], f["Core/Series/SeriesRegistry.js"], f["Core/Renderer/SVG/SVGRenderer.js"], f["Core/Time.js"], f["Core/Utilities.js"], f["Core/Renderer/HTML/AST.js"]], function (a, f, B, H, w, E, I, A, u, n, k, e, c, p, g) {
	    var t = a.animate,
	      q = a.animObject,
	      F = a.setAnimation,
	      y = B.numberFormat,
	      x = H.registerEventOptions,
	      z = w.charts,
	      m = w.doc,
	      h = w.marginNames,
	      b = w.svg,
	      l = w.win,
	      d = A.defaultOptions,
	      D = A.defaultTime,
	      v = k.seriesTypes,
	      r = p.addEvent,
	      C = p.attr,
	      P = p.cleanRecursively,
	      S = p.createElement,
	      N = p.css,
	      Y = p.defined,
	      X = p.discardElement,
	      J = p.erase,
	      L = p.error,
	      K = p.extend,
	      da = p.find,
	      Q = p.fireEvent,
	      ea = p.getStyle,
	      G = p.isArray,
	      T = p.isNumber,
	      M = p.isObject,
	      V = p.isString,
	      W = p.merge,
	      Z = p.objectEach,
	      R = p.pick,
	      ha = p.pInt,
	      aa = p.relativeLength,
	      ja = p.removeEvent,
	      ia = p.splat,
	      ba = p.syncTimeout,
	      ka = p.uniqueKey;
	    a = function () {
	      function a(b, a, c) {
	        this.series = this.renderTo = this.renderer = this.pointer = this.pointCount = this.plotWidth = this.plotTop = this.plotLeft = this.plotHeight = this.plotBox = this.options = this.numberFormatter = this.margin = this.legend = this.labelCollectors = this.isResizing = this.index = this.eventOptions = this.container = this.colorCounter = this.clipBox = this.chartWidth = this.chartHeight = this.bounds = this.axisOffset = this.axes = void 0;
	        this.sharedClips = {};
	        this.yAxis = this.xAxis = this.userOptions = this.titleOffset = this.time = this.symbolCounter = this.spacingBox = this.spacing = void 0;
	        this.getArgs(b, a, c);
	      }
	      a.chart = function (b, c, d) {
	        return new a(b, c, d);
	      };
	      a.prototype.getArgs = function (b, a, c) {
	        V(b) || b.nodeName ? (this.renderTo = b, this.init(a, c)) : this.init(b, a);
	      };
	      a.prototype.init = function (b, a) {
	        var e = b.plotOptions || {};
	        Q(this, "init", {
	          args: arguments
	        }, function () {
	          var h = W(d, b),
	            g = h.chart;
	          Z(h.plotOptions, function (b, a) {
	            M(b) && (b.tooltip = e[a] && W(e[a].tooltip) || void 0);
	          });
	          h.tooltip.userOptions = b.chart && b.chart.forExport && b.tooltip.userOptions || b.tooltip;
	          this.userOptions = b;
	          this.margin = [];
	          this.spacing = [];
	          this.bounds = {
	            h: {},
	            v: {}
	          };
	          this.labelCollectors = [];
	          this.callback = a;
	          this.isResizing = 0;
	          this.options = h;
	          this.axes = [];
	          this.series = [];
	          this.time = b.time && Object.keys(b.time).length ? new c(b.time) : w.time;
	          this.numberFormatter = g.numberFormatter || y;
	          this.styledMode = g.styledMode;
	          this.hasCartesianSeries = g.showAxes;
	          this.index = z.length;
	          z.push(this);
	          w.chartCount++;
	          x(this, g);
	          this.xAxis = [];
	          this.yAxis = [];
	          this.pointCount = this.colorCounter = this.symbolCounter = 0;
	          Q(this, "afterInit");
	          this.firstRender();
	        });
	      };
	      a.prototype.initSeries = function (b) {
	        var a = this.options.chart;
	        a = b.type || a.type || a.defaultSeriesType;
	        var c = v[a];
	        c || L(17, !0, this, {
	          missingModuleFor: a
	        });
	        a = new c();
	        "function" === typeof a.init && a.init(this, b);
	        return a;
	      };
	      a.prototype.setSeriesData = function () {
	        this.getSeriesOrderByLinks().forEach(function (b) {
	          b.points || b.data || !b.enabledDataSorting || b.setData(b.options.data, !1);
	        });
	      };
	      a.prototype.getSeriesOrderByLinks = function () {
	        return this.series.concat().sort(function (b, a) {
	          return b.linkedSeries.length || a.linkedSeries.length ? a.linkedSeries.length - b.linkedSeries.length : 0;
	        });
	      };
	      a.prototype.orderSeries = function (b) {
	        var a = this.series;
	        b = b || 0;
	        for (var c = a.length; b < c; ++b) a[b] && (a[b].index = b, a[b].name = a[b].getName());
	      };
	      a.prototype.isInsidePlot = function (b, a, c) {
	        void 0 === c && (c = {});
	        var d = this.inverted,
	          e = this.plotBox,
	          h = this.plotLeft,
	          g = this.plotTop,
	          f = this.scrollablePlotBox,
	          l = 0;
	        var k = 0;
	        c.visiblePlotOnly && this.scrollingContainer && (k = this.scrollingContainer, l = k.scrollLeft, k = k.scrollTop);
	        var m = c.series;
	        e = c.visiblePlotOnly && f || e;
	        f = c.inverted ? a : b;
	        a = c.inverted ? b : a;
	        b = {
	          x: f,
	          y: a,
	          isInsidePlot: !0
	        };
	        if (!c.ignoreX) {
	          var p = m && (d ? m.yAxis : m.xAxis) || {
	            pos: h,
	            len: Infinity
	          };
	          f = c.paneCoordinates ? p.pos + f : h + f;
	          f >= Math.max(l + h, p.pos) && f <= Math.min(l + h + e.width, p.pos + p.len) || (b.isInsidePlot = !1);
	        }
	        !c.ignoreY && b.isInsidePlot && (d = m && (d ? m.xAxis : m.yAxis) || {
	          pos: g,
	          len: Infinity
	        }, c = c.paneCoordinates ? d.pos + a : g + a, c >= Math.max(k + g, d.pos) && c <= Math.min(k + g + e.height, d.pos + d.len) || (b.isInsidePlot = !1));
	        Q(this, "afterIsInsidePlot", b);
	        return b.isInsidePlot;
	      };
	      a.prototype.redraw = function (b) {
	        Q(this, "beforeRedraw");
	        var a = this.hasCartesianSeries ? this.axes : this.colorAxis || [],
	          c = this.series,
	          d = this.pointer,
	          e = this.legend,
	          h = this.userOptions.legend,
	          g = this.renderer,
	          f = g.isHidden(),
	          l = [],
	          k = this.isDirtyBox,
	          m = this.isDirtyLegend;
	        this.setResponsive && this.setResponsive(!1);
	        F(this.hasRendered ? b : !1, this);
	        f && this.temporaryDisplay();
	        this.layOutTitles();
	        for (b = c.length; b--;) {
	          var p = c[b];
	          if (p.options.stacking || p.options.centerInCategory) {
	            var G = !0;
	            if (p.isDirty) {
	              var n = !0;
	              break;
	            }
	          }
	        }
	        if (n) for (b = c.length; b--;) p = c[b], p.options.stacking && (p.isDirty = !0);
	        c.forEach(function (b) {
	          b.isDirty && ("point" === b.options.legendType ? ("function" === typeof b.updateTotals && b.updateTotals(), m = !0) : h && (h.labelFormatter || h.labelFormat) && (m = !0));
	          b.isDirtyData && Q(b, "updatedData");
	        });
	        m && e && e.options.enabled && (e.render(), this.isDirtyLegend = !1);
	        G && this.getStacks();
	        a.forEach(function (b) {
	          b.updateNames();
	          b.setScale();
	        });
	        this.getMargins();
	        a.forEach(function (b) {
	          b.isDirty && (k = !0);
	        });
	        a.forEach(function (b) {
	          var a = b.min + "," + b.max;
	          b.extKey !== a && (b.extKey = a, l.push(function () {
	            Q(b, "afterSetExtremes", K(b.eventArgs, b.getExtremes()));
	            delete b.eventArgs;
	          }));
	          (k || G) && b.redraw();
	        });
	        k && this.drawChartBox();
	        Q(this, "predraw");
	        c.forEach(function (b) {
	          (k || b.isDirty) && b.visible && b.redraw();
	          b.isDirtyData = !1;
	        });
	        d && d.reset(!0);
	        g.draw();
	        Q(this, "redraw");
	        Q(this, "render");
	        f && this.temporaryDisplay(!0);
	        l.forEach(function (b) {
	          b.call();
	        });
	      };
	      a.prototype.get = function (b) {
	        function a(a) {
	          return a.id === b || a.options && a.options.id === b;
	        }
	        for (var c = this.series, d = da(this.axes, a) || da(this.series, a), e = 0; !d && e < c.length; e++) d = da(c[e].points || [], a);
	        return d;
	      };
	      a.prototype.getAxes = function () {
	        var b = this,
	          a = this.options,
	          c = a.xAxis = ia(a.xAxis || {});
	        a = a.yAxis = ia(a.yAxis || {});
	        Q(this, "getAxes");
	        c.forEach(function (b, a) {
	          b.index = a;
	          b.isX = !0;
	        });
	        a.forEach(function (b, a) {
	          b.index = a;
	        });
	        c.concat(a).forEach(function (a) {
	          new f(b, a);
	        });
	        Q(this, "afterGetAxes");
	      };
	      a.prototype.getSelectedPoints = function () {
	        return this.series.reduce(function (b, a) {
	          a.getPointsCollection().forEach(function (a) {
	            R(a.selectedStaging, a.selected) && b.push(a);
	          });
	          return b;
	        }, []);
	      };
	      a.prototype.getSelectedSeries = function () {
	        return this.series.filter(function (b) {
	          return b.selected;
	        });
	      };
	      a.prototype.setTitle = function (b, a, c) {
	        this.applyDescription("title", b);
	        this.applyDescription("subtitle", a);
	        this.applyDescription("caption", void 0);
	        this.layOutTitles(c);
	      };
	      a.prototype.applyDescription = function (b, a) {
	        var c = this,
	          d = "title" === b ? {
	            color: "#333333",
	            fontSize: this.options.isStock ? "16px" : "18px"
	          } : {
	            color: "#666666"
	          };
	        d = this.options[b] = W(!this.styledMode && {
	          style: d
	        }, this.options[b], a);
	        var e = this[b];
	        e && a && (this[b] = e = e.destroy());
	        d && !e && (e = this.renderer.text(d.text, 0, 0, d.useHTML).attr({
	          align: d.align,
	          "class": "highcharts-" + b,
	          zIndex: d.zIndex || 4
	        }).add(), e.update = function (a) {
	          c[{
	            title: "setTitle",
	            subtitle: "setSubtitle",
	            caption: "setCaption"
	          }[b]](a);
	        }, this.styledMode || e.css(d.style), this[b] = e);
	      };
	      a.prototype.layOutTitles = function (b) {
	        var a = [0, 0, 0],
	          c = this.renderer,
	          d = this.spacingBox;
	        ["title", "subtitle", "caption"].forEach(function (b) {
	          var e = this[b],
	            h = this.options[b],
	            g = h.verticalAlign || "top";
	          b = "title" === b ? "top" === g ? -3 : 0 : "top" === g ? a[0] + 2 : 0;
	          var f;
	          if (e) {
	            this.styledMode || (f = h.style && h.style.fontSize);
	            f = c.fontMetrics(f, e).b;
	            e.css({
	              width: (h.width || d.width + (h.widthAdjust || 0)) + "px"
	            });
	            var l = Math.round(e.getBBox(h.useHTML).height);
	            e.align(K({
	              y: "bottom" === g ? f : b + f,
	              height: l
	            }, h), !1, "spacingBox");
	            h.floating || ("top" === g ? a[0] = Math.ceil(a[0] + l) : "bottom" === g && (a[2] = Math.ceil(a[2] + l)));
	          }
	        }, this);
	        a[0] && "top" === (this.options.title.verticalAlign || "top") && (a[0] += this.options.title.margin);
	        a[2] && "bottom" === this.options.caption.verticalAlign && (a[2] += this.options.caption.margin);
	        var e = !this.titleOffset || this.titleOffset.join(",") !== a.join(",");
	        this.titleOffset = a;
	        Q(this, "afterLayOutTitles");
	        !this.isDirtyBox && e && (this.isDirtyBox = this.isDirtyLegend = e, this.hasRendered && R(b, !0) && this.isDirtyBox && this.redraw());
	      };
	      a.prototype.getChartSize = function () {
	        var b = this.options.chart,
	          a = b.width;
	        b = b.height;
	        var c = this.renderTo;
	        Y(a) || (this.containerWidth = ea(c, "width"));
	        Y(b) || (this.containerHeight = ea(c, "height"));
	        this.chartWidth = Math.max(0, a || this.containerWidth || 600);
	        this.chartHeight = Math.max(0, aa(b, this.chartWidth) || (1 < this.containerHeight ? this.containerHeight : 400));
	      };
	      a.prototype.temporaryDisplay = function (b) {
	        var a = this.renderTo;
	        if (b) for (; a && a.style;) a.hcOrigStyle && (N(a, a.hcOrigStyle), delete a.hcOrigStyle), a.hcOrigDetached && (m.body.removeChild(a), a.hcOrigDetached = !1), a = a.parentNode;else for (; a && a.style;) {
	          m.body.contains(a) || a.parentNode || (a.hcOrigDetached = !0, m.body.appendChild(a));
	          if ("none" === ea(a, "display", !1) || a.hcOricDetached) a.hcOrigStyle = {
	            display: a.style.display,
	            height: a.style.height,
	            overflow: a.style.overflow
	          }, b = {
	            display: "block",
	            overflow: "hidden"
	          }, a !== this.renderTo && (b.height = 0), N(a, b), a.offsetWidth || a.style.setProperty("display", "block", "important");
	          a = a.parentNode;
	          if (a === m.body) break;
	        }
	      };
	      a.prototype.setClassName = function (b) {
	        this.container.className = "highcharts-container " + (b || "");
	      };
	      a.prototype.getContainer = function () {
	        var a = this.options,
	          c = a.chart,
	          d = ka(),
	          h,
	          f = this.renderTo;
	        f || (this.renderTo = f = c.renderTo);
	        V(f) && (this.renderTo = f = m.getElementById(f));
	        f || L(13, !0, this);
	        var l = ha(C(f, "data-highcharts-chart"));
	        T(l) && z[l] && z[l].hasRendered && z[l].destroy();
	        C(f, "data-highcharts-chart", this.index);
	        f.innerHTML = g.emptyHTML;
	        c.skipClone || f.offsetWidth || this.temporaryDisplay();
	        this.getChartSize();
	        l = this.chartWidth;
	        var k = this.chartHeight;
	        N(f, {
	          overflow: "hidden"
	        });
	        this.styledMode || (h = K({
	          position: "relative",
	          overflow: "hidden",
	          width: l + "px",
	          height: k + "px",
	          textAlign: "left",
	          lineHeight: "normal",
	          zIndex: 0,
	          "-webkit-tap-highlight-color": "rgba(0,0,0,0)",
	          userSelect: "none",
	          "touch-action": "manipulation",
	          outline: "none"
	        }, c.style || {}));
	        this.container = d = S("div", {
	          id: d
	        }, h, f);
	        this._cursor = d.style.cursor;
	        this.renderer = new (c.renderer || !b ? n.getRendererType(c.renderer) : e)(d, l, k, void 0, c.forExport, a.exporting && a.exporting.allowHTML, this.styledMode);
	        F(void 0, this);
	        this.setClassName(c.className);
	        if (this.styledMode) for (var p in a.defs) this.renderer.definition(a.defs[p]);else this.renderer.setStyle(c.style);
	        this.renderer.chartIndex = this.index;
	        Q(this, "afterGetContainer");
	      };
	      a.prototype.getMargins = function (b) {
	        var a = this.spacing,
	          c = this.margin,
	          d = this.titleOffset;
	        this.resetMargins();
	        d[0] && !Y(c[0]) && (this.plotTop = Math.max(this.plotTop, d[0] + a[0]));
	        d[2] && !Y(c[2]) && (this.marginBottom = Math.max(this.marginBottom, d[2] + a[2]));
	        this.legend && this.legend.display && this.legend.adjustMargins(c, a);
	        Q(this, "getMargins");
	        b || this.getAxisMargins();
	      };
	      a.prototype.getAxisMargins = function () {
	        var b = this,
	          a = b.axisOffset = [0, 0, 0, 0],
	          c = b.colorAxis,
	          d = b.margin,
	          e = function (b) {
	            b.forEach(function (b) {
	              b.visible && b.getOffset();
	            });
	          };
	        b.hasCartesianSeries ? e(b.axes) : c && c.length && e(c);
	        h.forEach(function (c, e) {
	          Y(d[e]) || (b[c] += a[e]);
	        });
	        b.setChartSize();
	      };
	      a.prototype.reflow = function (b) {
	        var a = this,
	          c = a.options.chart,
	          d = a.renderTo,
	          e = Y(c.width) && Y(c.height),
	          h = c.width || ea(d, "width");
	        c = c.height || ea(d, "height");
	        d = b ? b.target : l;
	        delete a.pointer.chartPosition;
	        if (!e && !a.isPrinting && h && c && (d === l || d === m)) {
	          if (h !== a.containerWidth || c !== a.containerHeight) p.clearTimeout(a.reflowTimeout), a.reflowTimeout = ba(function () {
	            a.container && a.setSize(void 0, void 0, !1);
	          }, b ? 100 : 0);
	          a.containerWidth = h;
	          a.containerHeight = c;
	        }
	      };
	      a.prototype.setReflow = function (b) {
	        var a = this;
	        !1 === b || this.unbindReflow ? !1 === b && this.unbindReflow && (this.unbindReflow = this.unbindReflow()) : (this.unbindReflow = r(l, "resize", function (b) {
	          a.options && a.reflow(b);
	        }), r(this, "destroy", this.unbindReflow));
	      };
	      a.prototype.setSize = function (b, a, c) {
	        var d = this,
	          e = d.renderer;
	        d.isResizing += 1;
	        F(c, d);
	        c = e.globalAnimation;
	        d.oldChartHeight = d.chartHeight;
	        d.oldChartWidth = d.chartWidth;
	        "undefined" !== typeof b && (d.options.chart.width = b);
	        "undefined" !== typeof a && (d.options.chart.height = a);
	        d.getChartSize();
	        d.styledMode || (c ? t : N)(d.container, {
	          width: d.chartWidth + "px",
	          height: d.chartHeight + "px"
	        }, c);
	        d.setChartSize(!0);
	        e.setSize(d.chartWidth, d.chartHeight, c);
	        d.axes.forEach(function (b) {
	          b.isDirty = !0;
	          b.setScale();
	        });
	        d.isDirtyLegend = !0;
	        d.isDirtyBox = !0;
	        d.layOutTitles();
	        d.getMargins();
	        d.redraw(c);
	        d.oldChartHeight = null;
	        Q(d, "resize");
	        ba(function () {
	          d && Q(d, "endResize", null, function () {
	            --d.isResizing;
	          });
	        }, q(c).duration);
	      };
	      a.prototype.setChartSize = function (b) {
	        var a = this.inverted,
	          c = this.renderer,
	          d = this.chartWidth,
	          e = this.chartHeight,
	          h = this.options.chart,
	          g = this.spacing,
	          f = this.clipOffset,
	          l,
	          k,
	          m,
	          p;
	        this.plotLeft = l = Math.round(this.plotLeft);
	        this.plotTop = k = Math.round(this.plotTop);
	        this.plotWidth = m = Math.max(0, Math.round(d - l - this.marginRight));
	        this.plotHeight = p = Math.max(0, Math.round(e - k - this.marginBottom));
	        this.plotSizeX = a ? p : m;
	        this.plotSizeY = a ? m : p;
	        this.plotBorderWidth = h.plotBorderWidth || 0;
	        this.spacingBox = c.spacingBox = {
	          x: g[3],
	          y: g[0],
	          width: d - g[3] - g[1],
	          height: e - g[0] - g[2]
	        };
	        this.plotBox = c.plotBox = {
	          x: l,
	          y: k,
	          width: m,
	          height: p
	        };
	        a = 2 * Math.floor(this.plotBorderWidth / 2);
	        d = Math.ceil(Math.max(a, f[3]) / 2);
	        e = Math.ceil(Math.max(a, f[0]) / 2);
	        this.clipBox = {
	          x: d,
	          y: e,
	          width: Math.floor(this.plotSizeX - Math.max(a, f[1]) / 2 - d),
	          height: Math.max(0, Math.floor(this.plotSizeY - Math.max(a, f[2]) / 2 - e))
	        };
	        b || (this.axes.forEach(function (b) {
	          b.setAxisSize();
	          b.setAxisTranslation();
	        }), c.alignElements());
	        Q(this, "afterSetChartSize", {
	          skipAxes: b
	        });
	      };
	      a.prototype.resetMargins = function () {
	        Q(this, "resetMargins");
	        var b = this,
	          a = b.options.chart;
	        ["margin", "spacing"].forEach(function (c) {
	          var d = a[c],
	            e = M(d) ? d : [d, d, d, d];
	          ["Top", "Right", "Bottom", "Left"].forEach(function (d, h) {
	            b[c][h] = R(a[c + d], e[h]);
	          });
	        });
	        h.forEach(function (a, c) {
	          b[a] = R(b.margin[c], b.spacing[c]);
	        });
	        b.axisOffset = [0, 0, 0, 0];
	        b.clipOffset = [0, 0, 0, 0];
	      };
	      a.prototype.drawChartBox = function () {
	        var b = this.options.chart,
	          a = this.renderer,
	          c = this.chartWidth,
	          d = this.chartHeight,
	          e = this.styledMode,
	          h = this.plotBGImage,
	          g = b.backgroundColor,
	          f = b.plotBackgroundColor,
	          l = b.plotBackgroundImage,
	          k = this.plotLeft,
	          m = this.plotTop,
	          p = this.plotWidth,
	          G = this.plotHeight,
	          n = this.plotBox,
	          q = this.clipRect,
	          r = this.clipBox,
	          t = this.chartBackground,
	          M = this.plotBackground,
	          y = this.plotBorder,
	          z,
	          x = "animate";
	        t || (this.chartBackground = t = a.rect().addClass("highcharts-background").add(), x = "attr");
	        if (e) var v = z = t.strokeWidth();else {
	          v = b.borderWidth || 0;
	          z = v + (b.shadow ? 8 : 0);
	          g = {
	            fill: g || "none"
	          };
	          if (v || t["stroke-width"]) g.stroke = b.borderColor, g["stroke-width"] = v;
	          t.attr(g).shadow(b.shadow);
	        }
	        t[x]({
	          x: z / 2,
	          y: z / 2,
	          width: c - z - v % 2,
	          height: d - z - v % 2,
	          r: b.borderRadius
	        });
	        x = "animate";
	        M || (x = "attr", this.plotBackground = M = a.rect().addClass("highcharts-plot-background").add());
	        M[x](n);
	        e || (M.attr({
	          fill: f || "none"
	        }).shadow(b.plotShadow), l && (h ? (l !== h.attr("href") && h.attr("href", l), h.animate(n)) : this.plotBGImage = a.image(l, k, m, p, G).add()));
	        q ? q.animate({
	          width: r.width,
	          height: r.height
	        }) : this.clipRect = a.clipRect(r);
	        x = "animate";
	        y || (x = "attr", this.plotBorder = y = a.rect().addClass("highcharts-plot-border").attr({
	          zIndex: 1
	        }).add());
	        e || y.attr({
	          stroke: b.plotBorderColor,
	          "stroke-width": b.plotBorderWidth || 0,
	          fill: "none"
	        });
	        y[x](y.crisp({
	          x: k,
	          y: m,
	          width: p,
	          height: G
	        }, -y.strokeWidth()));
	        this.isDirtyBox = !1;
	        Q(this, "afterDrawChartBox");
	      };
	      a.prototype.propFromSeries = function () {
	        var b = this,
	          a = b.options.chart,
	          c = b.options.series,
	          d,
	          e,
	          h;
	        ["inverted", "angular", "polar"].forEach(function (g) {
	          e = v[a.type || a.defaultSeriesType];
	          h = a[g] || e && e.prototype[g];
	          for (d = c && c.length; !h && d--;) (e = v[c[d].type]) && e.prototype[g] && (h = !0);
	          b[g] = h;
	        });
	      };
	      a.prototype.linkSeries = function () {
	        var b = this,
	          a = b.series;
	        a.forEach(function (b) {
	          b.linkedSeries.length = 0;
	        });
	        a.forEach(function (a) {
	          var c = a.options.linkedTo;
	          V(c) && (c = ":previous" === c ? b.series[a.index - 1] : b.get(c)) && c.linkedParent !== a && (c.linkedSeries.push(a), a.linkedParent = c, c.enabledDataSorting && a.setDataSortingOptions(), a.visible = R(a.options.visible, c.options.visible, a.visible));
	        });
	        Q(this, "afterLinkSeries");
	      };
	      a.prototype.renderSeries = function () {
	        this.series.forEach(function (b) {
	          b.translate();
	          b.render();
	        });
	      };
	      a.prototype.renderLabels = function () {
	        var b = this,
	          a = b.options.labels;
	        a.items && a.items.forEach(function (c) {
	          var d = K(a.style, c.style),
	            e = ha(d.left) + b.plotLeft,
	            h = ha(d.top) + b.plotTop + 12;
	          delete d.left;
	          delete d.top;
	          b.renderer.text(c.html, e, h).attr({
	            zIndex: 2
	          }).css(d).add();
	        });
	      };
	      a.prototype.render = function () {
	        var b = this.axes,
	          a = this.colorAxis,
	          c = this.renderer,
	          d = this.options,
	          e = function (b) {
	            b.forEach(function (b) {
	              b.visible && b.render();
	            });
	          },
	          h = 0;
	        this.setTitle();
	        this.legend = new E(this, d.legend);
	        this.getStacks && this.getStacks();
	        this.getMargins(!0);
	        this.setChartSize();
	        d = this.plotWidth;
	        b.some(function (b) {
	          if (b.horiz && b.visible && b.options.labels.enabled && b.series.length) return h = 21, !0;
	        });
	        var g = this.plotHeight = Math.max(this.plotHeight - h, 0);
	        b.forEach(function (b) {
	          b.setScale();
	        });
	        this.getAxisMargins();
	        var f = 1.1 < d / this.plotWidth,
	          l = 1.05 < g / this.plotHeight;
	        if (f || l) b.forEach(function (b) {
	          (b.horiz && f || !b.horiz && l) && b.setTickInterval(!0);
	        }), this.getMargins();
	        this.drawChartBox();
	        this.hasCartesianSeries ? e(b) : a && a.length && e(a);
	        this.seriesGroup || (this.seriesGroup = c.g("series-group").attr({
	          zIndex: 3
	        }).add());
	        this.renderSeries();
	        this.renderLabels();
	        this.addCredits();
	        this.setResponsive && this.setResponsive();
	        this.hasRendered = !0;
	      };
	      a.prototype.addCredits = function (b) {
	        var a = this,
	          c = W(!0, this.options.credits, b);
	        c.enabled && !this.credits && (this.credits = this.renderer.text(c.text + (this.mapCredits || ""), 0, 0).addClass("highcharts-credits").on("click", function () {
	          c.href && (l.location.href = c.href);
	        }).attr({
	          align: c.position.align,
	          zIndex: 8
	        }), a.styledMode || this.credits.css(c.style), this.credits.add().align(c.position), this.credits.update = function (b) {
	          a.credits = a.credits.destroy();
	          a.addCredits(b);
	        });
	      };
	      a.prototype.destroy = function () {
	        var b = this,
	          a = b.axes,
	          c = b.series,
	          d = b.container,
	          e = d && d.parentNode,
	          h;
	        Q(b, "destroy");
	        b.renderer.forExport ? J(z, b) : z[b.index] = void 0;
	        w.chartCount--;
	        b.renderTo.removeAttribute("data-highcharts-chart");
	        ja(b);
	        for (h = a.length; h--;) a[h] = a[h].destroy();
	        this.scroller && this.scroller.destroy && this.scroller.destroy();
	        for (h = c.length; h--;) c[h] = c[h].destroy();
	        "title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer".split(" ").forEach(function (a) {
	          var c = b[a];
	          c && c.destroy && (b[a] = c.destroy());
	        });
	        d && (d.innerHTML = g.emptyHTML, ja(d), e && X(d));
	        Z(b, function (a, c) {
	          delete b[c];
	        });
	      };
	      a.prototype.firstRender = function () {
	        var b = this,
	          a = b.options;
	        if (!b.isReadyToRender || b.isReadyToRender()) {
	          b.getContainer();
	          b.resetMargins();
	          b.setChartSize();
	          b.propFromSeries();
	          b.getAxes();
	          (G(a.series) ? a.series : []).forEach(function (a) {
	            b.initSeries(a);
	          });
	          b.linkSeries();
	          b.setSeriesData();
	          Q(b, "beforeRender");
	          u && (I.isRequired() ? b.pointer = new I(b, a) : b.pointer = new u(b, a));
	          b.render();
	          b.pointer.getChartPosition();
	          if (!b.renderer.imgCount && !b.hasLoaded) b.onload();
	          b.temporaryDisplay(!0);
	        }
	      };
	      a.prototype.onload = function () {
	        this.callbacks.concat([this.callback]).forEach(function (b) {
	          b && "undefined" !== typeof this.index && b.apply(this, [this]);
	        }, this);
	        Q(this, "load");
	        Q(this, "render");
	        Y(this.index) && this.setReflow(this.options.chart.reflow);
	        this.warnIfA11yModuleNotLoaded();
	        this.hasLoaded = !0;
	      };
	      a.prototype.warnIfA11yModuleNotLoaded = function () {
	        var b = this;
	        setTimeout(function () {
	          var a = b && b.options;
	          !a || b.accessibility || a.accessibility && !1 === a.accessibility.enabled || L('Highcharts warning: Consider including the "accessibility.js" module to make your chart more usable for people with disabilities. Set the "accessibility.enabled" option to false to remove this warning. See https://www.highcharts.com/docs/accessibility/accessibility-module.', !1, b);
	        }, 100);
	      };
	      a.prototype.addSeries = function (b, a, c) {
	        var d = this,
	          e;
	        b && (a = R(a, !0), Q(d, "addSeries", {
	          options: b
	        }, function () {
	          e = d.initSeries(b);
	          d.isDirtyLegend = !0;
	          d.linkSeries();
	          e.enabledDataSorting && e.setData(b.data, !1);
	          Q(d, "afterAddSeries", {
	            series: e
	          });
	          a && d.redraw(c);
	        }));
	        return e;
	      };
	      a.prototype.addAxis = function (b, a, c, d) {
	        return this.createAxis(a ? "xAxis" : "yAxis", {
	          axis: b,
	          redraw: c,
	          animation: d
	        });
	      };
	      a.prototype.addColorAxis = function (b, a, c) {
	        return this.createAxis("colorAxis", {
	          axis: b,
	          redraw: a,
	          animation: c
	        });
	      };
	      a.prototype.createAxis = function (b, a) {
	        b = new f(this, W(a.axis, {
	          index: this[b].length,
	          isX: "xAxis" === b
	        }));
	        R(a.redraw, !0) && this.redraw(a.animation);
	        return b;
	      };
	      a.prototype.showLoading = function (b) {
	        var a = this,
	          c = a.options,
	          d = c.loading,
	          e = function () {
	            h && N(h, {
	              left: a.plotLeft + "px",
	              top: a.plotTop + "px",
	              width: a.plotWidth + "px",
	              height: a.plotHeight + "px"
	            });
	          },
	          h = a.loadingDiv,
	          f = a.loadingSpan;
	        h || (a.loadingDiv = h = S("div", {
	          className: "highcharts-loading highcharts-loading-hidden"
	        }, null, a.container));
	        f || (a.loadingSpan = f = S("span", {
	          className: "highcharts-loading-inner"
	        }, null, h), r(a, "redraw", e));
	        h.className = "highcharts-loading";
	        g.setElementHTML(f, R(b, c.lang.loading, ""));
	        a.styledMode || (N(h, K(d.style, {
	          zIndex: 10
	        })), N(f, d.labelStyle), a.loadingShown || (N(h, {
	          opacity: 0,
	          display: ""
	        }), t(h, {
	          opacity: d.style.opacity || .5
	        }, {
	          duration: d.showDuration || 0
	        })));
	        a.loadingShown = !0;
	        e();
	      };
	      a.prototype.hideLoading = function () {
	        var b = this.options,
	          a = this.loadingDiv;
	        a && (a.className = "highcharts-loading highcharts-loading-hidden", this.styledMode || t(a, {
	          opacity: 0
	        }, {
	          duration: b.loading.hideDuration || 100,
	          complete: function () {
	            N(a, {
	              display: "none"
	            });
	          }
	        }));
	        this.loadingShown = !1;
	      };
	      a.prototype.update = function (b, a, d, e) {
	        var h = this,
	          g = {
	            credits: "addCredits",
	            title: "setTitle",
	            subtitle: "setSubtitle",
	            caption: "setCaption"
	          },
	          f = b.isResponsiveOptions,
	          l = [],
	          k,
	          m;
	        Q(h, "update", {
	          options: b
	        });
	        f || h.setResponsive(!1, !0);
	        b = P(b, h.options);
	        h.userOptions = W(h.userOptions, b);
	        var p = b.chart;
	        if (p) {
	          W(!0, h.options.chart, p);
	          "className" in p && h.setClassName(p.className);
	          "reflow" in p && h.setReflow(p.reflow);
	          if ("inverted" in p || "polar" in p || "type" in p) {
	            h.propFromSeries();
	            var G = !0;
	          }
	          "alignTicks" in p && (G = !0);
	          "events" in p && x(this, p);
	          Z(p, function (b, a) {
	            -1 !== h.propsRequireUpdateSeries.indexOf("chart." + a) && (k = !0);
	            -1 !== h.propsRequireDirtyBox.indexOf(a) && (h.isDirtyBox = !0);
	            -1 !== h.propsRequireReflow.indexOf(a) && (f ? h.isDirtyBox = !0 : m = !0);
	          });
	          !h.styledMode && p.style && h.renderer.setStyle(h.options.chart.style || {});
	        }
	        !h.styledMode && b.colors && (this.options.colors = b.colors);
	        b.time && (this.time === D && (this.time = new c(b.time)), W(!0, h.options.time, b.time));
	        Z(b, function (a, c) {
	          if (h[c] && "function" === typeof h[c].update) h[c].update(a, !1);else if ("function" === typeof h[g[c]]) h[g[c]](a);else "colors" !== c && -1 === h.collectionsWithUpdate.indexOf(c) && W(!0, h.options[c], b[c]);
	          "chart" !== c && -1 !== h.propsRequireUpdateSeries.indexOf(c) && (k = !0);
	        });
	        this.collectionsWithUpdate.forEach(function (a) {
	          if (b[a]) {
	            var c = [];
	            h[a].forEach(function (b, a) {
	              b.options.isInternal || c.push(R(b.options.index, a));
	            });
	            ia(b[a]).forEach(function (b, e) {
	              var g = Y(b.id),
	                f;
	              g && (f = h.get(b.id));
	              !f && h[a] && (f = h[a][c ? c[e] : e]) && g && Y(f.options.id) && (f = void 0);
	              f && f.coll === a && (f.update(b, !1), d && (f.touched = !0));
	              !f && d && h.collectionsWithInit[a] && (h.collectionsWithInit[a][0].apply(h, [b].concat(h.collectionsWithInit[a][1] || []).concat([!1])).touched = !0);
	            });
	            d && h[a].forEach(function (b) {
	              b.touched || b.options.isInternal ? delete b.touched : l.push(b);
	            });
	          }
	        });
	        l.forEach(function (b) {
	          b.chart && b.remove && b.remove(!1);
	        });
	        G && h.axes.forEach(function (b) {
	          b.update({}, !1);
	        });
	        k && h.getSeriesOrderByLinks().forEach(function (b) {
	          b.chart && b.update({}, !1);
	        }, this);
	        G = p && p.width;
	        p = p && (V(p.height) ? aa(p.height, G || h.chartWidth) : p.height);
	        m || T(G) && G !== h.chartWidth || T(p) && p !== h.chartHeight ? h.setSize(G, p, e) : R(a, !0) && h.redraw(e);
	        Q(h, "afterUpdate", {
	          options: b,
	          redraw: a,
	          animation: e
	        });
	      };
	      a.prototype.setSubtitle = function (b, a) {
	        this.applyDescription("subtitle", b);
	        this.layOutTitles(a);
	      };
	      a.prototype.setCaption = function (b, a) {
	        this.applyDescription("caption", b);
	        this.layOutTitles(a);
	      };
	      a.prototype.showResetZoom = function () {
	        function b() {
	          a.zoomOut();
	        }
	        var a = this,
	          c = d.lang,
	          e = a.options.chart.resetZoomButton,
	          h = e.theme,
	          g = "chart" === e.relativeTo || "spacingBox" === e.relativeTo ? null : "scrollablePlotBox";
	        Q(this, "beforeShowResetZoom", null, function () {
	          a.resetZoomButton = a.renderer.button(c.resetZoom, null, null, b, h).attr({
	            align: e.position.align,
	            title: c.resetZoomTitle
	          }).addClass("highcharts-reset-zoom").add().align(e.position, !1, g);
	        });
	        Q(this, "afterShowResetZoom");
	      };
	      a.prototype.zoomOut = function () {
	        Q(this, "selection", {
	          resetSelection: !0
	        }, this.zoom);
	      };
	      a.prototype.zoom = function (b) {
	        var a = this,
	          c = a.pointer,
	          d = a.inverted ? c.mouseDownX : c.mouseDownY,
	          e = !1,
	          h;
	        !b || b.resetSelection ? (a.axes.forEach(function (b) {
	          h = b.zoom();
	        }), c.initiated = !1) : b.xAxis.concat(b.yAxis).forEach(function (b) {
	          var g = b.axis,
	            f = a.inverted ? g.left : g.top,
	            l = a.inverted ? f + g.width : f + g.height,
	            k = g.isXAxis,
	            m = !1;
	          if (!k && d >= f && d <= l || k || !Y(d)) m = !0;
	          c[k ? "zoomX" : "zoomY"] && m && (h = g.zoom(b.min, b.max), g.displayBtn && (e = !0));
	        });
	        var g = a.resetZoomButton;
	        e && !g ? a.showResetZoom() : !e && M(g) && (a.resetZoomButton = g.destroy());
	        h && a.redraw(R(a.options.chart.animation, b && b.animation, 100 > a.pointCount));
	      };
	      a.prototype.pan = function (b, a) {
	        var c = this,
	          d = c.hoverPoints;
	        a = "object" === typeof a ? a : {
	          enabled: a,
	          type: "x"
	        };
	        var e = c.options.chart,
	          h = c.options.mapNavigation && c.options.mapNavigation.enabled;
	        e && e.panning && (e.panning = a);
	        var g = a.type,
	          f;
	        Q(this, "pan", {
	          originalEvent: b
	        }, function () {
	          d && d.forEach(function (b) {
	            b.setState();
	          });
	          var a = c.xAxis;
	          "xy" === g ? a = a.concat(c.yAxis) : "y" === g && (a = c.yAxis);
	          var e = {};
	          a.forEach(function (a) {
	            if (a.options.panningEnabled && !a.options.isInternal) {
	              var d = a.horiz,
	                l = b[d ? "chartX" : "chartY"];
	              d = d ? "mouseDownX" : "mouseDownY";
	              var k = c[d],
	                m = a.minPointOffset || 0,
	                p = a.reversed && !c.inverted || !a.reversed && c.inverted ? -1 : 1,
	                G = a.getExtremes(),
	                n = a.toValue(k - l, !0) + m * p,
	                q = a.toValue(k + a.len - l, !0) - (m * p || a.isXAxis && a.pointRangePadding || 0),
	                r = q < n;
	              p = a.hasVerticalPanning();
	              k = r ? q : n;
	              n = r ? n : q;
	              var t = a.panningState;
	              !p || a.isXAxis || t && !t.isDirty || a.series.forEach(function (b) {
	                var a = b.getProcessedData(!0);
	                a = b.getExtremes(a.yData, !0);
	                t || (t = {
	                  startMin: Number.MAX_VALUE,
	                  startMax: -Number.MAX_VALUE
	                });
	                T(a.dataMin) && T(a.dataMax) && (t.startMin = Math.min(R(b.options.threshold, Infinity), a.dataMin, t.startMin), t.startMax = Math.max(R(b.options.threshold, -Infinity), a.dataMax, t.startMax));
	              });
	              p = Math.min(R(t && t.startMin, G.dataMin), m ? G.min : a.toValue(a.toPixels(G.min) - a.minPixelPadding));
	              q = Math.max(R(t && t.startMax, G.dataMax), m ? G.max : a.toValue(a.toPixels(G.max) + a.minPixelPadding));
	              a.panningState = t;
	              a.isOrdinal || (m = p - k, 0 < m && (n += m, k = p), m = n - q, 0 < m && (n = q, k -= m), a.series.length && k !== G.min && n !== G.max && k >= p && n <= q && (a.setExtremes(k, n, !1, !1, {
	                trigger: "pan"
	              }), c.resetZoomButton || h || k === p || n === q || !g.match("y") || (c.showResetZoom(), a.displayBtn = !1), f = !0), e[d] = l);
	            }
	          });
	          Z(e, function (b, a) {
	            c[a] = b;
	          });
	          f && c.redraw(!1);
	          N(c.container, {
	            cursor: "move"
	          });
	        });
	      };
	      return a;
	    }();
	    K(a.prototype, {
	      callbacks: [],
	      collectionsWithInit: {
	        xAxis: [a.prototype.addAxis, [!0]],
	        yAxis: [a.prototype.addAxis, [!1]],
	        series: [a.prototype.addSeries]
	      },
	      collectionsWithUpdate: ["xAxis", "yAxis", "series"],
	      propsRequireDirtyBox: "backgroundColor borderColor borderWidth borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow".split(" "),
	      propsRequireReflow: "margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft".split(" "),
	      propsRequireUpdateSeries: "chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip".split(" ")
	    });
	    return a;
	  });
	  K(f, "Core/Legend/LegendSymbol.js", [f["Core/Utilities.js"]], function (a) {
	    var f = a.merge,
	      B = a.pick,
	      H;
	    (function (a) {
	      a.drawLineMarker = function (a) {
	        var w = this.options,
	          A = a.symbolWidth,
	          u = a.symbolHeight,
	          n = u / 2,
	          k = this.chart.renderer,
	          e = this.legendGroup;
	        a = a.baseline - Math.round(.3 * a.fontMetrics.b);
	        var c = {},
	          p = w.marker;
	        this.chart.styledMode || (c = {
	          "stroke-width": w.lineWidth || 0
	        }, w.dashStyle && (c.dashstyle = w.dashStyle));
	        this.legendLine = k.path([["M", 0, a], ["L", A, a]]).addClass("highcharts-graph").attr(c).add(e);
	        p && !1 !== p.enabled && A && (w = Math.min(B(p.radius, n), n), 0 === this.symbol.indexOf("url") && (p = f(p, {
	          width: u,
	          height: u
	        }), w = 0), this.legendSymbol = A = k.symbol(this.symbol, A / 2 - w, a - w, 2 * w, 2 * w, p).addClass("highcharts-point").add(e), A.isMarker = !0);
	      };
	      a.drawRectangle = function (a, f) {
	        var w = a.symbolHeight,
	          u = a.options.squareSymbol;
	        f.legendSymbol = this.chart.renderer.rect(u ? (a.symbolWidth - w) / 2 : 0, a.baseline - w + 1, u ? w : a.symbolWidth, w, B(a.options.symbolRadius, w / 2)).addClass("highcharts-point").attr({
	          zIndex: 3
	        }).add(f.legendGroup);
	      };
	    })(H || (H = {}));
	    return H;
	  });
	  K(f, "Core/Series/SeriesDefaults.js", [], function () {
	    return {
	      lineWidth: 2,
	      allowPointSelect: !1,
	      crisp: !0,
	      showCheckbox: !1,
	      animation: {
	        duration: 1E3
	      },
	      events: {},
	      marker: {
	        enabledThreshold: 2,
	        lineColor: "#ffffff",
	        lineWidth: 0,
	        radius: 4,
	        states: {
	          normal: {
	            animation: !0
	          },
	          hover: {
	            animation: {
	              duration: 50
	            },
	            enabled: !0,
	            radiusPlus: 2,
	            lineWidthPlus: 1
	          },
	          select: {
	            fillColor: "#cccccc",
	            lineColor: "#000000",
	            lineWidth: 2
	          }
	        }
	      },
	      point: {
	        events: {}
	      },
	      dataLabels: {
	        animation: {},
	        align: "center",
	        defer: !0,
	        formatter: function () {
	          var a = this.series.chart.numberFormatter;
	          return "number" !== typeof this.y ? "" : a(this.y, -1);
	        },
	        padding: 5,
	        style: {
	          fontSize: "11px",
	          fontWeight: "bold",
	          color: "contrast",
	          textOutline: "1px contrast"
	        },
	        verticalAlign: "bottom",
	        x: 0,
	        y: 0
	      },
	      cropThreshold: 300,
	      opacity: 1,
	      pointRange: 0,
	      softThreshold: !0,
	      states: {
	        normal: {
	          animation: !0
	        },
	        hover: {
	          animation: {
	            duration: 50
	          },
	          lineWidthPlus: 1,
	          marker: {},
	          halo: {
	            size: 10,
	            opacity: .25
	          }
	        },
	        select: {
	          animation: {
	            duration: 0
	          }
	        },
	        inactive: {
	          animation: {
	            duration: 50
	          },
	          opacity: .2
	        }
	      },
	      stickyTracking: !0,
	      turboThreshold: 1E3,
	      findNearestPointBy: "x"
	    };
	  });
	  K(f, "Core/Series/Series.js", [f["Core/Animation/AnimationUtilities.js"], f["Core/DefaultOptions.js"], f["Core/Foundation.js"], f["Core/Globals.js"], f["Core/Legend/LegendSymbol.js"], f["Core/Series/Point.js"], f["Core/Series/SeriesDefaults.js"], f["Core/Series/SeriesRegistry.js"], f["Core/Renderer/SVG/SVGElement.js"], f["Core/Utilities.js"]], function (a, f, B, H, w, E, I, A, u, n) {
	    var k = a.animObject,
	      e = a.setAnimation,
	      c = f.defaultOptions,
	      p = B.registerEventOptions,
	      g = H.hasTouch,
	      t = H.svg,
	      q = H.win,
	      F = A.seriesTypes,
	      y = n.addEvent,
	      x = n.arrayMax,
	      z = n.arrayMin,
	      m = n.clamp,
	      h = n.cleanRecursively,
	      b = n.correctFloat,
	      l = n.defined,
	      d = n.erase,
	      D = n.error,
	      v = n.extend,
	      r = n.find,
	      C = n.fireEvent,
	      P = n.getNestedProperty,
	      S = n.isArray,
	      N = n.isNumber,
	      Y = n.isString,
	      X = n.merge,
	      J = n.objectEach,
	      L = n.pick,
	      K = n.removeEvent,
	      da = n.splat,
	      Q = n.syncTimeout;
	    a = function () {
	      function a() {
	        this.zones = this.yAxis = this.xAxis = this.userOptions = this.tooltipOptions = this.processedYData = this.processedXData = this.points = this.options = this.linkedSeries = this.index = this.eventsToUnbind = this.eventOptions = this.data = this.chart = this._i = void 0;
	      }
	      a.prototype.init = function (b, a) {
	        C(this, "init", {
	          options: a
	        });
	        var c = this,
	          d = b.series;
	        this.eventsToUnbind = [];
	        c.chart = b;
	        c.options = c.setOptions(a);
	        a = c.options;
	        c.linkedSeries = [];
	        c.bindAxes();
	        v(c, {
	          name: a.name,
	          state: "",
	          visible: !1 !== a.visible,
	          selected: !0 === a.selected
	        });
	        p(this, a);
	        var e = a.events;
	        if (e && e.click || a.point && a.point.events && a.point.events.click || a.allowPointSelect) b.runTrackerClick = !0;
	        c.getColor();
	        c.getSymbol();
	        c.parallelArrays.forEach(function (b) {
	          c[b + "Data"] || (c[b + "Data"] = []);
	        });
	        c.isCartesian && (b.hasCartesianSeries = !0);
	        var h;
	        d.length && (h = d[d.length - 1]);
	        c._i = L(h && h._i, -1) + 1;
	        c.opacity = c.options.opacity;
	        b.orderSeries(this.insert(d));
	        a.dataSorting && a.dataSorting.enabled ? c.setDataSortingOptions() : c.points || c.data || c.setData(a.data, !1);
	        C(this, "afterInit");
	      };
	      a.prototype.is = function (b) {
	        return F[b] && this instanceof F[b];
	      };
	      a.prototype.insert = function (b) {
	        var a = this.options.index,
	          c;
	        if (N(a)) {
	          for (c = b.length; c--;) if (a >= L(b[c].options.index, b[c]._i)) {
	            b.splice(c + 1, 0, this);
	            break;
	          }
	          -1 === c && b.unshift(this);
	          c += 1;
	        } else b.push(this);
	        return L(c, b.length - 1);
	      };
	      a.prototype.bindAxes = function () {
	        var b = this,
	          a = b.options,
	          c = b.chart,
	          d;
	        C(this, "bindAxes", null, function () {
	          (b.axisTypes || []).forEach(function (e) {
	            var h = 0;
	            c[e].forEach(function (c) {
	              d = c.options;
	              if (a[e] === h && !d.isInternal || "undefined" !== typeof a[e] && a[e] === d.id || "undefined" === typeof a[e] && 0 === d.index) b.insert(c.series), b[e] = c, c.isDirty = !0;
	              d.isInternal || h++;
	            });
	            b[e] || b.optionalAxis === e || D(18, !0, c);
	          });
	        });
	        C(this, "afterBindAxes");
	      };
	      a.prototype.updateParallelArrays = function (b, a) {
	        var c = b.series,
	          d = arguments,
	          e = N(a) ? function (d) {
	            var e = "y" === d && c.toYData ? c.toYData(b) : b[d];
	            c[d + "Data"][a] = e;
	          } : function (b) {
	            Array.prototype[a].apply(c[b + "Data"], Array.prototype.slice.call(d, 2));
	          };
	        c.parallelArrays.forEach(e);
	      };
	      a.prototype.hasData = function () {
	        return this.visible && "undefined" !== typeof this.dataMax && "undefined" !== typeof this.dataMin || this.visible && this.yData && 0 < this.yData.length;
	      };
	      a.prototype.autoIncrement = function (b) {
	        var a = this.options,
	          c = a.pointIntervalUnit,
	          d = a.relativeXValue,
	          e = this.chart.time,
	          h = this.xIncrement,
	          g;
	        h = L(h, a.pointStart, 0);
	        this.pointInterval = g = L(this.pointInterval, a.pointInterval, 1);
	        d && N(b) && (g *= b);
	        c && (a = new e.Date(h), "day" === c ? e.set("Date", a, e.get("Date", a) + g) : "month" === c ? e.set("Month", a, e.get("Month", a) + g) : "year" === c && e.set("FullYear", a, e.get("FullYear", a) + g), g = a.getTime() - h);
	        if (d && N(b)) return h + g;
	        this.xIncrement = h + g;
	        return h;
	      };
	      a.prototype.setDataSortingOptions = function () {
	        var b = this.options;
	        v(this, {
	          requireSorting: !1,
	          sorted: !1,
	          enabledDataSorting: !0,
	          allowDG: !1
	        });
	        l(b.pointRange) || (b.pointRange = 1);
	      };
	      a.prototype.setOptions = function (b) {
	        var a = this.chart,
	          d = a.options,
	          e = d.plotOptions,
	          h = a.userOptions || {};
	        b = X(b);
	        a = a.styledMode;
	        var g = {
	          plotOptions: e,
	          userOptions: b
	        };
	        C(this, "setOptions", g);
	        var f = g.plotOptions[this.type],
	          k = h.plotOptions || {};
	        this.userOptions = g.userOptions;
	        h = X(f, e.series, h.plotOptions && h.plotOptions[this.type], b);
	        this.tooltipOptions = X(c.tooltip, c.plotOptions.series && c.plotOptions.series.tooltip, c.plotOptions[this.type].tooltip, d.tooltip.userOptions, e.series && e.series.tooltip, e[this.type].tooltip, b.tooltip);
	        this.stickyTracking = L(b.stickyTracking, k[this.type] && k[this.type].stickyTracking, k.series && k.series.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? !0 : h.stickyTracking);
	        null === f.marker && delete h.marker;
	        this.zoneAxis = h.zoneAxis;
	        e = this.zones = (h.zones || []).slice();
	        !h.negativeColor && !h.negativeFillColor || h.zones || (d = {
	          value: h[this.zoneAxis + "Threshold"] || h.threshold || 0,
	          className: "highcharts-negative"
	        }, a || (d.color = h.negativeColor, d.fillColor = h.negativeFillColor), e.push(d));
	        e.length && l(e[e.length - 1].value) && e.push(a ? {} : {
	          color: this.color,
	          fillColor: this.fillColor
	        });
	        C(this, "afterSetOptions", {
	          options: h
	        });
	        return h;
	      };
	      a.prototype.getName = function () {
	        return L(this.options.name, "Series " + (this.index + 1));
	      };
	      a.prototype.getCyclic = function (b, a, c) {
	        var d = this.chart,
	          e = this.userOptions,
	          h = b + "Index",
	          g = b + "Counter",
	          f = c ? c.length : L(d.options.chart[b + "Count"], d[b + "Count"]);
	        if (!a) {
	          var k = L(e[h], e["_" + h]);
	          l(k) || (d.series.length || (d[g] = 0), e["_" + h] = k = d[g] % f, d[g] += 1);
	          c && (a = c[k]);
	        }
	        "undefined" !== typeof k && (this[h] = k);
	        this[b] = a;
	      };
	      a.prototype.getColor = function () {
	        this.chart.styledMode ? this.getCyclic("color") : this.options.colorByPoint ? this.color = "#cccccc" : this.getCyclic("color", this.options.color || c.plotOptions[this.type].color, this.chart.options.colors);
	      };
	      a.prototype.getPointsCollection = function () {
	        return (this.hasGroupedData ? this.points : this.data) || [];
	      };
	      a.prototype.getSymbol = function () {
	        this.getCyclic("symbol", this.options.marker.symbol, this.chart.options.symbols);
	      };
	      a.prototype.findPointIndex = function (b, a) {
	        var c = b.id,
	          d = b.x,
	          e = this.points,
	          h = this.options.dataSorting,
	          g,
	          f;
	        if (c) h = this.chart.get(c), h instanceof E && (g = h);else if (this.linkedParent || this.enabledDataSorting || this.options.relativeXValue) if (g = function (a) {
	          return !a.touched && a.index === b.index;
	        }, h && h.matchByName ? g = function (a) {
	          return !a.touched && a.name === b.name;
	        } : this.options.relativeXValue && (g = function (a) {
	          return !a.touched && a.options.x === b.x;
	        }), g = r(e, g), !g) return;
	        if (g) {
	          var l = g && g.index;
	          "undefined" !== typeof l && (f = !0);
	        }
	        "undefined" === typeof l && N(d) && (l = this.xData.indexOf(d, a));
	        -1 !== l && "undefined" !== typeof l && this.cropped && (l = l >= this.cropStart ? l - this.cropStart : l);
	        !f && N(l) && e[l] && e[l].touched && (l = void 0);
	        return l;
	      };
	      a.prototype.updateData = function (b, a) {
	        var c = this.options,
	          d = c.dataSorting,
	          e = this.points,
	          h = [],
	          g = this.requireSorting,
	          f = b.length === e.length,
	          k,
	          m,
	          p,
	          n = !0;
	        this.xIncrement = null;
	        b.forEach(function (b, a) {
	          var m = l(b) && this.pointClass.prototype.optionsToObject.call({
	              series: this
	            }, b) || {},
	            n = m.x;
	          if (m.id || N(n)) {
	            if (m = this.findPointIndex(m, p), -1 === m || "undefined" === typeof m ? h.push(b) : e[m] && b !== c.data[m] ? (e[m].update(b, !1, null, !1), e[m].touched = !0, g && (p = m + 1)) : e[m] && (e[m].touched = !0), !f || a !== m || d && d.enabled || this.hasDerivedData) k = !0;
	          } else h.push(b);
	        }, this);
	        if (k) for (b = e.length; b--;) (m = e[b]) && !m.touched && m.remove && m.remove(!1, a);else !f || d && d.enabled ? n = !1 : (b.forEach(function (b, a) {
	          b !== e[a].y && e[a].update && e[a].update(b, !1, null, !1);
	        }), h.length = 0);
	        e.forEach(function (b) {
	          b && (b.touched = !1);
	        });
	        if (!n) return !1;
	        h.forEach(function (b) {
	          this.addPoint(b, !1, null, null, !1);
	        }, this);
	        null === this.xIncrement && this.xData && this.xData.length && (this.xIncrement = x(this.xData), this.autoIncrement());
	        return !0;
	      };
	      a.prototype.setData = function (b, a, c, d) {
	        var e = this,
	          h = e.points,
	          g = h && h.length || 0,
	          f = e.options,
	          l = e.chart,
	          k = f.dataSorting,
	          m = e.xAxis,
	          p = f.turboThreshold,
	          n = this.xData,
	          q = this.yData,
	          r = e.pointArrayMap;
	        r = r && r.length;
	        var G = f.keys,
	          t,
	          y = 0,
	          z = 1,
	          x = null;
	        if (!l.options.chart.allowMutatingData) {
	          f.data && delete e.options.data;
	          e.userOptions.data && delete e.userOptions.data;
	          var v = X(!0, b);
	        }
	        b = v || b || [];
	        v = b.length;
	        a = L(a, !0);
	        k && k.enabled && (b = this.sortData(b));
	        l.options.chart.allowMutatingData && !1 !== d && v && g && !e.cropped && !e.hasGroupedData && e.visible && !e.isSeriesBoosting && (t = this.updateData(b, c));
	        if (!t) {
	          e.xIncrement = null;
	          e.colorCounter = 0;
	          this.parallelArrays.forEach(function (b) {
	            e[b + "Data"].length = 0;
	          });
	          if (p && v > p) {
	            if (x = e.getFirstValidPoint(b), N(x)) for (c = 0; c < v; c++) n[c] = this.autoIncrement(), q[c] = b[c];else if (S(x)) {
	              if (r) {
	                if (x.length === r) for (c = 0; c < v; c++) n[c] = this.autoIncrement(), q[c] = b[c];else for (c = 0; c < v; c++) d = b[c], n[c] = d[0], q[c] = d.slice(1, r + 1);
	              } else if (G && (y = G.indexOf("x"), z = G.indexOf("y"), y = 0 <= y ? y : 0, z = 0 <= z ? z : 1), 1 === x.length && (z = 0), y === z) for (c = 0; c < v; c++) n[c] = this.autoIncrement(), q[c] = b[c][z];else for (c = 0; c < v; c++) d = b[c], n[c] = d[y], q[c] = d[z];
	            } else D(12, !1, l);
	          } else for (c = 0; c < v; c++) "undefined" !== typeof b[c] && (d = {
	            series: e
	          }, e.pointClass.prototype.applyOptions.apply(d, [b[c]]), e.updateParallelArrays(d, c));
	          q && Y(q[0]) && D(14, !0, l);
	          e.data = [];
	          e.options.data = e.userOptions.data = b;
	          for (c = g; c--;) h[c] && h[c].destroy && h[c].destroy();
	          m && (m.minRange = m.userMinRange);
	          e.isDirty = l.isDirtyBox = !0;
	          e.isDirtyData = !!h;
	          c = !1;
	        }
	        "point" === f.legendType && (this.processData(), this.generatePoints());
	        a && l.redraw(c);
	      };
	      a.prototype.sortData = function (b) {
	        var a = this,
	          c = a.options.dataSorting.sortKey || "y",
	          d = function (b, a) {
	            return l(a) && b.pointClass.prototype.optionsToObject.call({
	              series: b
	            }, a) || {};
	          };
	        b.forEach(function (c, e) {
	          b[e] = d(a, c);
	          b[e].index = e;
	        }, this);
	        b.concat().sort(function (b, a) {
	          b = P(c, b);
	          a = P(c, a);
	          return a < b ? -1 : a > b ? 1 : 0;
	        }).forEach(function (b, a) {
	          b.x = a;
	        }, this);
	        a.linkedSeries && a.linkedSeries.forEach(function (a) {
	          var c = a.options,
	            e = c.data;
	          c.dataSorting && c.dataSorting.enabled || !e || (e.forEach(function (c, h) {
	            e[h] = d(a, c);
	            b[h] && (e[h].x = b[h].x, e[h].index = h);
	          }), a.setData(e, !1));
	        });
	        return b;
	      };
	      a.prototype.getProcessedData = function (b) {
	        var a = this.xAxis,
	          c = this.options,
	          d = c.cropThreshold,
	          e = b || this.getExtremesFromAll || c.getExtremesFromAll,
	          h = this.isCartesian;
	        b = a && a.val2lin;
	        c = !(!a || !a.logarithmic);
	        var g = 0,
	          f = this.xData,
	          l = this.yData,
	          k = this.requireSorting;
	        var m = !1;
	        var p = f.length;
	        if (a) {
	          m = a.getExtremes();
	          var n = m.min;
	          var q = m.max;
	          m = !(!a.categories || a.names.length);
	        }
	        if (h && this.sorted && !e && (!d || p > d || this.forceCrop)) if (f[p - 1] < n || f[0] > q) f = [], l = [];else if (this.yData && (f[0] < n || f[p - 1] > q)) {
	          var r = this.cropData(this.xData, this.yData, n, q);
	          f = r.xData;
	          l = r.yData;
	          g = r.start;
	          r = !0;
	        }
	        for (d = f.length || 1; --d;) if (a = c ? b(f[d]) - b(f[d - 1]) : f[d] - f[d - 1], 0 < a && ("undefined" === typeof G || a < G)) var G = a;else 0 > a && k && !m && (D(15, !1, this.chart), k = !1);
	        return {
	          xData: f,
	          yData: l,
	          cropped: r,
	          cropStart: g,
	          closestPointRange: G
	        };
	      };
	      a.prototype.processData = function (b) {
	        var a = this.xAxis;
	        if (this.isCartesian && !this.isDirty && !a.isDirty && !this.yAxis.isDirty && !b) return !1;
	        b = this.getProcessedData();
	        this.cropped = b.cropped;
	        this.cropStart = b.cropStart;
	        this.processedXData = b.xData;
	        this.processedYData = b.yData;
	        this.closestPointRange = this.basePointRange = b.closestPointRange;
	        C(this, "afterProcessData");
	      };
	      a.prototype.cropData = function (b, a, c, d, e) {
	        var h = b.length,
	          g,
	          f = 0,
	          l = h;
	        e = L(e, this.cropShoulder);
	        for (g = 0; g < h; g++) if (b[g] >= c) {
	          f = Math.max(0, g - e);
	          break;
	        }
	        for (c = g; c < h; c++) if (b[c] > d) {
	          l = c + e;
	          break;
	        }
	        return {
	          xData: b.slice(f, l),
	          yData: a.slice(f, l),
	          start: f,
	          end: l
	        };
	      };
	      a.prototype.generatePoints = function () {
	        var b = this.options,
	          a = this.processedData || b.data,
	          c = this.processedXData,
	          d = this.processedYData,
	          e = this.pointClass,
	          h = c.length,
	          g = this.cropStart || 0,
	          f = this.hasGroupedData,
	          l = b.keys,
	          k = [];
	        b = b.dataGrouping && b.dataGrouping.groupAll ? g : 0;
	        var m,
	          p,
	          n = this.data;
	        if (!n && !f) {
	          var q = [];
	          q.length = a.length;
	          n = this.data = q;
	        }
	        l && f && (this.options.keys = !1);
	        for (p = 0; p < h; p++) {
	          q = g + p;
	          if (f) {
	            var r = new e().init(this, [c[p]].concat(da(d[p])));
	            r.dataGroup = this.groupMap[b + p];
	            r.dataGroup.options && (r.options = r.dataGroup.options, v(r, r.dataGroup.options), delete r.dataLabels);
	          } else (r = n[q]) || "undefined" === typeof a[q] || (n[q] = r = new e().init(this, a[q], c[p]));
	          r && (r.index = f ? b + p : q, k[p] = r);
	        }
	        this.options.keys = l;
	        if (n && (h !== (m = n.length) || f)) for (p = 0; p < m; p++) p !== g || f || (p += h), n[p] && (n[p].destroyElements(), n[p].plotX = void 0);
	        this.data = n;
	        this.points = k;
	        C(this, "afterGeneratePoints");
	      };
	      a.prototype.getXExtremes = function (b) {
	        return {
	          min: z(b),
	          max: x(b)
	        };
	      };
	      a.prototype.getExtremes = function (b, a) {
	        var c = this.xAxis,
	          d = this.yAxis,
	          e = this.processedXData || this.xData,
	          h = [],
	          g = this.requireSorting ? this.cropShoulder : 0;
	        d = d ? d.positiveValuesOnly : !1;
	        var f,
	          l = 0,
	          k = 0,
	          m = 0;
	        b = b || this.stackedYData || this.processedYData || [];
	        var p = b.length;
	        if (c) {
	          var n = c.getExtremes();
	          l = n.min;
	          k = n.max;
	        }
	        for (f = 0; f < p; f++) {
	          var q = e[f];
	          n = b[f];
	          var r = (N(n) || S(n)) && (n.length || 0 < n || !d);
	          q = a || this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !c || (e[f + g] || q) >= l && (e[f - g] || q) <= k;
	          if (r && q) if (r = n.length) for (; r--;) N(n[r]) && (h[m++] = n[r]);else h[m++] = n;
	        }
	        b = {
	          activeYData: h,
	          dataMin: z(h),
	          dataMax: x(h)
	        };
	        C(this, "afterGetExtremes", {
	          dataExtremes: b
	        });
	        return b;
	      };
	      a.prototype.applyExtremes = function () {
	        var b = this.getExtremes();
	        this.dataMin = b.dataMin;
	        this.dataMax = b.dataMax;
	        return b;
	      };
	      a.prototype.getFirstValidPoint = function (b) {
	        for (var a = b.length, c = 0, d = null; null === d && c < a;) d = b[c], c++;
	        return d;
	      };
	      a.prototype.translate = function () {
	        this.processedXData || this.processData();
	        this.generatePoints();
	        var a = this.options,
	          c = a.stacking,
	          d = this.xAxis,
	          e = d.categories,
	          h = this.enabledDataSorting,
	          g = this.yAxis,
	          f = this.points,
	          k = f.length,
	          p = this.pointPlacementToXValue(),
	          n = !!p,
	          q = a.threshold,
	          r = a.startFromThreshold ? q : 0,
	          t = this.zoneAxis || "y",
	          y,
	          z,
	          x = Number.MAX_VALUE;
	        for (y = 0; y < k; y++) {
	          var v = f[y],
	            F = v.x,
	            u = void 0,
	            D = void 0,
	            w = v.y,
	            A = v.low,
	            B = c && g.stacking && g.stacking.stacks[(this.negStacks && w < (r ? 0 : q) ? "-" : "") + this.stackKey];
	          if (g.positiveValuesOnly && !g.validatePositiveValue(w) || d.positiveValuesOnly && !d.validatePositiveValue(F)) v.isNull = !0;
	          v.plotX = z = b(m(d.translate(F, 0, 0, 0, 1, p, "flags" === this.type), -1E5, 1E5));
	          if (c && this.visible && B && B[F]) {
	            var H = this.getStackIndicator(H, F, this.index);
	            v.isNull || (u = B[F], D = u.points[H.key]);
	          }
	          S(D) && (A = D[0], w = D[1], A === r && H.key === B[F].base && (A = L(N(q) && q, g.min)), g.positiveValuesOnly && 0 >= A && (A = null), v.total = v.stackTotal = u.total, v.percentage = u.total && v.y / u.total * 100, v.stackY = w, this.irregularWidths || u.setOffset(this.pointXOffset || 0, this.barW || 0));
	          v.yBottom = l(A) ? m(g.translate(A, 0, 1, 0, 1), -1E5, 1E5) : null;
	          this.dataModify && (w = this.dataModify.modifyValue(w, y));
	          v.plotY = void 0;
	          N(w) && (u = g.translate(w, !1, !0, !1, !0), "undefined" !== typeof u && (v.plotY = m(u, -1E5, 1E5)));
	          v.isInside = this.isPointInside(v);
	          v.clientX = n ? b(d.translate(F, 0, 0, 0, 1, p)) : z;
	          v.negative = v[t] < (a[t + "Threshold"] || q || 0);
	          v.category = L(e && e[v.x], v.x);
	          if (!v.isNull && !1 !== v.visible) {
	            "undefined" !== typeof I && (x = Math.min(x, Math.abs(z - I)));
	            var I = z;
	          }
	          v.zone = this.zones.length ? v.getZone() : void 0;
	          !v.graphic && this.group && h && (v.isNew = !0);
	        }
	        this.closestPointRangePx = x;
	        C(this, "afterTranslate");
	      };
	      a.prototype.getValidPoints = function (b, a, c) {
	        var d = this.chart;
	        return (b || this.points || []).filter(function (b) {
	          return a && !d.isInsidePlot(b.plotX, b.plotY, {
	            inverted: d.inverted
	          }) ? !1 : !1 !== b.visible && (c || !b.isNull);
	        });
	      };
	      a.prototype.getClipBox = function () {
	        var b = this.chart,
	          a = this.xAxis,
	          c = this.yAxis,
	          d = X(b.clipBox);
	        a && a.len !== b.plotSizeX && (d.width = a.len);
	        c && c.len !== b.plotSizeY && (d.height = c.len);
	        return d;
	      };
	      a.prototype.getSharedClipKey = function () {
	        return this.sharedClipKey = (this.options.xAxis || 0) + "," + (this.options.yAxis || 0);
	      };
	      a.prototype.setClip = function () {
	        var b = this.chart,
	          a = this.group,
	          c = this.markerGroup,
	          d = b.sharedClips;
	        b = b.renderer;
	        var e = this.getClipBox(),
	          h = this.getSharedClipKey(),
	          g = d[h];
	        g ? g.animate(e) : d[h] = g = b.clipRect(e);
	        a && a.clip(!1 === this.options.clip ? void 0 : g);
	        c && c.clip();
	      };
	      a.prototype.animate = function (b) {
	        var a = this.chart,
	          c = this.group,
	          d = this.markerGroup,
	          e = a.inverted,
	          h = k(this.options.animation),
	          g = [this.getSharedClipKey(), h.duration, h.easing, h.defer].join(),
	          f = a.sharedClips[g],
	          l = a.sharedClips[g + "m"];
	        if (b && c) h = this.getClipBox(), f ? f.attr("height", h.height) : (h.width = 0, e && (h.x = a.plotHeight), f = a.renderer.clipRect(h), a.sharedClips[g] = f, l = a.renderer.clipRect({
	          x: e ? (a.plotSizeX || 0) + 99 : -99,
	          y: e ? -a.plotLeft : -a.plotTop,
	          width: 99,
	          height: e ? a.chartWidth : a.chartHeight
	        }), a.sharedClips[g + "m"] = l), c.clip(f), d && d.clip(l);else if (f && !f.hasClass("highcharts-animating")) {
	          a = this.getClipBox();
	          var m = h.step;
	          d && d.element.childNodes.length && (h.step = function (b, a) {
	            m && m.apply(a, arguments);
	            l && l.element && l.attr(a.prop, "width" === a.prop ? b + 99 : b);
	          });
	          f.addClass("highcharts-animating").animate(a, h);
	        }
	      };
	      a.prototype.afterAnimate = function () {
	        var b = this;
	        this.setClip();
	        J(this.chart.sharedClips, function (a, c, d) {
	          a && !b.chart.container.querySelector('[clip-path="url(#' + a.id + ')"]') && (a.destroy(), delete d[c]);
	        });
	        this.finishedAnimating = !0;
	        C(this, "afterAnimate");
	      };
	      a.prototype.drawPoints = function () {
	        var b = this.points,
	          a = this.chart,
	          c = this.options.marker,
	          d = this[this.specialGroup] || this.markerGroup,
	          e = this.xAxis,
	          h = L(c.enabled, !e || e.isRadial ? !0 : null, this.closestPointRangePx >= c.enabledThreshold * c.radius),
	          g,
	          f;
	        if (!1 !== c.enabled || this._hasPointMarkers) for (g = 0; g < b.length; g++) {
	          var l = b[g];
	          var k = (f = l.graphic) ? "animate" : "attr";
	          var m = l.marker || {};
	          var p = !!l.marker;
	          if ((h && "undefined" === typeof m.enabled || m.enabled) && !l.isNull && !1 !== l.visible) {
	            var n = L(m.symbol, this.symbol, "rect");
	            var q = this.markerAttribs(l, l.selected && "select");
	            this.enabledDataSorting && (l.startXPos = e.reversed ? -(q.width || 0) : e.width);
	            var r = !1 !== l.isInside;
	            f ? f[r ? "show" : "hide"](r).animate(q) : r && (0 < (q.width || 0) || l.hasImage) && (l.graphic = f = a.renderer.symbol(n, q.x, q.y, q.width, q.height, p ? m : c).add(d), this.enabledDataSorting && a.hasRendered && (f.attr({
	              x: l.startXPos
	            }), k = "animate"));
	            f && "animate" === k && f[r ? "show" : "hide"](r).animate(q);
	            if (f && !a.styledMode) f[k](this.pointAttribs(l, l.selected && "select"));
	            f && f.addClass(l.getClassName(), !0);
	          } else f && (l.graphic = f.destroy());
	        }
	      };
	      a.prototype.markerAttribs = function (b, a) {
	        var c = this.options,
	          d = c.marker,
	          e = b.marker || {},
	          h = e.symbol || d.symbol,
	          g = L(e.radius, d && d.radius);
	        a && (d = d.states[a], a = e.states && e.states[a], g = L(a && a.radius, d && d.radius, g && g + (d && d.radiusPlus || 0)));
	        b.hasImage = h && 0 === h.indexOf("url");
	        b.hasImage && (g = 0);
	        b = N(g) ? {
	          x: c.crisp ? Math.floor(b.plotX - g) : b.plotX - g,
	          y: b.plotY - g
	        } : {};
	        g && (b.width = b.height = 2 * g);
	        return b;
	      };
	      a.prototype.pointAttribs = function (b, a) {
	        var c = this.options.marker,
	          d = b && b.options,
	          e = d && d.marker || {},
	          h = d && d.color,
	          g = b && b.color,
	          f = b && b.zone && b.zone.color,
	          l = this.color;
	        b = L(e.lineWidth, c.lineWidth);
	        d = 1;
	        l = h || f || g || l;
	        h = e.fillColor || c.fillColor || l;
	        g = e.lineColor || c.lineColor || l;
	        a = a || "normal";
	        c = c.states[a] || {};
	        a = e.states && e.states[a] || {};
	        b = L(a.lineWidth, c.lineWidth, b + L(a.lineWidthPlus, c.lineWidthPlus, 0));
	        h = a.fillColor || c.fillColor || h;
	        g = a.lineColor || c.lineColor || g;
	        d = L(a.opacity, c.opacity, d);
	        return {
	          stroke: g,
	          "stroke-width": b,
	          fill: h,
	          opacity: d
	        };
	      };
	      a.prototype.destroy = function (b) {
	        var a = this,
	          c = a.chart,
	          e = /AppleWebKit\/533/.test(q.navigator.userAgent),
	          h = a.data || [],
	          g,
	          f,
	          l,
	          k;
	        C(a, "destroy", {
	          keepEventsForUpdate: b
	        });
	        this.removeEvents(b);
	        (a.axisTypes || []).forEach(function (b) {
	          (k = a[b]) && k.series && (d(k.series, a), k.isDirty = k.forceRedraw = !0);
	        });
	        a.legendItem && a.chart.legend.destroyItem(a);
	        for (f = h.length; f--;) (l = h[f]) && l.destroy && l.destroy();
	        a.clips && a.clips.forEach(function (b) {
	          return b.destroy();
	        });
	        n.clearTimeout(a.animationTimeout);
	        J(a, function (b, a) {
	          b instanceof u && !b.survive && (g = e && "group" === a ? "hide" : "destroy", b[g]());
	        });
	        c.hoverSeries === a && (c.hoverSeries = void 0);
	        d(c.series, a);
	        c.orderSeries();
	        J(a, function (c, d) {
	          b && "hcEvents" === d || delete a[d];
	        });
	      };
	      a.prototype.applyZones = function () {
	        var b = this,
	          a = this.chart,
	          c = a.renderer,
	          d = this.zones,
	          e = this.clips || [],
	          h = this.graph,
	          g = this.area,
	          f = Math.max(a.chartWidth, a.chartHeight),
	          l = this[(this.zoneAxis || "y") + "Axis"],
	          k = a.inverted,
	          p,
	          n,
	          q,
	          r,
	          t,
	          y,
	          v,
	          z,
	          x = !1;
	        if (d.length && (h || g) && l && "undefined" !== typeof l.min) {
	          var F = l.reversed;
	          var u = l.horiz;
	          h && !this.showLine && h.hide();
	          g && g.hide();
	          var D = l.getExtremes();
	          d.forEach(function (d, G) {
	            p = F ? u ? a.plotWidth : 0 : u ? 0 : l.toPixels(D.min) || 0;
	            p = m(L(n, p), 0, f);
	            n = m(Math.round(l.toPixels(L(d.value, D.max), !0) || 0), 0, f);
	            x && (p = n = l.toPixels(D.max));
	            r = Math.abs(p - n);
	            t = Math.min(p, n);
	            y = Math.max(p, n);
	            l.isXAxis ? (q = {
	              x: k ? y : t,
	              y: 0,
	              width: r,
	              height: f
	            }, u || (q.x = a.plotHeight - q.x)) : (q = {
	              x: 0,
	              y: k ? y : t,
	              width: f,
	              height: r
	            }, u && (q.y = a.plotWidth - q.y));
	            k && c.isVML && (q = l.isXAxis ? {
	              x: 0,
	              y: F ? t : y,
	              height: q.width,
	              width: a.chartWidth
	            } : {
	              x: q.y - a.plotLeft - a.spacingBox.x,
	              y: 0,
	              width: q.height,
	              height: a.chartHeight
	            });
	            e[G] ? e[G].animate(q) : e[G] = c.clipRect(q);
	            v = b["zone-area-" + G];
	            z = b["zone-graph-" + G];
	            h && z && z.clip(e[G]);
	            g && v && v.clip(e[G]);
	            x = d.value > D.max;
	            b.resetZones && 0 === n && (n = void 0);
	          });
	          this.clips = e;
	        } else b.visible && (h && h.show(), g && g.show());
	      };
	      a.prototype.invertGroups = function (b) {
	        function a() {
	          ["group", "markerGroup"].forEach(function (a) {
	            c[a] && (d.renderer.isVML && c[a].attr({
	              width: c.yAxis.len,
	              height: c.xAxis.len
	            }), c[a].width = c.yAxis.len, c[a].height = c.xAxis.len, c[a].invert(c.isRadialSeries ? !1 : b));
	          });
	        }
	        var c = this,
	          d = c.chart;
	        c.xAxis && (c.eventsToUnbind.push(y(d, "resize", a)), a(), c.invertGroups = a);
	      };
	      a.prototype.plotGroup = function (b, a, c, d, e) {
	        var h = this[b],
	          g = !h;
	        c = {
	          visibility: c,
	          zIndex: d || .1
	        };
	        "undefined" === typeof this.opacity || this.chart.styledMode || "inactive" === this.state || (c.opacity = this.opacity);
	        g && (this[b] = h = this.chart.renderer.g().add(e));
	        h.addClass("highcharts-" + a + " highcharts-series-" + this.index + " highcharts-" + this.type + "-series " + (l(this.colorIndex) ? "highcharts-color-" + this.colorIndex + " " : "") + (this.options.className || "") + (h.hasClass("highcharts-tracker") ? " highcharts-tracker" : ""), !0);
	        h.attr(c)[g ? "attr" : "animate"](this.getPlotBox());
	        return h;
	      };
	      a.prototype.getPlotBox = function () {
	        var b = this.chart,
	          a = this.xAxis,
	          c = this.yAxis;
	        b.inverted && (a = c, c = this.xAxis);
	        return {
	          translateX: a ? a.left : b.plotLeft,
	          translateY: c ? c.top : b.plotTop,
	          scaleX: 1,
	          scaleY: 1
	        };
	      };
	      a.prototype.removeEvents = function (b) {
	        b || K(this);
	        this.eventsToUnbind.length && (this.eventsToUnbind.forEach(function (b) {
	          b();
	        }), this.eventsToUnbind.length = 0);
	      };
	      a.prototype.render = function () {
	        var b = this,
	          a = b.chart,
	          c = b.options,
	          d = k(c.animation),
	          e = b.visible ? "inherit" : "hidden",
	          h = c.zIndex,
	          g = b.hasRendered,
	          f = a.seriesGroup,
	          l = a.inverted;
	        a = !b.finishedAnimating && a.renderer.isSVG ? d.duration : 0;
	        C(this, "render");
	        var m = b.plotGroup("group", "series", e, h, f);
	        b.markerGroup = b.plotGroup("markerGroup", "markers", e, h, f);
	        !1 !== c.clip && b.setClip();
	        b.animate && a && b.animate(!0);
	        m.inverted = L(b.invertible, b.isCartesian) ? l : !1;
	        b.drawGraph && (b.drawGraph(), b.applyZones());
	        b.visible && b.drawPoints();
	        b.drawDataLabels && b.drawDataLabels();
	        b.redrawPoints && b.redrawPoints();
	        b.drawTracker && !1 !== b.options.enableMouseTracking && b.drawTracker();
	        b.invertGroups(l);
	        b.animate && a && b.animate();
	        g || (a && d.defer && (a += d.defer), b.animationTimeout = Q(function () {
	          b.afterAnimate();
	        }, a || 0));
	        b.isDirty = !1;
	        b.hasRendered = !0;
	        C(b, "afterRender");
	      };
	      a.prototype.redraw = function () {
	        var b = this.chart,
	          a = this.isDirty || this.isDirtyData,
	          c = this.group,
	          d = this.xAxis,
	          e = this.yAxis;
	        c && (b.inverted && c.attr({
	          width: b.plotWidth,
	          height: b.plotHeight
	        }), c.animate({
	          translateX: L(d && d.left, b.plotLeft),
	          translateY: L(e && e.top, b.plotTop)
	        }));
	        this.translate();
	        this.render();
	        a && delete this.kdTree;
	      };
	      a.prototype.searchPoint = function (b, a) {
	        var c = this.xAxis,
	          d = this.yAxis,
	          e = this.chart.inverted;
	        return this.searchKDTree({
	          clientX: e ? c.len - b.chartY + c.pos : b.chartX - c.pos,
	          plotY: e ? d.len - b.chartX + d.pos : b.chartY - d.pos
	        }, a, b);
	      };
	      a.prototype.buildKDTree = function (b) {
	        function a(b, d, e) {
	          var h = b && b.length;
	          if (h) {
	            var g = c.kdAxisArray[d % e];
	            b.sort(function (b, a) {
	              return b[g] - a[g];
	            });
	            h = Math.floor(h / 2);
	            return {
	              point: b[h],
	              left: a(b.slice(0, h), d + 1, e),
	              right: a(b.slice(h + 1), d + 1, e)
	            };
	          }
	        }
	        this.buildingKdTree = !0;
	        var c = this,
	          d = -1 < c.options.findNearestPointBy.indexOf("y") ? 2 : 1;
	        delete c.kdTree;
	        Q(function () {
	          c.kdTree = a(c.getValidPoints(null, !c.directTouch), d, d);
	          c.buildingKdTree = !1;
	        }, c.options.kdNow || b && "touchstart" === b.type ? 0 : 1);
	      };
	      a.prototype.searchKDTree = function (b, a, c) {
	        function d(b, a, c, k) {
	          var m = a.point,
	            p = e.kdAxisArray[c % k],
	            n = m,
	            q = l(b[h]) && l(m[h]) ? Math.pow(b[h] - m[h], 2) : null;
	          var r = l(b[g]) && l(m[g]) ? Math.pow(b[g] - m[g], 2) : null;
	          r = (q || 0) + (r || 0);
	          m.dist = l(r) ? Math.sqrt(r) : Number.MAX_VALUE;
	          m.distX = l(q) ? Math.sqrt(q) : Number.MAX_VALUE;
	          p = b[p] - m[p];
	          r = 0 > p ? "left" : "right";
	          q = 0 > p ? "right" : "left";
	          a[r] && (r = d(b, a[r], c + 1, k), n = r[f] < n[f] ? r : m);
	          a[q] && Math.sqrt(p * p) < n[f] && (b = d(b, a[q], c + 1, k), n = b[f] < n[f] ? b : n);
	          return n;
	        }
	        var e = this,
	          h = this.kdAxisArray[0],
	          g = this.kdAxisArray[1],
	          f = a ? "distX" : "dist";
	        a = -1 < e.options.findNearestPointBy.indexOf("y") ? 2 : 1;
	        this.kdTree || this.buildingKdTree || this.buildKDTree(c);
	        if (this.kdTree) return d(b, this.kdTree, a, a);
	      };
	      a.prototype.pointPlacementToXValue = function () {
	        var b = this.options,
	          a = b.pointRange,
	          c = this.xAxis;
	        b = b.pointPlacement;
	        "between" === b && (b = c.reversed ? -.5 : .5);
	        return N(b) ? b * (a || c.pointRange) : 0;
	      };
	      a.prototype.isPointInside = function (b) {
	        var a = this.chart,
	          c = this.xAxis,
	          d = this.yAxis;
	        return "undefined" !== typeof b.plotY && "undefined" !== typeof b.plotX && 0 <= b.plotY && b.plotY <= (d ? d.len : a.plotHeight) && 0 <= b.plotX && b.plotX <= (c ? c.len : a.plotWidth);
	      };
	      a.prototype.drawTracker = function () {
	        var b = this,
	          a = b.options,
	          c = a.trackByArea,
	          d = [].concat(c ? b.areaPath : b.graphPath),
	          e = b.chart,
	          h = e.pointer,
	          f = e.renderer,
	          l = e.options.tooltip.snap,
	          k = b.tracker,
	          m = function (a) {
	            if (e.hoverSeries !== b) b.onMouseOver();
	          },
	          p = "rgba(192,192,192," + (t ? .0001 : .002) + ")";
	        k ? k.attr({
	          d: d
	        }) : b.graph && (b.tracker = f.path(d).attr({
	          visibility: b.visible ? "inherit" : "hidden",
	          zIndex: 2
	        }).addClass(c ? "highcharts-tracker-area" : "highcharts-tracker-line").add(b.group), e.styledMode || b.tracker.attr({
	          "stroke-linecap": "round",
	          "stroke-linejoin": "round",
	          stroke: p,
	          fill: c ? p : "none",
	          "stroke-width": b.graph.strokeWidth() + (c ? 0 : 2 * l)
	        }), [b.tracker, b.markerGroup, b.dataLabelsGroup].forEach(function (b) {
	          if (b && (b.addClass("highcharts-tracker").on("mouseover", m).on("mouseout", function (b) {
	            h.onTrackerMouseOut(b);
	          }), a.cursor && !e.styledMode && b.css({
	            cursor: a.cursor
	          }), g)) b.on("touchstart", m);
	        }));
	        C(this, "afterDrawTracker");
	      };
	      a.prototype.addPoint = function (b, a, c, d, e) {
	        var h = this.options,
	          g = this.data,
	          f = this.chart,
	          l = this.xAxis;
	        l = l && l.hasNames && l.names;
	        var k = h.data,
	          m = this.xData,
	          p;
	        a = L(a, !0);
	        var n = {
	          series: this
	        };
	        this.pointClass.prototype.applyOptions.apply(n, [b]);
	        var q = n.x;
	        var r = m.length;
	        if (this.requireSorting && q < m[r - 1]) for (p = !0; r && m[r - 1] > q;) r--;
	        this.updateParallelArrays(n, "splice", r, 0, 0);
	        this.updateParallelArrays(n, r);
	        l && n.name && (l[q] = n.name);
	        k.splice(r, 0, b);
	        if (p || this.processedData) this.data.splice(r, 0, null), this.processData();
	        "point" === h.legendType && this.generatePoints();
	        c && (g[0] && g[0].remove ? g[0].remove(!1) : (g.shift(), this.updateParallelArrays(n, "shift"), k.shift()));
	        !1 !== e && C(this, "addPoint", {
	          point: n
	        });
	        this.isDirtyData = this.isDirty = !0;
	        a && f.redraw(d);
	      };
	      a.prototype.removePoint = function (b, a, c) {
	        var d = this,
	          h = d.data,
	          g = h[b],
	          f = d.points,
	          l = d.chart,
	          k = function () {
	            f && f.length === h.length && f.splice(b, 1);
	            h.splice(b, 1);
	            d.options.data.splice(b, 1);
	            d.updateParallelArrays(g || {
	              series: d
	            }, "splice", b, 1);
	            g && g.destroy();
	            d.isDirty = !0;
	            d.isDirtyData = !0;
	            a && l.redraw();
	          };
	        e(c, l);
	        a = L(a, !0);
	        g ? g.firePointEvent("remove", null, k) : k();
	      };
	      a.prototype.remove = function (b, a, c, d) {
	        function e() {
	          h.destroy(d);
	          g.isDirtyLegend = g.isDirtyBox = !0;
	          g.linkSeries();
	          L(b, !0) && g.redraw(a);
	        }
	        var h = this,
	          g = h.chart;
	        !1 !== c ? C(h, "remove", null, e) : e();
	      };
	      a.prototype.update = function (b, a) {
	        b = h(b, this.userOptions);
	        C(this, "update", {
	          options: b
	        });
	        var c = this,
	          d = c.chart,
	          e = c.userOptions,
	          g = c.initialType || c.type,
	          f = d.options.plotOptions,
	          l = F[g].prototype,
	          k = c.finishedAnimating && {
	            animation: !1
	          },
	          m = {},
	          p,
	          n = ["eventOptions", "navigatorSeries", "baseSeries"],
	          q = b.type || e.type || d.options.chart.type,
	          r = !(this.hasDerivedData || q && q !== this.type || "undefined" !== typeof b.pointStart || "undefined" !== typeof b.pointInterval || "undefined" !== typeof b.relativeXValue || b.joinBy || b.mapData || c.hasOptionChanged("dataGrouping") || c.hasOptionChanged("pointStart") || c.hasOptionChanged("pointInterval") || c.hasOptionChanged("pointIntervalUnit") || c.hasOptionChanged("keys"));
	        q = q || g;
	        r && (n.push("data", "isDirtyData", "points", "processedData", "processedXData", "processedYData", "xIncrement", "cropped", "_hasPointMarkers", "_hasPointLabels", "clips", "nodes", "layout", "level", "mapMap", "mapData", "minY", "maxY", "minX", "maxX"), !1 !== b.visible && n.push("area", "graph"), c.parallelArrays.forEach(function (b) {
	          n.push(b + "Data");
	        }), b.data && (b.dataSorting && v(c.options.dataSorting, b.dataSorting), this.setData(b.data, !1)));
	        b = X(e, k, {
	          index: "undefined" === typeof e.index ? c.index : e.index,
	          pointStart: L(f && f.series && f.series.pointStart, e.pointStart, c.xData[0])
	        }, !r && {
	          data: c.options.data
	        }, b);
	        r && b.data && (b.data = c.options.data);
	        n = ["group", "markerGroup", "dataLabelsGroup", "transformGroup"].concat(n);
	        n.forEach(function (b) {
	          n[b] = c[b];
	          delete c[b];
	        });
	        f = !1;
	        if (F[q]) {
	          if (f = q !== c.type, c.remove(!1, !1, !1, !0), f) if (Object.setPrototypeOf) Object.setPrototypeOf(c, F[q].prototype);else {
	            k = Object.hasOwnProperty.call(c, "hcEvents") && c.hcEvents;
	            for (p in l) c[p] = void 0;
	            v(c, F[q].prototype);
	            k ? c.hcEvents = k : delete c.hcEvents;
	          }
	        } else D(17, !0, d, {
	          missingModuleFor: q
	        });
	        n.forEach(function (b) {
	          c[b] = n[b];
	        });
	        c.init(d, b);
	        if (r && this.points) {
	          var t = c.options;
	          !1 === t.visible ? (m.graphic = 1, m.dataLabel = 1) : c._hasPointLabels || (b = t.marker, l = t.dataLabels, !b || !1 !== b.enabled && (e.marker && e.marker.symbol) === b.symbol || (m.graphic = 1), l && !1 === l.enabled && (m.dataLabel = 1));
	          this.points.forEach(function (b) {
	            b && b.series && (b.resolveColor(), Object.keys(m).length && b.destroyElements(m), !1 === t.showInLegend && b.legendItem && d.legend.destroyItem(b));
	          }, this);
	        }
	        c.initialType = g;
	        d.linkSeries();
	        f && c.linkedSeries.length && (c.isDirtyData = !0);
	        C(this, "afterUpdate");
	        L(a, !0) && d.redraw(r ? void 0 : !1);
	      };
	      a.prototype.setName = function (b) {
	        this.name = this.options.name = this.userOptions.name = b;
	        this.chart.isDirtyLegend = !0;
	      };
	      a.prototype.hasOptionChanged = function (b) {
	        var a = this.options[b],
	          c = this.chart.options.plotOptions,
	          d = this.userOptions[b];
	        return d ? a !== d : a !== L(c && c[this.type] && c[this.type][b], c && c.series && c.series[b], a);
	      };
	      a.prototype.onMouseOver = function () {
	        var b = this.chart,
	          a = b.hoverSeries;
	        b.pointer.setHoverChartIndex();
	        if (a && a !== this) a.onMouseOut();
	        this.options.events.mouseOver && C(this, "mouseOver");
	        this.setState("hover");
	        b.hoverSeries = this;
	      };
	      a.prototype.onMouseOut = function () {
	        var b = this.options,
	          a = this.chart,
	          c = a.tooltip,
	          d = a.hoverPoint;
	        a.hoverSeries = null;
	        if (d) d.onMouseOut();
	        this && b.events.mouseOut && C(this, "mouseOut");
	        !c || this.stickyTracking || c.shared && !this.noSharedTooltip || c.hide();
	        a.series.forEach(function (b) {
	          b.setState("", !0);
	        });
	      };
	      a.prototype.setState = function (b, a) {
	        var c = this,
	          d = c.options,
	          e = c.graph,
	          h = d.inactiveOtherPoints,
	          g = d.states,
	          f = L(g[b || "normal"] && g[b || "normal"].animation, c.chart.options.chart.animation),
	          l = d.lineWidth,
	          k = 0,
	          m = d.opacity;
	        b = b || "";
	        if (c.state !== b && ([c.group, c.markerGroup, c.dataLabelsGroup].forEach(function (a) {
	          a && (c.state && a.removeClass("highcharts-series-" + c.state), b && a.addClass("highcharts-series-" + b));
	        }), c.state = b, !c.chart.styledMode)) {
	          if (g[b] && !1 === g[b].enabled) return;
	          b && (l = g[b].lineWidth || l + (g[b].lineWidthPlus || 0), m = L(g[b].opacity, m));
	          if (e && !e.dashstyle) for (d = {
	            "stroke-width": l
	          }, e.animate(d, f); c["zone-graph-" + k];) c["zone-graph-" + k].animate(d, f), k += 1;
	          h || [c.group, c.markerGroup, c.dataLabelsGroup, c.labelBySeries].forEach(function (b) {
	            b && b.animate({
	              opacity: m
	            }, f);
	          });
	        }
	        a && h && c.points && c.setAllPointsToState(b || void 0);
	      };
	      a.prototype.setAllPointsToState = function (b) {
	        this.points.forEach(function (a) {
	          a.setState && a.setState(b);
	        });
	      };
	      a.prototype.setVisible = function (b, a) {
	        var c = this,
	          d = c.chart,
	          e = c.legendItem,
	          h = d.options.chart.ignoreHiddenSeries,
	          g = c.visible,
	          f = (c.visible = b = c.options.visible = c.userOptions.visible = "undefined" === typeof b ? !g : b) ? "show" : "hide";
	        ["group", "dataLabelsGroup", "markerGroup", "tracker", "tt"].forEach(function (b) {
	          if (c[b]) c[b][f]();
	        });
	        if (d.hoverSeries === c || (d.hoverPoint && d.hoverPoint.series) === c) c.onMouseOut();
	        e && d.legend.colorizeItem(c, b);
	        c.isDirty = !0;
	        c.options.stacking && d.series.forEach(function (b) {
	          b.options.stacking && b.visible && (b.isDirty = !0);
	        });
	        c.linkedSeries.forEach(function (a) {
	          a.setVisible(b, !1);
	        });
	        h && (d.isDirtyBox = !0);
	        C(c, f);
	        !1 !== a && d.redraw();
	      };
	      a.prototype.show = function () {
	        this.setVisible(!0);
	      };
	      a.prototype.hide = function () {
	        this.setVisible(!1);
	      };
	      a.prototype.select = function (b) {
	        this.selected = b = this.options.selected = "undefined" === typeof b ? !this.selected : b;
	        this.checkbox && (this.checkbox.checked = b);
	        C(this, b ? "select" : "unselect");
	      };
	      a.prototype.shouldShowTooltip = function (b, a, c) {
	        void 0 === c && (c = {});
	        c.series = this;
	        c.visiblePlotOnly = !0;
	        return this.chart.isInsidePlot(b, a, c);
	      };
	      a.defaultOptions = I;
	      return a;
	    }();
	    v(a.prototype, {
	      axisTypes: ["xAxis", "yAxis"],
	      coll: "series",
	      colorCounter: 0,
	      cropShoulder: 1,
	      directTouch: !1,
	      drawLegendSymbol: w.drawLineMarker,
	      isCartesian: !0,
	      kdAxisArray: ["clientX", "plotY"],
	      parallelArrays: ["x", "y"],
	      pointClass: E,
	      requireSorting: !0,
	      sorted: !0
	    });
	    A.series = a;
	    return a;
	  });
	  K(f, "Extensions/ScrollablePlotArea.js", [f["Core/Animation/AnimationUtilities.js"], f["Core/Axis/Axis.js"], f["Core/Chart/Chart.js"], f["Core/Series/Series.js"], f["Core/Renderer/RendererRegistry.js"], f["Core/Utilities.js"]], function (a, f, B, H, w, E) {
	    var C = a.stop,
	      A = E.addEvent,
	      u = E.createElement,
	      n = E.merge,
	      k = E.pick;
	    A(B, "afterSetChartSize", function (a) {
	      var c = this.options.chart.scrollablePlotArea,
	        e = c && c.minWidth;
	      c = c && c.minHeight;
	      if (!this.renderer.forExport) {
	        if (e) {
	          if (this.scrollablePixelsX = e = Math.max(0, e - this.chartWidth)) {
	            this.scrollablePlotBox = this.renderer.scrollablePlotBox = n(this.plotBox);
	            this.plotBox.width = this.plotWidth += e;
	            this.inverted ? this.clipBox.height += e : this.clipBox.width += e;
	            var g = {
	              1: {
	                name: "right",
	                value: e
	              }
	            };
	          }
	        } else c && (this.scrollablePixelsY = e = Math.max(0, c - this.chartHeight)) && (this.scrollablePlotBox = this.renderer.scrollablePlotBox = n(this.plotBox), this.plotBox.height = this.plotHeight += e, this.inverted ? this.clipBox.width += e : this.clipBox.height += e, g = {
	          2: {
	            name: "bottom",
	            value: e
	          }
	        });
	        g && !a.skipAxes && this.axes.forEach(function (a) {
	          g[a.side] ? a.getPlotLinePath = function () {
	            var c = g[a.side].name,
	              e = this[c];
	            this[c] = e - g[a.side].value;
	            var k = f.prototype.getPlotLinePath.apply(this, arguments);
	            this[c] = e;
	            return k;
	          } : (a.setAxisSize(), a.setAxisTranslation());
	        });
	      }
	    });
	    A(B, "render", function () {
	      this.scrollablePixelsX || this.scrollablePixelsY ? (this.setUpScrolling && this.setUpScrolling(), this.applyFixed()) : this.fixedDiv && this.applyFixed();
	    });
	    B.prototype.setUpScrolling = function () {
	      var a = this,
	        c = {
	          WebkitOverflowScrolling: "touch",
	          overflowX: "hidden",
	          overflowY: "hidden"
	        };
	      this.scrollablePixelsX && (c.overflowX = "auto");
	      this.scrollablePixelsY && (c.overflowY = "auto");
	      this.scrollingParent = u("div", {
	        className: "highcharts-scrolling-parent"
	      }, {
	        position: "relative"
	      }, this.renderTo);
	      this.scrollingContainer = u("div", {
	        className: "highcharts-scrolling"
	      }, c, this.scrollingParent);
	      A(this.scrollingContainer, "scroll", function () {
	        a.pointer && delete a.pointer.chartPosition;
	      });
	      this.innerContainer = u("div", {
	        className: "highcharts-inner-container"
	      }, null, this.scrollingContainer);
	      this.innerContainer.appendChild(this.container);
	      this.setUpScrolling = null;
	    };
	    B.prototype.moveFixedElements = function () {
	      var a = this.container,
	        c = this.fixedRenderer,
	        f = ".highcharts-contextbutton .highcharts-credits .highcharts-legend .highcharts-legend-checkbox .highcharts-navigator-series .highcharts-navigator-xaxis .highcharts-navigator-yaxis .highcharts-navigator .highcharts-reset-zoom .highcharts-drillup-button .highcharts-scrollbar .highcharts-subtitle .highcharts-title".split(" "),
	        g;
	      this.scrollablePixelsX && !this.inverted ? g = ".highcharts-yaxis" : this.scrollablePixelsX && this.inverted ? g = ".highcharts-xaxis" : this.scrollablePixelsY && !this.inverted ? g = ".highcharts-xaxis" : this.scrollablePixelsY && this.inverted && (g = ".highcharts-yaxis");
	      g && f.push(g + ":not(.highcharts-radial-axis)", g + "-labels:not(.highcharts-radial-axis-labels)");
	      f.forEach(function (e) {
	        [].forEach.call(a.querySelectorAll(e), function (a) {
	          (a.namespaceURI === c.SVG_NS ? c.box : c.box.parentNode).appendChild(a);
	          a.style.pointerEvents = "auto";
	        });
	      });
	    };
	    B.prototype.applyFixed = function () {
	      var a = !this.fixedDiv,
	        c = this.options.chart,
	        f = c.scrollablePlotArea,
	        g = w.getRendererType();
	      a ? (this.fixedDiv = u("div", {
	        className: "highcharts-fixed"
	      }, {
	        position: "absolute",
	        overflow: "hidden",
	        pointerEvents: "none",
	        zIndex: (c.style && c.style.zIndex || 0) + 2,
	        top: 0
	      }, null, !0), this.scrollingContainer && this.scrollingContainer.parentNode.insertBefore(this.fixedDiv, this.scrollingContainer), this.renderTo.style.overflow = "visible", this.fixedRenderer = c = new g(this.fixedDiv, this.chartWidth, this.chartHeight, this.options.chart.style), this.scrollableMask = c.path().attr({
	        fill: this.options.chart.backgroundColor || "#fff",
	        "fill-opacity": k(f.opacity, .85),
	        zIndex: -1
	      }).addClass("highcharts-scrollable-mask").add(), A(this, "afterShowResetZoom", this.moveFixedElements), A(this, "afterApplyDrilldown", this.moveFixedElements), A(this, "afterLayOutTitles", this.moveFixedElements)) : this.fixedRenderer.setSize(this.chartWidth, this.chartHeight);
	      if (this.scrollableDirty || a) this.scrollableDirty = !1, this.moveFixedElements();
	      c = this.chartWidth + (this.scrollablePixelsX || 0);
	      g = this.chartHeight + (this.scrollablePixelsY || 0);
	      C(this.container);
	      this.container.style.width = c + "px";
	      this.container.style.height = g + "px";
	      this.renderer.boxWrapper.attr({
	        width: c,
	        height: g,
	        viewBox: [0, 0, c, g].join(" ")
	      });
	      this.chartBackground.attr({
	        width: c,
	        height: g
	      });
	      this.scrollingContainer.style.height = this.chartHeight + "px";
	      a && (f.scrollPositionX && (this.scrollingContainer.scrollLeft = this.scrollablePixelsX * f.scrollPositionX), f.scrollPositionY && (this.scrollingContainer.scrollTop = this.scrollablePixelsY * f.scrollPositionY));
	      g = this.axisOffset;
	      a = this.plotTop - g[0] - 1;
	      f = this.plotLeft - g[3] - 1;
	      c = this.plotTop + this.plotHeight + g[2] + 1;
	      g = this.plotLeft + this.plotWidth + g[1] + 1;
	      var n = this.plotLeft + this.plotWidth - (this.scrollablePixelsX || 0),
	        q = this.plotTop + this.plotHeight - (this.scrollablePixelsY || 0);
	      a = this.scrollablePixelsX ? [["M", 0, a], ["L", this.plotLeft - 1, a], ["L", this.plotLeft - 1, c], ["L", 0, c], ["Z"], ["M", n, a], ["L", this.chartWidth, a], ["L", this.chartWidth, c], ["L", n, c], ["Z"]] : this.scrollablePixelsY ? [["M", f, 0], ["L", f, this.plotTop - 1], ["L", g, this.plotTop - 1], ["L", g, 0], ["Z"], ["M", f, q], ["L", f, this.chartHeight], ["L", g, this.chartHeight], ["L", g, q], ["Z"]] : [["M", 0, 0]];
	      "adjustHeight" !== this.redrawTrigger && this.scrollableMask.attr({
	        d: a
	      });
	    };
	    A(f, "afterInit", function () {
	      this.chart.scrollableDirty = !0;
	    });
	    A(H, "show", function () {
	      this.chart.scrollableDirty = !0;
	    });
	  });
	  K(f, "Core/Axis/StackingAxis.js", [f["Core/Animation/AnimationUtilities.js"], f["Core/Axis/Axis.js"], f["Core/Utilities.js"]], function (a, f, B) {
	    var C = a.getDeferredAnimation,
	      w = B.addEvent,
	      E = B.destroyObjectProperties,
	      I = B.fireEvent,
	      A = B.isNumber,
	      u = B.objectEach,
	      n;
	    (function (a) {
	      function e() {
	        var a = this.stacking;
	        if (a) {
	          var c = a.stacks;
	          u(c, function (a, e) {
	            E(a);
	            c[e] = null;
	          });
	          a && a.stackTotalGroup && a.stackTotalGroup.destroy();
	        }
	      }
	      function c() {
	        this.stacking || (this.stacking = new g(this));
	      }
	      var f = [];
	      a.compose = function (a) {
	        -1 === f.indexOf(a) && (f.push(a), w(a, "init", c), w(a, "destroy", e));
	        return a;
	      };
	      var g = function () {
	        function a(a) {
	          this.oldStacks = {};
	          this.stacks = {};
	          this.stacksTouched = 0;
	          this.axis = a;
	        }
	        a.prototype.buildStacks = function () {
	          var a = this.axis,
	            c = a.series,
	            e = a.options.reversedStacks,
	            g = c.length,
	            f;
	          if (!a.isXAxis) {
	            this.usePercentage = !1;
	            for (f = g; f--;) {
	              var k = c[e ? f : g - f - 1];
	              k.setStackedPoints();
	              k.setGroupedPoints();
	            }
	            for (f = 0; f < g; f++) c[f].modifyStacks();
	            I(a, "afterBuildStacks");
	          }
	        };
	        a.prototype.cleanStacks = function () {
	          if (!this.axis.isXAxis) {
	            if (this.oldStacks) var a = this.stacks = this.oldStacks;
	            u(a, function (a) {
	              u(a, function (a) {
	                a.cumulative = a.total;
	              });
	            });
	          }
	        };
	        a.prototype.resetStacks = function () {
	          var a = this,
	            c = a.stacks;
	          a.axis.isXAxis || u(c, function (c) {
	            u(c, function (e, g) {
	              A(e.touched) && e.touched < a.stacksTouched ? (e.destroy(), delete c[g]) : (e.total = null, e.cumulative = null);
	            });
	          });
	        };
	        a.prototype.renderStackTotals = function () {
	          var a = this.axis,
	            c = a.chart,
	            e = c.renderer,
	            g = this.stacks;
	          a = C(c, a.options.stackLabels && a.options.stackLabels.animation || !1);
	          var f = this.stackTotalGroup = this.stackTotalGroup || e.g("stack-labels").attr({
	            zIndex: 6,
	            opacity: 0
	          }).add();
	          f.translate(c.plotLeft, c.plotTop);
	          u(g, function (a) {
	            u(a, function (a) {
	              a.render(f);
	            });
	          });
	          f.animate({
	            opacity: 1
	          }, a);
	        };
	        return a;
	      }();
	      a.Additions = g;
	    })(n || (n = {}));
	    return n;
	  });
	  K(f, "Extensions/Stacking.js", [f["Core/Axis/Axis.js"], f["Core/Chart/Chart.js"], f["Core/FormatUtilities.js"], f["Core/Globals.js"], f["Core/Series/Series.js"], f["Core/Axis/StackingAxis.js"], f["Core/Utilities.js"]], function (a, f, B, H, w, E, I) {
	    var A = B.format,
	      u = I.correctFloat,
	      n = I.defined,
	      k = I.destroyObjectProperties,
	      e = I.isArray,
	      c = I.isNumber,
	      p = I.objectEach,
	      g = I.pick,
	      t = function () {
	        function a(a, c, e, g, f) {
	          var h = a.chart.inverted;
	          this.axis = a;
	          this.isNegative = e;
	          this.options = c = c || {};
	          this.x = g;
	          this.total = null;
	          this.points = {};
	          this.hasValidPoints = !1;
	          this.stack = f;
	          this.rightCliff = this.leftCliff = 0;
	          this.alignOptions = {
	            align: c.align || (h ? e ? "left" : "right" : "center"),
	            verticalAlign: c.verticalAlign || (h ? "middle" : e ? "bottom" : "top"),
	            y: c.y,
	            x: c.x
	          };
	          this.textAlign = c.textAlign || (h ? e ? "right" : "left" : "center");
	        }
	        a.prototype.destroy = function () {
	          k(this, this.axis);
	        };
	        a.prototype.render = function (a) {
	          var c = this.axis.chart,
	            e = this.options,
	            f = e.format;
	          f = f ? A(f, this, c) : e.formatter.call(this);
	          this.label ? this.label.attr({
	            text: f,
	            visibility: "hidden"
	          }) : (this.label = c.renderer.label(f, null, null, e.shape, null, null, e.useHTML, !1, "stack-labels"), f = {
	            r: e.borderRadius || 0,
	            text: f,
	            rotation: e.rotation,
	            padding: g(e.padding, 5),
	            visibility: "hidden"
	          }, c.styledMode || (f.fill = e.backgroundColor, f.stroke = e.borderColor, f["stroke-width"] = e.borderWidth, this.label.css(e.style)), this.label.attr(f), this.label.added || this.label.add(a));
	          this.label.labelrank = c.plotSizeY;
	        };
	        a.prototype.setOffset = function (a, e, f, k, m) {
	          var h = this.axis,
	            b = h.chart;
	          k = h.translate(h.stacking.usePercentage ? 100 : k ? k : this.total, 0, 0, 0, 1);
	          f = h.translate(f ? f : 0);
	          f = n(k) && Math.abs(k - f);
	          a = g(m, b.xAxis[0].translate(this.x)) + a;
	          h = n(k) && this.getStackBox(b, this, a, k, e, f, h);
	          e = this.label;
	          f = this.isNegative;
	          a = "justify" === g(this.options.overflow, "justify");
	          var l = this.textAlign;
	          e && h && (m = e.getBBox(), k = e.padding, l = "left" === l ? b.inverted ? -k : k : "right" === l ? m.width : b.inverted && "center" === l ? m.width / 2 : b.inverted ? f ? m.width + k : -k : m.width / 2, f = b.inverted ? m.height / 2 : f ? -k : m.height, this.alignOptions.x = g(this.options.x, 0), this.alignOptions.y = g(this.options.y, 0), h.x -= l, h.y -= f, e.align(this.alignOptions, null, h), b.isInsidePlot(e.alignAttr.x + l - this.alignOptions.x, e.alignAttr.y + f - this.alignOptions.y) ? e.show() : (e.hide(), a = !1), a && w.prototype.justifyDataLabel.call(this.axis, e, this.alignOptions, e.alignAttr, m, h), e.attr({
	            x: e.alignAttr.x,
	            y: e.alignAttr.y
	          }), g(!a && this.options.crop, !0) && ((b = c(e.x) && c(e.y) && b.isInsidePlot(e.x - k + e.width, e.y) && b.isInsidePlot(e.x + k, e.y)) || e.hide()));
	        };
	        a.prototype.getStackBox = function (a, c, e, g, f, h, b) {
	          var l = c.axis.reversed,
	            d = a.inverted,
	            k = b.height + b.pos - (d ? a.plotLeft : a.plotTop);
	          c = c.isNegative && !l || !c.isNegative && l;
	          return {
	            x: d ? c ? g - b.right : g - h + b.pos - a.plotLeft : e + a.xAxis[0].transB - a.plotLeft,
	            y: d ? b.height - e - f : c ? k - g - h : k - g,
	            width: d ? h : f,
	            height: d ? f : h
	          };
	        };
	        return a;
	      }();
	    f.prototype.getStacks = function () {
	      var a = this,
	        c = a.inverted;
	      a.yAxis.forEach(function (a) {
	        a.stacking && a.stacking.stacks && a.hasVisibleSeries && (a.stacking.oldStacks = a.stacking.stacks);
	      });
	      a.series.forEach(function (e) {
	        var f = e.xAxis && e.xAxis.options || {};
	        !e.options.stacking || !0 !== e.visible && !1 !== a.options.chart.ignoreHiddenSeries || (e.stackKey = [e.type, g(e.options.stack, ""), c ? f.top : f.left, c ? f.height : f.width].join());
	      });
	    };
	    E.compose(a);
	    w.prototype.setGroupedPoints = function () {
	      var a = this.yAxis.stacking;
	      this.options.centerInCategory && (this.is("column") || this.is("columnrange")) && !this.options.stacking && 1 < this.chart.series.length ? w.prototype.setStackedPoints.call(this, "group") : a && p(a.stacks, function (c, e) {
	        "group" === e.slice(-5) && (p(c, function (a) {
	          return a.destroy();
	        }), delete a.stacks[e]);
	      });
	    };
	    w.prototype.setStackedPoints = function (a) {
	      var c = a || this.options.stacking;
	      if (c && (!0 === this.visible || !1 === this.chart.options.chart.ignoreHiddenSeries)) {
	        var f = this.processedXData,
	          k = this.processedYData,
	          p = [],
	          m = k.length,
	          h = this.options,
	          b = h.threshold,
	          l = g(h.startFromThreshold && b, 0);
	        h = h.stack;
	        a = a ? this.type + "," + c : this.stackKey;
	        var d = "-" + a,
	          q = this.negStacks,
	          v = this.yAxis,
	          r = v.stacking.stacks,
	          w = v.stacking.oldStacks,
	          A,
	          C;
	        v.stacking.stacksTouched += 1;
	        for (C = 0; C < m; C++) {
	          var B = f[C];
	          var H = k[C];
	          var I = this.getStackIndicator(I, B, this.index);
	          var J = I.key;
	          var E = (A = q && H < (l ? 0 : b)) ? d : a;
	          r[E] || (r[E] = {});
	          r[E][B] || (w[E] && w[E][B] ? (r[E][B] = w[E][B], r[E][B].total = null) : r[E][B] = new t(v, v.options.stackLabels, A, B, h));
	          E = r[E][B];
	          null !== H ? (E.points[J] = E.points[this.index] = [g(E.cumulative, l)], n(E.cumulative) || (E.base = J), E.touched = v.stacking.stacksTouched, 0 < I.index && !1 === this.singleStacks && (E.points[J][0] = E.points[this.index + "," + B + ",0"][0])) : E.points[J] = E.points[this.index] = null;
	          "percent" === c ? (A = A ? a : d, q && r[A] && r[A][B] ? (A = r[A][B], E.total = A.total = Math.max(A.total, E.total) + Math.abs(H) || 0) : E.total = u(E.total + (Math.abs(H) || 0))) : "group" === c ? (e(H) && (H = H[0]), null !== H && (E.total = (E.total || 0) + 1)) : E.total = u(E.total + (H || 0));
	          E.cumulative = "group" === c ? (E.total || 1) - 1 : g(E.cumulative, l) + (H || 0);
	          null !== H && (E.points[J].push(E.cumulative), p[C] = E.cumulative, E.hasValidPoints = !0);
	        }
	        "percent" === c && (v.stacking.usePercentage = !0);
	        "group" !== c && (this.stackedYData = p);
	        v.stacking.oldStacks = {};
	      }
	    };
	    w.prototype.modifyStacks = function () {
	      var a = this,
	        c = a.stackKey,
	        e = a.yAxis.stacking.stacks,
	        g = a.processedXData,
	        f,
	        k = a.options.stacking;
	      a[k + "Stacker"] && [c, "-" + c].forEach(function (c) {
	        for (var b = g.length, h, d; b--;) if (h = g[b], f = a.getStackIndicator(f, h, a.index, c), d = (h = e[c] && e[c][h]) && h.points[f.key]) a[k + "Stacker"](d, h, b);
	      });
	    };
	    w.prototype.percentStacker = function (a, c, e) {
	      c = c.total ? 100 / c.total : 0;
	      a[0] = u(a[0] * c);
	      a[1] = u(a[1] * c);
	      this.stackedYData[e] = a[1];
	    };
	    w.prototype.getStackIndicator = function (a, c, e, g) {
	      !n(a) || a.x !== c || g && a.stackKey !== g ? a = {
	        x: c,
	        index: 0,
	        key: g,
	        stackKey: g
	      } : a.index++;
	      a.key = [e, c, a.index].join();
	      return a;
	    };
	    H.StackItem = t;
	    return H.StackItem;
	  });
	  K(f, "Series/Line/LineSeries.js", [f["Core/Series/Series.js"], f["Core/Series/SeriesRegistry.js"], f["Core/Utilities.js"]], function (a, f, B) {
	    var C = this && this.__extends || function () {
	        var a = function (f, u) {
	          a = Object.setPrototypeOf || {
	            __proto__: []
	          } instanceof Array && function (a, f) {
	            a.__proto__ = f;
	          } || function (a, f) {
	            for (var e in f) f.hasOwnProperty(e) && (a[e] = f[e]);
	          };
	          return a(f, u);
	        };
	        return function (f, u) {
	          function n() {
	            this.constructor = f;
	          }
	          a(f, u);
	          f.prototype = null === u ? Object.create(u) : (n.prototype = u.prototype, new n());
	        };
	      }(),
	      w = B.defined,
	      E = B.merge;
	    B = function (f) {
	      function A() {
	        var a = null !== f && f.apply(this, arguments) || this;
	        a.data = void 0;
	        a.options = void 0;
	        a.points = void 0;
	        return a;
	      }
	      C(A, f);
	      A.prototype.drawGraph = function () {
	        var a = this,
	          f = this.options,
	          k = (this.gappedPath || this.getGraphPath).call(this),
	          e = this.chart.styledMode,
	          c = [["graph", "highcharts-graph"]];
	        e || c[0].push(f.lineColor || this.color || "#cccccc", f.dashStyle);
	        c = a.getZonesGraphs(c);
	        c.forEach(function (c, g) {
	          var p = c[0],
	            n = a[p],
	            u = n ? "animate" : "attr";
	          n ? (n.endX = a.preventGraphAnimation ? null : k.xMap, n.animate({
	            d: k
	          })) : k.length && (a[p] = n = a.chart.renderer.path(k).addClass(c[1]).attr({
	            zIndex: 1
	          }).add(a.group));
	          n && !e && (p = {
	            stroke: c[2],
	            "stroke-width": f.lineWidth,
	            fill: a.fillGraph && a.color || "none"
	          }, c[3] ? p.dashstyle = c[3] : "square" !== f.linecap && (p["stroke-linecap"] = p["stroke-linejoin"] = "round"), n[u](p).shadow(2 > g && f.shadow));
	          n && (n.startX = k.xMap, n.isArea = k.isArea);
	        });
	      };
	      A.prototype.getGraphPath = function (a, f, k) {
	        var e = this,
	          c = e.options,
	          p = [],
	          g = [],
	          n,
	          q = c.step;
	        a = a || e.points;
	        var u = a.reversed;
	        u && a.reverse();
	        (q = {
	          right: 1,
	          center: 2
	        }[q] || q && 3) && u && (q = 4 - q);
	        a = this.getValidPoints(a, !1, !(c.connectNulls && !f && !k));
	        a.forEach(function (t, x) {
	          var z = t.plotX,
	            m = t.plotY,
	            h = a[x - 1];
	          (t.leftCliff || h && h.rightCliff) && !k && (n = !0);
	          t.isNull && !w(f) && 0 < x ? n = !c.connectNulls : t.isNull && !f ? n = !0 : (0 === x || n ? x = [["M", t.plotX, t.plotY]] : e.getPointSpline ? x = [e.getPointSpline(a, t, x)] : q ? (x = 1 === q ? [["L", h.plotX, m]] : 2 === q ? [["L", (h.plotX + z) / 2, h.plotY], ["L", (h.plotX + z) / 2, m]] : [["L", z, h.plotY]], x.push(["L", z, m])) : x = [["L", z, m]], g.push(t.x), q && (g.push(t.x), 2 === q && g.push(t.x)), p.push.apply(p, x), n = !1);
	        });
	        p.xMap = g;
	        return e.graphPath = p;
	      };
	      A.prototype.getZonesGraphs = function (a) {
	        this.zones.forEach(function (f, k) {
	          k = ["zone-graph-" + k, "highcharts-graph highcharts-zone-graph-" + k + " " + (f.className || "")];
	          this.chart.styledMode || k.push(f.color || this.color, f.dashStyle || this.options.dashStyle);
	          a.push(k);
	        }, this);
	        return a;
	      };
	      A.defaultOptions = E(a.defaultOptions, {});
	      return A;
	    }(a);
	    f.registerSeriesType("line", B);
	    return B;
	  });
	  K(f, "Series/Area/AreaSeries.js", [f["Core/Color/Color.js"], f["Core/Legend/LegendSymbol.js"], f["Core/Series/SeriesRegistry.js"], f["Core/Utilities.js"]], function (a, f, B, H) {
	    var w = this && this.__extends || function () {
	        var a = function (e, c) {
	          a = Object.setPrototypeOf || {
	            __proto__: []
	          } instanceof Array && function (a, c) {
	            a.__proto__ = c;
	          } || function (a, c) {
	            for (var e in c) c.hasOwnProperty(e) && (a[e] = c[e]);
	          };
	          return a(e, c);
	        };
	        return function (e, c) {
	          function f() {
	            this.constructor = e;
	          }
	          a(e, c);
	          e.prototype = null === c ? Object.create(c) : (f.prototype = c.prototype, new f());
	        };
	      }(),
	      C = a.parse,
	      I = B.seriesTypes.line;
	    a = H.extend;
	    var A = H.merge,
	      u = H.objectEach,
	      n = H.pick;
	    H = function (a) {
	      function e() {
	        var c = null !== a && a.apply(this, arguments) || this;
	        c.data = void 0;
	        c.options = void 0;
	        c.points = void 0;
	        return c;
	      }
	      w(e, a);
	      e.prototype.drawGraph = function () {
	        this.areaPath = [];
	        a.prototype.drawGraph.apply(this);
	        var c = this,
	          e = this.areaPath,
	          f = this.options,
	          k = [["area", "highcharts-area", this.color, f.fillColor]];
	        this.zones.forEach(function (a, e) {
	          k.push(["zone-area-" + e, "highcharts-area highcharts-zone-area-" + e + " " + a.className, a.color || c.color, a.fillColor || f.fillColor]);
	        });
	        k.forEach(function (a) {
	          var g = a[0],
	            k = c[g],
	            p = k ? "animate" : "attr",
	            q = {};
	          k ? (k.endX = c.preventGraphAnimation ? null : e.xMap, k.animate({
	            d: e
	          })) : (q.zIndex = 0, k = c[g] = c.chart.renderer.path(e).addClass(a[1]).add(c.group), k.isArea = !0);
	          c.chart.styledMode || (q.fill = n(a[3], C(a[2]).setOpacity(n(f.fillOpacity, .75)).get()));
	          k[p](q);
	          k.startX = e.xMap;
	          k.shiftUnit = f.step ? 2 : 1;
	        });
	      };
	      e.prototype.getGraphPath = function (a) {
	        var c = I.prototype.getGraphPath,
	          e = this.options,
	          f = e.stacking,
	          k = this.yAxis,
	          u,
	          y = [],
	          x = [],
	          z = this.index,
	          m = k.stacking.stacks[this.stackKey],
	          h = e.threshold,
	          b = Math.round(k.getThreshold(e.threshold));
	        e = n(e.connectNulls, "percent" === f);
	        var l = function (c, d, e) {
	          var g = a[c];
	          c = f && m[g.x].points[z];
	          var l = g[e + "Null"] || 0;
	          e = g[e + "Cliff"] || 0;
	          g = !0;
	          if (e || l) {
	            var p = (l ? c[0] : c[1]) + e;
	            var n = c[0] + e;
	            g = !!l;
	          } else !f && a[d] && a[d].isNull && (p = n = h);
	          "undefined" !== typeof p && (x.push({
	            plotX: D,
	            plotY: null === p ? b : k.getThreshold(p),
	            isNull: g,
	            isCliff: !0
	          }), y.push({
	            plotX: D,
	            plotY: null === n ? b : k.getThreshold(n),
	            doCurve: !1
	          }));
	        };
	        a = a || this.points;
	        f && (a = this.getStackPoints(a));
	        for (u = 0; u < a.length; u++) {
	          f || (a[u].leftCliff = a[u].rightCliff = a[u].leftNull = a[u].rightNull = void 0);
	          var d = a[u].isNull;
	          var D = n(a[u].rectPlotX, a[u].plotX);
	          var v = f ? n(a[u].yBottom, b) : b;
	          if (!d || e) e || l(u, u - 1, "left"), d && !f && e || (x.push(a[u]), y.push({
	            x: u,
	            plotX: D,
	            plotY: v
	          })), e || l(u, u + 1, "right");
	        }
	        u = c.call(this, x, !0, !0);
	        y.reversed = !0;
	        d = c.call(this, y, !0, !0);
	        (v = d[0]) && "M" === v[0] && (d[0] = ["L", v[1], v[2]]);
	        d = u.concat(d);
	        d.length && d.push(["Z"]);
	        c = c.call(this, x, !1, e);
	        d.xMap = u.xMap;
	        this.areaPath = d;
	        return c;
	      };
	      e.prototype.getStackPoints = function (a) {
	        var c = this,
	          e = [],
	          f = [],
	          k = this.xAxis,
	          w = this.yAxis,
	          y = w.stacking.stacks[this.stackKey],
	          x = {},
	          z = w.series,
	          m = z.length,
	          h = w.options.reversedStacks ? 1 : -1,
	          b = z.indexOf(c);
	        a = a || this.points;
	        if (this.options.stacking) {
	          for (var l = 0; l < a.length; l++) a[l].leftNull = a[l].rightNull = void 0, x[a[l].x] = a[l];
	          u(y, function (b, a) {
	            null !== b.total && f.push(a);
	          });
	          f.sort(function (b, a) {
	            return b - a;
	          });
	          var d = z.map(function (b) {
	            return b.visible;
	          });
	          f.forEach(function (a, g) {
	            var l = 0,
	              p,
	              q;
	            if (x[a] && !x[a].isNull) e.push(x[a]), [-1, 1].forEach(function (e) {
	              var l = 1 === e ? "rightNull" : "leftNull",
	                k = 0,
	                n = y[f[g + e]];
	              if (n) for (var r = b; 0 <= r && r < m;) {
	                var t = z[r].index;
	                p = n.points[t];
	                p || (t === c.index ? x[a][l] = !0 : d[r] && (q = y[a].points[t]) && (k -= q[1] - q[0]));
	                r += h;
	              }
	              x[a][1 === e ? "rightCliff" : "leftCliff"] = k;
	            });else {
	              for (var t = b; 0 <= t && t < m;) {
	                if (p = y[a].points[z[t].index]) {
	                  l = p[1];
	                  break;
	                }
	                t += h;
	              }
	              l = n(l, 0);
	              l = w.translate(l, 0, 1, 0, 1);
	              e.push({
	                isNull: !0,
	                plotX: k.translate(a, 0, 0, 0, 1),
	                x: a,
	                plotY: l,
	                yBottom: l
	              });
	            }
	          });
	        }
	        return e;
	      };
	      e.defaultOptions = A(I.defaultOptions, {
	        threshold: 0
	      });
	      return e;
	    }(I);
	    a(H.prototype, {
	      singleStacks: !1,
	      drawLegendSymbol: f.drawRectangle
	    });
	    B.registerSeriesType("area", H);
	    return H;
	  });
	  K(f, "Series/Spline/SplineSeries.js", [f["Core/Series/SeriesRegistry.js"], f["Core/Utilities.js"]], function (a, f) {
	    var C = this && this.__extends || function () {
	        var a = function (f, u) {
	          a = Object.setPrototypeOf || {
	            __proto__: []
	          } instanceof Array && function (a, f) {
	            a.__proto__ = f;
	          } || function (a, f) {
	            for (var e in f) f.hasOwnProperty(e) && (a[e] = f[e]);
	          };
	          return a(f, u);
	        };
	        return function (f, u) {
	          function n() {
	            this.constructor = f;
	          }
	          a(f, u);
	          f.prototype = null === u ? Object.create(u) : (n.prototype = u.prototype, new n());
	        };
	      }(),
	      H = a.seriesTypes.line,
	      w = f.merge,
	      E = f.pick;
	    f = function (a) {
	      function f() {
	        var f = null !== a && a.apply(this, arguments) || this;
	        f.data = void 0;
	        f.options = void 0;
	        f.points = void 0;
	        return f;
	      }
	      C(f, a);
	      f.prototype.getPointSpline = function (a, f, k) {
	        var e = f.plotX || 0,
	          c = f.plotY || 0,
	          p = a[k - 1];
	        k = a[k + 1];
	        if (p && !p.isNull && !1 !== p.doCurve && !f.isCliff && k && !k.isNull && !1 !== k.doCurve && !f.isCliff) {
	          a = p.plotY || 0;
	          var g = k.plotX || 0;
	          k = k.plotY || 0;
	          var n = 0;
	          var q = (1.5 * e + (p.plotX || 0)) / 2.5;
	          var u = (1.5 * c + a) / 2.5;
	          g = (1.5 * e + g) / 2.5;
	          var y = (1.5 * c + k) / 2.5;
	          g !== q && (n = (y - u) * (g - e) / (g - q) + c - y);
	          u += n;
	          y += n;
	          u > a && u > c ? (u = Math.max(a, c), y = 2 * c - u) : u < a && u < c && (u = Math.min(a, c), y = 2 * c - u);
	          y > k && y > c ? (y = Math.max(k, c), u = 2 * c - y) : y < k && y < c && (y = Math.min(k, c), u = 2 * c - y);
	          f.rightContX = g;
	          f.rightContY = y;
	        }
	        f = ["C", E(p.rightContX, p.plotX, 0), E(p.rightContY, p.plotY, 0), E(q, e, 0), E(u, c, 0), e, c];
	        p.rightContX = p.rightContY = void 0;
	        return f;
	      };
	      f.defaultOptions = w(H.defaultOptions);
	      return f;
	    }(H);
	    a.registerSeriesType("spline", f);
	    return f;
	  });
	  K(f, "Series/AreaSpline/AreaSplineSeries.js", [f["Series/Area/AreaSeries.js"], f["Series/Spline/SplineSeries.js"], f["Core/Legend/LegendSymbol.js"], f["Core/Series/SeriesRegistry.js"], f["Core/Utilities.js"]], function (a, f, B, H, w) {
	    var C = this && this.__extends || function () {
	        var a = function (f, e) {
	          a = Object.setPrototypeOf || {
	            __proto__: []
	          } instanceof Array && function (a, e) {
	            a.__proto__ = e;
	          } || function (a, e) {
	            for (var c in e) e.hasOwnProperty(c) && (a[c] = e[c]);
	          };
	          return a(f, e);
	        };
	        return function (f, e) {
	          function c() {
	            this.constructor = f;
	          }
	          a(f, e);
	          f.prototype = null === e ? Object.create(e) : (c.prototype = e.prototype, new c());
	        };
	      }(),
	      I = a.prototype,
	      A = w.extend,
	      u = w.merge;
	    w = function (n) {
	      function k() {
	        var a = null !== n && n.apply(this, arguments) || this;
	        a.data = void 0;
	        a.points = void 0;
	        a.options = void 0;
	        return a;
	      }
	      C(k, n);
	      k.defaultOptions = u(f.defaultOptions, a.defaultOptions);
	      return k;
	    }(f);
	    A(w.prototype, {
	      getGraphPath: I.getGraphPath,
	      getStackPoints: I.getStackPoints,
	      drawGraph: I.drawGraph,
	      drawLegendSymbol: B.drawRectangle
	    });
	    H.registerSeriesType("areaspline", w);
	    return w;
	  });
	  K(f, "Series/Column/ColumnSeries.js", [f["Core/Animation/AnimationUtilities.js"], f["Core/Color/Color.js"], f["Core/Globals.js"], f["Core/Legend/LegendSymbol.js"], f["Core/Series/Series.js"], f["Core/Series/SeriesRegistry.js"], f["Core/Utilities.js"]], function (a, f, B, H, w, E, I) {
	    var C = this && this.__extends || function () {
	        var a = function (c, b) {
	          a = Object.setPrototypeOf || {
	            __proto__: []
	          } instanceof Array && function (b, a) {
	            b.__proto__ = a;
	          } || function (b, a) {
	            for (var c in a) a.hasOwnProperty(c) && (b[c] = a[c]);
	          };
	          return a(c, b);
	        };
	        return function (c, b) {
	          function e() {
	            this.constructor = c;
	          }
	          a(c, b);
	          c.prototype = null === b ? Object.create(b) : (e.prototype = b.prototype, new e());
	        };
	      }(),
	      u = a.animObject,
	      n = f.parse,
	      k = B.hasTouch;
	    a = B.noop;
	    var e = I.clamp,
	      c = I.css,
	      p = I.defined,
	      g = I.extend,
	      t = I.fireEvent,
	      q = I.isArray,
	      F = I.isNumber,
	      y = I.merge,
	      x = I.pick,
	      z = I.objectEach;
	    I = function (a) {
	      function f() {
	        var b = null !== a && a.apply(this, arguments) || this;
	        b.borderWidth = void 0;
	        b.data = void 0;
	        b.group = void 0;
	        b.options = void 0;
	        b.points = void 0;
	        return b;
	      }
	      C(f, a);
	      f.prototype.animate = function (b) {
	        var a = this,
	          c = this.yAxis,
	          f = a.options,
	          h = this.chart.inverted,
	          k = {},
	          m = h ? "translateX" : "translateY";
	        if (b) k.scaleY = .001, b = e(c.toPixels(f.threshold), c.pos, c.pos + c.len), h ? k.translateX = b - c.len : k.translateY = b, a.clipBox && a.setClip(), a.group.attr(k);else {
	          var p = Number(a.group.attr(m));
	          a.group.animate({
	            scaleY: 1
	          }, g(u(a.options.animation), {
	            step: function (b, d) {
	              a.group && (k[m] = p + d.pos * (c.pos - p), a.group.attr(k));
	            }
	          }));
	        }
	      };
	      f.prototype.init = function (b, c) {
	        a.prototype.init.apply(this, arguments);
	        var d = this;
	        b = d.chart;
	        b.hasRendered && b.series.forEach(function (b) {
	          b.type === d.type && (b.isDirty = !0);
	        });
	      };
	      f.prototype.getColumnMetrics = function () {
	        var b = this,
	          a = b.options,
	          c = b.xAxis,
	          e = b.yAxis,
	          f = c.options.reversedStacks;
	        f = c.reversed && !f || !c.reversed && f;
	        var h = {},
	          g,
	          k = 0;
	        !1 === a.grouping ? k = 1 : b.chart.series.forEach(function (a) {
	          var c = a.yAxis,
	            d = a.options;
	          if (a.type === b.type && (a.visible || !b.chart.options.chart.ignoreHiddenSeries) && e.len === c.len && e.pos === c.pos) {
	            if (d.stacking && "group" !== d.stacking) {
	              g = a.stackKey;
	              "undefined" === typeof h[g] && (h[g] = k++);
	              var f = h[g];
	            } else !1 !== d.grouping && (f = k++);
	            a.columnIndex = f;
	          }
	        });
	        var m = Math.min(Math.abs(c.transA) * (c.ordinal && c.ordinal.slope || a.pointRange || c.closestPointRange || c.tickInterval || 1), c.len),
	          p = m * a.groupPadding,
	          n = (m - 2 * p) / (k || 1);
	        a = Math.min(a.maxPointWidth || c.len, x(a.pointWidth, n * (1 - 2 * a.pointPadding)));
	        b.columnMetrics = {
	          width: a,
	          offset: (n - a) / 2 + (p + ((b.columnIndex || 0) + (f ? 1 : 0)) * n - m / 2) * (f ? -1 : 1),
	          paddedWidth: n,
	          columnCount: k
	        };
	        return b.columnMetrics;
	      };
	      f.prototype.crispCol = function (b, a, c, e) {
	        var d = this.chart,
	          f = this.borderWidth,
	          h = -(f % 2 ? .5 : 0);
	        f = f % 2 ? .5 : 1;
	        d.inverted && d.renderer.isVML && (f += 1);
	        this.options.crisp && (c = Math.round(b + c) + h, b = Math.round(b) + h, c -= b);
	        e = Math.round(a + e) + f;
	        h = .5 >= Math.abs(a) && .5 < e;
	        a = Math.round(a) + f;
	        e -= a;
	        h && e && (--a, e += 1);
	        return {
	          x: b,
	          y: a,
	          width: c,
	          height: e
	        };
	      };
	      f.prototype.adjustForMissingColumns = function (b, a, c, e) {
	        var d = this,
	          f = this.options.stacking;
	        if (!c.isNull && 1 < e.columnCount) {
	          var h = this.yAxis.options.reversedStacks,
	            g = 0,
	            l = h ? 0 : -e.columnCount;
	          z(this.yAxis.stacking && this.yAxis.stacking.stacks, function (b) {
	            if ("number" === typeof c.x && (b = b[c.x.toString()])) {
	              var a = b.points[d.index],
	                e = b.total;
	              f ? (a && (g = l), b.hasValidPoints && (h ? l++ : l--)) : q(a) && (g = a[1], l = e || 0);
	            }
	          });
	          b = (c.plotX || 0) + ((l - 1) * e.paddedWidth + a) / 2 - a - g * e.paddedWidth;
	        }
	        return b;
	      };
	      f.prototype.translate = function () {
	        var b = this,
	          a = b.chart,
	          c = b.options,
	          f = b.dense = 2 > b.closestPointRange * b.xAxis.transA;
	        f = b.borderWidth = x(c.borderWidth, f ? 0 : 1);
	        var h = b.xAxis,
	          g = b.yAxis,
	          k = c.threshold,
	          m = b.translatedThreshold = g.getThreshold(k),
	          n = x(c.minPointLength, 5),
	          q = b.getColumnMetrics(),
	          t = q.width,
	          z = b.pointXOffset = q.offset,
	          u = b.dataMin,
	          y = b.dataMax,
	          C = b.barW = Math.max(t, 1 + 2 * f);
	        a.inverted && (m -= .5);
	        c.pointPadding && (C = Math.ceil(C));
	        w.prototype.translate.apply(b);
	        b.points.forEach(function (d) {
	          var f = x(d.yBottom, m),
	            l = 999 + Math.abs(f),
	            r = d.plotX || 0;
	          l = e(d.plotY, -l, g.len + l);
	          var v = Math.min(l, f),
	            w = Math.max(l, f) - v,
	            D = t,
	            A = r + z,
	            B = C;
	          n && Math.abs(w) < n && (w = n, r = !g.reversed && !d.negative || g.reversed && d.negative, F(k) && F(y) && d.y === k && y <= k && (g.min || 0) < k && (u !== y || (g.max || 0) <= k) && (r = !r), v = Math.abs(v - m) > n ? f - n : m - (r ? n : 0));
	          p(d.options.pointWidth) && (D = B = Math.ceil(d.options.pointWidth), A -= Math.round((D - t) / 2));
	          c.centerInCategory && (A = b.adjustForMissingColumns(A, D, d, q));
	          d.barX = A;
	          d.pointWidth = D;
	          d.tooltipPos = a.inverted ? [e(g.len + g.pos - a.plotLeft - l, g.pos - a.plotLeft, g.len + g.pos - a.plotLeft), h.len + h.pos - a.plotTop - A - B / 2, w] : [h.left - a.plotLeft + A + B / 2, e(l + g.pos - a.plotTop, g.pos - a.plotTop, g.len + g.pos - a.plotTop), w];
	          d.shapeType = b.pointClass.prototype.shapeType || "rect";
	          d.shapeArgs = b.crispCol.apply(b, d.isNull ? [A, m, B, 0] : [A, v, B, w]);
	        });
	      };
	      f.prototype.drawGraph = function () {
	        this.group[this.dense ? "addClass" : "removeClass"]("highcharts-dense-data");
	      };
	      f.prototype.pointAttribs = function (b, a) {
	        var c = this.options,
	          e = this.pointAttrToOptions || {},
	          f = e.stroke || "borderColor",
	          h = e["stroke-width"] || "borderWidth",
	          g = b && b.color || this.color,
	          l = b && b[f] || c[f] || g;
	        e = b && b.options.dashStyle || c.dashStyle;
	        var k = b && b[h] || c[h] || this[h] || 0,
	          m = x(b && b.opacity, c.opacity, 1);
	        if (b && this.zones.length) {
	          var p = b.getZone();
	          g = b.options.color || p && (p.color || b.nonZonedColor) || this.color;
	          p && (l = p.borderColor || l, e = p.dashStyle || e, k = p.borderWidth || k);
	        }
	        a && b && (b = y(c.states[a], b.options.states && b.options.states[a] || {}), a = b.brightness, g = b.color || "undefined" !== typeof a && n(g).brighten(b.brightness).get() || g, l = b[f] || l, k = b[h] || k, e = b.dashStyle || e, m = x(b.opacity, m));
	        f = {
	          fill: g,
	          stroke: l,
	          "stroke-width": k,
	          opacity: m
	        };
	        e && (f.dashstyle = e);
	        return f;
	      };
	      f.prototype.drawPoints = function () {
	        var b = this,
	          a = this.chart,
	          c = b.options,
	          e = a.renderer,
	          f = c.animationLimit || 250,
	          h;
	        b.points.forEach(function (d) {
	          var g = d.graphic,
	            l = !!g,
	            k = g && a.pointCount < f ? "animate" : "attr";
	          if (F(d.plotY) && null !== d.y) {
	            h = d.shapeArgs;
	            g && d.hasNewShapeType() && (g = g.destroy());
	            b.enabledDataSorting && (d.startXPos = b.xAxis.reversed ? -(h ? h.width || 0 : 0) : b.xAxis.width);
	            g || (d.graphic = g = e[d.shapeType](h).add(d.group || b.group)) && b.enabledDataSorting && a.hasRendered && a.pointCount < f && (g.attr({
	              x: d.startXPos
	            }), l = !0, k = "animate");
	            if (g && l) g[k](y(h));
	            if (c.borderRadius) g[k]({
	              r: c.borderRadius
	            });
	            a.styledMode || g[k](b.pointAttribs(d, d.selected && "select")).shadow(!1 !== d.allowShadow && c.shadow, null, c.stacking && !c.borderRadius);
	            g && (g.addClass(d.getClassName(), !0), g.attr({
	              visibility: d.visible ? "inherit" : "hidden"
	            }));
	          } else g && (d.graphic = g.destroy());
	        });
	      };
	      f.prototype.drawTracker = function () {
	        var b = this,
	          a = b.chart,
	          d = a.pointer,
	          e = function (b) {
	            var a = d.getPointFromEvent(b);
	            "undefined" !== typeof a && (d.isDirectTouch = !0, a.onMouseOver(b));
	          },
	          f;
	        b.points.forEach(function (b) {
	          f = q(b.dataLabels) ? b.dataLabels : b.dataLabel ? [b.dataLabel] : [];
	          b.graphic && (b.graphic.element.point = b);
	          f.forEach(function (a) {
	            a.div ? a.div.point = b : a.element.point = b;
	          });
	        });
	        b._hasTracking || (b.trackerGroups.forEach(function (f) {
	          if (b[f]) {
	            b[f].addClass("highcharts-tracker").on("mouseover", e).on("mouseout", function (b) {
	              d.onTrackerMouseOut(b);
	            });
	            if (k) b[f].on("touchstart", e);
	            !a.styledMode && b.options.cursor && b[f].css(c).css({
	              cursor: b.options.cursor
	            });
	          }
	        }), b._hasTracking = !0);
	        t(this, "afterDrawTracker");
	      };
	      f.prototype.remove = function () {
	        var b = this,
	          a = b.chart;
	        a.hasRendered && a.series.forEach(function (a) {
	          a.type === b.type && (a.isDirty = !0);
	        });
	        w.prototype.remove.apply(b, arguments);
	      };
	      f.defaultOptions = y(w.defaultOptions, {
	        borderRadius: 0,
	        centerInCategory: !1,
	        groupPadding: .2,
	        marker: null,
	        pointPadding: .1,
	        minPointLength: 0,
	        cropThreshold: 50,
	        pointRange: null,
	        states: {
	          hover: {
	            halo: !1,
	            brightness: .1
	          },
	          select: {
	            color: "#cccccc",
	            borderColor: "#000000"
	          }
	        },
	        dataLabels: {
	          align: void 0,
	          verticalAlign: void 0,
	          y: void 0
	        },
	        startFromThreshold: !0,
	        stickyTracking: !1,
	        tooltip: {
	          distance: 6
	        },
	        threshold: 0,
	        borderColor: "#ffffff"
	      });
	      return f;
	    }(w);
	    g(I.prototype, {
	      cropShoulder: 0,
	      directTouch: !0,
	      drawLegendSymbol: H.drawRectangle,
	      getSymbol: a,
	      negStacks: !0,
	      trackerGroups: ["group", "dataLabelsGroup"]
	    });
	    E.registerSeriesType("column", I);
	    return I;
	  });
	  K(f, "Core/Series/DataLabel.js", [f["Core/Animation/AnimationUtilities.js"], f["Core/FormatUtilities.js"], f["Core/Utilities.js"]], function (a, f, B) {
	    var C = a.getDeferredAnimation,
	      w = f.format,
	      E = B.defined,
	      I = B.extend,
	      A = B.fireEvent,
	      u = B.isArray,
	      n = B.merge,
	      k = B.objectEach,
	      e = B.pick,
	      c = B.splat,
	      p;
	    (function (a) {
	      function f(a, b, c, d, f) {
	        var h = this,
	          g = this.chart,
	          l = this.isCartesian && g.inverted,
	          k = this.enabledDataSorting,
	          m = e(a.dlBox && a.dlBox.centerX, a.plotX),
	          p = a.plotY,
	          n = c.rotation,
	          q = c.align,
	          t = E(m) && E(p) && g.isInsidePlot(m, Math.round(p), {
	            inverted: l,
	            paneCoordinates: !0,
	            series: h
	          }),
	          z = function (c) {
	            k && h.xAxis && !u && h.setDataLabelStartPos(a, b, f, t, c);
	          },
	          u = "justify" === e(c.overflow, k ? "none" : "justify"),
	          x = this.visible && !1 !== a.visible && (a.series.forceDL || k && !u || t || e(c.inside, !!this.options.stacking) && d && g.isInsidePlot(m, l ? d.x + 1 : d.y + d.height - 1, {
	            inverted: l,
	            paneCoordinates: !0,
	            series: h
	          }));
	        if (x && E(m) && E(p)) {
	          n && b.attr({
	            align: q
	          });
	          q = b.getBBox(!0);
	          var y = [0, 0];
	          var w = g.renderer.fontMetrics(g.styledMode ? void 0 : c.style.fontSize, b).b;
	          d = I({
	            x: l ? this.yAxis.len - p : m,
	            y: Math.round(l ? this.xAxis.len - m : p),
	            width: 0,
	            height: 0
	          }, d);
	          I(c, {
	            width: q.width,
	            height: q.height
	          });
	          n ? (u = !1, y = g.renderer.rotCorr(w, n), m = {
	            x: d.x + (c.x || 0) + d.width / 2 + y.x,
	            y: d.y + (c.y || 0) + {
	              top: 0,
	              middle: .5,
	              bottom: 1
	            }[c.verticalAlign] * d.height
	          }, y = [q.x - Number(b.attr("x")), q.y - Number(b.attr("y"))], z(m), b[f ? "attr" : "animate"](m)) : (z(d), b.align(c, void 0, d), m = b.alignAttr);
	          u && 0 <= d.height ? this.justifyDataLabel(b, c, m, q, d, f) : e(c.crop, !0) && (d = m.x, z = m.y, d += y[0], z += y[1], x = g.isInsidePlot(d, z, {
	            paneCoordinates: !0,
	            series: h
	          }) && g.isInsidePlot(d + q.width, z + q.height, {
	            paneCoordinates: !0,
	            series: h
	          }));
	          if (c.shape && !n) b[f ? "attr" : "animate"]({
	            anchorX: l ? g.plotWidth - a.plotY : a.plotX,
	            anchorY: l ? g.plotHeight - a.plotX : a.plotY
	          });
	        }
	        f && k && (b.placed = !1);
	        x || k && !u ? b.show() : (b.hide(), b.placed = !1);
	      }
	      function g(a, b) {
	        var c = b.filter;
	        return c ? (b = c.operator, a = a[c.property], c = c.value, ">" === b && a > c || "<" === b && a < c || ">=" === b && a >= c || "<=" === b && a <= c || "==" === b && a == c || "===" === b && a === c ? !0 : !1) : !0;
	      }
	      function p() {
	        var a = this,
	          b = a.chart,
	          f = a.options,
	          d = a.points,
	          m = a.hasRendered || 0,
	          p = b.renderer,
	          n = f.dataLabels,
	          q,
	          t = n.animation;
	        t = n.defer ? C(b, t, a) : {
	          defer: 0,
	          duration: 0
	        };
	        n = x(x(b.options.plotOptions && b.options.plotOptions.series && b.options.plotOptions.series.dataLabels, b.options.plotOptions && b.options.plotOptions[a.type] && b.options.plotOptions[a.type].dataLabels), n);
	        A(this, "drawDataLabels");
	        if (u(n) || n.enabled || a._hasPointLabels) {
	          var z = a.plotGroup("dataLabelsGroup", "data-labels", m ? "inherit" : "hidden", n.zIndex || 6);
	          z.attr({
	            opacity: +m
	          });
	          !m && (m = a.dataLabelsGroup) && (a.visible && z.show(), m[f.animation ? "animate" : "attr"]({
	            opacity: 1
	          }, t));
	          d.forEach(function (d) {
	            q = c(x(n, d.dlOptions || d.options && d.options.dataLabels));
	            q.forEach(function (c, h) {
	              var l = c.enabled && (!d.isNull || d.dataLabelOnNull) && g(d, c),
	                m = d.connectors ? d.connectors[h] : d.connector,
	                n = d.dataLabels ? d.dataLabels[h] : d.dataLabel,
	                q = !n,
	                r = e(c.distance, d.labelDistance);
	              if (l) {
	                var t = d.getLabelConfig();
	                var v = e(c[d.formatPrefix + "Format"], c.format);
	                t = E(v) ? w(v, t, b) : (c[d.formatPrefix + "Formatter"] || c.formatter).call(t, c);
	                v = c.style;
	                var u = c.rotation;
	                b.styledMode || (v.color = e(c.color, v.color, a.color, "#000000"), "contrast" === v.color ? (d.contrastColor = p.getContrast(d.color || a.color), v.color = !E(r) && c.inside || 0 > r || f.stacking ? d.contrastColor : "#000000") : delete d.contrastColor, f.cursor && (v.cursor = f.cursor));
	                var x = {
	                  r: c.borderRadius || 0,
	                  rotation: u,
	                  padding: c.padding,
	                  zIndex: 1
	                };
	                b.styledMode || (x.fill = c.backgroundColor, x.stroke = c.borderColor, x["stroke-width"] = c.borderWidth);
	                k(x, function (b, a) {
	                  "undefined" === typeof b && delete x[a];
	                });
	              }
	              !n || l && E(t) && !!n.div === !!c.useHTML && (n.rotation && c.rotation || n.rotation === c.rotation) || (q = !0, d.dataLabel = n = d.dataLabel && d.dataLabel.destroy(), d.dataLabels && (1 === d.dataLabels.length ? delete d.dataLabels : delete d.dataLabels[h]), h || delete d.dataLabel, m && (d.connector = d.connector.destroy(), d.connectors && (1 === d.connectors.length ? delete d.connectors : delete d.connectors[h])));
	              l && E(t) ? (n ? x.text = t : (d.dataLabels = d.dataLabels || [], n = d.dataLabels[h] = u ? p.text(t, 0, 0, c.useHTML).addClass("highcharts-data-label") : p.label(t, 0, 0, c.shape, null, null, c.useHTML, null, "data-label"), h || (d.dataLabel = n), n.addClass(" highcharts-data-label-color-" + d.colorIndex + " " + (c.className || "") + (c.useHTML ? " highcharts-tracker" : ""))), n.options = c, n.attr(x), b.styledMode || n.css(v).shadow(c.shadow), n.added || n.add(z), c.textPath && !c.useHTML && (n.setTextPath(d.getDataLabelPath && d.getDataLabelPath(n) || d.graphic, c.textPath), d.dataLabelPath && !c.textPath.enabled && (d.dataLabelPath = d.dataLabelPath.destroy())), a.alignDataLabel(d, n, c, null, q)) : n && n.hide();
	            });
	          });
	        }
	        A(this, "afterDrawDataLabels");
	      }
	      function y(a, b, c, d, e, f) {
	        var h = this.chart,
	          g = b.align,
	          k = b.verticalAlign,
	          l = a.box ? 0 : a.padding || 0,
	          m = b.x;
	        m = void 0 === m ? 0 : m;
	        var p = b.y;
	        p = void 0 === p ? 0 : p;
	        var n = (c.x || 0) + l;
	        if (0 > n) {
	          "right" === g && 0 <= m ? (b.align = "left", b.inside = !0) : m -= n;
	          var q = !0;
	        }
	        n = (c.x || 0) + d.width - l;
	        n > h.plotWidth && ("left" === g && 0 >= m ? (b.align = "right", b.inside = !0) : m += h.plotWidth - n, q = !0);
	        n = c.y + l;
	        0 > n && ("bottom" === k && 0 <= p ? (b.verticalAlign = "top", b.inside = !0) : p -= n, q = !0);
	        n = (c.y || 0) + d.height - l;
	        n > h.plotHeight && ("top" === k && 0 >= p ? (b.verticalAlign = "bottom", b.inside = !0) : p += h.plotHeight - n, q = !0);
	        q && (b.x = m, b.y = p, a.placed = !f, a.align(b, void 0, e));
	        return q;
	      }
	      function x(a, b) {
	        var c = [],
	          d;
	        if (u(a) && !u(b)) c = a.map(function (a) {
	          return n(a, b);
	        });else if (u(b) && !u(a)) c = b.map(function (b) {
	          return n(a, b);
	        });else if (u(a) || u(b)) for (d = Math.max(a.length, b.length); d--;) c[d] = n(a[d], b[d]);else c = n(a, b);
	        return c;
	      }
	      function z(a, b, c, d, e) {
	        var f = this.chart,
	          g = f.inverted,
	          h = this.xAxis,
	          k = h.reversed,
	          l = g ? b.height / 2 : b.width / 2;
	        a = (a = a.pointWidth) ? a / 2 : 0;
	        b.startXPos = g ? e.x : k ? -l - a : h.width - l + a;
	        b.startYPos = g ? k ? this.yAxis.height - l + a : -l - a : e.y;
	        d ? "hidden" === b.visibility && (b.show(), b.attr({
	          opacity: 0
	        }).animate({
	          opacity: 1
	        })) : b.attr({
	          opacity: 1
	        }).animate({
	          opacity: 0
	        }, void 0, b.hide);
	        f.hasRendered && (c && b.attr({
	          x: b.startXPos,
	          y: b.startYPos
	        }), b.placed = !0);
	      }
	      var m = [];
	      a.compose = function (a) {
	        if (-1 === m.indexOf(a)) {
	          var b = a.prototype;
	          m.push(a);
	          b.alignDataLabel = f;
	          b.drawDataLabels = p;
	          b.justifyDataLabel = y;
	          b.setDataLabelStartPos = z;
	        }
	      };
	    })(p || (p = {}));
	    return p;
	  });
	  K(f, "Series/Column/ColumnDataLabel.js", [f["Core/Series/DataLabel.js"], f["Core/Series/SeriesRegistry.js"], f["Core/Utilities.js"]], function (a, f, B) {
	    var C = f.series,
	      w = B.merge,
	      E = B.pick,
	      I;
	    (function (f) {
	      function u(a, e, c, f, g) {
	        var k = this.chart.inverted,
	          n = a.series,
	          p = (n.xAxis ? n.xAxis.len : this.chart.plotSizeX) || 0;
	        n = (n.yAxis ? n.yAxis.len : this.chart.plotSizeY) || 0;
	        var u = a.dlBox || a.shapeArgs,
	          x = E(a.below, a.plotY > E(this.translatedThreshold, n)),
	          z = E(c.inside, !!this.options.stacking);
	        u && (f = w(u), 0 > f.y && (f.height += f.y, f.y = 0), u = f.y + f.height - n, 0 < u && u < f.height && (f.height -= u), k && (f = {
	          x: n - f.y - f.height,
	          y: p - f.x - f.width,
	          width: f.height,
	          height: f.width
	        }), z || (k ? (f.x += x ? 0 : f.width, f.width = 0) : (f.y += x ? f.height : 0, f.height = 0)));
	        c.align = E(c.align, !k || z ? "center" : x ? "right" : "left");
	        c.verticalAlign = E(c.verticalAlign, k || z ? "middle" : x ? "top" : "bottom");
	        C.prototype.alignDataLabel.call(this, a, e, c, f, g);
	        c.inside && a.contrastColor && e.css({
	          color: a.contrastColor
	        });
	      }
	      var n = [];
	      f.compose = function (f) {
	        a.compose(C);
	        -1 === n.indexOf(f) && (n.push(f), f.prototype.alignDataLabel = u);
	      };
	    })(I || (I = {}));
	    return I;
	  });
	  K(f, "Series/Bar/BarSeries.js", [f["Series/Column/ColumnSeries.js"], f["Core/Series/SeriesRegistry.js"], f["Core/Utilities.js"]], function (a, f, B) {
	    var C = this && this.__extends || function () {
	        var a = function (f, u) {
	          a = Object.setPrototypeOf || {
	            __proto__: []
	          } instanceof Array && function (a, f) {
	            a.__proto__ = f;
	          } || function (a, f) {
	            for (var e in f) f.hasOwnProperty(e) && (a[e] = f[e]);
	          };
	          return a(f, u);
	        };
	        return function (f, u) {
	          function n() {
	            this.constructor = f;
	          }
	          a(f, u);
	          f.prototype = null === u ? Object.create(u) : (n.prototype = u.prototype, new n());
	        };
	      }(),
	      w = B.extend,
	      E = B.merge;
	    B = function (f) {
	      function w() {
	        var a = null !== f && f.apply(this, arguments) || this;
	        a.data = void 0;
	        a.options = void 0;
	        a.points = void 0;
	        return a;
	      }
	      C(w, f);
	      w.defaultOptions = E(a.defaultOptions, {});
	      return w;
	    }(a);
	    w(B.prototype, {
	      inverted: !0
	    });
	    f.registerSeriesType("bar", B);
	    return B;
	  });
	  K(f, "Series/Scatter/ScatterSeries.js", [f["Series/Column/ColumnSeries.js"], f["Series/Line/LineSeries.js"], f["Core/Series/SeriesRegistry.js"], f["Core/Utilities.js"]], function (a, f, B, H) {
	    var w = this && this.__extends || function () {
	        var a = function (f, k) {
	          a = Object.setPrototypeOf || {
	            __proto__: []
	          } instanceof Array && function (a, c) {
	            a.__proto__ = c;
	          } || function (a, c) {
	            for (var e in c) c.hasOwnProperty(e) && (a[e] = c[e]);
	          };
	          return a(f, k);
	        };
	        return function (f, k) {
	          function e() {
	            this.constructor = f;
	          }
	          a(f, k);
	          f.prototype = null === k ? Object.create(k) : (e.prototype = k.prototype, new e());
	        };
	      }(),
	      C = H.addEvent,
	      I = H.extend,
	      A = H.merge;
	    H = function (a) {
	      function n() {
	        var f = null !== a && a.apply(this, arguments) || this;
	        f.data = void 0;
	        f.options = void 0;
	        f.points = void 0;
	        return f;
	      }
	      w(n, a);
	      n.prototype.applyJitter = function () {
	        var a = this,
	          e = this.options.jitter,
	          c = this.points.length;
	        e && this.points.forEach(function (f, g) {
	          ["x", "y"].forEach(function (k, n) {
	            var p = "plot" + k.toUpperCase();
	            if (e[k] && !f.isNull) {
	              var q = a[k + "Axis"];
	              var t = e[k] * q.transA;
	              if (q && !q.isLog) {
	                var z = Math.max(0, f[p] - t);
	                q = Math.min(q.len, f[p] + t);
	                n = 1E4 * Math.sin(g + n * c);
	                f[p] = z + (q - z) * (n - Math.floor(n));
	                "x" === k && (f.clientX = f.plotX);
	              }
	            }
	          });
	        });
	      };
	      n.prototype.drawGraph = function () {
	        this.options.lineWidth ? a.prototype.drawGraph.call(this) : this.graph && (this.graph = this.graph.destroy());
	      };
	      n.defaultOptions = A(f.defaultOptions, {
	        lineWidth: 0,
	        findNearestPointBy: "xy",
	        jitter: {
	          x: 0,
	          y: 0
	        },
	        marker: {
	          enabled: !0
	        },
	        tooltip: {
	          headerFormat: '<span style="color:{point.color}">\u25cf</span> <span style="font-size: 10px"> {series.name}</span><br/>',
	          pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>"
	        }
	      });
	      return n;
	    }(f);
	    I(H.prototype, {
	      drawTracker: a.prototype.drawTracker,
	      sorted: !1,
	      requireSorting: !1,
	      noSharedTooltip: !0,
	      trackerGroups: ["group", "markerGroup", "dataLabelsGroup"],
	      takeOrdinalPosition: !1
	    });
	    C(H, "afterTranslate", function () {
	      this.applyJitter();
	    });
	    B.registerSeriesType("scatter", H);
	    return H;
	  });
	  K(f, "Series/CenteredUtilities.js", [f["Core/Globals.js"], f["Core/Series/Series.js"], f["Core/Utilities.js"]], function (a, f, B) {
	    var C = a.deg2rad,
	      w = B.isNumber,
	      E = B.pick,
	      I = B.relativeLength,
	      A;
	    (function (a) {
	      a.getCenter = function () {
	        var a = this.options,
	          k = this.chart,
	          e = 2 * (a.slicedOffset || 0),
	          c = k.plotWidth - 2 * e,
	          p = k.plotHeight - 2 * e,
	          g = a.center,
	          t = Math.min(c, p),
	          q = a.thickness,
	          u = a.size,
	          y = a.innerSize || 0;
	        "string" === typeof u && (u = parseFloat(u));
	        "string" === typeof y && (y = parseFloat(y));
	        a = [E(g[0], "50%"), E(g[1], "50%"), E(u && 0 > u ? void 0 : a.size, "100%"), E(y && 0 > y ? void 0 : a.innerSize || 0, "0%")];
	        !k.angular || this instanceof f || (a[3] = 0);
	        for (g = 0; 4 > g; ++g) u = a[g], k = 2 > g || 2 === g && /%$/.test(u), a[g] = I(u, [c, p, t, a[2]][g]) + (k ? e : 0);
	        a[3] > a[2] && (a[3] = a[2]);
	        w(q) && 2 * q < a[2] && 0 < q && (a[3] = a[2] - 2 * q);
	        return a;
	      };
	      a.getStartAndEndRadians = function (a, f) {
	        a = w(a) ? a : 0;
	        f = w(f) && f > a && 360 > f - a ? f : a + 360;
	        return {
	          start: C * (a + -90),
	          end: C * (f + -90)
	        };
	      };
	    })(A || (A = {}));
	    return A;
	  });
	  K(f, "Series/Pie/PiePoint.js", [f["Core/Animation/AnimationUtilities.js"], f["Core/Series/Point.js"], f["Core/Utilities.js"]], function (a, f, B) {
	    var C = this && this.__extends || function () {
	        var a = function (e, c) {
	          a = Object.setPrototypeOf || {
	            __proto__: []
	          } instanceof Array && function (a, c) {
	            a.__proto__ = c;
	          } || function (a, c) {
	            for (var e in c) c.hasOwnProperty(e) && (a[e] = c[e]);
	          };
	          return a(e, c);
	        };
	        return function (e, c) {
	          function f() {
	            this.constructor = e;
	          }
	          a(e, c);
	          e.prototype = null === c ? Object.create(c) : (f.prototype = c.prototype, new f());
	        };
	      }(),
	      w = a.setAnimation,
	      E = B.addEvent,
	      I = B.defined;
	    a = B.extend;
	    var A = B.isNumber,
	      u = B.pick,
	      n = B.relativeLength;
	    f = function (a) {
	      function e() {
	        var c = null !== a && a.apply(this, arguments) || this;
	        c.labelDistance = void 0;
	        c.options = void 0;
	        c.series = void 0;
	        return c;
	      }
	      C(e, a);
	      e.prototype.getConnectorPath = function () {
	        var a = this.labelPosition,
	          e = this.series.options.dataLabels,
	          f = this.connectorShapes,
	          k = e.connectorShape;
	        f[k] && (k = f[k]);
	        return k.call(this, {
	          x: a.final.x,
	          y: a.final.y,
	          alignment: a.alignment
	        }, a.connectorPosition, e);
	      };
	      e.prototype.getTranslate = function () {
	        return this.sliced ? this.slicedTranslation : {
	          translateX: 0,
	          translateY: 0
	        };
	      };
	      e.prototype.haloPath = function (a) {
	        var c = this.shapeArgs;
	        return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(c.x, c.y, c.r + a, c.r + a, {
	          innerR: c.r - 1,
	          start: c.start,
	          end: c.end
	        });
	      };
	      e.prototype.init = function () {
	        var c = this;
	        a.prototype.init.apply(this, arguments);
	        this.name = u(this.name, "Slice");
	        var e = function (a) {
	          c.slice("select" === a.type);
	        };
	        E(this, "select", e);
	        E(this, "unselect", e);
	        return this;
	      };
	      e.prototype.isValid = function () {
	        return A(this.y) && 0 <= this.y;
	      };
	      e.prototype.setVisible = function (a, e) {
	        var c = this,
	          f = this.series,
	          k = f.chart,
	          n = f.options.ignoreHiddenPoint;
	        e = u(e, n);
	        a !== this.visible && (this.visible = this.options.visible = a = "undefined" === typeof a ? !this.visible : a, f.options.data[f.data.indexOf(this)] = this.options, ["graphic", "dataLabel", "connector", "shadowGroup"].forEach(function (e) {
	          if (c[e]) c[e][a ? "show" : "hide"](a);
	        }), this.legendItem && k.legend.colorizeItem(this, a), a || "hover" !== this.state || this.setState(""), n && (f.isDirty = !0), e && k.redraw());
	      };
	      e.prototype.slice = function (a, e, f) {
	        var c = this.series;
	        w(f, c.chart);
	        u(e, !0);
	        this.sliced = this.options.sliced = I(a) ? a : !this.sliced;
	        c.options.data[c.data.indexOf(this)] = this.options;
	        this.graphic && this.graphic.animate(this.getTranslate());
	        this.shadowGroup && this.shadowGroup.animate(this.getTranslate());
	      };
	      return e;
	    }(f);
	    a(f.prototype, {
	      connectorShapes: {
	        fixedOffset: function (a, e, c) {
	          var f = e.breakAt;
	          e = e.touchingSliceAt;
	          return [["M", a.x, a.y], c.softConnector ? ["C", a.x + ("left" === a.alignment ? -5 : 5), a.y, 2 * f.x - e.x, 2 * f.y - e.y, f.x, f.y] : ["L", f.x, f.y], ["L", e.x, e.y]];
	        },
	        straight: function (a, e) {
	          e = e.touchingSliceAt;
	          return [["M", a.x, a.y], ["L", e.x, e.y]];
	        },
	        crookedLine: function (a, e, c) {
	          e = e.touchingSliceAt;
	          var f = this.series,
	            g = f.center[0],
	            k = f.chart.plotWidth,
	            q = f.chart.plotLeft;
	          f = a.alignment;
	          var u = this.shapeArgs.r;
	          c = n(c.crookDistance, 1);
	          k = "left" === f ? g + u + (k + q - g - u) * (1 - c) : q + (g - u) * c;
	          c = ["L", k, a.y];
	          g = !0;
	          if ("left" === f ? k > a.x || k < e.x : k < a.x || k > e.x) g = !1;
	          a = [["M", a.x, a.y]];
	          g && a.push(c);
	          a.push(["L", e.x, e.y]);
	          return a;
	        }
	      }
	    });
	    return f;
	  });
	  K(f, "Series/Pie/PieSeries.js", [f["Series/CenteredUtilities.js"], f["Series/Column/ColumnSeries.js"], f["Core/Globals.js"], f["Core/Legend/LegendSymbol.js"], f["Series/Pie/PiePoint.js"], f["Core/Series/Series.js"], f["Core/Series/SeriesRegistry.js"], f["Core/Renderer/SVG/Symbols.js"], f["Core/Utilities.js"]], function (a, f, B, H, w, E, I, A, u) {
	    var n = this && this.__extends || function () {
	        var a = function (c, e) {
	          a = Object.setPrototypeOf || {
	            __proto__: []
	          } instanceof Array && function (a, c) {
	            a.__proto__ = c;
	          } || function (a, c) {
	            for (var e in c) c.hasOwnProperty(e) && (a[e] = c[e]);
	          };
	          return a(c, e);
	        };
	        return function (c, e) {
	          function f() {
	            this.constructor = c;
	          }
	          a(c, e);
	          c.prototype = null === e ? Object.create(e) : (f.prototype = e.prototype, new f());
	        };
	      }(),
	      k = a.getStartAndEndRadians;
	    B = B.noop;
	    var e = u.clamp,
	      c = u.extend,
	      p = u.fireEvent,
	      g = u.merge,
	      t = u.pick,
	      q = u.relativeLength;
	    u = function (a) {
	      function c() {
	        var c = null !== a && a.apply(this, arguments) || this;
	        c.center = void 0;
	        c.data = void 0;
	        c.maxLabelDistance = void 0;
	        c.options = void 0;
	        c.points = void 0;
	        return c;
	      }
	      n(c, a);
	      c.prototype.animate = function (a) {
	        var c = this,
	          e = c.points,
	          f = c.startAngleRad;
	        a || e.forEach(function (a) {
	          var b = a.graphic,
	            d = a.shapeArgs;
	          b && d && (b.attr({
	            r: t(a.startR, c.center && c.center[3] / 2),
	            start: f,
	            end: f
	          }), b.animate({
	            r: d.r,
	            start: d.start,
	            end: d.end
	          }, c.options.animation));
	        });
	      };
	      c.prototype.drawEmpty = function () {
	        var a = this.startAngleRad,
	          c = this.endAngleRad,
	          e = this.options;
	        if (0 === this.total && this.center) {
	          var f = this.center[0];
	          var b = this.center[1];
	          this.graph || (this.graph = this.chart.renderer.arc(f, b, this.center[1] / 2, 0, a, c).addClass("highcharts-empty-series").add(this.group));
	          this.graph.attr({
	            d: A.arc(f, b, this.center[2] / 2, 0, {
	              start: a,
	              end: c,
	              innerR: this.center[3] / 2
	            })
	          });
	          this.chart.styledMode || this.graph.attr({
	            "stroke-width": e.borderWidth,
	            fill: e.fillColor || "none",
	            stroke: e.color || "#cccccc"
	          });
	        } else this.graph && (this.graph = this.graph.destroy());
	      };
	      c.prototype.drawPoints = function () {
	        var a = this.chart.renderer;
	        this.points.forEach(function (c) {
	          c.graphic && c.hasNewShapeType() && (c.graphic = c.graphic.destroy());
	          c.graphic || (c.graphic = a[c.shapeType](c.shapeArgs).add(c.series.group), c.delayedRendering = !0);
	        });
	      };
	      c.prototype.generatePoints = function () {
	        a.prototype.generatePoints.call(this);
	        this.updateTotals();
	      };
	      c.prototype.getX = function (a, c, f) {
	        var g = this.center,
	          b = this.radii ? this.radii[f.index] || 0 : g[2] / 2;
	        a = Math.asin(e((a - g[1]) / (b + f.labelDistance), -1, 1));
	        return g[0] + (c ? -1 : 1) * Math.cos(a) * (b + f.labelDistance) + (0 < f.labelDistance ? (c ? -1 : 1) * this.options.dataLabels.padding : 0);
	      };
	      c.prototype.hasData = function () {
	        return !!this.processedXData.length;
	      };
	      c.prototype.redrawPoints = function () {
	        var a = this,
	          c = a.chart,
	          e = c.renderer,
	          f = a.options.shadow,
	          b,
	          l,
	          d,
	          k;
	        this.drawEmpty();
	        !f || a.shadowGroup || c.styledMode || (a.shadowGroup = e.g("shadow").attr({
	          zIndex: -1
	        }).add(a.group));
	        a.points.forEach(function (h) {
	          var m = {};
	          l = h.graphic;
	          if (!h.isNull && l) {
	            var n = void 0;
	            k = h.shapeArgs;
	            b = h.getTranslate();
	            c.styledMode || (n = h.shadowGroup, f && !n && (n = h.shadowGroup = e.g("shadow").add(a.shadowGroup)), n && n.attr(b), d = a.pointAttribs(h, h.selected && "select"));
	            h.delayedRendering ? (l.setRadialReference(a.center).attr(k).attr(b), c.styledMode || l.attr(d).attr({
	              "stroke-linejoin": "round"
	            }).shadow(f, n), h.delayedRendering = !1) : (l.setRadialReference(a.center), c.styledMode || g(!0, m, d), g(!0, m, k, b), l.animate(m));
	            l.attr({
	              visibility: h.visible ? "inherit" : "hidden"
	            });
	            l.addClass(h.getClassName(), !0);
	          } else l && (h.graphic = l.destroy());
	        });
	      };
	      c.prototype.sortByAngle = function (a, c) {
	        a.sort(function (a, e) {
	          return "undefined" !== typeof a.angle && (e.angle - a.angle) * c;
	        });
	      };
	      c.prototype.translate = function (a) {
	        this.generatePoints();
	        var c = this.options,
	          e = c.slicedOffset,
	          f = e + (c.borderWidth || 0),
	          b = k(c.startAngle, c.endAngle),
	          g = this.startAngleRad = b.start;
	        b = (this.endAngleRad = b.end) - g;
	        var d = this.points,
	          n = c.dataLabels.distance;
	        c = c.ignoreHiddenPoint;
	        var v = d.length,
	          r,
	          u = 0;
	        a || (this.center = a = this.getCenter());
	        for (r = 0; r < v; r++) {
	          var w = d[r];
	          var y = g + u * b;
	          !w.isValid() || c && !w.visible || (u += w.percentage / 100);
	          var x = g + u * b;
	          var C = {
	            x: a[0],
	            y: a[1],
	            r: a[2] / 2,
	            innerR: a[3] / 2,
	            start: Math.round(1E3 * y) / 1E3,
	            end: Math.round(1E3 * x) / 1E3
	          };
	          w.shapeType = "arc";
	          w.shapeArgs = C;
	          w.labelDistance = t(w.options.dataLabels && w.options.dataLabels.distance, n);
	          w.labelDistance = q(w.labelDistance, C.r);
	          this.maxLabelDistance = Math.max(this.maxLabelDistance || 0, w.labelDistance);
	          x = (x + y) / 2;
	          x > 1.5 * Math.PI ? x -= 2 * Math.PI : x < -Math.PI / 2 && (x += 2 * Math.PI);
	          w.slicedTranslation = {
	            translateX: Math.round(Math.cos(x) * e),
	            translateY: Math.round(Math.sin(x) * e)
	          };
	          C = Math.cos(x) * a[2] / 2;
	          var A = Math.sin(x) * a[2] / 2;
	          w.tooltipPos = [a[0] + .7 * C, a[1] + .7 * A];
	          w.half = x < -Math.PI / 2 || x > Math.PI / 2 ? 1 : 0;
	          w.angle = x;
	          y = Math.min(f, w.labelDistance / 5);
	          w.labelPosition = {
	            natural: {
	              x: a[0] + C + Math.cos(x) * w.labelDistance,
	              y: a[1] + A + Math.sin(x) * w.labelDistance
	            },
	            "final": {},
	            alignment: 0 > w.labelDistance ? "center" : w.half ? "right" : "left",
	            connectorPosition: {
	              breakAt: {
	                x: a[0] + C + Math.cos(x) * y,
	                y: a[1] + A + Math.sin(x) * y
	              },
	              touchingSliceAt: {
	                x: a[0] + C,
	                y: a[1] + A
	              }
	            }
	          };
	        }
	        p(this, "afterTranslate");
	      };
	      c.prototype.updateTotals = function () {
	        var a = this.points,
	          c = a.length,
	          e = this.options.ignoreHiddenPoint,
	          f,
	          b = 0;
	        for (f = 0; f < c; f++) {
	          var g = a[f];
	          !g.isValid() || e && !g.visible || (b += g.y);
	        }
	        this.total = b;
	        for (f = 0; f < c; f++) g = a[f], g.percentage = 0 < b && (g.visible || !e) ? g.y / b * 100 : 0, g.total = b;
	      };
	      c.defaultOptions = g(E.defaultOptions, {
	        center: [null, null],
	        clip: !1,
	        colorByPoint: !0,
	        dataLabels: {
	          allowOverlap: !0,
	          connectorPadding: 5,
	          connectorShape: "fixedOffset",
	          crookDistance: "70%",
	          distance: 30,
	          enabled: !0,
	          formatter: function () {
	            return this.point.isNull ? void 0 : this.point.name;
	          },
	          softConnector: !0,
	          x: 0
	        },
	        fillColor: void 0,
	        ignoreHiddenPoint: !0,
	        inactiveOtherPoints: !0,
	        legendType: "point",
	        marker: null,
	        size: null,
	        showInLegend: !1,
	        slicedOffset: 10,
	        stickyTracking: !1,
	        tooltip: {
	          followPointer: !0
	        },
	        borderColor: "#ffffff",
	        borderWidth: 1,
	        lineWidth: void 0,
	        states: {
	          hover: {
	            brightness: .1
	          }
	        }
	      });
	      return c;
	    }(E);
	    c(u.prototype, {
	      axisTypes: [],
	      directTouch: !0,
	      drawGraph: void 0,
	      drawLegendSymbol: H.drawRectangle,
	      drawTracker: f.prototype.drawTracker,
	      getCenter: a.getCenter,
	      getSymbol: B,
	      isCartesian: !1,
	      noSharedTooltip: !0,
	      pointAttribs: f.prototype.pointAttribs,
	      pointClass: w,
	      requireSorting: !1,
	      searchPoint: B,
	      trackerGroups: ["group", "dataLabelsGroup"]
	    });
	    I.registerSeriesType("pie", u);
	    return u;
	  });
	  K(f, "Series/Pie/PieDataLabel.js", [f["Core/Series/DataLabel.js"], f["Core/Globals.js"], f["Core/Renderer/RendererUtilities.js"], f["Core/Series/SeriesRegistry.js"], f["Core/Utilities.js"]], function (a, f, B, H, w) {
	    var C = f.noop,
	      I = B.distribute,
	      A = H.series,
	      u = w.arrayMax,
	      n = w.clamp,
	      k = w.defined,
	      e = w.merge,
	      c = w.pick,
	      p = w.relativeLength,
	      g;
	    (function (f) {
	      function g() {
	        var a = this,
	          f = a.data,
	          b = a.chart,
	          g = a.options.dataLabels || {},
	          d = g.connectorPadding,
	          n = b.plotWidth,
	          p = b.plotHeight,
	          q = b.plotLeft,
	          t = Math.round(b.chartWidth / 3),
	          w = a.center,
	          z = w[2] / 2,
	          x = w[1],
	          y = [[], []],
	          C = [0, 0, 0, 0],
	          B = a.dataLabelPositioners,
	          F,
	          E,
	          H,
	          K,
	          U,
	          G,
	          T,
	          M,
	          V,
	          W,
	          Z,
	          R;
	        a.visible && (g.enabled || a._hasPointLabels) && (f.forEach(function (a) {
	          a.dataLabel && a.visible && a.dataLabel.shortened && (a.dataLabel.attr({
	            width: "auto"
	          }).css({
	            width: "auto",
	            textOverflow: "clip"
	          }), a.dataLabel.shortened = !1);
	        }), A.prototype.drawDataLabels.apply(a), f.forEach(function (a) {
	          a.dataLabel && (a.visible ? (y[a.half].push(a), a.dataLabel._pos = null, !k(g.style.width) && !k(a.options.dataLabels && a.options.dataLabels.style && a.options.dataLabels.style.width) && a.dataLabel.getBBox().width > t && (a.dataLabel.css({
	            width: Math.round(.7 * t) + "px"
	          }), a.dataLabel.shortened = !0)) : (a.dataLabel = a.dataLabel.destroy(), a.dataLabels && 1 === a.dataLabels.length && delete a.dataLabels));
	        }), y.forEach(function (e, f) {
	          var h = e.length,
	            l = [],
	            m;
	          if (h) {
	            a.sortByAngle(e, f - .5);
	            if (0 < a.maxLabelDistance) {
	              var r = Math.max(0, x - z - a.maxLabelDistance);
	              var t = Math.min(x + z + a.maxLabelDistance, b.plotHeight);
	              e.forEach(function (a) {
	                0 < a.labelDistance && a.dataLabel && (a.top = Math.max(0, x - z - a.labelDistance), a.bottom = Math.min(x + z + a.labelDistance, b.plotHeight), m = a.dataLabel.getBBox().height || 21, a.distributeBox = {
	                  target: a.labelPosition.natural.y - a.top + m / 2,
	                  size: m,
	                  rank: a.y
	                }, l.push(a.distributeBox));
	              });
	              r = t + m - r;
	              I(l, r, r / 5);
	            }
	            for (Z = 0; Z < h; Z++) {
	              F = e[Z];
	              G = F.labelPosition;
	              K = F.dataLabel;
	              W = !1 === F.visible ? "hidden" : "inherit";
	              V = r = G.natural.y;
	              l && k(F.distributeBox) && ("undefined" === typeof F.distributeBox.pos ? W = "hidden" : (T = F.distributeBox.size, V = B.radialDistributionY(F)));
	              delete F.positionIndex;
	              if (g.justify) M = B.justify(F, z, w);else switch (g.alignTo) {
	                case "connectors":
	                  M = B.alignToConnectors(e, f, n, q);
	                  break;
	                case "plotEdges":
	                  M = B.alignToPlotEdges(K, f, n, q);
	                  break;
	                default:
	                  M = B.radialDistributionX(a, F, V, r);
	              }
	              K._attr = {
	                visibility: W,
	                align: G.alignment
	              };
	              R = F.options.dataLabels || {};
	              K._pos = {
	                x: M + c(R.x, g.x) + ({
	                  left: d,
	                  right: -d
	                }[G.alignment] || 0),
	                y: V + c(R.y, g.y) - 10
	              };
	              G.final.x = M;
	              G.final.y = V;
	              c(g.crop, !0) && (U = K.getBBox().width, r = null, M - U < d && 1 === f ? (r = Math.round(U - M + d), C[3] = Math.max(r, C[3])) : M + U > n - d && 0 === f && (r = Math.round(M + U - n + d), C[1] = Math.max(r, C[1])), 0 > V - T / 2 ? C[0] = Math.max(Math.round(-V + T / 2), C[0]) : V + T / 2 > p && (C[2] = Math.max(Math.round(V + T / 2 - p), C[2])), K.sideOverflow = r);
	            }
	          }
	        }), 0 === u(C) || this.verifyDataLabelOverflow(C)) && (this.placeDataLabels(), this.points.forEach(function (d) {
	          R = e(g, d.options.dataLabels);
	          if (E = c(R.connectorWidth, 1)) {
	            var f;
	            H = d.connector;
	            if ((K = d.dataLabel) && K._pos && d.visible && 0 < d.labelDistance) {
	              W = K._attr.visibility;
	              if (f = !H) d.connector = H = b.renderer.path().addClass("highcharts-data-label-connector  highcharts-color-" + d.colorIndex + (d.className ? " " + d.className : "")).add(a.dataLabelsGroup), b.styledMode || H.attr({
	                "stroke-width": E,
	                stroke: R.connectorColor || d.color || "#666666"
	              });
	              H[f ? "attr" : "animate"]({
	                d: d.getConnectorPath()
	              });
	              H.attr("visibility", W);
	            } else H && (d.connector = H.destroy());
	          }
	        }));
	      }
	      function t() {
	        this.points.forEach(function (a) {
	          var c = a.dataLabel,
	            b;
	          c && a.visible && ((b = c._pos) ? (c.sideOverflow && (c._attr.width = Math.max(c.getBBox().width - c.sideOverflow, 0), c.css({
	            width: c._attr.width + "px",
	            textOverflow: (this.options.dataLabels.style || {}).textOverflow || "ellipsis"
	          }), c.shortened = !0), c.attr(c._attr), c[c.moved ? "animate" : "attr"](b), c.moved = !0) : c && c.attr({
	            y: -9999
	          }));
	          delete a.distributeBox;
	        }, this);
	      }
	      function w(a) {
	        var c = this.center,
	          b = this.options,
	          e = b.center,
	          d = b.minSize || 80,
	          f = null !== b.size;
	        if (!f) {
	          if (null !== e[0]) var g = Math.max(c[2] - Math.max(a[1], a[3]), d);else g = Math.max(c[2] - a[1] - a[3], d), c[0] += (a[3] - a[1]) / 2;
	          null !== e[1] ? g = n(g, d, c[2] - Math.max(a[0], a[2])) : (g = n(g, d, c[2] - a[0] - a[2]), c[1] += (a[0] - a[2]) / 2);
	          g < c[2] ? (c[2] = g, c[3] = Math.min(b.thickness ? Math.max(0, g - 2 * b.thickness) : Math.max(0, p(b.innerSize || 0, g)), g), this.translate(c), this.drawDataLabels && this.drawDataLabels()) : f = !0;
	        }
	        return f;
	      }
	      var x = [],
	        z = {
	          radialDistributionY: function (a) {
	            return a.top + a.distributeBox.pos;
	          },
	          radialDistributionX: function (a, c, b, e) {
	            return a.getX(b < c.top + 2 || b > c.bottom - 2 ? e : b, c.half, c);
	          },
	          justify: function (a, c, b) {
	            return b[0] + (a.half ? -1 : 1) * (c + a.labelDistance);
	          },
	          alignToPlotEdges: function (a, c, b, e) {
	            a = a.getBBox().width;
	            return c ? a + e : b - a - e;
	          },
	          alignToConnectors: function (a, c, b, e) {
	            var d = 0,
	              f;
	            a.forEach(function (a) {
	              f = a.dataLabel.getBBox().width;
	              f > d && (d = f);
	            });
	            return c ? d + e : b - d - e;
	          }
	        };
	      f.compose = function (c) {
	        a.compose(A);
	        -1 === x.indexOf(c) && (x.push(c), c = c.prototype, c.dataLabelPositioners = z, c.alignDataLabel = C, c.drawDataLabels = g, c.placeDataLabels = t, c.verifyDataLabelOverflow = w);
	      };
	    })(g || (g = {}));
	    return g;
	  });
	  K(f, "Extensions/OverlappingDataLabels.js", [f["Core/Chart/Chart.js"], f["Core/Utilities.js"]], function (a, f) {
	    function C(a, f) {
	      var e = !1;
	      if (a) {
	        var c = a.newOpacity;
	        a.oldOpacity !== c && (a.alignAttr && a.placed ? (a[c ? "removeClass" : "addClass"]("highcharts-data-label-hidden"), e = !0, a.alignAttr.opacity = c, a[a.isOld ? "animate" : "attr"](a.alignAttr, null, function () {
	          f.styledMode || a.css({
	            pointerEvents: c ? "auto" : "none"
	          });
	        }), w(f, "afterHideOverlappingLabel")) : a.attr({
	          opacity: c
	        }));
	        a.isOld = !0;
	      }
	      return e;
	    }
	    var H = f.addEvent,
	      w = f.fireEvent,
	      E = f.isArray,
	      I = f.isNumber,
	      A = f.objectEach,
	      u = f.pick;
	    H(a, "render", function () {
	      var a = this,
	        f = [];
	      (this.labelCollectors || []).forEach(function (a) {
	        f = f.concat(a());
	      });
	      (this.yAxis || []).forEach(function (a) {
	        a.stacking && a.options.stackLabels && !a.options.stackLabels.allowOverlap && A(a.stacking.stacks, function (a) {
	          A(a, function (a) {
	            a.label && f.push(a.label);
	          });
	        });
	      });
	      (this.series || []).forEach(function (e) {
	        var c = e.options.dataLabels;
	        e.visible && (!1 !== c.enabled || e._hasPointLabels) && (c = function (c) {
	          return c.forEach(function (c) {
	            c.visible && (E(c.dataLabels) ? c.dataLabels : c.dataLabel ? [c.dataLabel] : []).forEach(function (e) {
	              var g = e.options;
	              e.labelrank = u(g.labelrank, c.labelrank, c.shapeArgs && c.shapeArgs.height);
	              g.allowOverlap ? (e.oldOpacity = e.opacity, e.newOpacity = 1, C(e, a)) : f.push(e);
	            });
	          });
	        }, c(e.nodes || []), c(e.points));
	      });
	      this.hideOverlappingLabels(f);
	    });
	    a.prototype.hideOverlappingLabels = function (a) {
	      var f = this,
	        e = a.length,
	        c = f.renderer,
	        n,
	        g,
	        t,
	        q = !1;
	      var u = function (a) {
	        var e,
	          f = a.box ? 0 : a.padding || 0,
	          b = e = 0,
	          g;
	        if (a && (!a.alignAttr || a.placed)) {
	          var d = a.alignAttr || {
	            x: a.attr("x"),
	            y: a.attr("y")
	          };
	          var k = a.parentGroup;
	          a.width || (e = a.getBBox(), a.width = e.width, a.height = e.height, e = c.fontMetrics(null, a.element).h);
	          var n = a.width - 2 * f;
	          (g = {
	            left: "0",
	            center: "0.5",
	            right: "1"
	          }[a.alignValue]) ? b = +g * n : I(a.x) && Math.round(a.x) !== a.translateX && (b = a.x - a.translateX);
	          return {
	            x: d.x + (k.translateX || 0) + f - (b || 0),
	            y: d.y + (k.translateY || 0) + f - e,
	            width: a.width - 2 * f,
	            height: a.height - 2 * f
	          };
	        }
	      };
	      for (g = 0; g < e; g++) if (n = a[g]) n.oldOpacity = n.opacity, n.newOpacity = 1, n.absoluteBox = u(n);
	      a.sort(function (a, c) {
	        return (c.labelrank || 0) - (a.labelrank || 0);
	      });
	      for (g = 0; g < e; g++) {
	        var y = (u = a[g]) && u.absoluteBox;
	        for (n = g + 1; n < e; ++n) {
	          var x = (t = a[n]) && t.absoluteBox;
	          !y || !x || u === t || 0 === u.newOpacity || 0 === t.newOpacity || "hidden" === u.visibility || "hidden" === t.visibility || x.x >= y.x + y.width || x.x + x.width <= y.x || x.y >= y.y + y.height || x.y + x.height <= y.y || ((u.labelrank < t.labelrank ? u : t).newOpacity = 0);
	        }
	      }
	      a.forEach(function (a) {
	        C(a, f) && (q = !0);
	      });
	      q && w(f, "afterHideAllOverlappingLabels");
	    };
	  });
	  K(f, "Core/Responsive.js", [f["Core/Utilities.js"]], function (a) {
	    var f = a.extend,
	      B = a.find,
	      H = a.isArray,
	      w = a.isObject,
	      E = a.merge,
	      I = a.objectEach,
	      A = a.pick,
	      u = a.splat,
	      n = a.uniqueKey,
	      k;
	    (function (a) {
	      var c = [];
	      a.compose = function (a) {
	        -1 === c.indexOf(a) && (c.push(a), f(a.prototype, e.prototype));
	        return a;
	      };
	      var e = function () {
	        function a() {}
	        a.prototype.currentOptions = function (a) {
	          function c(a, f, g, h) {
	            var b;
	            I(a, function (a, d) {
	              if (!h && -1 < e.collectionsWithUpdate.indexOf(d) && f[d]) for (a = u(a), g[d] = [], b = 0; b < Math.max(a.length, f[d].length); b++) f[d][b] && (void 0 === a[b] ? g[d][b] = f[d][b] : (g[d][b] = {}, c(a[b], f[d][b], g[d][b], h + 1)));else w(a) ? (g[d] = H(a) ? [] : {}, c(a, f[d] || {}, g[d], h + 1)) : g[d] = "undefined" === typeof f[d] ? null : f[d];
	            });
	          }
	          var e = this,
	            f = {};
	          c(a, this.options, f, 0);
	          return f;
	        };
	        a.prototype.matchResponsiveRule = function (a, c) {
	          var e = a.condition;
	          (e.callback || function () {
	            return this.chartWidth <= A(e.maxWidth, Number.MAX_VALUE) && this.chartHeight <= A(e.maxHeight, Number.MAX_VALUE) && this.chartWidth >= A(e.minWidth, 0) && this.chartHeight >= A(e.minHeight, 0);
	          }).call(this) && c.push(a._id);
	        };
	        a.prototype.setResponsive = function (a, c) {
	          var e = this,
	            f = this.options.responsive,
	            g = this.currentResponsive,
	            k = [];
	          !c && f && f.rules && f.rules.forEach(function (a) {
	            "undefined" === typeof a._id && (a._id = n());
	            e.matchResponsiveRule(a, k);
	          }, this);
	          c = E.apply(void 0, k.map(function (a) {
	            return B((f || {}).rules || [], function (c) {
	              return c._id === a;
	            });
	          }).map(function (a) {
	            return a && a.chartOptions;
	          }));
	          c.isResponsiveOptions = !0;
	          k = k.toString() || void 0;
	          k !== (g && g.ruleIds) && (g && this.update(g.undoOptions, a, !0), k ? (g = this.currentOptions(c), g.isResponsiveOptions = !0, this.currentResponsive = {
	            ruleIds: k,
	            mergedOptions: c,
	            undoOptions: g
	          }, this.update(c, a, !0)) : this.currentResponsive = void 0);
	        };
	        return a;
	      }();
	    })(k || (k = {}));
	    return k;
	  });
	  K(f, "masters/highcharts.src.js", [f["Core/Globals.js"], f["Core/Utilities.js"], f["Core/DefaultOptions.js"], f["Core/Animation/Fx.js"], f["Core/Animation/AnimationUtilities.js"], f["Core/Renderer/HTML/AST.js"], f["Core/FormatUtilities.js"], f["Core/Renderer/RendererUtilities.js"], f["Core/Renderer/SVG/SVGElement.js"], f["Core/Renderer/SVG/SVGRenderer.js"], f["Core/Renderer/HTML/HTMLElement.js"], f["Core/Renderer/HTML/HTMLRenderer.js"], f["Core/Axis/Axis.js"], f["Core/Axis/DateTimeAxis.js"], f["Core/Axis/LogarithmicAxis.js"], f["Core/Axis/PlotLineOrBand/PlotLineOrBand.js"], f["Core/Axis/Tick.js"], f["Core/Tooltip.js"], f["Core/Series/Point.js"], f["Core/Pointer.js"], f["Core/MSPointer.js"], f["Core/Legend/Legend.js"], f["Core/Chart/Chart.js"], f["Core/Series/Series.js"], f["Core/Series/SeriesRegistry.js"], f["Series/Column/ColumnSeries.js"], f["Series/Column/ColumnDataLabel.js"], f["Series/Pie/PieSeries.js"], f["Series/Pie/PieDataLabel.js"], f["Core/Series/DataLabel.js"], f["Core/Responsive.js"], f["Core/Color/Color.js"], f["Core/Time.js"]], function (a, f, B, H, w, E, I, A, u, n, k, e, c, p, g, t, q, F, y, x, z, m, h, b, l, d, D, v, r, K, P, S, N) {
	    a.animate = w.animate;
	    a.animObject = w.animObject;
	    a.getDeferredAnimation = w.getDeferredAnimation;
	    a.setAnimation = w.setAnimation;
	    a.stop = w.stop;
	    a.timers = H.timers;
	    a.AST = E;
	    a.Axis = c;
	    a.Chart = h;
	    a.chart = h.chart;
	    a.Fx = H;
	    a.Legend = m;
	    a.PlotLineOrBand = t;
	    a.Point = y;
	    a.Pointer = z.isRequired() ? z : x;
	    a.Series = b;
	    a.SVGElement = u;
	    a.SVGRenderer = n;
	    a.Tick = q;
	    a.Time = N;
	    a.Tooltip = F;
	    a.Color = S;
	    a.color = S.parse;
	    e.compose(n);
	    k.compose(u);
	    a.defaultOptions = B.defaultOptions;
	    a.getOptions = B.getOptions;
	    a.time = B.defaultTime;
	    a.setOptions = B.setOptions;
	    a.dateFormat = I.dateFormat;
	    a.format = I.format;
	    a.numberFormat = I.numberFormat;
	    a.addEvent = f.addEvent;
	    a.arrayMax = f.arrayMax;
	    a.arrayMin = f.arrayMin;
	    a.attr = f.attr;
	    a.clearTimeout = f.clearTimeout;
	    a.correctFloat = f.correctFloat;
	    a.createElement = f.createElement;
	    a.css = f.css;
	    a.defined = f.defined;
	    a.destroyObjectProperties = f.destroyObjectProperties;
	    a.discardElement = f.discardElement;
	    a.distribute = A.distribute;
	    a.erase = f.erase;
	    a.error = f.error;
	    a.extend = f.extend;
	    a.extendClass = f.extendClass;
	    a.find = f.find;
	    a.fireEvent = f.fireEvent;
	    a.getMagnitude = f.getMagnitude;
	    a.getStyle = f.getStyle;
	    a.inArray = f.inArray;
	    a.isArray = f.isArray;
	    a.isClass = f.isClass;
	    a.isDOMElement = f.isDOMElement;
	    a.isFunction = f.isFunction;
	    a.isNumber = f.isNumber;
	    a.isObject = f.isObject;
	    a.isString = f.isString;
	    a.keys = f.keys;
	    a.merge = f.merge;
	    a.normalizeTickInterval = f.normalizeTickInterval;
	    a.objectEach = f.objectEach;
	    a.offset = f.offset;
	    a.pad = f.pad;
	    a.pick = f.pick;
	    a.pInt = f.pInt;
	    a.relativeLength = f.relativeLength;
	    a.removeEvent = f.removeEvent;
	    a.seriesType = l.seriesType;
	    a.splat = f.splat;
	    a.stableSort = f.stableSort;
	    a.syncTimeout = f.syncTimeout;
	    a.timeUnits = f.timeUnits;
	    a.uniqueKey = f.uniqueKey;
	    a.useSerialIds = f.useSerialIds;
	    a.wrap = f.wrap;
	    D.compose(d);
	    K.compose(b);
	    p.compose(c);
	    g.compose(c);
	    r.compose(v);
	    t.compose(c);
	    P.compose(h);
	    return a;
	  });
	  f["masters/highcharts.src.js"]._modules = f;
	  return f["masters/highcharts.src.js"];
	});
} (highcharts));

var Highcharts$1 = highcharts.exports;

var _default$q = /*#__PURE__*/function (_Controller) {
  _inherits$w(_default, _Controller);
  var _super = _createSuper$w(_default);
  function _default() {
    _classCallCheck$x(this, _default);
    return _super.apply(this, arguments);
  }
  _createClass$x(_default, [{
    key: "initialize",
    value: function initialize() {
      this.getJson();
      this.addCurrentPeriodClassToDefaultPeriod();
    }

    // A user clicked on a period link eg "3y"
    // Update the 'period' stimulus 'value' data attribute on the controller element in the DOM with
    // the data-period attribute on the clicked link, and then refresh the graph, which will request
    // json for the selected time period eg "3y"
  }, {
    key: "periodChanged",
    value: function periodChanged(event) {
      this.periodValue = event.target.getAttribute("data-period");
      this.removeCurrentClassFromAllPeriods();
      this.addCurrentClassToSelectedPeriod(event.target);
      this.getJson();
    }
  }, {
    key: "removeCurrentClassFromAllPeriods",
    value: function removeCurrentClassFromAllPeriods() {
      this.periodTargets.forEach(function (el) {
        el.classList.remove("current-period");
      });
    }
  }, {
    key: "addCurrentPeriodClassToDefaultPeriod",
    value: function addCurrentPeriodClassToDefaultPeriod() {
      var _this = this;
      this.periodTargets.forEach(function (el) {
        if (el.getAttribute("data-period") == _this.periodValue) {
          _this.addCurrentClassToSelectedPeriod(el);
        }
      });
    }
  }, {
    key: "addCurrentClassToSelectedPeriod",
    value: function addCurrentClassToSelectedPeriod(el) {
      el.classList.add(this.currentPeriodClass);
    }
  }, {
    key: "updateChart",
    value: function updateChart(json) {
      Highcharts$1.chart(this.chartTarget, {
        chart: {
          zoomType: "x"
        },
        credits: {
          enabled: false
        },
        title: {
          text: this.titleValue,
          align: "left"
        },
        xAxis: {
          type: "datetime"
        },
        yAxis: {
          type: this.yAxisTypeValue,
          title: {
            text: this.yAxisLabelValue
          }
        },
        tooltip: {
          headerFormat: "<b>{series.name}</b><br>",
          pointFormat: "{point.x:%e-%b-%Y}: {point.y:.2f}"
        },
        plotOptions: {
          series: {
            animation: {
              duration: 500
            },
            marker: {
              enabled: true
            }
          }
        },
        series: json,
        responsive: {
          rules: [{
            condition: {
              maxWidth: 500
            },
            chartOptions: {
              plotOptions: {
                series: {
                  marker: {
                    radius: 2.5
                  }
                }
              }
            }
          }]
        }
      });
    }
  }, {
    key: "getJson",
    value: function getJson() {
      var _this2 = this;
      fetch(this.urlValue + "?" + new URLSearchParams$1({
        period: this.periodValue
      }), {
        credentials: "same-origin",
        headers: new Headers({
          "content-type": "application/json"
        })
      }).then(function (response) {
        return response.json();
      }).then(function (json) {
        _this2.updateChart(json);
      });
    }
  }]);
  return _default;
}(Controller);
_defineProperty$x(_default$q, "targets", ["chart",
// chart container
"period" // array of period (10y, 3y..) links
]);
_defineProperty$x(_default$q, "values", {
  url: String,
  // API endpoint for chart json
  title: String,
  // Chart title
  period: String,
  // State for the last selected period
  yAxisLabel: String,
  // eg Kg
  yAxisType: String // linear or logarithmic
});
_defineProperty$x(_default$q, "classes", ["currentPeriod" // Maps to a CSS class name via data attribute on controller element
]);

var Rails$2 = window.Rails;
var _ = window._;

// This controller has 3 related functions
// - Keep a users session alive
//   Keep the user's session alive if they are 'active' (there are keypresses,
//   clicks or resize events on the same page) by sending a throttled ajax
//   request to reset the session window which will prevent their session
//   expiring and throwing them out when they are for example writing a long
//   letter (which they would otherwise not finish before their session expires)
// - Auto logging-out a user after a period of inactivity
//   Check after a period of intactivity to see if their session has expired.
//   If it has then refresh the page which will redirect them to the login page.
// - Signalling to other open tabs when the user's session has expired or they
//   have manually logged out - so that all tabs go to the login page at around
//   the same time.
//
// Goals:
// - Performance and code clarity more important than having an accurate session
//   window - if it is extended for a minute or two that is OK.
// - The server should always be the judge of whether the session has timed out
// - Query the server as little as possible - partly for performance and partly
//   to avoid noise in the server logs
// - Keep event handler activity minimal to preserve CPU cycles - ie use
//   throttle or debounce
//
// Possible enhancements:
// - After a period of inactivity, show a dialog asking if user wants to extend
//   the session - this would involve starting a separate timer and displaying
//   the countdown
//
// Scenarios to test:
// - Keypresses, clicks and window resizing - any of these should reset session
//   and thus the user remains logged in as long as one of these events ocurrs
//   within sessionTimeoutSeconds
// - User closes lid on laptop overnight and reopens in the morning - what is
//   expected?
// - Network disconnected - what do we do?
// - user gets withing 10 seconds of session timeout and starts typing - session
//   window shoud be reset
// - user has > 1 tab open and logs out of one - ideally it should log out of
//   other tabs before too long. We do by setting a localStorage value to signal
//   to other tabs
//
// Known issues:
// - user sitting on register page will keep polling checkAlivePath
// - if a user becomes active on a page within throttlePeriodSeconds of
//   sessionTimeoutSeconds then there is no currently opportunity for
//   throttledRegisterUserActivity to reset kick in a trump
//   checkForSessionExpiryTimeout - so the session will log out. We might need
//   an extra step before calling checkForSessionExpiry - a final chance to
//   check if the user was
//   active
// - Not quite sure if putting the data attribute config settings in the body
//   tag is the right thing to do - perhaps should be in a config .js.erb
var _default$p = /*#__PURE__*/function (_Controller) {
  _inherits$w(_default, _Controller);
  var _super = _createSuper$w(_default);
  function _default() {
    var _this;
    _classCallCheck$x(this, _default);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$x(_assertThisInitialized$w(_this), "checkForSessionExpiryTimeout", null);
    _defineProperty$x(_assertThisInitialized$w(_this), "userActivityDetected", false);
    _defineProperty$x(_assertThisInitialized$w(_this), "checkAlivePath", null);
    _defineProperty$x(_assertThisInitialized$w(_this), "keepAlivePath", null);
    _defineProperty$x(_assertThisInitialized$w(_this), "loginPath", null);
    _defineProperty$x(_assertThisInitialized$w(_this), "throttledRegisterUserActivity", null);
    _defineProperty$x(_assertThisInitialized$w(_this), "sessionTimeoutSeconds", 0);
    _defineProperty$x(_assertThisInitialized$w(_this), "defaultSessionTimeoutSeconds", 20 * 60);
    _defineProperty$x(_assertThisInitialized$w(_this), "throttlePeriodSeconds", 0);
    _defineProperty$x(_assertThisInitialized$w(_this), "defaultThrottlePeriodSeconds", 20);
    return _this;
  }
  _createClass$x(_default, [{
    key: "initialize",
    value: function initialize() {
      this.throttlePeriodSeconds = parseInt(this.data.get("register-user-activity-after") || this.defaultThrottlePeriodSeconds);
      this.sessionTimeoutSeconds = parseInt(this.data.get("timeout") || this.defaultSessionTimeoutSeconds);
      this.sessionTimeoutSeconds += 10; // To allow for network roundtrips etc
      this.checkAlivePath = this.data.get("check-alive-path");
      this.loginPath = this.data.get("login-path");
      this.keepAlivePath = this.data.get("keep-alive-path");
      this.logSettings();

      // Throttle the user activity callback because we only need to know about user activity
      // only very occasionally, so that we can periodically tell there server the user was active.
      // Here, even if there are hundreds of events (click, keypress etc) within throttlePeriodSeconds,
      // our function is only called at most once in that period, when throttlePeriodSeconds has
      // passed (since trailing = true). This suits is as we want to avoid making any call to the
      // server unless the user has been on the page for at least throttlePeriodSeconds.
      // See https://lodash.com/docs/#trottle
      this.throttledRegisterUserActivity = _.throttle(this.registerUserActivity.bind(this), this.throttlePeriodSeconds * 1000, {
        "leading": false,
        "trailing": true
      });
    }
  }, {
    key: "connect",
    value: function connect() {
      if (this.onLoginPage) {
        this.log("connect: onLoginPage - skipping session time");
      } else {
        this.addHandlersToMonitorUserActivity();
        this.resetCheckForSessionExpiryTimeout(this.sessionTimeoutSeconds);
      }
    }
  }, {
    key: "disconnect",
    value: function disconnect() {
      if (!this.onLoginPage) {
        this.removeUserActivityHandlers();
        clearTimeout(this.checkForSessionExpiryTimeout);
      }
    }
  }, {
    key: "sendLogoutMessageToAnyOpenTabs",
    value: function sendLogoutMessageToAnyOpenTabs() {
      window.localStorage.setItem("logout-event", "logout" + Math.random());
    }

    // Debounced event handler for key/click/resize
    // If we come in there then the user has interacted with the page
    // within throttlePeriodSeconds
  }, {
    key: "registerUserActivity",
    value: function registerUserActivity() {
      this.sendRequestToKeepSessionAlive();
      this.resetCheckForSessionExpiryTimeout(this.sessionTimeoutSeconds);
    }

    // Timeout handler for checking if the sesison has expired
  }, {
    key: "resetCheckForSessionExpiryTimeout",
    value: function resetCheckForSessionExpiryTimeout(intervalSeconds) {
      this.log("resetting session expiry timeout ".concat(intervalSeconds));
      clearTimeout(this.checkForSessionExpiryTimeout);
      this.checkForSessionExpiryTimeout = setTimeout(this.checkForSessionExpiry.bind(this), intervalSeconds * 1000);
    }

    // Here we really expect the session to have expired. In case it hasn't
    // we reset the timeout to check again. We could reset the timeout to be
    // sessionTimeoutSeconds, but if when we checked for expiry we had only just
    // missed it, we will end up staying on this page (assuming the user is
    // inactive) for nearly twice as long as we need to. So we set the timeout
    // to be throttlePeriodSeconds * 2, which gives time for the
    // throttledRegisterUserActivity handler to reset the session again if it
    // fires.
  }, {
    key: "checkForSessionExpiry",
    value: function checkForSessionExpiry() {
      this.sendRequestToTestForSessionExpiry();
      this.resetCheckForSessionExpiryTimeout(this.throttlePeriodSeconds * 2);
    }
  }, {
    key: "sendRequestToKeepSessionAlive",
    value: function sendRequestToKeepSessionAlive() {
      this.ajaxGet(this.keepAlivePath);
    }
  }, {
    key: "sendRequestToTestForSessionExpiry",
    value: function sendRequestToTestForSessionExpiry() {
      this.log("checking for session expiry");
      this.ajaxGet(this.checkAlivePath);
    }
  }, {
    key: "ajaxGet",
    value: function ajaxGet(path) {
      Rails$2.ajax({
        type: "GET",
        url: path,
        dataType: "text",
        error: this.reloadPageIfAjaxRequestWasUnauthorised.bind(this)
      });
    }
  }, {
    key: "reloadPageIfAjaxRequestWasUnauthorised",
    value: function reloadPageIfAjaxRequestWasUnauthorised(responseText, status, xhr) {
      if (xhr.status == 401) {
        window.location.reload();
        this.sendLogoutMessageToAnyOpenTabs();
      }
    }
  }, {
    key: "addHandlersToMonitorUserActivity",
    value: function addHandlersToMonitorUserActivity() {
      document.addEventListener("click", this.throttledRegisterUserActivity.bind(this));
      document.addEventListener("keydown", this.throttledRegisterUserActivity.bind(this));
      window.addEventListener("resize", this.throttledRegisterUserActivity.bind(this));
      window.addEventListener("storage", this.storageChange.bind(this));
    }
  }, {
    key: "removeUserActivityHandlers",
    value: function removeUserActivityHandlers() {
      document.removeEventListener("click", this.throttledRegisterUserActivity.bind(this));
      document.removeEventListener("keydown", this.throttledRegisterUserActivity.bind(this));
      window.removeEventListener("resize", this.throttledRegisterUserActivity.bind(this));
      window.removeEventListener("storage", this.storageChange.bind(this));
    }
  }, {
    key: "logSettings",
    value: function logSettings() {
      if (this.debug) {
        this.log("keepAlivePath ".concat(this.keepAlivePath));
        this.log("checkAlivePath ".concat(this.checkAlivePath));
        this.log("loginPath ".concat(this.loginPath));
        this.log("sessionTimeoutSeconds ".concat(this.sessionTimeoutSeconds));
        this.log("throttlePeriodSeconds ".concat(this.throttlePeriodSeconds));
      }
    }
  }, {
    key: "log",
    value: function log(msg) {
      if (this.debug) {
        console.log(msg);
      }
    }

    // An event handler to watch for changes in the value of the local storage item called
    // 'logged_in'. We use localStorage as a cross-tab communication protocol: when the user has
    // logged out of one tab, this mechanism is used to signal to any other logged-in tabs that they
    // should log themselves out.
    // This applies in 2 circumstances:
    // - the user has clicked the "Log Out" link in the navbar - the sendLogoutMessageToAnyOpenTabs()
    //   action defined above is called
    // - our tab has timed out due to inactivity; other open tabs may not timeout for another few
    //   minutes (depending on the polling frequency etc) so we give them a nudge.
  }, {
    key: "storageChange",
    value: function storageChange(event) {
      if (event.key == "logout-event") {
        setTimeout(this.sendRequestToTestForSessionExpiry.bind(this), 2000);
      }
    }
  }, {
    key: "onLoginPage",
    get: function get() {
      return window.location.pathname == this.loginPath;
    }

    // If you add data-session-debug=1 then logging will be enabled
    // This is evaluated each time we can add debugging into a running page
  }, {
    key: "debug",
    get: function get() {
      return this.data.get("debug") === "true";
    }
  }]);
  return _default;
}(Controller);

var _default$o = /*#__PURE__*/function (_Controller) {
  _inherits$w(_default, _Controller);
  var _super = _createSuper$w(_default);
  function _default() {
    _classCallCheck$x(this, _default);
    return _super.apply(this, arguments);
  }
  _createClass$x(_default, [{
    key: "connect",
    value: function connect() {
      this.toggleClass = this.data.get("class") || "hidden";
    }
  }, {
    key: "toggle",
    value: function toggle(event) {
      var _this = this;
      event.preventDefault();
      this.toggleableTargets.forEach(function (target) {
        target.classList.toggle(_this.toggleClass);
      });
    }
  }]);
  return _default;
}(Controller);
_defineProperty$x(_default$o, "targets", ["toggleable"]);

var _default$n = /*#__PURE__*/function (_Controller) {
  _inherits$w(_default, _Controller);
  var _super = _createSuper$w(_default);
  function _default() {
    _classCallCheck$x(this, _default);
    return _super.apply(this, arguments);
  }
  _createClass$x(_default, [{
    key: "connect",
    value: function connect() {
      this.toggleClass = this.data.get("class") || "hidden";
    }
  }, {
    key: "select",
    value: function select(event) {
      var _this = this;
      event.preventDefault();
      var selectedOption = event.currentTarget.value;
      this.itemTargets.filter(function (target) {
        return _this.isMatch(target.dataset.showOnSelectedOption, selectedOption);
      }).forEach(function (target) {
        target.classList.remove(_this.toggleClass);
        Array.from(target.getElementsByTagName("input")).forEach(function (input) {
          input.disabled = false;
        });
      });
      this.itemTargets.filter(function (target) {
        return !_this.isMatch(target.dataset.showOnSelectedOption, selectedOption);
      }).forEach(function (target) {
        target.classList.add(_this.toggleClass);
        Array.from(target.getElementsByTagName("input")).forEach(function (input) {
          input.disabled = true;
        });
      });
    }
  }, {
    key: "isMatch",
    value: function isMatch(candidate, target) {
      var candidates = [this.parsePotentialJson(candidate)].flat();
      return candidates.includes(target);
    }

    // Support both "regular" strings and JSON encoded arrays for
    // data-show-on-selected-option attributes
  }, {
    key: "parsePotentialJson",
    value: function parsePotentialJson(valueOrJson) {
      try {
        return JSON.parse(valueOrJson);
      } catch (error) {
        return valueOrJson;
      }
    }
  }]);
  return _default;
}(Controller);
_defineProperty$x(_default$n, "targets", ["item"]);

var _default$m = /*#__PURE__*/function (_Controller) {
  _inherits$w(_default, _Controller);
  var _super = _createSuper$w(_default);
  function _default() {
    _classCallCheck$x(this, _default);
    return _super.apply(this, arguments);
  }
  _createClass$x(_default, [{
    key: "connect",
    value: function connect() {}
  }, {
    key: "initialize",
    value: function initialize() {
      this.activeTabClasses = (this.data.get("activeTab") || "active").split(" ");
      this.showTab();
    }
  }, {
    key: "change",
    value: function change(event) {
      event.preventDefault();
      this.index = this.tabTargets.indexOf(event.currentTarget);
    }
  }, {
    key: "showTab",
    value: function showTab() {
      var _this = this;
      this.tabTargets.forEach(function (tab, index) {
        var panel = _this.panelTargets[index];
        if (index === _this.index) {
          var _tab$classList;
          panel.classList.remove("hidden");
          (_tab$classList = tab.classList).add.apply(_tab$classList, _toConsumableArray(_this.activeTabClasses));
        } else {
          var _tab$classList2;
          panel.classList.add("hidden");
          (_tab$classList2 = tab.classList).remove.apply(_tab$classList2, _toConsumableArray(_this.activeTabClasses));
        }
      });
    }
  }, {
    key: "index",
    get: function get() {
      return parseInt(this.data.get("index") || 0);
    },
    set: function set(value) {
      this.data.set("index", value);
      this.showTab();
    }
  }]);
  return _default;
}(Controller);
_defineProperty$x(_default$m, "targets", ["tab", "panel"]);

var highchartsMore = {exports: {}};

/*
 Highcharts JS v10.1.0 (2022-04-29)

 (c) 2009-2021 Torstein Honsi

 License: www.highcharts.com/license
*/

(function (module) {
	(function (d) {
	  module.exports ? (d["default"] = d, module.exports = d) : d("undefined" !== typeof Highcharts ? Highcharts : void 0);
	})(function (d) {
	  function A(d, e, l, a) {
	    d.hasOwnProperty(e) || (d[e] = a.apply(null, l), "function" === typeof CustomEvent && window.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", {
	      detail: {
	        path: e,
	        module: d[e]
	      }
	    })));
	  }
	  d = d ? d._modules : {};
	  A(d, "Extensions/Pane.js", [d["Core/Chart/Chart.js"], d["Series/CenteredUtilities.js"], d["Core/Globals.js"], d["Core/Pointer.js"], d["Core/Utilities.js"]], function (d, e, l, a, c) {
	    function t(b, m, n) {
	      return Math.sqrt(Math.pow(b - n[0], 2) + Math.pow(m - n[1], 2)) <= n[2] / 2;
	    }
	    var p = c.addEvent,
	      k = c.extend,
	      x = c.merge,
	      w = c.pick,
	      b = c.splat;
	    d.prototype.collectionsWithUpdate.push("pane");
	    c = function () {
	      function g(b, g) {
	        this.options = this.chart = this.center = this.background = void 0;
	        this.coll = "pane";
	        this.defaultOptions = {
	          center: ["50%", "50%"],
	          size: "85%",
	          innerSize: "0%",
	          startAngle: 0
	        };
	        this.defaultBackgroundOptions = {
	          shape: "circle",
	          borderWidth: 1,
	          borderColor: "#cccccc",
	          backgroundColor: {
	            linearGradient: {
	              x1: 0,
	              y1: 0,
	              x2: 0,
	              y2: 1
	            },
	            stops: [[0, "#ffffff"], [1, "#e6e6e6"]]
	          },
	          from: -Number.MAX_VALUE,
	          innerRadius: 0,
	          to: Number.MAX_VALUE,
	          outerRadius: "105%"
	        };
	        this.init(b, g);
	      }
	      g.prototype.init = function (b, g) {
	        this.chart = g;
	        this.background = [];
	        g.pane.push(this);
	        this.setOptions(b);
	      };
	      g.prototype.setOptions = function (b) {
	        this.options = x(this.defaultOptions, this.chart.angular ? {
	          background: {}
	        } : void 0, b);
	      };
	      g.prototype.render = function () {
	        var g = this.options,
	          n = this.options.background,
	          q = this.chart.renderer;
	        this.group || (this.group = q.g("pane-group").attr({
	          zIndex: g.zIndex || 0
	        }).add());
	        this.updateCenter();
	        if (n) for (n = b(n), g = Math.max(n.length, this.background.length || 0), q = 0; q < g; q++) n[q] && this.axis ? this.renderBackground(x(this.defaultBackgroundOptions, n[q]), q) : this.background[q] && (this.background[q] = this.background[q].destroy(), this.background.splice(q, 1));
	      };
	      g.prototype.renderBackground = function (b, g) {
	        var n = "animate",
	          m = {
	            "class": "highcharts-pane " + (b.className || "")
	          };
	        this.chart.styledMode || k(m, {
	          fill: b.backgroundColor,
	          stroke: b.borderColor,
	          "stroke-width": b.borderWidth
	        });
	        this.background[g] || (this.background[g] = this.chart.renderer.path().add(this.group), n = "attr");
	        this.background[g][n]({
	          d: this.axis.getPlotBandPath(b.from, b.to, b)
	        }).attr(m);
	      };
	      g.prototype.updateCenter = function (b) {
	        this.center = (b || this.axis || {}).center = e.getCenter.call(this);
	      };
	      g.prototype.update = function (b, g) {
	        x(!0, this.options, b);
	        this.setOptions(this.options);
	        this.render();
	        this.chart.axes.forEach(function (b) {
	          b.pane === this && (b.pane = null, b.update({}, g));
	        }, this);
	      };
	      return g;
	    }();
	    d.prototype.getHoverPane = function (b) {
	      var g = this,
	        n;
	      b && g.pane.forEach(function (q) {
	        var m = b.chartX - g.plotLeft,
	          a = b.chartY - g.plotTop;
	        t(g.inverted ? a : m, g.inverted ? m : a, q.center) && (n = q);
	      });
	      return n;
	    };
	    p(d, "afterIsInsidePlot", function (b) {
	      this.polar && (b.isInsidePlot = this.pane.some(function (g) {
	        return t(b.x, b.y, g.center);
	      }));
	    });
	    p(a, "beforeGetHoverData", function (b) {
	      var g = this.chart;
	      g.polar ? (g.hoverPane = g.getHoverPane(b), b.filter = function (n) {
	        return n.visible && !(!b.shared && n.directTouch) && w(n.options.enableMouseTracking, !0) && (!g.hoverPane || n.xAxis.pane === g.hoverPane);
	      }) : g.hoverPane = void 0;
	    });
	    p(a, "afterGetHoverData", function (b) {
	      var g = this.chart;
	      b.hoverPoint && b.hoverPoint.plotX && b.hoverPoint.plotY && g.hoverPane && !t(b.hoverPoint.plotX, b.hoverPoint.plotY, g.hoverPane.center) && (b.hoverPoint = void 0);
	    });
	    l.Pane = c;
	    return l.Pane;
	  });
	  A(d, "Core/Axis/RadialAxis.js", [d["Core/Axis/AxisDefaults.js"], d["Core/DefaultOptions.js"], d["Core/Globals.js"], d["Core/Utilities.js"]], function (d, e, l, a) {
	    var c = e.defaultOptions,
	      t = l.noop,
	      p = a.addEvent,
	      k = a.correctFloat,
	      x = a.defined,
	      w = a.extend,
	      b = a.fireEvent,
	      g = a.merge,
	      m = a.pick,
	      n = a.relativeLength,
	      q = a.wrap,
	      H;
	    (function (a) {
	      function e() {
	        this.autoConnect = this.isCircular && "undefined" === typeof m(this.userMax, this.options.max) && k(this.endAngleRad - this.startAngleRad) === k(2 * Math.PI);
	        !this.isCircular && this.chart.inverted && this.max++;
	        this.autoConnect && (this.max += this.categories && 1 || this.pointRange || this.closestPointRange || 0);
	      }
	      function y() {
	        var h = this;
	        return function () {
	          if (h.isRadial && h.tickPositions && h.options.labels && !0 !== h.options.labels.allowOverlap) return h.tickPositions.map(function (f) {
	            return h.ticks[f] && h.ticks[f].label;
	          }).filter(function (h) {
	            return !!h;
	          });
	        };
	      }
	      function z() {
	        return t;
	      }
	      function f(h, f, b) {
	        var r = this.pane.center,
	          u = h.value;
	        if (this.isCircular) {
	          if (x(u)) h.point && (g = h.point.shapeArgs || {}, g.start && (u = this.chart.inverted ? this.translate(h.point.rectPlotY, !0) : h.point.x));else {
	            var g = h.chartX || 0;
	            var v = h.chartY || 0;
	            u = this.translate(Math.atan2(v - b, g - f) - this.startAngleRad, !0);
	          }
	          h = this.getPosition(u);
	          g = h.x;
	          v = h.y;
	        } else x(u) || (g = h.chartX, v = h.chartY), x(g) && x(v) && (b = r[1] + this.chart.plotTop, u = this.translate(Math.min(Math.sqrt(Math.pow(g - f, 2) + Math.pow(v - b, 2)), r[2] / 2) - r[3] / 2, !0));
	        return [u, g || 0, v || 0];
	      }
	      function h(h, f, b) {
	        h = this.pane.center;
	        var r = this.chart,
	          u = this.left || 0,
	          g = this.top || 0,
	          v = m(f, h[2] / 2 - this.offset);
	        "undefined" === typeof b && (b = this.horiz ? 0 : this.center && -this.center[3] / 2);
	        b && (v += b);
	        this.isCircular || "undefined" !== typeof f ? (f = this.chart.renderer.symbols.arc(u + h[0], g + h[1], v, v, {
	          start: this.startAngleRad,
	          end: this.endAngleRad,
	          open: !0,
	          innerR: 0
	        }), f.xBounds = [u + h[0]], f.yBounds = [g + h[1] - v]) : (f = this.postTranslate(this.angleRad, v), f = [["M", this.center[0] + r.plotLeft, this.center[1] + r.plotTop], ["L", f.x, f.y]]);
	        return f;
	      }
	      function u() {
	        this.constructor.prototype.getOffset.call(this);
	        this.chart.axisOffset[this.side] = 0;
	      }
	      function r(h, f, b) {
	        var r = this.chart,
	          u = function (h) {
	            if ("string" === typeof h) {
	              var f = parseInt(h, 10);
	              y.test(h) && (f = f * B / 100);
	              return f;
	            }
	            return h;
	          },
	          g = this.center,
	          v = this.startAngleRad,
	          B = g[2] / 2,
	          n = Math.min(this.offset, 0),
	          q = this.left || 0,
	          a = this.top || 0,
	          y = /%$/,
	          z = this.isCircular,
	          c = m(u(b.outerRadius), B),
	          k = u(b.innerRadius);
	        u = m(u(b.thickness), 10);
	        if ("polygon" === this.options.gridLineInterpolation) n = this.getPlotLinePath({
	          value: h
	        }).concat(this.getPlotLinePath({
	          value: f,
	          reverse: !0
	        }));else {
	          h = Math.max(h, this.min);
	          f = Math.min(f, this.max);
	          h = this.translate(h);
	          f = this.translate(f);
	          z || (c = h || 0, k = f || 0);
	          if ("circle" !== b.shape && z) b = v + (h || 0), v += f || 0;else {
	            b = -Math.PI / 2;
	            v = 1.5 * Math.PI;
	            var E = !0;
	          }
	          c -= n;
	          n = r.renderer.symbols.arc(q + g[0], a + g[1], c, c, {
	            start: Math.min(b, v),
	            end: Math.max(b, v),
	            innerR: m(k, c - (u - n)),
	            open: E
	          });
	          z && (z = (v + b) / 2, q = q + g[0] + g[2] / 2 * Math.cos(z), n.xBounds = z > -Math.PI / 2 && z < Math.PI / 2 ? [q, r.plotWidth] : [0, q], n.yBounds = [a + g[1] + g[2] / 2 * Math.sin(z)], n.yBounds[0] += z > -Math.PI && 0 > z || z > Math.PI ? -10 : 10);
	        }
	        return n;
	      }
	      function B(h) {
	        var f = this,
	          b = this.pane.center,
	          r = this.chart,
	          u = r.inverted,
	          g = h.reverse,
	          v = this.pane.options.background ? this.pane.options.background[0] || this.pane.options.background : {},
	          B = v.innerRadius || "0%",
	          q = v.outerRadius || "100%",
	          a = b[0] + r.plotLeft,
	          z = b[1] + r.plotTop,
	          c = this.height,
	          y = h.isCrosshair;
	        v = b[3] / 2;
	        var m = h.value,
	          k;
	        var E = this.getPosition(m);
	        var e = E.x;
	        E = E.y;
	        y && (E = this.getCrosshairPosition(h, a, z), m = E[0], e = E[1], E = E[2]);
	        if (this.isCircular) m = Math.sqrt(Math.pow(e - a, 2) + Math.pow(E - z, 2)), g = "string" === typeof B ? n(B, 1) : B / m, r = "string" === typeof q ? n(q, 1) : q / m, b && v && (v /= m, g < v && (g = v), r < v && (r = v)), b = [["M", a + g * (e - a), z - g * (z - E)], ["L", e - (1 - r) * (e - a), E + (1 - r) * (z - E)]];else if ((m = this.translate(m)) && (0 > m || m > c) && (m = 0), "circle" === this.options.gridLineInterpolation) b = this.getLinePath(0, m, v);else if (b = [], r[u ? "yAxis" : "xAxis"].forEach(function (h) {
	          h.pane === f.pane && (k = h);
	        }), k) for (a = k.tickPositions, k.autoConnect && (a = a.concat([a[0]])), g && (a = a.slice().reverse()), m && (m += v), z = 0; z < a.length; z++) v = k.getPosition(a[z], m), b.push(z ? ["L", v.x, v.y] : ["M", v.x, v.y]);
	        return b;
	      }
	      function v(h, f) {
	        h = this.translate(h);
	        return this.postTranslate(this.isCircular ? h : this.angleRad, m(this.isCircular ? f : 0 > h ? 0 : h, this.center[2] / 2) - this.offset);
	      }
	      function E() {
	        var h = this.center,
	          f = this.chart,
	          b = this.options.title;
	        return {
	          x: f.plotLeft + h[0] + (b.x || 0),
	          y: f.plotTop + h[1] - {
	            high: .5,
	            middle: .25,
	            low: 0
	          }[b.align] * h[2] + (b.y || 0)
	        };
	      }
	      function l(b) {
	        b.beforeSetTickPositions = e;
	        b.createLabelCollector = y;
	        b.getCrosshairPosition = f;
	        b.getLinePath = h;
	        b.getOffset = u;
	        b.getPlotBandPath = r;
	        b.getPlotLinePath = B;
	        b.getPosition = v;
	        b.getTitlePosition = E;
	        b.postTranslate = O;
	        b.setAxisSize = A;
	        b.setAxisTranslation = P;
	        b.setOptions = Q;
	      }
	      function L() {
	        var h = this.chart,
	          f = this.options,
	          b = this.pane,
	          r = b && b.options;
	        h.angular && this.isXAxis || !b || !h.angular && !h.polar || (this.angleRad = (f.angle || 0) * Math.PI / 180, this.startAngleRad = (r.startAngle - 90) * Math.PI / 180, this.endAngleRad = (m(r.endAngle, r.startAngle + 360) - 90) * Math.PI / 180, this.offset = f.offset || 0);
	      }
	      function H(h) {
	        this.isRadial && (h.align = void 0, h.preventDefault());
	      }
	      function K() {
	        if (this.chart && this.chart.labelCollectors) {
	          var h = this.labelCollector ? this.chart.labelCollectors.indexOf(this.labelCollector) : -1;
	          0 <= h && this.chart.labelCollectors.splice(h, 1);
	        }
	      }
	      function C(h) {
	        var f = this.chart,
	          b = f.inverted,
	          r = f.angular,
	          u = f.polar,
	          v = this.isXAxis,
	          B = this.coll,
	          n = r && v,
	          a = f.options;
	        h = h.userOptions.pane || 0;
	        h = this.pane = f.pane && f.pane[h];
	        var q;
	        if ("colorAxis" === B) this.isRadial = !1;else {
	          if (r) {
	            if (n ? (this.isHidden = !0, this.createLabelCollector = z, this.getOffset = t, this.render = this.redraw = G, this.setTitle = this.setCategories = this.setScale = t) : l(this), q = !v) this.defaultPolarOptions = R;
	          } else u && (l(this), this.defaultPolarOptions = (q = this.horiz) ? S : g("xAxis" === B ? d.defaultXAxisOptions : d.defaultYAxisOptions, T), b && "yAxis" === B && (this.defaultPolarOptions.stackLabels = d.defaultYAxisOptions.stackLabels, this.defaultPolarOptions.reversedStacks = !0));
	          r || u ? (this.isRadial = !0, a.chart.zoomType = null, this.labelCollector || (this.labelCollector = this.createLabelCollector()), this.labelCollector && f.labelCollectors.push(this.labelCollector)) : this.isRadial = !1;
	          h && q && (h.axis = this);
	          this.isCircular = q;
	        }
	      }
	      function U() {
	        this.isRadial && this.beforeSetTickPositions();
	      }
	      function J(h) {
	        var f = this.label;
	        if (f) {
	          var b = this.axis,
	            r = f.getBBox(),
	            u = b.options.labels,
	            v = (b.translate(this.pos) + b.startAngleRad + Math.PI / 2) / Math.PI * 180 % 360,
	            g = Math.round(v),
	            B = x(u.y) ? 0 : .3 * -r.height,
	            a = u.y,
	            q = 20,
	            z = u.align,
	            c = "end",
	            y = 0 > g ? g + 360 : g,
	            E = y,
	            k = 0,
	            e = 0;
	          if (b.isRadial) {
	            var l = b.getPosition(this.pos, b.center[2] / 2 + n(m(u.distance, -25), b.center[2] / 2, -b.center[2] / 2));
	            "auto" === u.rotation ? f.attr({
	              rotation: v
	            }) : x(a) || (a = b.chart.renderer.fontMetrics(f.styles && f.styles.fontSize).b - r.height / 2);
	            x(z) || (b.isCircular ? (r.width > b.len * b.tickInterval / (b.max - b.min) && (q = 0), z = v > q && v < 180 - q ? "left" : v > 180 + q && v < 360 - q ? "right" : "center") : z = "center", f.attr({
	              align: z
	            }));
	            if ("auto" === z && 2 === b.tickPositions.length && b.isCircular) {
	              90 < y && 180 > y ? y = 180 - y : 270 < y && 360 >= y && (y = 540 - y);
	              180 < E && 360 >= E && (E = 360 - E);
	              if (b.pane.options.startAngle === g || b.pane.options.startAngle === g + 360 || b.pane.options.startAngle === g - 360) c = "start";
	              z = -90 <= g && 90 >= g || -360 <= g && -270 >= g || 270 <= g && 360 >= g ? "start" === c ? "right" : "left" : "start" === c ? "left" : "right";
	              70 < E && 110 > E && (z = "center");
	              15 > y || 180 <= y && 195 > y ? k = .3 * r.height : 15 <= y && 35 >= y ? k = "start" === c ? 0 : .75 * r.height : 195 <= y && 215 >= y ? k = "start" === c ? .75 * r.height : 0 : 35 < y && 90 >= y ? k = "start" === c ? .25 * -r.height : r.height : 215 < y && 270 >= y && (k = "start" === c ? r.height : .25 * -r.height);
	              15 > E ? e = "start" === c ? .15 * -r.height : .15 * r.height : 165 < E && 180 >= E && (e = "start" === c ? .15 * r.height : .15 * -r.height);
	              f.attr({
	                align: z
	              });
	              f.translate(e, k + B);
	            }
	            h.pos.x = l.x + (u.x || 0);
	            h.pos.y = l.y + (a || 0);
	          }
	        }
	      }
	      function V(h) {
	        this.axis.getPosition && w(h.pos, this.axis.getPosition(this.pos));
	      }
	      function O(h, f) {
	        var b = this.chart,
	          r = this.center;
	        h = this.startAngleRad + h;
	        return {
	          x: b.plotLeft + r[0] + Math.cos(h) * f,
	          y: b.plotTop + r[1] + Math.sin(h) * f
	        };
	      }
	      function G() {
	        this.isDirty = !1;
	      }
	      function A() {
	        this.constructor.prototype.setAxisSize.call(this);
	        if (this.isRadial) {
	          this.pane.updateCenter(this);
	          var h = this.center = this.pane.center.slice();
	          if (this.isCircular) this.sector = this.endAngleRad - this.startAngleRad;else {
	            var f = this.postTranslate(this.angleRad, h[3] / 2);
	            h[0] = f.x - this.chart.plotLeft;
	            h[1] = f.y - this.chart.plotTop;
	          }
	          this.len = this.width = this.height = (h[2] - h[3]) * m(this.sector, 1) / 2;
	        }
	      }
	      function P() {
	        this.constructor.prototype.setAxisTranslation.call(this);
	        this.center && (this.transA = this.isCircular ? (this.endAngleRad - this.startAngleRad) / (this.max - this.min || 1) : (this.center[2] - this.center[3]) / 2 / (this.max - this.min || 1), this.minPixelPadding = this.isXAxis ? this.transA * this.minPointOffset : 0);
	      }
	      function Q(h) {
	        h = this.options = g(this.constructor.defaultOptions, this.defaultPolarOptions, c[this.coll], h);
	        h.plotBands || (h.plotBands = []);
	        b(this, "afterSetOptions");
	      }
	      function W(h, f, b, r, u, g, v) {
	        var B = this.axis;
	        B.isRadial ? (h = B.getPosition(this.pos, B.center[2] / 2 + r), f = ["M", f, b, "L", h.x, h.y]) : f = h.call(this, f, b, r, u, g, v);
	        return f;
	      }
	      var N = [],
	        S = {
	          gridLineWidth: 1,
	          labels: {
	            align: void 0,
	            distance: 15,
	            x: 0,
	            y: void 0,
	            style: {
	              textOverflow: "none"
	            }
	          },
	          maxPadding: 0,
	          minPadding: 0,
	          showLastLabel: !1,
	          tickLength: 0
	        },
	        R = {
	          labels: {
	            align: "center",
	            x: 0,
	            y: void 0
	          },
	          minorGridLineWidth: 0,
	          minorTickInterval: "auto",
	          minorTickLength: 10,
	          minorTickPosition: "inside",
	          minorTickWidth: 1,
	          tickLength: 10,
	          tickPosition: "inside",
	          tickWidth: 2,
	          title: {
	            rotation: 0
	          },
	          zIndex: 2
	        },
	        T = {
	          gridLineInterpolation: "circle",
	          gridLineWidth: 1,
	          labels: {
	            align: "right",
	            x: -3,
	            y: -2
	          },
	          showLastLabel: !1,
	          title: {
	            x: 4,
	            text: null,
	            rotation: 90
	          }
	        };
	      a.compose = function (h, f) {
	        -1 === N.indexOf(h) && (N.push(h), p(h, "afterInit", L), p(h, "autoLabelAlign", H), p(h, "destroy", K), p(h, "init", C), p(h, "initialAxisTranslation", U));
	        -1 === N.indexOf(f) && (N.push(f), p(f, "afterGetLabelPosition", J), p(f, "afterGetPosition", V), q(f.prototype, "getMarkPath", W));
	        return h;
	      };
	    })(H || (H = {}));
	    return H;
	  });
	  A(d, "Series/AreaRange/AreaRangePoint.js", [d["Series/Area/AreaSeries.js"], d["Core/Series/Point.js"], d["Core/Utilities.js"]], function (d, e, l) {
	    var a = this && this.__extends || function () {
	        var a = function (c, k) {
	          a = Object.setPrototypeOf || {
	            __proto__: []
	          } instanceof Array && function (b, g) {
	            b.__proto__ = g;
	          } || function (b, g) {
	            for (var a in g) g.hasOwnProperty(a) && (b[a] = g[a]);
	          };
	          return a(c, k);
	        };
	        return function (c, k) {
	          function b() {
	            this.constructor = c;
	          }
	          a(c, k);
	          c.prototype = null === k ? Object.create(k) : (b.prototype = k.prototype, new b());
	        };
	      }(),
	      c = e.prototype,
	      t = l.defined,
	      p = l.isNumber;
	    return function (k) {
	      function e() {
	        var a = null !== k && k.apply(this, arguments) || this;
	        a.high = void 0;
	        a.low = void 0;
	        a.options = void 0;
	        a.plotHigh = void 0;
	        a.plotLow = void 0;
	        a.plotHighX = void 0;
	        a.plotLowX = void 0;
	        a.plotX = void 0;
	        a.series = void 0;
	        return a;
	      }
	      a(e, k);
	      e.prototype.setState = function () {
	        var a = this.state,
	          b = this.series,
	          g = b.chart.polar;
	        t(this.plotHigh) || (this.plotHigh = b.yAxis.toPixels(this.high, !0));
	        t(this.plotLow) || (this.plotLow = this.plotY = b.yAxis.toPixels(this.low, !0));
	        b.stateMarkerGraphic && (b.lowerStateMarkerGraphic = b.stateMarkerGraphic, b.stateMarkerGraphic = b.upperStateMarkerGraphic);
	        this.graphic = this.upperGraphic;
	        this.plotY = this.plotHigh;
	        g && (this.plotX = this.plotHighX);
	        c.setState.apply(this, arguments);
	        this.state = a;
	        this.plotY = this.plotLow;
	        this.graphic = this.lowerGraphic;
	        g && (this.plotX = this.plotLowX);
	        b.stateMarkerGraphic && (b.upperStateMarkerGraphic = b.stateMarkerGraphic, b.stateMarkerGraphic = b.lowerStateMarkerGraphic, b.lowerStateMarkerGraphic = void 0);
	        c.setState.apply(this, arguments);
	      };
	      e.prototype.haloPath = function () {
	        var a = this.series.chart.polar,
	          b = [];
	        this.plotY = this.plotLow;
	        a && (this.plotX = this.plotLowX);
	        this.isInside && (b = c.haloPath.apply(this, arguments));
	        this.plotY = this.plotHigh;
	        a && (this.plotX = this.plotHighX);
	        this.isTopInside && (b = b.concat(c.haloPath.apply(this, arguments)));
	        return b;
	      };
	      e.prototype.isValid = function () {
	        return p(this.low) && p(this.high);
	      };
	      return e;
	    }(d.prototype.pointClass);
	  });
	  A(d, "Series/AreaRange/AreaRangeSeries.js", [d["Series/AreaRange/AreaRangePoint.js"], d["Series/Area/AreaSeries.js"], d["Series/Column/ColumnSeries.js"], d["Core/Globals.js"], d["Core/Series/Series.js"], d["Core/Series/SeriesRegistry.js"], d["Core/Utilities.js"]], function (d, e, l, a, c, t, p) {
	    var k = this && this.__extends || function () {
	        var b = function (g, a) {
	          b = Object.setPrototypeOf || {
	            __proto__: []
	          } instanceof Array && function (b, f) {
	            b.__proto__ = f;
	          } || function (b, f) {
	            for (var h in f) f.hasOwnProperty(h) && (b[h] = f[h]);
	          };
	          return b(g, a);
	        };
	        return function (g, a) {
	          function n() {
	            this.constructor = g;
	          }
	          b(g, a);
	          g.prototype = null === a ? Object.create(a) : (n.prototype = a.prototype, new n());
	        };
	      }(),
	      x = e.prototype,
	      w = l.prototype;
	    l = a.noop;
	    var b = c.prototype,
	      g = p.defined,
	      m = p.extend,
	      n = p.isArray,
	      q = p.pick,
	      H = p.merge;
	    c = function (a) {
	      function c() {
	        var b = null !== a && a.apply(this, arguments) || this;
	        b.data = void 0;
	        b.options = void 0;
	        b.points = void 0;
	        b.lowerStateMarkerGraphic = void 0;
	        b.xAxis = void 0;
	        return b;
	      }
	      k(c, a);
	      c.prototype.toYData = function (b) {
	        return [b.low, b.high];
	      };
	      c.prototype.highToXY = function (b) {
	        var g = this.chart,
	          f = this.xAxis.postTranslate(b.rectPlotX || 0, this.yAxis.len - b.plotHigh);
	        b.plotHighX = f.x - g.plotLeft;
	        b.plotHigh = f.y - g.plotTop;
	        b.plotLowX = b.plotX;
	      };
	      c.prototype.translate = function () {
	        var b = this,
	          g = b.yAxis;
	        x.translate.apply(b);
	        b.points.forEach(function (f) {
	          var h = f.high,
	            u = f.plotY;
	          f.isNull ? f.plotY = null : (f.plotLow = u, f.plotHigh = g.translate(b.dataModify ? b.dataModify.modifyValue(h) : h, 0, 1, 0, 1), b.dataModify && (f.yBottom = f.plotHigh));
	        });
	        this.chart.polar && this.points.forEach(function (f) {
	          b.highToXY(f);
	          f.tooltipPos = [(f.plotHighX + f.plotLowX) / 2, (f.plotHigh + f.plotLow) / 2];
	        });
	      };
	      c.prototype.getGraphPath = function (b) {
	        var g = [],
	          f = [],
	          h,
	          u = x.getGraphPath;
	        var r = this.options;
	        var a = this.chart.polar,
	          v = a && !1 !== r.connectEnds,
	          n = r.connectNulls,
	          c = r.step;
	        b = b || this.points;
	        for (h = b.length; h--;) {
	          var m = b[h];
	          var k = a ? {
	            plotX: m.rectPlotX,
	            plotY: m.yBottom,
	            doCurve: !1
	          } : {
	            plotX: m.plotX,
	            plotY: m.plotY,
	            doCurve: !1
	          };
	          m.isNull || v || n || b[h + 1] && !b[h + 1].isNull || f.push(k);
	          var e = {
	            polarPlotY: m.polarPlotY,
	            rectPlotX: m.rectPlotX,
	            yBottom: m.yBottom,
	            plotX: q(m.plotHighX, m.plotX),
	            plotY: m.plotHigh,
	            isNull: m.isNull
	          };
	          f.push(e);
	          g.push(e);
	          m.isNull || v || n || b[h - 1] && !b[h - 1].isNull || f.push(k);
	        }
	        b = u.call(this, b);
	        c && (!0 === c && (c = "left"), r.step = {
	          left: "right",
	          center: "center",
	          right: "left"
	        }[c]);
	        g = u.call(this, g);
	        f = u.call(this, f);
	        r.step = c;
	        r = [].concat(b, g);
	        !this.chart.polar && f[0] && "M" === f[0][0] && (f[0] = ["L", f[0][1], f[0][2]]);
	        this.graphPath = r;
	        this.areaPath = b.concat(f);
	        r.isArea = !0;
	        r.xMap = b.xMap;
	        this.areaPath.xMap = b.xMap;
	        return r;
	      };
	      c.prototype.drawDataLabels = function () {
	        var g = this.points,
	          a = g.length,
	          f,
	          h = [],
	          u = this.options.dataLabels,
	          r,
	          B = this.chart.inverted;
	        if (u) {
	          if (n(u)) {
	            var v = u[0] || {
	              enabled: !1
	            };
	            var c = u[1] || {
	              enabled: !1
	            };
	          } else v = m({}, u), v.x = u.xHigh, v.y = u.yHigh, c = m({}, u), c.x = u.xLow, c.y = u.yLow;
	          if (v.enabled || this._hasPointLabels) {
	            for (f = a; f--;) if (r = g[f]) {
	              var q = v.inside ? r.plotHigh < r.plotLow : r.plotHigh > r.plotLow;
	              r.y = r.high;
	              r._plotY = r.plotY;
	              r.plotY = r.plotHigh;
	              h[f] = r.dataLabel;
	              r.dataLabel = r.dataLabelUpper;
	              r.below = q;
	              B ? v.align || (v.align = q ? "right" : "left") : v.verticalAlign || (v.verticalAlign = q ? "top" : "bottom");
	            }
	            this.options.dataLabels = v;
	            b.drawDataLabels && b.drawDataLabels.apply(this, arguments);
	            for (f = a; f--;) if (r = g[f]) r.dataLabelUpper = r.dataLabel, r.dataLabel = h[f], delete r.dataLabels, r.y = r.low, r.plotY = r._plotY;
	          }
	          if (c.enabled || this._hasPointLabels) {
	            for (f = a; f--;) if (r = g[f]) q = c.inside ? r.plotHigh < r.plotLow : r.plotHigh > r.plotLow, r.below = !q, B ? c.align || (c.align = q ? "left" : "right") : c.verticalAlign || (c.verticalAlign = q ? "bottom" : "top");
	            this.options.dataLabels = c;
	            b.drawDataLabels && b.drawDataLabels.apply(this, arguments);
	          }
	          if (v.enabled) for (f = a; f--;) if (r = g[f]) r.dataLabels = [r.dataLabelUpper, r.dataLabel].filter(function (h) {
	            return !!h;
	          });
	          this.options.dataLabels = u;
	        }
	      };
	      c.prototype.alignDataLabel = function () {
	        w.alignDataLabel.apply(this, arguments);
	      };
	      c.prototype.drawPoints = function () {
	        var a = this.points.length,
	          c;
	        b.drawPoints.apply(this, arguments);
	        for (c = 0; c < a;) {
	          var f = this.points[c];
	          f.origProps = {
	            plotY: f.plotY,
	            plotX: f.plotX,
	            isInside: f.isInside,
	            negative: f.negative,
	            zone: f.zone,
	            y: f.y
	          };
	          f.lowerGraphic = f.graphic;
	          f.graphic = f.upperGraphic;
	          f.plotY = f.plotHigh;
	          g(f.plotHighX) && (f.plotX = f.plotHighX);
	          f.y = q(f.high, f.origProps.y);
	          f.negative = f.y < (this.options.threshold || 0);
	          this.zones.length && (f.zone = f.getZone());
	          this.chart.polar || (f.isInside = f.isTopInside = "undefined" !== typeof f.plotY && 0 <= f.plotY && f.plotY <= this.yAxis.len && 0 <= f.plotX && f.plotX <= this.xAxis.len);
	          c++;
	        }
	        b.drawPoints.apply(this, arguments);
	        for (c = 0; c < a;) f = this.points[c], f.upperGraphic = f.graphic, f.graphic = f.lowerGraphic, f.origProps && (m(f, f.origProps), delete f.origProps), c++;
	      };
	      c.defaultOptions = H(e.defaultOptions, {
	        lineWidth: 1,
	        threshold: null,
	        tooltip: {
	          pointFormat: '<span style="color:{series.color}">\u25cf</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'
	        },
	        trackByArea: !0,
	        dataLabels: {
	          align: void 0,
	          verticalAlign: void 0,
	          xLow: 0,
	          xHigh: 0,
	          yLow: 0,
	          yHigh: 0
	        }
	      });
	      return c;
	    }(e);
	    m(c.prototype, {
	      pointArrayMap: ["low", "high"],
	      pointValKey: "low",
	      deferTranslatePolar: !0,
	      pointClass: d,
	      setStackedPoints: l
	    });
	    t.registerSeriesType("arearange", c);
	    return c;
	  });
	  A(d, "Series/AreaSplineRange/AreaSplineRangeSeries.js", [d["Series/AreaRange/AreaRangeSeries.js"], d["Core/Series/SeriesRegistry.js"], d["Core/Utilities.js"]], function (d, e, l) {
	    var a = this && this.__extends || function () {
	        var a = function (c, k) {
	          a = Object.setPrototypeOf || {
	            __proto__: []
	          } instanceof Array && function (b, g) {
	            b.__proto__ = g;
	          } || function (b, g) {
	            for (var a in g) g.hasOwnProperty(a) && (b[a] = g[a]);
	          };
	          return a(c, k);
	        };
	        return function (c, k) {
	          function b() {
	            this.constructor = c;
	          }
	          a(c, k);
	          c.prototype = null === k ? Object.create(k) : (b.prototype = k.prototype, new b());
	        };
	      }(),
	      c = e.seriesTypes.spline,
	      t = l.merge;
	    l = l.extend;
	    var p = function (c) {
	      function k() {
	        var a = null !== c && c.apply(this, arguments) || this;
	        a.options = void 0;
	        a.data = void 0;
	        a.points = void 0;
	        return a;
	      }
	      a(k, c);
	      k.defaultOptions = t(d.defaultOptions);
	      return k;
	    }(d);
	    l(p.prototype, {
	      getPointSpline: c.prototype.getPointSpline
	    });
	    e.registerSeriesType("areasplinerange", p);
	    return p;
	  });
	  A(d, "Series/BoxPlot/BoxPlotSeries.js", [d["Series/Column/ColumnSeries.js"], d["Core/Globals.js"], d["Core/Series/SeriesRegistry.js"], d["Core/Utilities.js"]], function (d, e, l, a) {
	    var c = this && this.__extends || function () {
	      var a = function (c, b) {
	        a = Object.setPrototypeOf || {
	          __proto__: []
	        } instanceof Array && function (b, a) {
	          b.__proto__ = a;
	        } || function (b, a) {
	          for (var g in a) a.hasOwnProperty(g) && (b[g] = a[g]);
	        };
	        return a(c, b);
	      };
	      return function (c, b) {
	        function g() {
	          this.constructor = c;
	        }
	        a(c, b);
	        c.prototype = null === b ? Object.create(b) : (g.prototype = b.prototype, new g());
	      };
	    }();
	    e = e.noop;
	    var t = a.extend,
	      p = a.merge,
	      k = a.pick;
	    a = function (a) {
	      function e() {
	        var b = null !== a && a.apply(this, arguments) || this;
	        b.data = void 0;
	        b.options = void 0;
	        b.points = void 0;
	        return b;
	      }
	      c(e, a);
	      e.prototype.pointAttribs = function () {
	        return {};
	      };
	      e.prototype.translate = function () {
	        var b = this.yAxis,
	          g = this.pointArrayMap;
	        a.prototype.translate.apply(this);
	        this.points.forEach(function (a) {
	          g.forEach(function (g) {
	            null !== a[g] && (a[g + "Plot"] = b.translate(a[g], 0, 1, 0, 1));
	          });
	          a.plotHigh = a.highPlot;
	        });
	      };
	      e.prototype.drawPoints = function () {
	        var b = this,
	          g = b.options,
	          a = b.chart,
	          c = a.renderer,
	          q,
	          e,
	          l,
	          d,
	          y,
	          z,
	          f = 0,
	          h,
	          u,
	          r,
	          B,
	          v = !1 !== b.doQuartiles,
	          E,
	          p = b.options.whiskerLength;
	        b.points.forEach(function (n) {
	          var m = n.graphic,
	            H = m ? "animate" : "attr",
	            t = n.shapeArgs,
	            x = {},
	            I = {},
	            w = {},
	            L = {},
	            M = n.color || b.color;
	          "undefined" !== typeof n.plotY && (h = Math.round(t.width), u = Math.floor(t.x), r = u + h, B = Math.round(h / 2), q = Math.floor(v ? n.q1Plot : n.lowPlot), e = Math.floor(v ? n.q3Plot : n.lowPlot), l = Math.floor(n.highPlot), d = Math.floor(n.lowPlot), m || (n.graphic = m = c.g("point").add(b.group), n.stem = c.path().addClass("highcharts-boxplot-stem").add(m), p && (n.whiskers = c.path().addClass("highcharts-boxplot-whisker").add(m)), v && (n.box = c.path(void 0).addClass("highcharts-boxplot-box").add(m)), n.medianShape = c.path(void 0).addClass("highcharts-boxplot-median").add(m)), a.styledMode || (I.stroke = n.stemColor || g.stemColor || M, I["stroke-width"] = k(n.stemWidth, g.stemWidth, g.lineWidth), I.dashstyle = n.stemDashStyle || g.stemDashStyle || g.dashStyle, n.stem.attr(I), p && (w.stroke = n.whiskerColor || g.whiskerColor || M, w["stroke-width"] = k(n.whiskerWidth, g.whiskerWidth, g.lineWidth), w.dashstyle = n.whiskerDashStyle || g.whiskerDashStyle || g.dashStyle, n.whiskers.attr(w)), v && (x.fill = n.fillColor || g.fillColor || M, x.stroke = g.lineColor || M, x["stroke-width"] = g.lineWidth || 0, x.dashstyle = n.boxDashStyle || g.boxDashStyle || g.dashStyle, n.box.attr(x)), L.stroke = n.medianColor || g.medianColor || M, L["stroke-width"] = k(n.medianWidth, g.medianWidth, g.lineWidth), L.dashstyle = n.medianDashStyle || g.medianDashStyle || g.dashStyle, n.medianShape.attr(L)), z = n.stem.strokeWidth() % 2 / 2, f = u + B + z, m = [["M", f, e], ["L", f, l], ["M", f, q], ["L", f, d]], n.stem[H]({
	            d: m
	          }), v && (z = n.box.strokeWidth() % 2 / 2, q = Math.floor(q) + z, e = Math.floor(e) + z, u += z, r += z, m = [["M", u, e], ["L", u, q], ["L", r, q], ["L", r, e], ["L", u, e], ["Z"]], n.box[H]({
	            d: m
	          })), p && (z = n.whiskers.strokeWidth() % 2 / 2, l += z, d += z, E = /%$/.test(p) ? B * parseFloat(p) / 100 : p / 2, m = [["M", f - E, l], ["L", f + E, l], ["M", f - E, d], ["L", f + E, d]], n.whiskers[H]({
	            d: m
	          })), y = Math.round(n.medianPlot), z = n.medianShape.strokeWidth() % 2 / 2, y += z, m = [["M", u, y], ["L", r, y]], n.medianShape[H]({
	            d: m
	          }));
	        });
	      };
	      e.prototype.toYData = function (b) {
	        return [b.low, b.q1, b.median, b.q3, b.high];
	      };
	      e.defaultOptions = p(d.defaultOptions, {
	        threshold: null,
	        tooltip: {
	          pointFormat: '<span style="color:{point.color}">\u25cf</span> <b> {series.name}</b><br/>Maximum: {point.high}<br/>Upper quartile: {point.q3}<br/>Median: {point.median}<br/>Lower quartile: {point.q1}<br/>Minimum: {point.low}<br/>'
	        },
	        whiskerLength: "50%",
	        fillColor: "#ffffff",
	        lineWidth: 1,
	        medianWidth: 2,
	        whiskerWidth: 2
	      });
	      return e;
	    }(d);
	    t(a.prototype, {
	      pointArrayMap: ["low", "q1", "median", "q3", "high"],
	      pointValKey: "high",
	      drawDataLabels: e,
	      setStackedPoints: e
	    });
	    l.registerSeriesType("boxplot", a);
	    return a;
	  });
	  A(d, "Series/Bubble/BubbleLegendDefaults.js", [], function () {
	    return {
	      borderColor: void 0,
	      borderWidth: 2,
	      className: void 0,
	      color: void 0,
	      connectorClassName: void 0,
	      connectorColor: void 0,
	      connectorDistance: 60,
	      connectorWidth: 1,
	      enabled: !1,
	      labels: {
	        className: void 0,
	        allowOverlap: !1,
	        format: "",
	        formatter: void 0,
	        align: "right",
	        style: {
	          fontSize: "10px",
	          color: "#000000"
	        },
	        x: 0,
	        y: 0
	      },
	      maxSize: 60,
	      minSize: 10,
	      legendIndex: 0,
	      ranges: {
	        value: void 0,
	        borderColor: void 0,
	        color: void 0,
	        connectorColor: void 0
	      },
	      sizeBy: "area",
	      sizeByAbsoluteValue: !1,
	      zIndex: 1,
	      zThreshold: 0
	    };
	  });
	  A(d, "Series/Bubble/BubbleLegendItem.js", [d["Core/Color/Color.js"], d["Core/FormatUtilities.js"], d["Core/Globals.js"], d["Core/Utilities.js"]], function (d, e, l, a) {
	    var c = d.parse,
	      t = l.noop,
	      p = a.arrayMax,
	      k = a.arrayMin,
	      x = a.isNumber,
	      w = a.merge,
	      b = a.pick,
	      g = a.stableSort;
	    return function () {
	      function a(b, a) {
	        this.options = this.symbols = this.visible = this.selected = this.ranges = this.movementX = this.maxLabel = this.legendSymbol = this.legendItemWidth = this.legendItemHeight = this.legendItem = this.legendGroup = this.legend = this.fontMetrics = this.chart = void 0;
	        this.setState = t;
	        this.init(b, a);
	      }
	      a.prototype.init = function (b, a) {
	        this.options = b;
	        this.visible = !0;
	        this.chart = a.chart;
	        this.legend = a;
	      };
	      a.prototype.addToLegend = function (b) {
	        b.splice(this.options.legendIndex, 0, this);
	      };
	      a.prototype.drawLegendSymbol = function (a) {
	        var c = this.chart,
	          n = this.options,
	          e = b(a.options.itemDistance, 20),
	          k = n.ranges,
	          m = n.connectorDistance;
	        this.fontMetrics = c.renderer.fontMetrics(n.labels.style.fontSize);
	        k && k.length && x(k[0].value) ? (g(k, function (b, f) {
	          return f.value - b.value;
	        }), this.ranges = k, this.setOptions(), this.render(), a = this.getMaxLabelSize(), k = this.ranges[0].radius, c = 2 * k, m = m - k + a.width, m = 0 < m ? m : 0, this.maxLabel = a, this.movementX = "left" === n.labels.align ? m : 0, this.legendItemWidth = c + m + e, this.legendItemHeight = c + this.fontMetrics.h / 2) : a.options.bubbleLegend.autoRanges = !0;
	      };
	      a.prototype.setOptions = function () {
	        var a = this.ranges,
	          g = this.options,
	          k = this.chart.series[g.seriesIndex],
	          e = this.legend.baseline,
	          m = {
	            zIndex: g.zIndex,
	            "stroke-width": g.borderWidth
	          },
	          l = {
	            zIndex: g.zIndex,
	            "stroke-width": g.connectorWidth
	          },
	          z = {
	            align: this.legend.options.rtl || "left" === g.labels.align ? "right" : "left",
	            zIndex: g.zIndex
	          },
	          f = k.options.marker.fillOpacity,
	          h = this.chart.styledMode;
	        a.forEach(function (u, r) {
	          h || (m.stroke = b(u.borderColor, g.borderColor, k.color), m.fill = b(u.color, g.color, 1 !== f ? c(k.color).setOpacity(f).get("rgba") : k.color), l.stroke = b(u.connectorColor, g.connectorColor, k.color));
	          a[r].radius = this.getRangeRadius(u.value);
	          a[r] = w(a[r], {
	            center: a[0].radius - a[r].radius + e
	          });
	          h || w(!0, a[r], {
	            bubbleAttribs: w(m),
	            connectorAttribs: w(l),
	            labelAttribs: z
	          });
	        }, this);
	      };
	      a.prototype.getRangeRadius = function (b) {
	        var a = this.options;
	        return this.chart.series[this.options.seriesIndex].getRadius.call(this, a.ranges[a.ranges.length - 1].value, a.ranges[0].value, a.minSize, a.maxSize, b);
	      };
	      a.prototype.render = function () {
	        var b = this.chart.renderer,
	          a = this.options.zThreshold;
	        this.symbols || (this.symbols = {
	          connectors: [],
	          bubbleItems: [],
	          labels: []
	        });
	        this.legendSymbol = b.g("bubble-legend");
	        this.legendItem = b.g("bubble-legend-item");
	        this.legendSymbol.translateX = 0;
	        this.legendSymbol.translateY = 0;
	        this.ranges.forEach(function (b) {
	          b.value >= a && this.renderRange(b);
	        }, this);
	        this.legendSymbol.add(this.legendItem);
	        this.legendItem.add(this.legendGroup);
	        this.hideOverlappingLabels();
	      };
	      a.prototype.renderRange = function (b) {
	        var a = this.options,
	          g = a.labels,
	          c = this.chart,
	          n = c.series[a.seriesIndex],
	          k = c.renderer,
	          e = this.symbols;
	        c = e.labels;
	        var f = b.center,
	          h = Math.abs(b.radius),
	          u = a.connectorDistance || 0,
	          r = g.align,
	          B = a.connectorWidth,
	          v = this.ranges[0].radius || 0,
	          m = f - h - a.borderWidth / 2 + B / 2,
	          l = this.fontMetrics;
	        l = l.f / 2 - (l.h - l.f) / 2;
	        var d = k.styledMode;
	        u = this.legend.options.rtl || "left" === r ? -u : u;
	        "center" === r && (u = 0, a.connectorDistance = 0, b.labelAttribs.align = "center");
	        r = m + a.labels.y;
	        var p = v + u + a.labels.x;
	        e.bubbleItems.push(k.circle(v, f + ((m % 1 ? 1 : .5) - (B % 2 ? 0 : .5)), h).attr(d ? {} : b.bubbleAttribs).addClass((d ? "highcharts-color-" + n.colorIndex + " " : "") + "highcharts-bubble-legend-symbol " + (a.className || "")).add(this.legendSymbol));
	        e.connectors.push(k.path(k.crispLine([["M", v, m], ["L", v + u, m]], a.connectorWidth)).attr(d ? {} : b.connectorAttribs).addClass((d ? "highcharts-color-" + this.options.seriesIndex + " " : "") + "highcharts-bubble-legend-connectors " + (a.connectorClassName || "")).add(this.legendSymbol));
	        b = k.text(this.formatLabel(b), p, r + l).attr(d ? {} : b.labelAttribs).css(d ? {} : g.style).addClass("highcharts-bubble-legend-labels " + (a.labels.className || "")).add(this.legendSymbol);
	        c.push(b);
	        b.placed = !0;
	        b.alignAttr = {
	          x: p,
	          y: r + l
	        };
	      };
	      a.prototype.getMaxLabelSize = function () {
	        var b, a;
	        this.symbols.labels.forEach(function (g) {
	          a = g.getBBox(!0);
	          b = b ? a.width > b.width ? a : b : a;
	        });
	        return b || {};
	      };
	      a.prototype.formatLabel = function (b) {
	        var a = this.options,
	          g = a.labels.formatter;
	        a = a.labels.format;
	        var c = this.chart.numberFormatter;
	        return a ? e.format(a, b) : g ? g.call(b) : c(b.value, 1);
	      };
	      a.prototype.hideOverlappingLabels = function () {
	        var b = this.chart,
	          a = this.symbols;
	        !this.options.labels.allowOverlap && a && (b.hideOverlappingLabels(a.labels), a.labels.forEach(function (b, g) {
	          b.newOpacity ? b.newOpacity !== b.oldOpacity && a.connectors[g].show() : a.connectors[g].hide();
	        }));
	      };
	      a.prototype.getRanges = function () {
	        var a = this.legend.bubbleLegend,
	          g = a.options.ranges,
	          c,
	          e = Number.MAX_VALUE,
	          m = -Number.MAX_VALUE;
	        a.chart.series.forEach(function (a) {
	          a.isBubble && !a.ignoreSeries && (c = a.zData.filter(x), c.length && (e = b(a.options.zMin, Math.min(e, Math.max(k(c), !1 === a.options.displayNegative ? a.options.zThreshold : -Number.MAX_VALUE))), m = b(a.options.zMax, Math.max(m, p(c)))));
	        });
	        var l = e === m ? [{
	          value: m
	        }] : [{
	          value: e
	        }, {
	          value: (e + m) / 2
	        }, {
	          value: m,
	          autoRanges: !0
	        }];
	        g.length && g[0].radius && l.reverse();
	        l.forEach(function (b, f) {
	          g && g[f] && (l[f] = w(g[f], b));
	        });
	        return l;
	      };
	      a.prototype.predictBubbleSizes = function () {
	        var b = this.chart,
	          a = this.fontMetrics,
	          g = b.legend.options,
	          c = g.floating,
	          k = (g = "horizontal" === g.layout) ? b.legend.lastLineHeight : 0,
	          e = b.plotSizeX,
	          m = b.plotSizeY,
	          f = b.series[this.options.seriesIndex],
	          h = f.getPxExtremes();
	        b = Math.ceil(h.minPxSize);
	        h = Math.ceil(h.maxPxSize);
	        var u = Math.min(m, e);
	        f = f.options.maxSize;
	        if (c || !/%$/.test(f)) a = h;else if (f = parseFloat(f), a = (u + k - a.h / 2) * f / 100 / (f / 100 + 1), g && m - a >= e || !g && e - a >= m) a = h;
	        return [b, Math.ceil(a)];
	      };
	      a.prototype.updateRanges = function (b, a) {
	        var g = this.legend.options.bubbleLegend;
	        g.minSize = b;
	        g.maxSize = a;
	        g.ranges = this.getRanges();
	      };
	      a.prototype.correctSizes = function () {
	        var b = this.legend,
	          a = this.chart.series[this.options.seriesIndex].getPxExtremes();
	        1 < Math.abs(Math.ceil(a.maxPxSize) - this.options.maxSize) && (this.updateRanges(this.options.minSize, a.maxPxSize), b.render());
	      };
	      return a;
	    }();
	  });
	  A(d, "Series/Bubble/BubbleLegendComposition.js", [d["Series/Bubble/BubbleLegendDefaults.js"], d["Series/Bubble/BubbleLegendItem.js"], d["Core/DefaultOptions.js"], d["Core/Utilities.js"]], function (d, e, l, a) {
	    var c = l.setOptions,
	      t = a.addEvent,
	      p = a.objectEach,
	      k = a.wrap,
	      x;
	    (function (a) {
	      function b(b, a, c) {
	        var f = this.legend,
	          h = 0 <= g(this);
	        if (f && f.options.enabled && f.bubbleLegend && f.options.bubbleLegend.autoRanges && h) {
	          var u = f.bubbleLegend.options;
	          h = f.bubbleLegend.predictBubbleSizes();
	          f.bubbleLegend.updateRanges(h[0], h[1]);
	          u.placed || (f.group.placed = !1, f.allItems.forEach(function (h) {
	            h.legendGroup.translateY = null;
	          }));
	          f.render();
	          this.getMargins();
	          this.axes.forEach(function (h) {
	            h.visible && h.render();
	            u.placed || (h.setScale(), h.updateNames(), p(h.ticks, function (h) {
	              h.isNew = !0;
	              h.isNewLabel = !0;
	            }));
	          });
	          u.placed = !0;
	          this.getMargins();
	          b.call(this, a, c);
	          f.bubbleLegend.correctSizes();
	          x(f, m(f));
	        } else b.call(this, a, c), f && f.options.enabled && f.bubbleLegend && (f.render(), x(f, m(f)));
	      }
	      function g(b) {
	        b = b.series;
	        for (var a = 0; a < b.length;) {
	          if (b[a] && b[a].isBubble && b[a].visible && b[a].zData.length) return a;
	          a++;
	        }
	        return -1;
	      }
	      function m(b) {
	        b = b.allItems;
	        var a = [],
	          g = b.length,
	          f,
	          h = 0;
	        for (f = 0; f < g; f++) if (b[f].legendItemHeight && (b[f].itemHeight = b[f].legendItemHeight), b[f] === b[g - 1] || b[f + 1] && b[f]._legendItemPos[1] !== b[f + 1]._legendItemPos[1]) {
	          a.push({
	            height: 0
	          });
	          var u = a[a.length - 1];
	          for (h; h <= f; h++) b[h].itemHeight > u.height && (u.height = b[h].itemHeight);
	          u.step = f;
	        }
	        return a;
	      }
	      function n(b) {
	        var a = this.bubbleLegend,
	          c = this.options,
	          f = c.bubbleLegend,
	          h = g(this.chart);
	        a && a.ranges && a.ranges.length && (f.ranges.length && (f.autoRanges = !!f.ranges[0].autoRanges), this.destroyItem(a));
	        0 <= h && c.enabled && f.enabled && (f.seriesIndex = h, this.bubbleLegend = new e(f, this), this.bubbleLegend.addToLegend(b.allItems));
	      }
	      function l() {
	        var b = this.chart,
	          a = this.visible,
	          c = this.chart.legend;
	        c && c.bubbleLegend && (this.visible = !a, this.ignoreSeries = a, b = 0 <= g(b), c.bubbleLegend.visible !== b && (c.update({
	          bubbleLegend: {
	            enabled: b
	          }
	        }), c.bubbleLegend.visible = b), this.visible = a);
	      }
	      function x(b, a) {
	        var g = b.options.rtl,
	          f,
	          h,
	          u,
	          r = 0;
	        b.allItems.forEach(function (b, c) {
	          f = b.legendGroup.translateX;
	          h = b._legendItemPos[1];
	          if ((u = b.movementX) || g && b.ranges) u = g ? f - b.options.maxSize / 2 : f + u, b.legendGroup.attr({
	            translateX: u
	          });
	          c > a[r].step && r++;
	          b.legendGroup.attr({
	            translateY: Math.round(h + a[r].height / 2)
	          });
	          b._legendItemPos[1] = h + a[r].height / 2;
	        });
	      }
	      var w = [];
	      a.compose = function (a, g, e) {
	        -1 === w.indexOf(a) && (w.push(a), c({
	          legend: {
	            bubbleLegend: d
	          }
	        }), k(a.prototype, "drawChartBox", b));
	        -1 === w.indexOf(g) && (w.push(g), t(g, "afterGetAllItems", n));
	        -1 === w.indexOf(e) && (w.push(e), t(e, "legendItemClick", l));
	      };
	    })(x || (x = {}));
	    return x;
	  });
	  A(d, "Series/Bubble/BubblePoint.js", [d["Core/Series/Point.js"], d["Core/Series/SeriesRegistry.js"], d["Core/Utilities.js"]], function (d, e, l) {
	    var a = this && this.__extends || function () {
	      var a = function (c, e) {
	        a = Object.setPrototypeOf || {
	          __proto__: []
	        } instanceof Array && function (a, c) {
	          a.__proto__ = c;
	        } || function (a, c) {
	          for (var e in c) c.hasOwnProperty(e) && (a[e] = c[e]);
	        };
	        return a(c, e);
	      };
	      return function (c, e) {
	        function k() {
	          this.constructor = c;
	        }
	        a(c, e);
	        c.prototype = null === e ? Object.create(e) : (k.prototype = e.prototype, new k());
	      };
	    }();
	    l = l.extend;
	    e = function (c) {
	      function e() {
	        var a = null !== c && c.apply(this, arguments) || this;
	        a.options = void 0;
	        a.series = void 0;
	        return a;
	      }
	      a(e, c);
	      e.prototype.haloPath = function (a) {
	        return d.prototype.haloPath.call(this, 0 === a ? 0 : (this.marker ? this.marker.radius || 0 : 0) + a);
	      };
	      return e;
	    }(e.seriesTypes.scatter.prototype.pointClass);
	    l(e.prototype, {
	      ttBelow: !1
	    });
	    return e;
	  });
	  A(d, "Series/Bubble/BubbleSeries.js", [d["Core/Axis/Axis.js"], d["Series/Bubble/BubbleLegendComposition.js"], d["Series/Bubble/BubblePoint.js"], d["Core/Color/Color.js"], d["Core/Globals.js"], d["Core/Series/Series.js"], d["Core/Series/SeriesRegistry.js"], d["Core/Utilities.js"]], function (d, e, l, a, c, t, p, k) {
	    var x = this && this.__extends || function () {
	        var b = function (f, h) {
	          b = Object.setPrototypeOf || {
	            __proto__: []
	          } instanceof Array && function (b, h) {
	            b.__proto__ = h;
	          } || function (b, h) {
	            for (var f in h) h.hasOwnProperty(f) && (b[f] = h[f]);
	          };
	          return b(f, h);
	        };
	        return function (f, h) {
	          function a() {
	            this.constructor = f;
	          }
	          b(f, h);
	          f.prototype = null === h ? Object.create(h) : (a.prototype = h.prototype, new a());
	        };
	      }(),
	      w = a.parse;
	    a = c.noop;
	    var b = p.seriesTypes;
	    c = b.column;
	    var g = b.scatter;
	    b = k.addEvent;
	    var m = k.arrayMax,
	      n = k.arrayMin,
	      q = k.clamp,
	      H = k.extend,
	      K = k.isNumber,
	      I = k.merge,
	      y = k.pick;
	    k = function (b) {
	      function f() {
	        var h = null !== b && b.apply(this, arguments) || this;
	        h.data = void 0;
	        h.maxPxSize = void 0;
	        h.minPxSize = void 0;
	        h.options = void 0;
	        h.points = void 0;
	        h.radii = void 0;
	        h.yData = void 0;
	        h.zData = void 0;
	        return h;
	      }
	      x(f, b);
	      f.prototype.animate = function (b) {
	        !b && this.points.length < this.options.animationLimit && this.points.forEach(function (b) {
	          var h = b.graphic;
	          h && h.width && (this.hasRendered || h.attr({
	            x: b.plotX,
	            y: b.plotY,
	            width: 1,
	            height: 1
	          }), h.animate(this.markerAttribs(b), this.options.animation));
	        }, this);
	      };
	      f.prototype.getRadii = function () {
	        var b = this,
	          f = this.zData,
	          a = this.yData,
	          g = [],
	          c = this.chart.bubbleZExtremes;
	        var e = this.getPxExtremes();
	        var m = e.minPxSize,
	          k = e.maxPxSize;
	        if (!c) {
	          var n = Number.MAX_VALUE,
	            l = -Number.MAX_VALUE,
	            d;
	          this.chart.series.forEach(function (h) {
	            h.bubblePadding && (h.visible || !b.chart.options.chart.ignoreHiddenSeries) && (h = h.getZExtremes()) && (n = Math.min(n || h.zMin, h.zMin), l = Math.max(l || h.zMax, h.zMax), d = !0);
	          });
	          d ? (c = {
	            zMin: n,
	            zMax: l
	          }, this.chart.bubbleZExtremes = c) : c = {
	            zMin: 0,
	            zMax: 0
	          };
	        }
	        var p = 0;
	        for (e = f.length; p < e; p++) {
	          var q = f[p];
	          g.push(this.getRadius(c.zMin, c.zMax, m, k, q, a[p]));
	        }
	        this.radii = g;
	      };
	      f.prototype.getRadius = function (b, f, a, g, c, e) {
	        var h = this.options,
	          r = "width" !== h.sizeBy,
	          u = h.zThreshold,
	          v = f - b,
	          m = .5;
	        if (null === e || null === c) return null;
	        if (K(c)) {
	          h.sizeByAbsoluteValue && (c = Math.abs(c - u), v = Math.max(f - u, Math.abs(b - u)), b = 0);
	          if (c < b) return a / 2 - 1;
	          0 < v && (m = (c - b) / v);
	        }
	        r && 0 <= m && (m = Math.sqrt(m));
	        return Math.ceil(a + m * (g - a)) / 2;
	      };
	      f.prototype.hasData = function () {
	        return !!this.processedXData.length;
	      };
	      f.prototype.pointAttribs = function (b, f) {
	        var h = this.options.marker.fillOpacity;
	        b = t.prototype.pointAttribs.call(this, b, f);
	        1 !== h && (b.fill = w(b.fill).setOpacity(h).get("rgba"));
	        return b;
	      };
	      f.prototype.translate = function () {
	        b.prototype.translate.call(this);
	        this.getRadii();
	        this.translateBubble();
	      };
	      f.prototype.translateBubble = function () {
	        for (var b = this.data, f = this.radii, a = this.getPxExtremes().minPxSize, g = b.length; g--;) {
	          var c = b[g],
	            e = f ? f[g] : 0;
	          K(e) && e >= a / 2 ? (c.marker = H(c.marker, {
	            radius: e,
	            width: 2 * e,
	            height: 2 * e
	          }), c.dlBox = {
	            x: c.plotX - e,
	            y: c.plotY - e,
	            width: 2 * e,
	            height: 2 * e
	          }) : c.shapeArgs = c.plotY = c.dlBox = void 0;
	        }
	      };
	      f.prototype.getPxExtremes = function () {
	        var b = Math.min(this.chart.plotWidth, this.chart.plotHeight),
	          f = function (h) {
	            if ("string" === typeof h) {
	              var f = /%$/.test(h);
	              h = parseInt(h, 10);
	            }
	            return f ? b * h / 100 : h;
	          },
	          a = f(y(this.options.minSize, 8));
	        f = Math.max(f(y(this.options.maxSize, "20%")), a);
	        return {
	          minPxSize: a,
	          maxPxSize: f
	        };
	      };
	      f.prototype.getZExtremes = function () {
	        var b = this.options,
	          f = (this.zData || []).filter(K);
	        if (f.length) {
	          var a = y(b.zMin, q(n(f), !1 === b.displayNegative ? b.zThreshold || 0 : -Number.MAX_VALUE, Number.MAX_VALUE));
	          b = y(b.zMax, m(f));
	          if (K(a) && K(b)) return {
	            zMin: a,
	            zMax: b
	          };
	        }
	      };
	      f.compose = e.compose;
	      f.defaultOptions = I(g.defaultOptions, {
	        dataLabels: {
	          formatter: function () {
	            var b = this.series.chart.numberFormatter,
	              f = this.point.z;
	            return K(f) ? b(f, -1) : "";
	          },
	          inside: !0,
	          verticalAlign: "middle"
	        },
	        animationLimit: 250,
	        marker: {
	          lineColor: null,
	          lineWidth: 1,
	          fillOpacity: .5,
	          radius: null,
	          states: {
	            hover: {
	              radiusPlus: 0
	            }
	          },
	          symbol: "circle"
	        },
	        minSize: 8,
	        maxSize: "20%",
	        softThreshold: !1,
	        states: {
	          hover: {
	            halo: {
	              size: 5
	            }
	          }
	        },
	        tooltip: {
	          pointFormat: "({point.x}, {point.y}), Size: {point.z}"
	        },
	        turboThreshold: 0,
	        zThreshold: 0,
	        zoneAxis: "z"
	      });
	      return f;
	    }(g);
	    H(k.prototype, {
	      alignDataLabel: c.prototype.alignDataLabel,
	      applyZones: a,
	      bubblePadding: !0,
	      buildKDTree: a,
	      directTouch: !0,
	      isBubble: !0,
	      pointArrayMap: ["y", "z"],
	      pointClass: l,
	      parallelArrays: ["x", "y", "z"],
	      trackerGroups: ["group", "dataLabelsGroup"],
	      specialGroup: "group",
	      zoneAxis: "z"
	    });
	    b(k, "updatedData", function (b) {
	      delete b.target.chart.bubbleZExtremes;
	    });
	    d.prototype.beforePadding = function () {
	      var b = this,
	        f = this.len,
	        h = this.chart,
	        a = 0,
	        g = f,
	        c = this.isXAxis,
	        v = c ? "xData" : "yData",
	        e = this.min,
	        m = this.max - e,
	        k = f / m,
	        n;
	      this.series.forEach(function (f) {
	        if (f.bubblePadding && (f.visible || !h.options.chart.ignoreHiddenSeries)) {
	          n = b.allowZoomOutside = !0;
	          var r = f[v];
	          c && f.getRadii(0, 0, f);
	          if (0 < m) for (var u = r.length; u--;) if (K(r[u]) && b.dataMin <= r[u] && r[u] <= b.max) {
	            var B = f.radii && f.radii[u] || 0;
	            a = Math.min((r[u] - e) * k - B, a);
	            g = Math.max((r[u] - e) * k + B, g);
	          }
	        }
	      });
	      n && 0 < m && !this.logarithmic && (g -= f, k *= (f + Math.max(0, a) - Math.min(g, f)) / f, [["min", "userMin", a], ["max", "userMax", g]].forEach(function (h) {
	        "undefined" === typeof y(b.options[h[0]], b[h[1]]) && (b[h[0]] += h[2] / k);
	      }));
	    };
	    p.registerSeriesType("bubble", k);
	    return k;
	  });
	  A(d, "Series/ColumnRange/ColumnRangePoint.js", [d["Core/Series/SeriesRegistry.js"], d["Core/Utilities.js"]], function (d, e) {
	    var l = this && this.__extends || function () {
	        var a = function (c, e) {
	          a = Object.setPrototypeOf || {
	            __proto__: []
	          } instanceof Array && function (a, b) {
	            a.__proto__ = b;
	          } || function (a, b) {
	            for (var g in b) b.hasOwnProperty(g) && (a[g] = b[g]);
	          };
	          return a(c, e);
	        };
	        return function (c, e) {
	          function k() {
	            this.constructor = c;
	          }
	          a(c, e);
	          c.prototype = null === e ? Object.create(e) : (k.prototype = e.prototype, new k());
	        };
	      }(),
	      a = d.seriesTypes;
	    d = a.column.prototype.pointClass;
	    var c = e.extend,
	      t = e.isNumber;
	    e = function (a) {
	      function c() {
	        var c = null !== a && a.apply(this, arguments) || this;
	        c.series = void 0;
	        c.options = void 0;
	        c.barX = void 0;
	        c.pointWidth = void 0;
	        c.shapeType = void 0;
	        return c;
	      }
	      l(c, a);
	      c.prototype.isValid = function () {
	        return t(this.low);
	      };
	      return c;
	    }(a.arearange.prototype.pointClass);
	    c(e.prototype, {
	      setState: d.prototype.setState
	    });
	    return e;
	  });
	  A(d, "Series/ColumnRange/ColumnRangeSeries.js", [d["Series/ColumnRange/ColumnRangePoint.js"], d["Core/Globals.js"], d["Core/Series/SeriesRegistry.js"], d["Core/Utilities.js"]], function (d, e, l, a) {
	    var c = this && this.__extends || function () {
	      var b = function (a, g) {
	        b = Object.setPrototypeOf || {
	          __proto__: []
	        } instanceof Array && function (b, a) {
	          b.__proto__ = a;
	        } || function (b, a) {
	          for (var g in a) a.hasOwnProperty(g) && (b[g] = a[g]);
	        };
	        return b(a, g);
	      };
	      return function (a, g) {
	        function c() {
	          this.constructor = a;
	        }
	        b(a, g);
	        a.prototype = null === g ? Object.create(g) : (c.prototype = g.prototype, new c());
	      };
	    }();
	    e = e.noop;
	    var t = l.seriesTypes,
	      p = t.arearange,
	      k = t.column,
	      x = k.prototype,
	      w = p.prototype,
	      b = a.clamp,
	      g = a.merge,
	      m = a.pick;
	    a = a.extend;
	    var n = {
	      pointRange: null,
	      marker: null,
	      states: {
	        hover: {
	          halo: !1
	        }
	      }
	    };
	    t = function (a) {
	      function e() {
	        var b = null !== a && a.apply(this, arguments) || this;
	        b.data = void 0;
	        b.points = void 0;
	        b.options = void 0;
	        return b;
	      }
	      c(e, a);
	      e.prototype.setOptions = function () {
	        g(!0, arguments[0], {
	          stacking: void 0
	        });
	        return w.setOptions.apply(this, arguments);
	      };
	      e.prototype.translate = function () {
	        var a = this,
	          g = a.yAxis,
	          c = a.xAxis,
	          e = c.startAngleRad,
	          f,
	          h = a.chart,
	          u = a.xAxis.isRadial,
	          r = Math.max(h.chartWidth, h.chartHeight) + 999,
	          k;
	        x.translate.apply(a);
	        a.points.forEach(function (v) {
	          var n = v.shapeArgs || {},
	            B = a.options.minPointLength;
	          v.plotHigh = k = b(g.translate(v.high, 0, 1, 0, 1), -r, r);
	          v.plotLow = b(v.plotY, -r, r);
	          var l = k;
	          var d = m(v.rectPlotY, v.plotY) - k;
	          Math.abs(d) < B ? (B -= d, d += B, l -= B / 2) : 0 > d && (d *= -1, l -= d);
	          u ? (f = v.barX + e, v.shapeType = "arc", v.shapeArgs = a.polarArc(l + d, l, f, f + v.pointWidth)) : (n.height = d, n.y = l, B = n.x, B = void 0 === B ? 0 : B, n = n.width, n = void 0 === n ? 0 : n, v.tooltipPos = h.inverted ? [g.len + g.pos - h.plotLeft - l - d / 2, c.len + c.pos - h.plotTop - B - n / 2, d] : [c.left - h.plotLeft + B + n / 2, g.pos - h.plotTop + l + d / 2, d]);
	        });
	      };
	      e.prototype.crispCol = function () {
	        return x.crispCol.apply(this, arguments);
	      };
	      e.prototype.drawPoints = function () {
	        return x.drawPoints.apply(this, arguments);
	      };
	      e.prototype.drawTracker = function () {
	        return x.drawTracker.apply(this, arguments);
	      };
	      e.prototype.getColumnMetrics = function () {
	        return x.getColumnMetrics.apply(this, arguments);
	      };
	      e.prototype.pointAttribs = function () {
	        return x.pointAttribs.apply(this, arguments);
	      };
	      e.prototype.adjustForMissingColumns = function () {
	        return x.adjustForMissingColumns.apply(this, arguments);
	      };
	      e.prototype.animate = function () {
	        return x.animate.apply(this, arguments);
	      };
	      e.prototype.translate3dPoints = function () {
	        return x.translate3dPoints.apply(this, arguments);
	      };
	      e.prototype.translate3dShapes = function () {
	        return x.translate3dShapes.apply(this, arguments);
	      };
	      e.defaultOptions = g(k.defaultOptions, p.defaultOptions, n);
	      return e;
	    }(p);
	    a(t.prototype, {
	      directTouch: !0,
	      trackerGroups: ["group", "dataLabelsGroup"],
	      drawGraph: e,
	      getSymbol: e,
	      polarArc: function () {
	        return x.polarArc.apply(this, arguments);
	      },
	      pointClass: d
	    });
	    l.registerSeriesType("columnrange", t);
	    return t;
	  });
	  A(d, "Series/ColumnPyramid/ColumnPyramidSeries.js", [d["Series/Column/ColumnSeries.js"], d["Core/Series/SeriesRegistry.js"], d["Core/Utilities.js"]], function (d, e, l) {
	    var a = this && this.__extends || function () {
	        var a = function (c, b) {
	          a = Object.setPrototypeOf || {
	            __proto__: []
	          } instanceof Array && function (b, a) {
	            b.__proto__ = a;
	          } || function (b, a) {
	            for (var g in a) a.hasOwnProperty(g) && (b[g] = a[g]);
	          };
	          return a(c, b);
	        };
	        return function (c, b) {
	          function g() {
	            this.constructor = c;
	          }
	          a(c, b);
	          c.prototype = null === b ? Object.create(b) : (g.prototype = b.prototype, new g());
	        };
	      }(),
	      c = d.prototype,
	      t = l.clamp,
	      p = l.merge,
	      k = l.pick;
	    l = function (e) {
	      function l() {
	        var b = null !== e && e.apply(this, arguments) || this;
	        b.data = void 0;
	        b.options = void 0;
	        b.points = void 0;
	        return b;
	      }
	      a(l, e);
	      l.prototype.translate = function () {
	        var b = this,
	          a = b.chart,
	          e = b.options,
	          n = b.dense = 2 > b.closestPointRange * b.xAxis.transA;
	        n = b.borderWidth = k(e.borderWidth, n ? 0 : 1);
	        var d = b.yAxis,
	          l = e.threshold,
	          p = b.translatedThreshold = d.getThreshold(l),
	          x = k(e.minPointLength, 5),
	          w = b.getColumnMetrics(),
	          z = w.width,
	          f = b.barW = Math.max(z, 1 + 2 * n),
	          h = b.pointXOffset = w.offset;
	        a.inverted && (p -= .5);
	        e.pointPadding && (f = Math.ceil(f));
	        c.translate.apply(b);
	        b.points.forEach(function (g) {
	          var c = k(g.yBottom, p),
	            u = 999 + Math.abs(c),
	            v = t(g.plotY, -u, d.len + u);
	          u = g.plotX + h;
	          var m = f / 2,
	            n = Math.min(v, c);
	          c = Math.max(v, c) - n;
	          var q;
	          g.barX = u;
	          g.pointWidth = z;
	          g.tooltipPos = a.inverted ? [d.len + d.pos - a.plotLeft - v, b.xAxis.len - u - m, c] : [u + m, v + d.pos - a.plotTop, c];
	          v = l + (g.total || g.y);
	          "percent" === e.stacking && (v = l + (0 > g.y) ? -100 : 100);
	          v = d.toPixels(v, !0);
	          var w = (q = a.plotHeight - v - (a.plotHeight - p)) ? m * (n - v) / q : 0;
	          var y = q ? m * (n + c - v) / q : 0;
	          q = u - w + m;
	          w = u + w + m;
	          var C = u + y + m;
	          y = u - y + m;
	          var H = n - x;
	          var D = n + c;
	          0 > g.y && (H = n, D = n + c + x);
	          a.inverted && (C = d.width - n, q = v - (d.width - p), w = m * (v - C) / q, y = m * (v - (C - c)) / q, q = u + m + w, w = q - 2 * w, C = u - y + m, y = u + y + m, H = n, D = n + c - x, 0 > g.y && (D = n + c + x));
	          g.shapeType = "path";
	          g.shapeArgs = {
	            x: q,
	            y: H,
	            width: w - q,
	            height: c,
	            d: [["M", q, H], ["L", w, H], ["L", C, D], ["L", y, D], ["Z"]]
	          };
	        });
	      };
	      l.defaultOptions = p(d.defaultOptions, {});
	      return l;
	    }(d);
	    e.registerSeriesType("columnpyramid", l);
	    return l;
	  });
	  A(d, "Series/ErrorBar/ErrorBarSeries.js", [d["Series/BoxPlot/BoxPlotSeries.js"], d["Series/Column/ColumnSeries.js"], d["Core/Series/SeriesRegistry.js"], d["Core/Utilities.js"]], function (d, e, l, a) {
	    var c = this && this.__extends || function () {
	        var a = function (c, b) {
	          a = Object.setPrototypeOf || {
	            __proto__: []
	          } instanceof Array && function (b, a) {
	            b.__proto__ = a;
	          } || function (b, a) {
	            for (var g in a) a.hasOwnProperty(g) && (b[g] = a[g]);
	          };
	          return a(c, b);
	        };
	        return function (c, b) {
	          function g() {
	            this.constructor = c;
	          }
	          a(c, b);
	          c.prototype = null === b ? Object.create(b) : (g.prototype = b.prototype, new g());
	        };
	      }(),
	      t = l.seriesTypes.arearange,
	      p = a.merge;
	    a = a.extend;
	    var k = function (a) {
	      function k() {
	        var b = null !== a && a.apply(this, arguments) || this;
	        b.data = void 0;
	        b.options = void 0;
	        b.points = void 0;
	        return b;
	      }
	      c(k, a);
	      k.prototype.getColumnMetrics = function () {
	        return this.linkedParent && this.linkedParent.columnMetrics || e.prototype.getColumnMetrics.call(this);
	      };
	      k.prototype.drawDataLabels = function () {
	        var b = this.pointValKey;
	        t && (t.prototype.drawDataLabels.call(this), this.data.forEach(function (a) {
	          a.y = a[b];
	        }));
	      };
	      k.prototype.toYData = function (b) {
	        return [b.low, b.high];
	      };
	      k.defaultOptions = p(d.defaultOptions, {
	        color: "#000000",
	        grouping: !1,
	        linkedTo: ":previous",
	        tooltip: {
	          pointFormat: '<span style="color:{point.color}">\u25cf</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'
	        },
	        whiskerWidth: null
	      });
	      return k;
	    }(d);
	    a(k.prototype, {
	      pointArrayMap: ["low", "high"],
	      pointValKey: "high",
	      doQuartiles: !1
	    });
	    l.registerSeriesType("errorbar", k);
	    return k;
	  });
	  A(d, "Series/Gauge/GaugePoint.js", [d["Core/Series/SeriesRegistry.js"]], function (d) {
	    var e = this && this.__extends || function () {
	      var e = function (a, c) {
	        e = Object.setPrototypeOf || {
	          __proto__: []
	        } instanceof Array && function (a, c) {
	          a.__proto__ = c;
	        } || function (a, c) {
	          for (var e in c) c.hasOwnProperty(e) && (a[e] = c[e]);
	        };
	        return e(a, c);
	      };
	      return function (a, c) {
	        function d() {
	          this.constructor = a;
	        }
	        e(a, c);
	        a.prototype = null === c ? Object.create(c) : (d.prototype = c.prototype, new d());
	      };
	    }();
	    return function (d) {
	      function a() {
	        var a = null !== d && d.apply(this, arguments) || this;
	        a.options = void 0;
	        a.series = void 0;
	        a.shapeArgs = void 0;
	        return a;
	      }
	      e(a, d);
	      a.prototype.setState = function (a) {
	        this.state = a;
	      };
	      return a;
	    }(d.series.prototype.pointClass);
	  });
	  A(d, "Series/Gauge/GaugeSeries.js", [d["Series/Gauge/GaugePoint.js"], d["Core/Globals.js"], d["Core/Series/SeriesRegistry.js"], d["Core/Utilities.js"]], function (d, e, l, a) {
	    var c = this && this.__extends || function () {
	      var b = function (a, g) {
	        b = Object.setPrototypeOf || {
	          __proto__: []
	        } instanceof Array && function (b, a) {
	          b.__proto__ = a;
	        } || function (b, a) {
	          for (var g in a) a.hasOwnProperty(g) && (b[g] = a[g]);
	        };
	        return b(a, g);
	      };
	      return function (a, g) {
	        function c() {
	          this.constructor = a;
	        }
	        b(a, g);
	        a.prototype = null === g ? Object.create(g) : (c.prototype = g.prototype, new c());
	      };
	    }();
	    e = e.noop;
	    var t = l.series,
	      p = l.seriesTypes.column,
	      k = a.clamp,
	      x = a.isNumber,
	      w = a.extend,
	      b = a.merge,
	      g = a.pick,
	      m = a.pInt;
	    a = function (a) {
	      function e() {
	        var b = null !== a && a.apply(this, arguments) || this;
	        b.data = void 0;
	        b.points = void 0;
	        b.options = void 0;
	        b.yAxis = void 0;
	        return b;
	      }
	      c(e, a);
	      e.prototype.translate = function () {
	        var a = this.yAxis,
	          c = this.options,
	          e = a.center;
	        this.generatePoints();
	        this.points.forEach(function (d) {
	          var n = b(c.dial, d.dial),
	            f = m(g(n.radius, "80%")) * e[2] / 200,
	            h = m(g(n.baseLength, "70%")) * f / 100,
	            u = m(g(n.rearLength, "10%")) * f / 100,
	            r = n.baseWidth || 3,
	            l = n.topWidth || 1,
	            v = c.overshoot,
	            p = a.startAngleRad + a.translate(d.y, null, null, null, !0);
	          if (x(v) || !1 === c.wrap) v = x(v) ? v / 180 * Math.PI : 0, p = k(p, a.startAngleRad - v, a.endAngleRad + v);
	          p = 180 * p / Math.PI;
	          d.shapeType = "path";
	          d.shapeArgs = {
	            d: n.path || [["M", -u, -r / 2], ["L", h, -r / 2], ["L", f, -l / 2], ["L", f, l / 2], ["L", h, r / 2], ["L", -u, r / 2], ["Z"]],
	            translateX: e[0],
	            translateY: e[1],
	            rotation: p
	          };
	          d.plotX = e[0];
	          d.plotY = e[1];
	        });
	      };
	      e.prototype.drawPoints = function () {
	        var a = this,
	          c = a.chart,
	          e = a.yAxis.center,
	          d = a.pivot,
	          m = a.options,
	          f = m.pivot,
	          h = c.renderer;
	        a.points.forEach(function (f) {
	          var g = f.graphic,
	            e = f.shapeArgs,
	            u = e.d,
	            d = b(m.dial, f.dial);
	          g ? (g.animate(e), e.d = u) : f.graphic = h[f.shapeType](e).attr({
	            rotation: e.rotation,
	            zIndex: 1
	          }).addClass("highcharts-dial").add(a.group);
	          if (!c.styledMode) f.graphic[g ? "animate" : "attr"]({
	            stroke: d.borderColor || "none",
	            "stroke-width": d.borderWidth || 0,
	            fill: d.backgroundColor || "#000000"
	          });
	        });
	        d ? d.animate({
	          translateX: e[0],
	          translateY: e[1]
	        }) : (a.pivot = h.circle(0, 0, g(f.radius, 5)).attr({
	          zIndex: 2
	        }).addClass("highcharts-pivot").translate(e[0], e[1]).add(a.group), c.styledMode || a.pivot.attr({
	          "stroke-width": f.borderWidth || 0,
	          stroke: f.borderColor || "#cccccc",
	          fill: f.backgroundColor || "#000000"
	        }));
	      };
	      e.prototype.animate = function (b) {
	        var a = this;
	        b || a.points.forEach(function (b) {
	          var g = b.graphic;
	          g && (g.attr({
	            rotation: 180 * a.yAxis.startAngleRad / Math.PI
	          }), g.animate({
	            rotation: b.shapeArgs.rotation
	          }, a.options.animation));
	        });
	      };
	      e.prototype.render = function () {
	        this.group = this.plotGroup("group", "series", this.visible ? "inherit" : "hidden", this.options.zIndex, this.chart.seriesGroup);
	        t.prototype.render.call(this);
	        this.group.clip(this.chart.clipRect);
	      };
	      e.prototype.setData = function (b, a) {
	        t.prototype.setData.call(this, b, !1);
	        this.processData();
	        this.generatePoints();
	        g(a, !0) && this.chart.redraw();
	      };
	      e.prototype.hasData = function () {
	        return !!this.points.length;
	      };
	      e.defaultOptions = b(t.defaultOptions, {
	        dataLabels: {
	          borderColor: "#cccccc",
	          borderRadius: 3,
	          borderWidth: 1,
	          crop: !1,
	          defer: !1,
	          enabled: !0,
	          verticalAlign: "top",
	          y: 15,
	          zIndex: 2
	        },
	        dial: {},
	        pivot: {},
	        tooltip: {
	          headerFormat: ""
	        },
	        showInLegend: !1
	      });
	      return e;
	    }(t);
	    w(a.prototype, {
	      angular: !0,
	      directTouch: !0,
	      drawGraph: e,
	      drawTracker: p.prototype.drawTracker,
	      fixedBox: !0,
	      forceDL: !0,
	      noSharedTooltip: !0,
	      pointClass: d,
	      trackerGroups: ["group", "dataLabelsGroup"]
	    });
	    l.registerSeriesType("gauge", a);
	    return a;
	  });
	  A(d, "Series/PackedBubble/PackedBubblePoint.js", [d["Core/Chart/Chart.js"], d["Core/Series/Point.js"], d["Core/Series/SeriesRegistry.js"]], function (d, e, l) {
	    var a = this && this.__extends || function () {
	      var a = function (c, e) {
	        a = Object.setPrototypeOf || {
	          __proto__: []
	        } instanceof Array && function (a, c) {
	          a.__proto__ = c;
	        } || function (a, c) {
	          for (var e in c) c.hasOwnProperty(e) && (a[e] = c[e]);
	        };
	        return a(c, e);
	      };
	      return function (c, e) {
	        function d() {
	          this.constructor = c;
	        }
	        a(c, e);
	        c.prototype = null === e ? Object.create(e) : (d.prototype = e.prototype, new d());
	      };
	    }();
	    return function (c) {
	      function l() {
	        var a = null !== c && c.apply(this, arguments) || this;
	        a.degree = NaN;
	        a.mass = NaN;
	        a.radius = NaN;
	        a.options = void 0;
	        a.series = void 0;
	        a.value = null;
	        return a;
	      }
	      a(l, c);
	      l.prototype.destroy = function () {
	        this.series.layout && this.series.layout.removeElementFromCollection(this, this.series.layout.nodes);
	        return e.prototype.destroy.apply(this, arguments);
	      };
	      l.prototype.firePointEvent = function () {
	        var a = this.series.options;
	        if (this.isParentNode && a.parentNode) {
	          var c = a.allowPointSelect;
	          a.allowPointSelect = a.parentNode.allowPointSelect;
	          e.prototype.firePointEvent.apply(this, arguments);
	          a.allowPointSelect = c;
	        } else e.prototype.firePointEvent.apply(this, arguments);
	      };
	      l.prototype.select = function () {
	        var a = this.series.chart;
	        this.isParentNode ? (a.getSelectedPoints = a.getSelectedParentNodes, e.prototype.select.apply(this, arguments), a.getSelectedPoints = d.prototype.getSelectedPoints) : e.prototype.select.apply(this, arguments);
	      };
	      return l;
	    }(l.seriesTypes.bubble.prototype.pointClass);
	  });
	  A(d, "Series/Networkgraph/DraggableNodes.js", [d["Core/Chart/Chart.js"], d["Core/Globals.js"], d["Core/Utilities.js"]], function (d, e, l) {
	    var a = l.addEvent;
	    e.dragNodesMixin = {
	      onMouseDown: function (a, e) {
	        e = this.chart.pointer.normalize(e);
	        a.fixedPosition = {
	          chartX: e.chartX,
	          chartY: e.chartY,
	          plotX: a.plotX,
	          plotY: a.plotY
	        };
	        a.inDragMode = !0;
	      },
	      onMouseMove: function (a, e) {
	        if (a.fixedPosition && a.inDragMode) {
	          var c = this.chart,
	            d = c.pointer.normalize(e);
	          e = a.fixedPosition.chartX - d.chartX;
	          d = a.fixedPosition.chartY - d.chartY;
	          var l = void 0,
	            w = void 0,
	            b = c.graphLayoutsLookup;
	          if (5 < Math.abs(e) || 5 < Math.abs(d)) l = a.fixedPosition.plotX - e, w = a.fixedPosition.plotY - d, c.isInsidePlot(l, w) && (a.plotX = l, a.plotY = w, a.hasDragged = !0, this.redrawHalo(a), b.forEach(function (b) {
	            b.restartSimulation();
	          }));
	        }
	      },
	      onMouseUp: function (a, e) {
	        a.fixedPosition && (a.hasDragged && (this.layout.enableSimulation ? this.layout.start() : this.chart.redraw()), a.inDragMode = a.hasDragged = !1, this.options.fixedDraggable || delete a.fixedPosition);
	      },
	      redrawHalo: function (a) {
	        a && this.halo && this.halo.attr({
	          d: a.haloPath(this.options.states.hover.halo.size)
	        });
	      }
	    };
	    a(d, "load", function () {
	      var c = this,
	        e,
	        d,
	        l;
	      c.container && (e = a(c.container, "mousedown", function (e) {
	        var k = c.hoverPoint;
	        k && k.series && k.series.hasDraggableNodes && k.series.options.draggable && (k.series.onMouseDown(k, e), d = a(c.container, "mousemove", function (b) {
	          return k && k.series && k.series.onMouseMove(k, b);
	        }), l = a(c.container.ownerDocument, "mouseup", function (b) {
	          d();
	          l();
	          return k && k.series && k.series.onMouseUp(k, b);
	        }));
	      }));
	      a(c, "destroy", function () {
	        e();
	      });
	    });
	  });
	  A(d, "Series/Networkgraph/Integrations.js", [d["Core/Globals.js"]], function (d) {
	    d.networkgraphIntegrations = {
	      verlet: {
	        attractiveForceFunction: function (e, d) {
	          return (d - e) / e;
	        },
	        repulsiveForceFunction: function (e, d) {
	          return (d - e) / e * (d > e ? 1 : 0);
	        },
	        barycenter: function () {
	          var e = this.options.gravitationalConstant,
	            d = this.barycenter.xFactor,
	            a = this.barycenter.yFactor;
	          d = (d - (this.box.left + this.box.width) / 2) * e;
	          a = (a - (this.box.top + this.box.height) / 2) * e;
	          this.nodes.forEach(function (c) {
	            c.fixedPosition || (c.plotX -= d / c.mass / c.degree, c.plotY -= a / c.mass / c.degree);
	          });
	        },
	        repulsive: function (e, d, a) {
	          d = d * this.diffTemperature / e.mass / e.degree;
	          e.fixedPosition || (e.plotX += a.x * d, e.plotY += a.y * d);
	        },
	        attractive: function (e, d, a) {
	          var c = e.getMass(),
	            l = -a.x * d * this.diffTemperature;
	          d = -a.y * d * this.diffTemperature;
	          e.fromNode.fixedPosition || (e.fromNode.plotX -= l * c.fromNode / e.fromNode.degree, e.fromNode.plotY -= d * c.fromNode / e.fromNode.degree);
	          e.toNode.fixedPosition || (e.toNode.plotX += l * c.toNode / e.toNode.degree, e.toNode.plotY += d * c.toNode / e.toNode.degree);
	        },
	        integrate: function (e, d) {
	          var a = -e.options.friction,
	            c = e.options.maxSpeed,
	            l = (d.plotX + d.dispX - d.prevX) * a;
	          a *= d.plotY + d.dispY - d.prevY;
	          var p = Math.abs,
	            k = p(l) / (l || 1);
	          p = p(a) / (a || 1);
	          l = k * Math.min(c, Math.abs(l));
	          a = p * Math.min(c, Math.abs(a));
	          d.prevX = d.plotX + d.dispX;
	          d.prevY = d.plotY + d.dispY;
	          d.plotX += l;
	          d.plotY += a;
	          d.temperature = e.vectorLength({
	            x: l,
	            y: a
	          });
	        },
	        getK: function (e) {
	          return Math.pow(e.box.width * e.box.height / e.nodes.length, .5);
	        }
	      },
	      euler: {
	        attractiveForceFunction: function (e, d) {
	          return e * e / d;
	        },
	        repulsiveForceFunction: function (e, d) {
	          return d * d / e;
	        },
	        barycenter: function () {
	          var e = this.options.gravitationalConstant,
	            d = this.barycenter.xFactor,
	            a = this.barycenter.yFactor;
	          this.nodes.forEach(function (c) {
	            if (!c.fixedPosition) {
	              var l = c.getDegree();
	              l *= 1 + l / 2;
	              c.dispX += (d - c.plotX) * e * l / c.degree;
	              c.dispY += (a - c.plotY) * e * l / c.degree;
	            }
	          });
	        },
	        repulsive: function (e, d, a, c) {
	          e.dispX += a.x / c * d / e.degree;
	          e.dispY += a.y / c * d / e.degree;
	        },
	        attractive: function (e, d, a, c) {
	          var l = e.getMass(),
	            p = a.x / c * d;
	          d *= a.y / c;
	          e.fromNode.fixedPosition || (e.fromNode.dispX -= p * l.fromNode / e.fromNode.degree, e.fromNode.dispY -= d * l.fromNode / e.fromNode.degree);
	          e.toNode.fixedPosition || (e.toNode.dispX += p * l.toNode / e.toNode.degree, e.toNode.dispY += d * l.toNode / e.toNode.degree);
	        },
	        integrate: function (e, d) {
	          d.dispX += d.dispX * e.options.friction;
	          d.dispY += d.dispY * e.options.friction;
	          var a = d.temperature = e.vectorLength({
	            x: d.dispX,
	            y: d.dispY
	          });
	          0 !== a && (d.plotX += d.dispX / a * Math.min(Math.abs(d.dispX), e.temperature), d.plotY += d.dispY / a * Math.min(Math.abs(d.dispY), e.temperature));
	        },
	        getK: function (e) {
	          return Math.pow(e.box.width * e.box.height / e.nodes.length, .3);
	        }
	      }
	    };
	  });
	  A(d, "Series/Networkgraph/QuadTree.js", [d["Core/Globals.js"], d["Core/Utilities.js"]], function (d, e) {
	    e = e.extend;
	    var l = d.QuadTreeNode = function (a) {
	      this.box = a;
	      this.boxSize = Math.min(a.width, a.height);
	      this.nodes = [];
	      this.body = this.isInternal = !1;
	      this.isEmpty = !0;
	    };
	    e(l.prototype, {
	      insert: function (a, c) {
	        this.isInternal ? this.nodes[this.getBoxPosition(a)].insert(a, c - 1) : (this.isEmpty = !1, this.body ? c ? (this.isInternal = !0, this.divideBox(), !0 !== this.body && (this.nodes[this.getBoxPosition(this.body)].insert(this.body, c - 1), this.body = !0), this.nodes[this.getBoxPosition(a)].insert(a, c - 1)) : (c = new l({
	          top: a.plotX,
	          left: a.plotY,
	          width: .1,
	          height: .1
	        }), c.body = a, c.isInternal = !1, this.nodes.push(c)) : (this.isInternal = !1, this.body = a));
	      },
	      updateMassAndCenter: function () {
	        var a = 0,
	          c = 0,
	          e = 0;
	        this.isInternal ? (this.nodes.forEach(function (d) {
	          d.isEmpty || (a += d.mass, c += d.plotX * d.mass, e += d.plotY * d.mass);
	        }), c /= a, e /= a) : this.body && (a = this.body.mass, c = this.body.plotX, e = this.body.plotY);
	        this.mass = a;
	        this.plotX = c;
	        this.plotY = e;
	      },
	      divideBox: function () {
	        var a = this.box.width / 2,
	          c = this.box.height / 2;
	        this.nodes[0] = new l({
	          left: this.box.left,
	          top: this.box.top,
	          width: a,
	          height: c
	        });
	        this.nodes[1] = new l({
	          left: this.box.left + a,
	          top: this.box.top,
	          width: a,
	          height: c
	        });
	        this.nodes[2] = new l({
	          left: this.box.left + a,
	          top: this.box.top + c,
	          width: a,
	          height: c
	        });
	        this.nodes[3] = new l({
	          left: this.box.left,
	          top: this.box.top + c,
	          width: a,
	          height: c
	        });
	      },
	      getBoxPosition: function (a) {
	        var c = a.plotY < this.box.top + this.box.height / 2;
	        return a.plotX < this.box.left + this.box.width / 2 ? c ? 0 : 3 : c ? 1 : 2;
	      }
	    });
	    d = d.QuadTree = function (a, c, e, d) {
	      this.box = {
	        left: a,
	        top: c,
	        width: e,
	        height: d
	      };
	      this.maxDepth = 25;
	      this.root = new l(this.box, "0");
	      this.root.isInternal = !0;
	      this.root.isRoot = !0;
	      this.root.divideBox();
	    };
	    e(d.prototype, {
	      insertNodes: function (a) {
	        a.forEach(function (a) {
	          this.root.insert(a, this.maxDepth);
	        }, this);
	      },
	      visitNodeRecursive: function (a, c, e) {
	        var d;
	        a || (a = this.root);
	        a === this.root && c && (d = c(a));
	        !1 !== d && (a.nodes.forEach(function (a) {
	          if (a.isInternal) {
	            c && (d = c(a));
	            if (!1 === d) return;
	            this.visitNodeRecursive(a, c, e);
	          } else a.body && c && c(a.body);
	          e && e(a);
	        }, this), a === this.root && e && e(a));
	      },
	      calculateMassAndCenter: function () {
	        this.visitNodeRecursive(null, null, function (a) {
	          a.updateMassAndCenter();
	        });
	      }
	    });
	  });
	  A(d, "Series/Networkgraph/Layouts.js", [d["Core/Chart/Chart.js"], d["Core/Animation/AnimationUtilities.js"], d["Core/Globals.js"], d["Core/Utilities.js"]], function (d, e, l, a) {
	    var c = e.setAnimation;
	    e = a.addEvent;
	    var t = a.clamp,
	      p = a.defined,
	      k = a.extend,
	      x = a.isFunction,
	      w = a.pick;
	    l.layouts = {
	      "reingold-fruchterman": function () {}
	    };
	    k(l.layouts["reingold-fruchterman"].prototype, {
	      init: function (b) {
	        this.options = b;
	        this.nodes = [];
	        this.links = [];
	        this.series = [];
	        this.box = {
	          x: 0,
	          y: 0,
	          width: 0,
	          height: 0
	        };
	        this.setInitialRendering(!0);
	        this.integration = l.networkgraphIntegrations[b.integration];
	        this.enableSimulation = b.enableSimulation;
	        this.attractiveForce = w(b.attractiveForce, this.integration.attractiveForceFunction);
	        this.repulsiveForce = w(b.repulsiveForce, this.integration.repulsiveForceFunction);
	        this.approximation = b.approximation;
	      },
	      updateSimulation: function (b) {
	        this.enableSimulation = w(b, this.options.enableSimulation);
	      },
	      start: function () {
	        var b = this.series,
	          a = this.options;
	        this.currentStep = 0;
	        this.forces = b[0] && b[0].forces || [];
	        this.chart = b[0] && b[0].chart;
	        this.initialRendering && (this.initPositions(), b.forEach(function (b) {
	          b.finishedAnimating = !0;
	          b.render();
	        }));
	        this.setK();
	        this.resetSimulation(a);
	        this.enableSimulation && this.step();
	      },
	      step: function () {
	        var b = this,
	          a = this.series;
	        b.currentStep++;
	        "barnes-hut" === b.approximation && (b.createQuadTree(), b.quadTree.calculateMassAndCenter());
	        b.forces.forEach(function (a) {
	          b[a + "Forces"](b.temperature);
	        });
	        b.applyLimits(b.temperature);
	        b.temperature = b.coolDown(b.startTemperature, b.diffTemperature, b.currentStep);
	        b.prevSystemTemperature = b.systemTemperature;
	        b.systemTemperature = b.getSystemTemperature();
	        b.enableSimulation && (a.forEach(function (b) {
	          b.chart && b.render();
	        }), b.maxIterations-- && isFinite(b.temperature) && !b.isStable() ? (b.simulation && l.win.cancelAnimationFrame(b.simulation), b.simulation = l.win.requestAnimationFrame(function () {
	          b.step();
	        })) : b.simulation = !1);
	      },
	      stop: function () {
	        this.simulation && l.win.cancelAnimationFrame(this.simulation);
	      },
	      setArea: function (b, a, c, e) {
	        this.box = {
	          left: b,
	          top: a,
	          width: c,
	          height: e
	        };
	      },
	      setK: function () {
	        this.k = this.options.linkLength || this.integration.getK(this);
	      },
	      addElementsToCollection: function (b, a) {
	        b.forEach(function (b) {
	          -1 === a.indexOf(b) && a.push(b);
	        });
	      },
	      removeElementFromCollection: function (b, a) {
	        b = a.indexOf(b);
	        -1 !== b && a.splice(b, 1);
	      },
	      clear: function () {
	        this.nodes.length = 0;
	        this.links.length = 0;
	        this.series.length = 0;
	        this.resetSimulation();
	      },
	      resetSimulation: function () {
	        this.forcedStop = !1;
	        this.systemTemperature = 0;
	        this.setMaxIterations();
	        this.setTemperature();
	        this.setDiffTemperature();
	      },
	      restartSimulation: function () {
	        this.simulation ? this.resetSimulation() : (this.setInitialRendering(!1), this.enableSimulation ? this.start() : this.setMaxIterations(1), this.chart && this.chart.redraw(), this.setInitialRendering(!0));
	      },
	      setMaxIterations: function (b) {
	        this.maxIterations = w(b, this.options.maxIterations);
	      },
	      setTemperature: function () {
	        this.temperature = this.startTemperature = Math.sqrt(this.nodes.length);
	      },
	      setDiffTemperature: function () {
	        this.diffTemperature = this.startTemperature / (this.options.maxIterations + 1);
	      },
	      setInitialRendering: function (b) {
	        this.initialRendering = b;
	      },
	      createQuadTree: function () {
	        this.quadTree = new l.QuadTree(this.box.left, this.box.top, this.box.width, this.box.height);
	        this.quadTree.insertNodes(this.nodes);
	      },
	      initPositions: function () {
	        var b = this.options.initialPositions;
	        x(b) ? (b.call(this), this.nodes.forEach(function (b) {
	          p(b.prevX) || (b.prevX = b.plotX);
	          p(b.prevY) || (b.prevY = b.plotY);
	          b.dispX = 0;
	          b.dispY = 0;
	        })) : "circle" === b ? this.setCircularPositions() : this.setRandomPositions();
	      },
	      setCircularPositions: function () {
	        function b(a) {
	          a.linksFrom.forEach(function (a) {
	            l[a.toNode.id] || (l[a.toNode.id] = !0, k.push(a.toNode), b(a.toNode));
	          });
	        }
	        var a = this.box,
	          c = this.nodes,
	          e = 2 * Math.PI / (c.length + 1),
	          d = c.filter(function (b) {
	            return 0 === b.linksTo.length;
	          }),
	          k = [],
	          l = {},
	          p = this.options.initialPositionRadius;
	        d.forEach(function (a) {
	          k.push(a);
	          b(a);
	        });
	        k.length ? c.forEach(function (b) {
	          -1 === k.indexOf(b) && k.push(b);
	        }) : k = c;
	        k.forEach(function (b, c) {
	          b.plotX = b.prevX = w(b.plotX, a.width / 2 + p * Math.cos(c * e));
	          b.plotY = b.prevY = w(b.plotY, a.height / 2 + p * Math.sin(c * e));
	          b.dispX = 0;
	          b.dispY = 0;
	        });
	      },
	      setRandomPositions: function () {
	        function b(b) {
	          b = b * b / Math.PI;
	          return b -= Math.floor(b);
	        }
	        var a = this.box,
	          c = this.nodes,
	          e = c.length + 1;
	        c.forEach(function (c, g) {
	          c.plotX = c.prevX = w(c.plotX, a.width * b(g));
	          c.plotY = c.prevY = w(c.plotY, a.height * b(e + g));
	          c.dispX = 0;
	          c.dispY = 0;
	        });
	      },
	      force: function (b) {
	        this.integration[b].apply(this, Array.prototype.slice.call(arguments, 1));
	      },
	      barycenterForces: function () {
	        this.getBarycenter();
	        this.force("barycenter");
	      },
	      getBarycenter: function () {
	        var b = 0,
	          a = 0,
	          c = 0;
	        this.nodes.forEach(function (g) {
	          a += g.plotX * g.mass;
	          c += g.plotY * g.mass;
	          b += g.mass;
	        });
	        return this.barycenter = {
	          x: a,
	          y: c,
	          xFactor: a / b,
	          yFactor: c / b
	        };
	      },
	      barnesHutApproximation: function (b, a) {
	        var c = this.getDistXY(b, a),
	          g = this.vectorLength(c);
	        if (b !== a && 0 !== g) if (a.isInternal) {
	          if (a.boxSize / g < this.options.theta && 0 !== g) {
	            var e = this.repulsiveForce(g, this.k);
	            this.force("repulsive", b, e * a.mass, c, g);
	            var d = !1;
	          } else d = !0;
	        } else e = this.repulsiveForce(g, this.k), this.force("repulsive", b, e * a.mass, c, g);
	        return d;
	      },
	      repulsiveForces: function () {
	        var b = this;
	        "barnes-hut" === b.approximation ? b.nodes.forEach(function (a) {
	          b.quadTree.visitNodeRecursive(null, function (c) {
	            return b.barnesHutApproximation(a, c);
	          });
	        }) : b.nodes.forEach(function (a) {
	          b.nodes.forEach(function (c) {
	            if (a !== c && !a.fixedPosition) {
	              var g = b.getDistXY(a, c);
	              var e = b.vectorLength(g);
	              if (0 !== e) {
	                var d = b.repulsiveForce(e, b.k);
	                b.force("repulsive", a, d * c.mass, g, e);
	              }
	            }
	          });
	        });
	      },
	      attractiveForces: function () {
	        var b = this,
	          a,
	          c,
	          e;
	        b.links.forEach(function (g) {
	          g.fromNode && g.toNode && (a = b.getDistXY(g.fromNode, g.toNode), c = b.vectorLength(a), 0 !== c && (e = b.attractiveForce(c, b.k), b.force("attractive", g, e, a, c)));
	        });
	      },
	      applyLimits: function () {
	        var b = this;
	        b.nodes.forEach(function (a) {
	          a.fixedPosition || (b.integration.integrate(b, a), b.applyLimitBox(a, b.box), a.dispX = 0, a.dispY = 0);
	        });
	      },
	      applyLimitBox: function (b, a) {
	        var c = b.radius;
	        b.plotX = t(b.plotX, a.left + c, a.width - c);
	        b.plotY = t(b.plotY, a.top + c, a.height - c);
	      },
	      coolDown: function (b, a, c) {
	        return b - a * c;
	      },
	      isStable: function () {
	        return .00001 > Math.abs(this.systemTemperature - this.prevSystemTemperature) || 0 >= this.temperature;
	      },
	      getSystemTemperature: function () {
	        return this.nodes.reduce(function (b, a) {
	          return b + a.temperature;
	        }, 0);
	      },
	      vectorLength: function (b) {
	        return Math.sqrt(b.x * b.x + b.y * b.y);
	      },
	      getDistR: function (b, a) {
	        b = this.getDistXY(b, a);
	        return this.vectorLength(b);
	      },
	      getDistXY: function (b, a) {
	        var c = b.plotX - a.plotX;
	        b = b.plotY - a.plotY;
	        return {
	          x: c,
	          y: b,
	          absX: Math.abs(c),
	          absY: Math.abs(b)
	        };
	      }
	    });
	    e(d, "predraw", function () {
	      this.graphLayoutsLookup && this.graphLayoutsLookup.forEach(function (b) {
	        b.stop();
	      });
	    });
	    e(d, "render", function () {
	      function b(b) {
	        b.maxIterations-- && isFinite(b.temperature) && !b.isStable() && !b.enableSimulation && (b.beforeStep && b.beforeStep(), b.step(), e = !1, a = !0);
	      }
	      var a = !1;
	      if (this.graphLayoutsLookup) {
	        c(!1, this);
	        for (this.graphLayoutsLookup.forEach(function (b) {
	          b.start();
	        }); !e;) {
	          var e = !0;
	          this.graphLayoutsLookup.forEach(b);
	        }
	        a && this.series.forEach(function (b) {
	          b && b.layout && b.render();
	        });
	      }
	    });
	    e(d, "beforePrint", function () {
	      this.graphLayoutsLookup && (this.graphLayoutsLookup.forEach(function (b) {
	        b.updateSimulation(!1);
	      }), this.redraw());
	    });
	    e(d, "afterPrint", function () {
	      this.graphLayoutsLookup && this.graphLayoutsLookup.forEach(function (b) {
	        b.updateSimulation();
	      });
	      this.redraw();
	    });
	  });
	  A(d, "Series/PackedBubble/PackedBubbleComposition.js", [d["Core/Chart/Chart.js"], d["Core/Globals.js"], d["Core/Utilities.js"]], function (d, e, l) {
	    var a = e.layouts["reingold-fruchterman"],
	      c = l.addEvent,
	      t = l.extendClass,
	      p = l.pick;
	    d.prototype.getSelectedParentNodes = function () {
	      var a = [];
	      this.series.forEach(function (c) {
	        c.parentNode && c.parentNode.selected && a.push(c.parentNode);
	      });
	      return a;
	    };
	    e.networkgraphIntegrations.packedbubble = {
	      repulsiveForceFunction: function (a, c, e, b) {
	        return Math.min(a, (e.marker.radius + b.marker.radius) / 2);
	      },
	      barycenter: function () {
	        var a = this,
	          c = a.options.gravitationalConstant,
	          e = a.box,
	          b = a.nodes,
	          d,
	          m;
	        b.forEach(function (g) {
	          a.options.splitSeries && !g.isParentNode ? (d = g.series.parentNode.plotX, m = g.series.parentNode.plotY) : (d = e.width / 2, m = e.height / 2);
	          g.fixedPosition || (g.plotX -= (g.plotX - d) * c / (g.mass * Math.sqrt(b.length)), g.plotY -= (g.plotY - m) * c / (g.mass * Math.sqrt(b.length)));
	        });
	      },
	      repulsive: function (a, c, e, b) {
	        var g = c * this.diffTemperature / a.mass / a.degree;
	        c = e.x * g;
	        e = e.y * g;
	        a.fixedPosition || (a.plotX += c, a.plotY += e);
	        b.fixedPosition || (b.plotX -= c, b.plotY -= e);
	      },
	      integrate: e.networkgraphIntegrations.verlet.integrate,
	      getK: e.noop
	    };
	    e.layouts.packedbubble = t(a, {
	      beforeStep: function () {
	        this.options.marker && this.series.forEach(function (a) {
	          a && a.calculateParentRadius();
	        });
	      },
	      isStable: function () {
	        var a = Math.abs(this.prevSystemTemperature - this.systemTemperature);
	        return 1 > Math.abs(10 * this.systemTemperature / Math.sqrt(this.nodes.length)) && .00001 > a || 0 >= this.temperature;
	      },
	      setCircularPositions: function () {
	        var a = this,
	          c = a.box,
	          e = a.nodes,
	          b = 2 * Math.PI / (e.length + 1),
	          g,
	          d,
	          n = a.options.initialPositionRadius;
	        e.forEach(function (e, k) {
	          a.options.splitSeries && !e.isParentNode ? (g = e.series.parentNode.plotX, d = e.series.parentNode.plotY) : (g = c.width / 2, d = c.height / 2);
	          e.plotX = e.prevX = p(e.plotX, g + n * Math.cos(e.index || k * b));
	          e.plotY = e.prevY = p(e.plotY, d + n * Math.sin(e.index || k * b));
	          e.dispX = 0;
	          e.dispY = 0;
	        });
	      },
	      repulsiveForces: function () {
	        var a = this,
	          c,
	          e,
	          b,
	          g = a.options.bubblePadding;
	        a.nodes.forEach(function (d) {
	          d.degree = d.mass;
	          d.neighbours = 0;
	          a.nodes.forEach(function (k) {
	            c = 0;
	            d === k || d.fixedPosition || !a.options.seriesInteraction && d.series !== k.series || (b = a.getDistXY(d, k), e = a.vectorLength(b) - (d.marker.radius + k.marker.radius + g), 0 > e && (d.degree += .01, d.neighbours++, c = a.repulsiveForce(-e / Math.sqrt(d.neighbours), a.k, d, k)), a.force("repulsive", d, c * k.mass, b, k, e));
	          });
	        });
	      },
	      applyLimitBox: function (c) {
	        if (this.options.splitSeries && !c.isParentNode && this.options.parentNodeLimit) {
	          var e = this.getDistXY(c, c.series.parentNode);
	          var d = c.series.parentNodeRadius - c.marker.radius - this.vectorLength(e);
	          0 > d && d > -2 * c.marker.radius && (c.plotX -= .01 * e.x, c.plotY -= .01 * e.y);
	        }
	        a.prototype.applyLimitBox.apply(this, arguments);
	      }
	    });
	    c(d, "beforeRedraw", function () {
	      this.allDataPoints && delete this.allDataPoints;
	    });
	  });
	  A(d, "Series/PackedBubble/PackedBubbleSeries.js", [d["Core/Color/Color.js"], d["Core/Globals.js"], d["Series/PackedBubble/PackedBubblePoint.js"], d["Core/Series/SeriesRegistry.js"], d["Core/Utilities.js"]], function (d, e, l, a, c) {
	    var t = this && this.__extends || function () {
	        var a = function (b, h) {
	          a = Object.setPrototypeOf || {
	            __proto__: []
	          } instanceof Array && function (a, b) {
	            a.__proto__ = b;
	          } || function (a, b) {
	            for (var h in b) b.hasOwnProperty(h) && (a[h] = b[h]);
	          };
	          return a(b, h);
	        };
	        return function (b, h) {
	          function f() {
	            this.constructor = b;
	          }
	          a(b, h);
	          b.prototype = null === h ? Object.create(h) : (f.prototype = h.prototype, new f());
	        };
	      }(),
	      p = d.parse,
	      k = a.series,
	      x = a.seriesTypes.bubble,
	      w = c.addEvent,
	      b = c.clamp,
	      g = c.defined,
	      m = c.extend,
	      n = c.fireEvent,
	      q = c.isArray,
	      H = c.isNumber,
	      A = c.merge,
	      I = c.pick,
	      y = e.dragNodesMixin;
	    d = function (a) {
	      function f() {
	        var b = null !== a && a.apply(this, arguments) || this;
	        b.chart = void 0;
	        b.data = void 0;
	        b.layout = void 0;
	        b.options = void 0;
	        b.points = void 0;
	        b.xData = void 0;
	        return b;
	      }
	      t(f, a);
	      f.prototype.accumulateAllPoints = function (a) {
	        var b = a.chart,
	          h = [],
	          f,
	          c;
	        for (f = 0; f < b.series.length; f++) if (a = b.series[f], a.is("packedbubble") && a.visible || !b.options.chart.ignoreHiddenSeries) for (c = 0; c < a.yData.length; c++) h.push([null, null, a.yData[c], a.index, c, {
	          id: c,
	          marker: {
	            radius: 0
	          }
	        }]);
	        return h;
	      };
	      f.prototype.addLayout = function () {
	        var a = this.options.layoutAlgorithm,
	          b = this.chart.graphLayoutsStorage,
	          f = this.chart.graphLayoutsLookup,
	          c = this.chart.options.chart;
	        b || (this.chart.graphLayoutsStorage = b = {}, this.chart.graphLayoutsLookup = f = []);
	        var d = b[a.type];
	        d || (a.enableSimulation = g(c.forExport) ? !c.forExport : a.enableSimulation, b[a.type] = d = new e.layouts[a.type](), d.init(a), f.splice(d.index, 0, d));
	        this.layout = d;
	        this.points.forEach(function (a) {
	          a.mass = 2;
	          a.degree = 1;
	          a.collisionNmb = 1;
	        });
	        d.setArea(0, 0, this.chart.plotWidth, this.chart.plotHeight);
	        d.addElementsToCollection([this], d.series);
	        d.addElementsToCollection(this.points, d.nodes);
	      };
	      f.prototype.addSeriesLayout = function () {
	        var a = this.options.layoutAlgorithm,
	          b = this.chart.graphLayoutsStorage,
	          f = this.chart.graphLayoutsLookup,
	          c = A(a, a.parentNodeOptions, {
	            enableSimulation: this.layout.options.enableSimulation
	          });
	        var d = b[a.type + "-series"];
	        d || (b[a.type + "-series"] = d = new e.layouts[a.type](), d.init(c), f.splice(d.index, 0, d));
	        this.parentNodeLayout = d;
	        this.createParentNodes();
	      };
	      f.prototype.calculateParentRadius = function () {
	        var a = this.seriesBox();
	        this.parentNodeRadius = b(Math.sqrt(2 * this.parentNodeMass / Math.PI) + 20, 20, a ? Math.max(Math.sqrt(Math.pow(a.width, 2) + Math.pow(a.height, 2)) / 2 + 20, 20) : Math.sqrt(2 * this.parentNodeMass / Math.PI) + 20);
	        this.parentNode && (this.parentNode.marker.radius = this.parentNode.radius = this.parentNodeRadius);
	      };
	      f.prototype.calculateZExtremes = function () {
	        var a = this.options.zMin,
	          b = this.options.zMax,
	          f = Infinity,
	          c = -Infinity;
	        if (a && b) return [a, b];
	        this.chart.series.forEach(function (a) {
	          a.yData.forEach(function (a) {
	            g(a) && (a > c && (c = a), a < f && (f = a));
	          });
	        });
	        a = I(a, f);
	        b = I(b, c);
	        return [a, b];
	      };
	      f.prototype.checkOverlap = function (a, b) {
	        var h = a[0] - b[0],
	          f = a[1] - b[1];
	        return -.001 > Math.sqrt(h * h + f * f) - Math.abs(a[2] + b[2]);
	      };
	      f.prototype.createParentNodes = function () {
	        var a = this,
	          b = a.chart,
	          f = a.parentNodeLayout,
	          c,
	          e = a.parentNode,
	          d = a.pointClass,
	          g = a.layout.options,
	          k = {
	            radius: a.parentNodeRadius,
	            lineColor: a.color,
	            fillColor: p(a.color).brighten(.4).get()
	          };
	        g.parentNodeOptions && (k = A(g.parentNodeOptions.marker || {}, k));
	        a.parentNodeMass = 0;
	        a.points.forEach(function (b) {
	          a.parentNodeMass += Math.PI * Math.pow(b.marker.radius, 2);
	        });
	        a.calculateParentRadius();
	        f.nodes.forEach(function (b) {
	          b.seriesIndex === a.index && (c = !0);
	        });
	        f.setArea(0, 0, b.plotWidth, b.plotHeight);
	        c || (e || (e = new d().init(this, {
	          mass: a.parentNodeRadius / 2,
	          marker: k,
	          dataLabels: {
	            inside: !1
	          },
	          states: {
	            normal: {
	              marker: k
	            },
	            hover: {
	              marker: k
	            }
	          },
	          dataLabelOnNull: !0,
	          degree: a.parentNodeRadius,
	          isParentNode: !0,
	          seriesIndex: a.index
	        })), a.parentNode && (e.plotX = a.parentNode.plotX, e.plotY = a.parentNode.plotY), a.parentNode = e, f.addElementsToCollection([a], f.series), f.addElementsToCollection([e], f.nodes));
	      };
	      f.prototype.deferLayout = function () {
	        var a = this.options.layoutAlgorithm;
	        this.visible && (this.addLayout(), a.splitSeries && this.addSeriesLayout());
	      };
	      f.prototype.destroy = function () {
	        this.chart.graphLayoutsLookup && this.chart.graphLayoutsLookup.forEach(function (a) {
	          a.removeElementFromCollection(this, a.series);
	        }, this);
	        this.parentNode && this.parentNodeLayout && (this.parentNodeLayout.removeElementFromCollection(this.parentNode, this.parentNodeLayout.nodes), this.parentNode.dataLabel && (this.parentNode.dataLabel = this.parentNode.dataLabel.destroy()));
	        k.prototype.destroy.apply(this, arguments);
	      };
	      f.prototype.drawDataLabels = function () {
	        var a = this.options.dataLabels.textPath,
	          b = this.points;
	        k.prototype.drawDataLabels.apply(this, arguments);
	        this.parentNode && (this.parentNode.formatPrefix = "parentNode", this.points = [this.parentNode], this.options.dataLabels.textPath = this.options.dataLabels.parentNodeTextPath, k.prototype.drawDataLabels.apply(this, arguments), this.points = b, this.options.dataLabels.textPath = a);
	      };
	      f.prototype.drawGraph = function () {
	        if (this.layout && this.layout.options.splitSeries) {
	          var a = this.chart;
	          var b = this.layout.options.parentNodeOptions.marker;
	          var f = {
	            fill: b.fillColor || p(this.color).brighten(.4).get(),
	            opacity: b.fillOpacity,
	            stroke: b.lineColor || this.color,
	            "stroke-width": I(b.lineWidth, this.options.lineWidth)
	          };
	          this.parentNodesGroup || (this.parentNodesGroup = this.plotGroup("parentNodesGroup", "parentNode", this.visible ? "inherit" : "hidden", .1, a.seriesGroup), this.group.attr({
	            zIndex: 2
	          }));
	          this.calculateParentRadius();
	          b = A({
	            x: this.parentNode.plotX - this.parentNodeRadius,
	            y: this.parentNode.plotY - this.parentNodeRadius,
	            width: 2 * this.parentNodeRadius,
	            height: 2 * this.parentNodeRadius
	          }, f);
	          this.parentNode.graphic || (this.graph = this.parentNode.graphic = a.renderer.symbol(f.symbol).add(this.parentNodesGroup));
	          this.parentNode.graphic.attr(b);
	        }
	      };
	      f.prototype.drawTracker = function () {
	        var b = this.parentNode;
	        a.prototype.drawTracker.call(this);
	        if (b) {
	          var f = q(b.dataLabels) ? b.dataLabels : b.dataLabel ? [b.dataLabel] : [];
	          b.graphic && (b.graphic.element.point = b);
	          f.forEach(function (a) {
	            a.div ? a.div.point = b : a.element.point = b;
	          });
	        }
	      };
	      f.prototype.getPointRadius = function () {
	        var a = this,
	          f = a.chart,
	          c = a.options,
	          e = c.useSimulation,
	          d = Math.min(f.plotWidth, f.plotHeight),
	          g = {},
	          k = [],
	          l = f.allDataPoints,
	          n,
	          m,
	          p,
	          z;
	        ["minSize", "maxSize"].forEach(function (a) {
	          var b = parseInt(c[a], 10),
	            f = /%$/.test(c[a]);
	          g[a] = f ? d * b / 100 : b * Math.sqrt(l.length);
	        });
	        f.minRadius = n = g.minSize / Math.sqrt(l.length);
	        f.maxRadius = m = g.maxSize / Math.sqrt(l.length);
	        var q = e ? a.calculateZExtremes() : [n, m];
	        (l || []).forEach(function (f, h) {
	          p = e ? b(f[2], q[0], q[1]) : f[2];
	          z = a.getRadius(q[0], q[1], n, m, p);
	          0 === z && (z = null);
	          l[h][2] = z;
	          k.push(z);
	        });
	        a.radii = k;
	      };
	      f.prototype.init = function () {
	        k.prototype.init.apply(this, arguments);
	        this.eventsToUnbind.push(w(this, "updatedData", function () {
	          this.chart.series.forEach(function (a) {
	            a.type === this.type && (a.isDirty = !0);
	          }, this);
	        }));
	        return this;
	      };
	      f.prototype.onMouseUp = function (a) {
	        if (a.fixedPosition && !a.removed) {
	          var b,
	            f,
	            h = this.layout,
	            c = this.parentNodeLayout;
	          c && h.options.dragBetweenSeries && c.nodes.forEach(function (c) {
	            a && a.marker && c !== a.series.parentNode && (b = h.getDistXY(a, c), f = h.vectorLength(b) - c.marker.radius - a.marker.radius, 0 > f && (c.series.addPoint(A(a.options, {
	              plotX: a.plotX,
	              plotY: a.plotY
	            }), !1), h.removeElementFromCollection(a, h.nodes), a.remove()));
	          });
	          y.onMouseUp.apply(this, arguments);
	        }
	      };
	      f.prototype.placeBubbles = function (a) {
	        var b = this.checkOverlap,
	          f = this.positionBubble,
	          c = [],
	          h = 1,
	          e = 0,
	          d = 0;
	        var g = [];
	        var k;
	        a = a.sort(function (a, b) {
	          return b[2] - a[2];
	        });
	        if (a.length) {
	          c.push([[0, 0, a[0][2], a[0][3], a[0][4]]]);
	          if (1 < a.length) for (c.push([[0, 0 - a[1][2] - a[0][2], a[1][2], a[1][3], a[1][4]]]), k = 2; k < a.length; k++) a[k][2] = a[k][2] || 1, g = f(c[h][e], c[h - 1][d], a[k]), b(g, c[h][0]) ? (c.push([]), d = 0, c[h + 1].push(f(c[h][e], c[h][0], a[k])), h++, e = 0) : 1 < h && c[h - 1][d + 1] && b(g, c[h - 1][d + 1]) ? (d++, c[h].push(f(c[h][e], c[h - 1][d], a[k])), e++) : (e++, c[h].push(g));
	          this.chart.stages = c;
	          this.chart.rawPositions = [].concat.apply([], c);
	          this.resizeRadius();
	          g = this.chart.rawPositions;
	        }
	        return g;
	      };
	      f.prototype.pointAttribs = function (a, b) {
	        var f = this.options,
	          c = f.marker;
	        a && a.isParentNode && f.layoutAlgorithm && f.layoutAlgorithm.parentNodeOptions && (c = f.layoutAlgorithm.parentNodeOptions.marker);
	        f = c.fillOpacity;
	        a = k.prototype.pointAttribs.call(this, a, b);
	        1 !== f && (a["fill-opacity"] = f);
	        return a;
	      };
	      f.prototype.positionBubble = function (a, b, f) {
	        var c = Math.sqrt,
	          h = Math.asin,
	          e = Math.acos,
	          d = Math.pow,
	          g = Math.abs;
	        c = c(d(a[0] - b[0], 2) + d(a[1] - b[1], 2));
	        e = e((d(c, 2) + d(f[2] + b[2], 2) - d(f[2] + a[2], 2)) / (2 * (f[2] + b[2]) * c));
	        h = h(g(a[0] - b[0]) / c);
	        a = (0 > a[1] - b[1] ? 0 : Math.PI) + e + h * (0 > (a[0] - b[0]) * (a[1] - b[1]) ? 1 : -1);
	        return [b[0] + (b[2] + f[2]) * Math.sin(a), b[1] - (b[2] + f[2]) * Math.cos(a), f[2], f[3], f[4]];
	      };
	      f.prototype.render = function () {
	        var a = [];
	        k.prototype.render.apply(this, arguments);
	        this.options.dataLabels.allowOverlap || (this.data.forEach(function (b) {
	          q(b.dataLabels) && b.dataLabels.forEach(function (b) {
	            a.push(b);
	          });
	        }), this.options.useSimulation && this.chart.hideOverlappingLabels(a));
	      };
	      f.prototype.resizeRadius = function () {
	        var a = this.chart,
	          b = a.rawPositions,
	          f = Math.min,
	          c = Math.max,
	          e = a.plotLeft,
	          d = a.plotTop,
	          g = a.plotHeight,
	          k = a.plotWidth,
	          l,
	          n,
	          m;
	        var p = l = Number.POSITIVE_INFINITY;
	        var z = n = Number.NEGATIVE_INFINITY;
	        for (m = 0; m < b.length; m++) {
	          var q = b[m][2];
	          p = f(p, b[m][0] - q);
	          z = c(z, b[m][0] + q);
	          l = f(l, b[m][1] - q);
	          n = c(n, b[m][1] + q);
	        }
	        m = [z - p, n - l];
	        f = f.apply([], [(k - e) / m[0], (g - d) / m[1]]);
	        if (1e-10 < Math.abs(f - 1)) {
	          for (m = 0; m < b.length; m++) b[m][2] *= f;
	          this.placeBubbles(b);
	        } else a.diffY = g / 2 + d - l - (n - l) / 2, a.diffX = k / 2 + e - p - (z - p) / 2;
	      };
	      f.prototype.seriesBox = function () {
	        var a = this.chart,
	          b = Math.max,
	          f = Math.min,
	          c,
	          e = [a.plotLeft, a.plotLeft + a.plotWidth, a.plotTop, a.plotTop + a.plotHeight];
	        this.data.forEach(function (a) {
	          g(a.plotX) && g(a.plotY) && a.marker.radius && (c = a.marker.radius, e[0] = f(e[0], a.plotX - c), e[1] = b(e[1], a.plotX + c), e[2] = f(e[2], a.plotY - c), e[3] = b(e[3], a.plotY + c));
	        });
	        return H(e.width / e.height) ? e : null;
	      };
	      f.prototype.setVisible = function () {
	        var a = this;
	        k.prototype.setVisible.apply(a, arguments);
	        a.parentNodeLayout && a.graph ? a.visible ? (a.graph.show(), a.parentNode.dataLabel && a.parentNode.dataLabel.show()) : (a.graph.hide(), a.parentNodeLayout.removeElementFromCollection(a.parentNode, a.parentNodeLayout.nodes), a.parentNode.dataLabel && a.parentNode.dataLabel.hide()) : a.layout && (a.visible ? a.layout.addElementsToCollection(a.points, a.layout.nodes) : a.points.forEach(function (b) {
	          a.layout.removeElementFromCollection(b, a.layout.nodes);
	        }));
	      };
	      f.prototype.translate = function () {
	        var a = this.chart,
	          b = this.data,
	          f = this.index,
	          c,
	          e = this.options.useSimulation;
	        this.processedXData = this.xData;
	        this.generatePoints();
	        g(a.allDataPoints) || (a.allDataPoints = this.accumulateAllPoints(this), this.getPointRadius());
	        if (e) var d = a.allDataPoints;else d = this.placeBubbles(a.allDataPoints), this.options.draggable = !1;
	        for (c = 0; c < d.length; c++) if (d[c][3] === f) {
	          var k = b[d[c][4]];
	          var l = I(d[c][2], void 0);
	          e || (k.plotX = d[c][0] - a.plotLeft + a.diffX, k.plotY = d[c][1] - a.plotTop + a.diffY);
	          H(l) && (k.marker = m(k.marker, {
	            radius: l,
	            width: 2 * l,
	            height: 2 * l
	          }), k.radius = l);
	        }
	        e && this.deferLayout();
	        n(this, "afterTranslate");
	      };
	      f.defaultOptions = A(x.defaultOptions, {
	        minSize: "10%",
	        maxSize: "50%",
	        sizeBy: "area",
	        zoneAxis: "y",
	        crisp: !1,
	        tooltip: {
	          pointFormat: "Value: {point.value}"
	        },
	        draggable: !0,
	        useSimulation: !0,
	        parentNode: {
	          allowPointSelect: !1
	        },
	        dataLabels: {
	          formatter: function () {
	            var a = this.series.chart.numberFormatter,
	              b = this.point.value;
	            return H(b) ? a(b, -1) : "";
	          },
	          parentNodeFormatter: function () {
	            return this.name;
	          },
	          parentNodeTextPath: {
	            enabled: !0
	          },
	          padding: 0,
	          style: {
	            transition: "opacity 2000ms"
	          }
	        },
	        layoutAlgorithm: {
	          initialPositions: "circle",
	          initialPositionRadius: 20,
	          bubblePadding: 5,
	          parentNodeLimit: !1,
	          seriesInteraction: !0,
	          dragBetweenSeries: !1,
	          parentNodeOptions: {
	            maxIterations: 400,
	            gravitationalConstant: .03,
	            maxSpeed: 50,
	            initialPositionRadius: 100,
	            seriesInteraction: !0,
	            marker: {
	              fillColor: null,
	              fillOpacity: 1,
	              lineWidth: null,
	              lineColor: null,
	              symbol: "circle"
	            }
	          },
	          enableSimulation: !0,
	          type: "packedbubble",
	          integration: "packedbubble",
	          maxIterations: 1E3,
	          splitSeries: !1,
	          maxSpeed: 5,
	          gravitationalConstant: .01,
	          friction: -.981
	        }
	      });
	      return f;
	    }(x);
	    m(d.prototype, {
	      alignDataLabel: k.prototype.alignDataLabel,
	      axisTypes: [],
	      directTouch: !0,
	      forces: ["barycenter", "repulsive"],
	      hasDraggableNodes: !0,
	      isCartesian: !1,
	      noSharedTooltip: !0,
	      onMouseDown: y.onMouseDown,
	      onMouseMove: y.onMouseMove,
	      pointArrayMap: ["value"],
	      pointClass: l,
	      pointValKey: "value",
	      redrawHalo: y.redrawHalo,
	      requireSorting: !1,
	      searchPoint: e.noop,
	      trackerGroups: ["group", "dataLabelsGroup", "parentNodesGroup"]
	    });
	    a.registerSeriesType("packedbubble", d);
	    return d;
	  });
	  A(d, "Series/Polygon/PolygonSeries.js", [d["Core/Globals.js"], d["Core/Legend/LegendSymbol.js"], d["Core/Series/SeriesRegistry.js"], d["Core/Utilities.js"]], function (d, e, l, a) {
	    var c = this && this.__extends || function () {
	      var a = function (b, c) {
	        a = Object.setPrototypeOf || {
	          __proto__: []
	        } instanceof Array && function (a, b) {
	          a.__proto__ = b;
	        } || function (a, b) {
	          for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);
	        };
	        return a(b, c);
	      };
	      return function (b, c) {
	        function e() {
	          this.constructor = b;
	        }
	        a(b, c);
	        b.prototype = null === c ? Object.create(c) : (e.prototype = c.prototype, new e());
	      };
	    }();
	    d = d.noop;
	    var t = l.series,
	      p = l.seriesTypes,
	      k = p.area,
	      x = p.line,
	      w = p.scatter;
	    p = a.extend;
	    var b = a.merge;
	    a = function (a) {
	      function e() {
	        var b = null !== a && a.apply(this, arguments) || this;
	        b.data = void 0;
	        b.options = void 0;
	        b.points = void 0;
	        return b;
	      }
	      c(e, a);
	      e.prototype.getGraphPath = function () {
	        for (var a = x.prototype.getGraphPath.call(this), b = a.length + 1; b--;) (b === a.length || "M" === a[b][0]) && 0 < b && a.splice(b, 0, ["Z"]);
	        return this.areaPath = a;
	      };
	      e.prototype.drawGraph = function () {
	        this.options.fillColor = this.color;
	        k.prototype.drawGraph.call(this);
	      };
	      e.defaultOptions = b(w.defaultOptions, {
	        marker: {
	          enabled: !1,
	          states: {
	            hover: {
	              enabled: !1
	            }
	          }
	        },
	        stickyTracking: !1,
	        tooltip: {
	          followPointer: !0,
	          pointFormat: ""
	        },
	        trackByArea: !0
	      });
	      return e;
	    }(w);
	    p(a.prototype, {
	      type: "polygon",
	      drawLegendSymbol: e.drawRectangle,
	      drawTracker: t.prototype.drawTracker,
	      setStackedPoints: d
	    });
	    l.registerSeriesType("polygon", a);
	    return a;
	  });
	  A(d, "Core/Axis/WaterfallAxis.js", [d["Extensions/Stacking.js"], d["Core/Utilities.js"]], function (d, e) {
	    var l = e.addEvent,
	      a = e.objectEach,
	      c;
	    (function (c) {
	      function e() {
	        var a = this.waterfall.stacks;
	        a && (a.changed = !1, delete a.alreadyChanged);
	      }
	      function k() {
	        var a = this.options.stackLabels;
	        a && a.enabled && this.waterfall.stacks && this.waterfall.renderStackTotals();
	      }
	      function x() {
	        for (var a = this.axes, b = this.series, c = b.length; c--;) b[c].options.stacking && (a.forEach(function (a) {
	          a.isXAxis || (a.waterfall.stacks.changed = !0);
	        }), c = 0);
	      }
	      function w() {
	        this.waterfall || (this.waterfall = new b(this));
	      }
	      var b = function () {
	        function b(a) {
	          this.axis = a;
	          this.stacks = {
	            changed: !1
	          };
	        }
	        b.prototype.renderStackTotals = function () {
	          var b = this.axis,
	            c = b.waterfall.stacks,
	            e = b.stacking && b.stacking.stackTotalGroup,
	            g = new d(b, b.options.stackLabels, !1, 0, void 0);
	          this.dummyStackItem = g;
	          a(c, function (b) {
	            a(b, function (a) {
	              g.total = a.stackTotal;
	              a.label && (g.label = a.label);
	              d.prototype.render.call(g, e);
	              a.label = g.label;
	              delete g.label;
	            });
	          });
	          g.total = null;
	        };
	        return b;
	      }();
	      c.Composition = b;
	      c.compose = function (a, b) {
	        l(a, "init", w);
	        l(a, "afterBuildStacks", e);
	        l(a, "afterRender", k);
	        l(b, "beforeRedraw", x);
	      };
	    })(c || (c = {}));
	    return c;
	  });
	  A(d, "Series/Waterfall/WaterfallPoint.js", [d["Series/Column/ColumnSeries.js"], d["Core/Series/Point.js"], d["Core/Utilities.js"]], function (d, e, l) {
	    var a = this && this.__extends || function () {
	        var a = function (c, e) {
	          a = Object.setPrototypeOf || {
	            __proto__: []
	          } instanceof Array && function (a, c) {
	            a.__proto__ = c;
	          } || function (a, c) {
	            for (var b in c) c.hasOwnProperty(b) && (a[b] = c[b]);
	          };
	          return a(c, e);
	        };
	        return function (c, e) {
	          function d() {
	            this.constructor = c;
	          }
	          a(c, e);
	          c.prototype = null === e ? Object.create(e) : (d.prototype = e.prototype, new d());
	        };
	      }(),
	      c = l.isNumber;
	    return function (d) {
	      function l() {
	        var a = null !== d && d.apply(this, arguments) || this;
	        a.options = void 0;
	        a.series = void 0;
	        return a;
	      }
	      a(l, d);
	      l.prototype.getClassName = function () {
	        var a = e.prototype.getClassName.call(this);
	        this.isSum ? a += " highcharts-sum" : this.isIntermediateSum && (a += " highcharts-intermediate-sum");
	        return a;
	      };
	      l.prototype.isValid = function () {
	        return c(this.y) || this.isSum || !!this.isIntermediateSum;
	      };
	      return l;
	    }(d.prototype.pointClass);
	  });
	  A(d, "Series/Waterfall/WaterfallSeries.js", [d["Core/Axis/Axis.js"], d["Core/Chart/Chart.js"], d["Core/Series/SeriesRegistry.js"], d["Core/Utilities.js"], d["Core/Axis/WaterfallAxis.js"], d["Series/Waterfall/WaterfallPoint.js"]], function (d, e, l, a, c, t) {
	    var p = this && this.__extends || function () {
	        var a = function (b, c) {
	          a = Object.setPrototypeOf || {
	            __proto__: []
	          } instanceof Array && function (a, b) {
	            a.__proto__ = b;
	          } || function (a, b) {
	            for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);
	          };
	          return a(b, c);
	        };
	        return function (b, c) {
	          function f() {
	            this.constructor = b;
	          }
	          a(b, c);
	          b.prototype = null === c ? Object.create(c) : (f.prototype = c.prototype, new f());
	        };
	      }(),
	      k = l.seriesTypes,
	      x = k.column,
	      w = k.line,
	      b = a.arrayMax,
	      g = a.arrayMin,
	      m = a.correctFloat;
	    k = a.extend;
	    var n = a.isNumber,
	      q = a.merge,
	      A = a.objectEach,
	      J = a.pick;
	    a = function (a) {
	      function c() {
	        var b = null !== a && a.apply(this, arguments) || this;
	        b.chart = void 0;
	        b.data = void 0;
	        b.options = void 0;
	        b.points = void 0;
	        b.stackedYNeg = void 0;
	        b.stackedYPos = void 0;
	        b.stackKey = void 0;
	        b.xData = void 0;
	        b.yAxis = void 0;
	        b.yData = void 0;
	        return b;
	      }
	      p(c, a);
	      c.prototype.generatePoints = function () {
	        var a;
	        x.prototype.generatePoints.apply(this);
	        var b = 0;
	        for (a = this.points.length; b < a; b++) {
	          var c = this.points[b];
	          var e = this.processedYData[b];
	          if (c.isIntermediateSum || c.isSum) c.y = m(e);
	        }
	      };
	      c.prototype.translate = function () {
	        var a = this.options,
	          b = this.yAxis,
	          c = J(a.minPointLength, 5),
	          e = c / 2,
	          d = a.threshold || 0,
	          g = d,
	          k = d;
	        a = a.stacking;
	        var l = b.waterfall.stacks[this.stackKey];
	        x.prototype.translate.apply(this);
	        for (var m = this.points, p = 0; p < m.length; p++) {
	          var q = m[p];
	          var w = this.processedYData[p];
	          var C = q.shapeArgs;
	          if (C && n(w)) {
	            var t = [0, w];
	            var D = q.y;
	            if (a) {
	              if (l) {
	                t = l[p];
	                if ("overlap" === a) {
	                  var y = t.stackState[t.stateIndex--];
	                  y = 0 <= D ? y : y - D;
	                  Object.hasOwnProperty.call(t, "absolutePos") && delete t.absolutePos;
	                  Object.hasOwnProperty.call(t, "absoluteNeg") && delete t.absoluteNeg;
	                } else 0 <= D ? (y = t.threshold + t.posTotal, t.posTotal -= D) : (y = t.threshold + t.negTotal, t.negTotal -= D, y -= D), !t.posTotal && Object.hasOwnProperty.call(t, "absolutePos") && (t.posTotal = t.absolutePos, delete t.absolutePos), !t.negTotal && Object.hasOwnProperty.call(t, "absoluteNeg") && (t.negTotal = t.absoluteNeg, delete t.absoluteNeg);
	                q.isSum || (t.connectorThreshold = t.threshold + t.stackTotal);
	                b.reversed ? (w = 0 <= D ? y - D : y + D, D = y) : (w = y, D = y - D);
	                q.below = w <= d;
	                C.y = b.translate(w, !1, !0, !1, !0) || 0;
	                C.height = Math.abs(C.y - (b.translate(D, !1, !0, !1, !0) || 0));
	                if (D = b.waterfall.dummyStackItem) D.x = p, D.label = l[p].label, D.setOffset(this.pointXOffset || 0, this.barW || 0, this.stackedYNeg[p], this.stackedYPos[p]);
	              }
	            } else y = Math.max(g, g + D) + t[0], C.y = b.translate(y, !1, !0, !1, !0) || 0, q.isSum ? (C.y = b.translate(t[1], !1, !0, !1, !0) || 0, C.height = Math.min(b.translate(t[0], !1, !0, !1, !0) || 0, b.len) - C.y, q.below = t[1] <= d) : q.isIntermediateSum ? (0 <= D ? (w = t[1] + k, D = k) : (w = k, D = t[1] + k), b.reversed && (w ^= D, D ^= w, w ^= D), C.y = b.translate(w, !1, !0, !1, !0) || 0, C.height = Math.abs(C.y - Math.min(b.translate(D, !1, !0, !1, !0) || 0, b.len)), k += t[1], q.below = w <= d) : (C.height = 0 < w ? (b.translate(g, !1, !0, !1, !0) || 0) - C.y : (b.translate(g, !1, !0, !1, !0) || 0) - (b.translate(g - w, !1, !0, !1, !0) || 0), g += w, q.below = g < d), 0 > C.height && (C.y += C.height, C.height *= -1);
	            q.plotY = C.y = Math.round(C.y || 0) - this.borderWidth % 2 / 2;
	            C.height = Math.max(Math.round(C.height || 0), .001);
	            q.yBottom = C.y + C.height;
	            C.height <= c && !q.isNull ? (C.height = c, C.y -= e, q.plotY = C.y, q.minPointLengthOffset = 0 > q.y ? -e : e) : (q.isNull && (C.width = 0), q.minPointLengthOffset = 0);
	            D = q.plotY + (q.negative ? C.height : 0);
	            q.below && (q.plotY += C.height);
	            q.tooltipPos && (this.chart.inverted ? q.tooltipPos[0] = b.len - D : q.tooltipPos[1] = D);
	            q.isInside = this.isPointInside(q);
	          }
	        }
	      };
	      c.prototype.processData = function (b) {
	        var c = this.options,
	          e = this.yData,
	          d = c.data,
	          g = e.length,
	          k = c.threshold || 0,
	          l,
	          n,
	          p,
	          q,
	          t;
	        for (t = n = l = p = q = 0; t < g; t++) {
	          var z = e[t];
	          var w = d && d[t] ? d[t] : {};
	          "sum" === z || w.isSum ? e[t] = m(n) : "intermediateSum" === z || w.isIntermediateSum ? (e[t] = m(l), l = 0) : (n += z, l += z);
	          p = Math.min(n, p);
	          q = Math.max(n, q);
	        }
	        a.prototype.processData.call(this, b);
	        c.stacking || (this.dataMin = p + k, this.dataMax = q);
	      };
	      c.prototype.toYData = function (a) {
	        return a.isSum ? "sum" : a.isIntermediateSum ? "intermediateSum" : a.y;
	      };
	      c.prototype.updateParallelArrays = function (b, c) {
	        a.prototype.updateParallelArrays.call(this, b, c);
	        if ("sum" === this.yData[0] || "intermediateSum" === this.yData[0]) this.yData[0] = null;
	      };
	      c.prototype.pointAttribs = function (a, b) {
	        var c = this.options.upColor;
	        c && !a.options.color && (a.color = 0 < a.y ? c : null);
	        a = x.prototype.pointAttribs.call(this, a, b);
	        delete a.dashstyle;
	        return a;
	      };
	      c.prototype.getGraphPath = function () {
	        return [["M", 0, 0]];
	      };
	      c.prototype.getCrispPath = function () {
	        var a = this.data,
	          b = this.yAxis,
	          c = a.length,
	          e = Math.round(this.graph.strokeWidth()) % 2 / 2,
	          d = Math.round(this.borderWidth) % 2 / 2,
	          g = this.xAxis.reversed,
	          k = this.yAxis.reversed,
	          l = this.options.stacking,
	          m = [],
	          n;
	        for (n = 1; n < c; n++) {
	          var p = a[n].shapeArgs;
	          var q = a[n - 1];
	          var t = a[n - 1].shapeArgs;
	          var w = b.waterfall.stacks[this.stackKey];
	          var x = 0 < q.y ? -t.height : 0;
	          w && t && p && (w = w[n - 1], l ? (w = w.connectorThreshold, x = Math.round(b.translate(w, 0, 1, 0, 1) + (k ? x : 0)) - e) : x = t.y + q.minPointLengthOffset + d - e, m.push(["M", (t.x || 0) + (g ? 0 : t.width || 0), x], ["L", (p.x || 0) + (g ? p.width || 0 : 0), x]));
	          t && m.length && (!l && 0 > q.y && !k || 0 < q.y && k) && ((q = m[m.length - 2]) && "number" === typeof q[2] && (q[2] += t.height || 0), (q = m[m.length - 1]) && "number" === typeof q[2] && (q[2] += t.height || 0));
	        }
	        return m;
	      };
	      c.prototype.drawGraph = function () {
	        w.prototype.drawGraph.call(this);
	        this.graph.attr({
	          d: this.getCrispPath()
	        });
	      };
	      c.prototype.setStackedPoints = function () {
	        function a(a, b, c, f) {
	          if (J) for (c; c < J; c++) A.stackState[c] += f;else A.stackState[0] = a, J = A.stackState.length;
	          A.stackState.push(A.stackState[J - 1] + b);
	        }
	        var b = this.options,
	          c = this.yAxis.waterfall.stacks,
	          e = b.threshold,
	          d = e || 0,
	          g = d,
	          k = this.stackKey,
	          l = this.xData,
	          m = l.length,
	          n,
	          p,
	          q;
	        this.yAxis.stacking.usePercentage = !1;
	        var t = p = q = d;
	        if (this.visible || !this.chart.options.chart.ignoreHiddenSeries) {
	          var w = c.changed;
	          (n = c.alreadyChanged) && 0 > n.indexOf(k) && (w = !0);
	          c[k] || (c[k] = {});
	          n = c[k];
	          for (var x = 0; x < m; x++) {
	            var y = l[x];
	            if (!n[y] || w) n[y] = {
	              negTotal: 0,
	              posTotal: 0,
	              stackTotal: 0,
	              threshold: 0,
	              stateIndex: 0,
	              stackState: [],
	              label: w && n[y] ? n[y].label : void 0
	            };
	            var A = n[y];
	            var G = this.yData[x];
	            0 <= G ? A.posTotal += G : A.negTotal += G;
	            var F = b.data[x];
	            y = A.absolutePos = A.posTotal;
	            var H = A.absoluteNeg = A.negTotal;
	            A.stackTotal = y + H;
	            var J = A.stackState.length;
	            F && F.isIntermediateSum ? (a(q, p, 0, q), q = p, p = e, d ^= g, g ^= d, d ^= g) : F && F.isSum ? (a(e, t, J), d = e) : (a(d, G, 0, t), F && (t += G, p += G));
	            A.stateIndex++;
	            A.threshold = d;
	            d += A.stackTotal;
	          }
	          c.changed = !1;
	          c.alreadyChanged || (c.alreadyChanged = []);
	          c.alreadyChanged.push(k);
	        }
	      };
	      c.prototype.getExtremes = function () {
	        var a = this.options.stacking;
	        if (a) {
	          var c = this.yAxis;
	          c = c.waterfall.stacks;
	          var e = this.stackedYNeg = [];
	          var d = this.stackedYPos = [];
	          "overlap" === a ? A(c[this.stackKey], function (a) {
	            e.push(g(a.stackState));
	            d.push(b(a.stackState));
	          }) : A(c[this.stackKey], function (a) {
	            e.push(a.negTotal + a.threshold);
	            d.push(a.posTotal + a.threshold);
	          });
	          return {
	            dataMin: g(e),
	            dataMax: b(d)
	          };
	        }
	        return {
	          dataMin: this.dataMin,
	          dataMax: this.dataMax
	        };
	      };
	      c.defaultOptions = q(x.defaultOptions, {
	        dataLabels: {
	          inside: !0
	        },
	        lineWidth: 1,
	        lineColor: "#333333",
	        dashStyle: "Dot",
	        borderColor: "#333333",
	        states: {
	          hover: {
	            lineWidthPlus: 0
	          }
	        }
	      });
	      return c;
	    }(x);
	    k(a.prototype, {
	      getZonesGraphs: w.prototype.getZonesGraphs,
	      pointValKey: "y",
	      showLine: !0,
	      pointClass: t
	    });
	    l.registerSeriesType("waterfall", a);
	    c.compose(d, e);
	    return a;
	  });
	  A(d, "Extensions/Polar.js", [d["Core/Animation/AnimationUtilities.js"], d["Core/Chart/Chart.js"], d["Core/Globals.js"], d["Extensions/Pane.js"], d["Core/Pointer.js"], d["Core/Series/Series.js"], d["Core/Series/SeriesRegistry.js"], d["Core/Renderer/SVG/SVGRenderer.js"], d["Core/Utilities.js"]], function (d, e, l, a, c, t, p, k, x) {
	    var w = d.animObject;
	    p = p.seriesTypes;
	    var b = x.addEvent,
	      g = x.defined,
	      m = x.find,
	      n = x.isNumber,
	      q = x.pick,
	      A = x.splat,
	      J = x.uniqueKey;
	    d = x.wrap;
	    var I = t.prototype;
	    c = c.prototype;
	    I.searchPointByAngle = function (a) {
	      var b = this.chart,
	        c = this.xAxis.pane.center;
	      return this.searchKDTree({
	        clientX: 180 + -180 / Math.PI * Math.atan2(a.chartX - c[0] - b.plotLeft, a.chartY - c[1] - b.plotTop)
	      });
	    };
	    I.getConnectors = function (a, b, c, e) {
	      var f = e ? 1 : 0;
	      var d = 0 <= b && b <= a.length - 1 ? b : 0 > b ? a.length - 1 + b : 0;
	      b = 0 > d - 1 ? a.length - (1 + f) : d - 1;
	      f = d + 1 > a.length - 1 ? f : d + 1;
	      var g = a[b];
	      f = a[f];
	      var h = g.plotX;
	      g = g.plotY;
	      var k = f.plotX;
	      var l = f.plotY;
	      f = a[d].plotX;
	      d = a[d].plotY;
	      h = (1.5 * f + h) / 2.5;
	      g = (1.5 * d + g) / 2.5;
	      k = (1.5 * f + k) / 2.5;
	      var r = (1.5 * d + l) / 2.5;
	      l = Math.sqrt(Math.pow(h - f, 2) + Math.pow(g - d, 2));
	      var n = Math.sqrt(Math.pow(k - f, 2) + Math.pow(r - d, 2));
	      h = Math.atan2(g - d, h - f);
	      r = Math.PI / 2 + (h + Math.atan2(r - d, k - f)) / 2;
	      Math.abs(h - r) > Math.PI / 2 && (r -= Math.PI);
	      h = f + Math.cos(r) * l;
	      g = d + Math.sin(r) * l;
	      k = f + Math.cos(Math.PI + r) * n;
	      r = d + Math.sin(Math.PI + r) * n;
	      f = {
	        rightContX: k,
	        rightContY: r,
	        leftContX: h,
	        leftContY: g,
	        plotX: f,
	        plotY: d
	      };
	      c && (f.prevPointCont = this.getConnectors(a, b, !1, e));
	      return f;
	    };
	    I.toXY = function (a) {
	      var b = this.chart,
	        c = this.xAxis,
	        f = this.yAxis,
	        d = a.plotX,
	        e = a.plotY,
	        g = a.series,
	        k = b.inverted,
	        l = a.y,
	        m = k ? d : f.len - e;
	      k && g && !g.isRadialBar && (a.plotY = e = "number" === typeof l ? f.translate(l) || 0 : 0);
	      a.rectPlotX = d;
	      a.rectPlotY = e;
	      f.center && (m += f.center[3] / 2);
	      n(e) && (f = k ? f.postTranslate(e, m) : c.postTranslate(d, m), a.plotX = a.polarPlotX = f.x - b.plotLeft, a.plotY = a.polarPlotY = f.y - b.plotTop);
	      this.kdByAngle ? (b = (d / Math.PI * 180 + c.pane.options.startAngle) % 360, 0 > b && (b += 360), a.clientX = b) : a.clientX = a.plotX;
	    };
	    p.spline && (d(p.spline.prototype, "getPointSpline", function (a, b, c, d) {
	      this.chart.polar ? d ? (a = this.getConnectors(b, d, !0, this.connectEnds), b = a.prevPointCont && a.prevPointCont.rightContX, c = a.prevPointCont && a.prevPointCont.rightContY, a = ["C", n(b) ? b : a.plotX, n(c) ? c : a.plotY, n(a.leftContX) ? a.leftContX : a.plotX, n(a.leftContY) ? a.leftContY : a.plotY, a.plotX, a.plotY]) : a = ["M", c.plotX, c.plotY] : a = a.call(this, b, c, d);
	      return a;
	    }), p.areasplinerange && (p.areasplinerange.prototype.getPointSpline = p.spline.prototype.getPointSpline));
	    b(t, "afterTranslate", function () {
	      var a = this.chart;
	      if (a.polar && this.xAxis) {
	        (this.kdByAngle = a.tooltip && a.tooltip.shared) ? this.searchPoint = this.searchPointByAngle : this.options.findNearestPointBy = "xy";
	        if (!this.preventPostTranslate) for (var c = this.points, d = c.length; d--;) this.toXY(c[d]), !a.hasParallelCoordinates && !this.yAxis.reversed && c[d].y < this.yAxis.min && (c[d].isNull = !0);
	        this.hasClipCircleSetter || (this.hasClipCircleSetter = !!this.eventsToUnbind.push(b(this, "afterRender", function () {
	          if (a.polar) {
	            var b = this.yAxis.pane.center;
	            this.clipCircle ? this.clipCircle.animate({
	              x: b[0],
	              y: b[1],
	              r: b[2] / 2,
	              innerR: b[3] / 2
	            }) : this.clipCircle = a.renderer.clipCircle(b[0], b[1], b[2] / 2, b[3] / 2);
	            this.group.clip(this.clipCircle);
	            this.setClip = l.noop;
	          }
	        })));
	      }
	    }, {
	      order: 2
	    });
	    d(p.line.prototype, "getGraphPath", function (a, b) {
	      var c = this,
	        d;
	      if (this.chart.polar) {
	        b = b || this.points;
	        for (d = 0; d < b.length; d++) if (!b[d].isNull) {
	          var e = d;
	          break;
	        }
	        if (!1 !== this.options.connectEnds && "undefined" !== typeof e) {
	          this.connectEnds = !0;
	          b.splice(b.length, 0, b[e]);
	          var f = !0;
	        }
	        b.forEach(function (a) {
	          "undefined" === typeof a.polarPlotY && c.toXY(a);
	        });
	      }
	      d = a.apply(this, [].slice.call(arguments, 1));
	      f && b.pop();
	      return d;
	    });
	    var y = function (a, b) {
	      var c = this,
	        d = this.chart,
	        e = this.options.animation,
	        f = this.group,
	        g = this.markerGroup,
	        h = this.xAxis && this.xAxis.center,
	        k = d.plotLeft,
	        n = d.plotTop,
	        m,
	        p,
	        t,
	        x;
	      if (d.polar) {
	        if (c.isRadialBar) b || (c.startAngleRad = q(c.translatedThreshold, c.xAxis.startAngleRad), l.seriesTypes.pie.prototype.animate.call(c, b));else {
	          if (d.renderer.isSVG) if (e = w(e), c.is("column")) {
	            if (!b) {
	              var y = h[3] / 2;
	              c.points.forEach(function (a) {
	                m = a.graphic;
	                t = (p = a.shapeArgs) && p.r;
	                x = p && p.innerR;
	                m && p && (m.attr({
	                  r: y,
	                  innerR: y
	                }), m.animate({
	                  r: t,
	                  innerR: x
	                }, c.options.animation));
	              });
	            }
	          } else b ? (a = {
	            translateX: h[0] + k,
	            translateY: h[1] + n,
	            scaleX: .001,
	            scaleY: .001
	          }, f.attr(a), g && g.attr(a)) : (a = {
	            translateX: k,
	            translateY: n,
	            scaleX: 1,
	            scaleY: 1
	          }, f.animate(a, e), g && g.animate(a, e));
	        }
	      } else a.call(this, b);
	    };
	    d(I, "animate", y);
	    if (p.column) {
	      var z = p.arearange.prototype;
	      p = p.column.prototype;
	      p.polarArc = function (a, b, c, d) {
	        var e = this.xAxis.center,
	          f = this.yAxis.len,
	          g = e[3] / 2;
	        b = f - b + g;
	        a = f - q(a, f) + g;
	        this.yAxis.reversed && (0 > b && (b = g), 0 > a && (a = g));
	        return {
	          x: e[0],
	          y: e[1],
	          r: b,
	          innerR: a,
	          start: c,
	          end: d
	        };
	      };
	      d(p, "animate", y);
	      d(p, "translate", function (a) {
	        var b = this.options,
	          c = b.stacking,
	          d = this.chart,
	          e = this.xAxis,
	          f = this.yAxis,
	          k = f.reversed,
	          l = f.center,
	          m = e.startAngleRad,
	          p = e.endAngleRad - m;
	        this.preventPostTranslate = !0;
	        a.call(this);
	        if (e.isRadial) {
	          a = this.points;
	          e = a.length;
	          var q = f.translate(f.min);
	          var t = f.translate(f.max);
	          b = b.threshold || 0;
	          if (d.inverted && n(b)) {
	            var w = f.translate(b);
	            g(w) && (0 > w ? w = 0 : w > p && (w = p), this.translatedThreshold = w + m);
	          }
	          for (; e--;) {
	            b = a[e];
	            var y = b.barX;
	            var z = b.x;
	            var A = b.y;
	            b.shapeType = "arc";
	            if (d.inverted) {
	              b.plotY = f.translate(A);
	              if (c && f.stacking) {
	                if (A = f.stacking.stacks[(0 > A ? "-" : "") + this.stackKey], this.visible && A && A[z] && !b.isNull) {
	                  var G = A[z].points[this.getStackIndicator(void 0, z, this.index).key];
	                  var F = f.translate(G[0]);
	                  G = f.translate(G[1]);
	                  g(F) && (F = x.clamp(F, 0, p));
	                }
	              } else F = w, G = b.plotY;
	              F > G && (G = [F, F = G][0]);
	              if (!k) {
	                if (F < q) F = q;else if (G > t) G = t;else {
	                  if (G < q || F > t) F = G = 0;
	                }
	              } else if (G > q) G = q;else if (F < t) F = t;else if (F > q || G < t) F = G = p;
	              f.min > f.max && (F = G = k ? p : 0);
	              F += m;
	              G += m;
	              l && (b.barX = y += l[3] / 2);
	              z = Math.max(y, 0);
	              A = Math.max(y + b.pointWidth, 0);
	              b.shapeArgs = {
	                x: l && l[0],
	                y: l && l[1],
	                r: A,
	                innerR: z,
	                start: F,
	                end: G
	              };
	              b.opacity = F === G ? 0 : void 0;
	              b.plotY = (g(this.translatedThreshold) && (F < this.translatedThreshold ? F : G)) - m;
	            } else F = y + m, b.shapeArgs = this.polarArc(b.yBottom, b.plotY, F, F + b.pointWidth);
	            this.toXY(b);
	            d.inverted ? (y = f.postTranslate(b.rectPlotY, y + b.pointWidth / 2), b.tooltipPos = [y.x - d.plotLeft, y.y - d.plotTop]) : b.tooltipPos = [b.plotX, b.plotY];
	            l && (b.ttBelow = b.plotY > l[1]);
	          }
	        }
	      });
	      p.findAlignments = function (a, b) {
	        null === b.align && (b.align = 20 < a && 160 > a ? "left" : 200 < a && 340 > a ? "right" : "center");
	        null === b.verticalAlign && (b.verticalAlign = 45 > a || 315 < a ? "bottom" : 135 < a && 225 > a ? "top" : "middle");
	        return b;
	      };
	      z && (z.findAlignments = p.findAlignments);
	      d(p, "alignDataLabel", function (a, b, c, d, e, g) {
	        var f = this.chart,
	          h = q(d.inside, !!this.options.stacking);
	        f.polar ? (a = b.rectPlotX / Math.PI * 180, f.inverted ? (this.forceDL = f.isInsidePlot(b.plotX, Math.round(b.plotY)), h && b.shapeArgs ? (e = b.shapeArgs, e = this.yAxis.postTranslate(((e.start || 0) + (e.end || 0)) / 2 - this.xAxis.startAngleRad, b.barX + b.pointWidth / 2), e = {
	          x: e.x - f.plotLeft,
	          y: e.y - f.plotTop
	        }) : b.tooltipPos && (e = {
	          x: b.tooltipPos[0],
	          y: b.tooltipPos[1]
	        }), d.align = q(d.align, "center"), d.verticalAlign = q(d.verticalAlign, "middle")) : this.findAlignments && (d = this.findAlignments(a, d)), I.alignDataLabel.call(this, b, c, d, e, g), this.isRadialBar && b.shapeArgs && b.shapeArgs.start === b.shapeArgs.end ? c.hide() : c.show()) : a.call(this, b, c, d, e, g);
	      });
	    }
	    d(c, "getCoordinates", function (a, b) {
	      var c = this.chart,
	        d = {
	          xAxis: [],
	          yAxis: []
	        };
	      c.polar ? c.axes.forEach(function (a) {
	        var e = a.isXAxis,
	          f = a.center;
	        if ("colorAxis" !== a.coll) {
	          var g = b.chartX - f[0] - c.plotLeft;
	          f = b.chartY - f[1] - c.plotTop;
	          d[e ? "xAxis" : "yAxis"].push({
	            axis: a,
	            value: a.translate(e ? Math.PI - Math.atan2(g, f) : Math.sqrt(Math.pow(g, 2) + Math.pow(f, 2)), !0)
	          });
	        }
	      }) : d = a.call(this, b);
	      return d;
	    });
	    k.prototype.clipCircle = function (a, b, c, d) {
	      var e = J(),
	        f = this.createElement("clipPath").attr({
	          id: e
	        }).add(this.defs);
	      a = d ? this.arc(a, b, c, d, 0, 2 * Math.PI).add(f) : this.circle(a, b, c).add(f);
	      a.id = e;
	      a.clipPath = f;
	      return a;
	    };
	    b(e, "getAxes", function () {
	      this.pane || (this.pane = []);
	      this.options.pane = A(this.options.pane);
	      this.options.pane.forEach(function (b) {
	        new a(b, this);
	      }, this);
	    });
	    b(e, "afterDrawChartBox", function () {
	      this.pane.forEach(function (a) {
	        a.render();
	      });
	    });
	    b(t, "afterInit", function () {
	      var a = this.chart;
	      a.inverted && a.polar && (this.isRadialSeries = !0, this.is("column") && (this.isRadialBar = !0));
	    });
	    d(e.prototype, "get", function (a, b) {
	      return m(this.pane || [], function (a) {
	        return a.options.id === b;
	      }) || a.call(this, b);
	    });
	  });
	  A(d, "masters/highcharts-more.src.js", [d["Core/Globals.js"], d["Core/Axis/RadialAxis.js"], d["Series/Bubble/BubbleSeries.js"]], function (d, e, l) {
	    e.compose(d.Axis, d.Tick);
	    l.compose(d.Chart, d.Legend, d.Series);
	  });
	});
} (highchartsMore));

var More = highchartsMore.exports;

// NB: importing Highcharts rather than the Chart module as could not quite get
// highcharts-more working using Chart or when both Chart + Highcharts loaded.
var $$1 = window.$;
More(Highcharts$1);
var _default$l = /*#__PURE__*/function (_Controller) {
  _inherits$w(_default, _Controller);
  var _super = _createSuper$w(_default);
  function _default() {
    _classCallCheck$x(this, _default);
    return _super.apply(this, arguments);
  }
  _createClass$x(_default, [{
    key: "connect",
    value: function connect() {
      var _this = this;
      $$1.getJSON(this.data.get("url"), function (data) {
        Highcharts$1.chart(_this.element, {
          chart: {
            scrollablePlotArea: {
              minWidth: 600,
              scrollPositionX: 1
            }
          },
          title: {
            //text: "Peritoneal Equilibration Test",
            text: "",
            align: "left"
          },
          subtitle: {
            text: "",
            align: "left"
          },
          xAxis: {
            title: {
              text: "D/P creatinine (4hrs)"
            },
            type: "linear",
            labels: {
              overflow: "justify"
            },
            plotBands: [{
              from: 0.3,
              to: 0.5,
              color: "rgba(68, 170, 213, 0.1)",
              label: {
                text: "Low",
                style: {
                  color: "#606060"
                }
              }
            }, {
              from: 0.5,
              to: 0.65,
              color: "rgba(0, 0, 0, 0)",
              label: {
                text: "Low average",
                style: {
                  color: "#606060"
                }
              }
            }, {
              from: 0.65,
              to: 0.82,
              color: "rgba(68, 170, 213, 0.1)",
              label: {
                text: "High average",
                style: {
                  color: "#606060"
                }
              }
            }, {
              from: 0.82,
              to: 1.0,
              color: "rgba(0, 0, 0, 0)",
              label: {
                text: "High",
                style: {
                  color: "#606060"
                }
              }
            }]
          },
          yAxis: {
            title: {
              text: "Net Ultrafiltration (mls)"
            },
            tickInterval: 200,
            minorGridLineWidth: 0,
            gridLineWidth: 0,
            alternateGridColor: null,
            floor: -600,
            plotLines: [{
              color: "#BBB",
              width: 1,
              value: 0
            }]
          },
          tooltip: {
            formatter: function formatter() {
              return "<br>D_Pcr <b>" + this.x + "</b><br>" + "netUF <b>" + this.y + "</b>";
            }
          },
          plotOptions: {
            pointStart: 0.3,
            line: {
              dataLabels: {
                enabled: true,
                format: "{point.index}",
                style: {
                  fontSize: "15px"
                }
              }
            },
            series: {
              enableMouseTracking: false
            },
            dataLabels: {
              enabled: true,
              style: {
                fontWeight: "bold"
              }
            }
          },
          series: [{
            name: "Expected",
            color: "#00a499",
            //"#D970D9",
            showInLegend: true,
            type: "polygon",
            data: [[0.36, 400], [0.36, 1000], [0.5, 1000], [0.9, 600], [0.9, 300], [0.6, 100], [0.36, 400]]
          }, {
            name: "Warning",
            color: "#fff495",
            showInLegend: true,
            type: "polygon",
            data: [[0.6, 100], [0.9, 300], [1.0, 200], [1.0, -600], [0.75, -600], [0.6, 100]]
          }, {
            // patient data
            color: "#040481",
            showInLegend: false,
            enableMouseTracking: true,
            data: data
          }],
          navigation: {
            menuItemStyle: {
              fontSize: "10px"
            }
          }
        });
        _this.element.style.overflow = "unset";
      });
    }
  }]);
  return _default;
}(Controller);

var _default$k = /*#__PURE__*/function (_Controller) {
  _inherits$w(_default, _Controller);
  var _super = _createSuper$w(_default);
  function _default() {
    _classCallCheck$x(this, _default);
    return _super.apply(this, arguments);
  }
  _createClass$x(_default, [{
    key: "connect",
    value: function connect() {
      // let data = this.data.get("chartData")
      // let chartId = this.chartTarget.id

      // console.log(chartId)
      // let json = [
      //     {
      //       name: "",
      //       data: data
      //     }
      //   ]
      console.log("Not implemented");
      //Highcharts.SparkLine(this.chartTarget, {})
      //     series: [{
      //         name: '',
      //         data: data
      //    }]
      // })
      //new Chartkick.LineChart(chartId, json, this.chartOptions)
    }

    // get chartOptions() {
    //   return {
    //     library: {
    //       chart: {
    //         type: "area",
    //         margin: [0, 0, 0, 0],
    //         height: 20,
    //         width: 80,
    //         skipClone: true,
    //         style: {
    //           overflow: "visible"
    //         }
    //       },
    //       credits: {
    //         enabled: false
    //       },
    //       title: "",
    //       xAxis: {
    //         type: "datetime",
    //         tickPositions: [],
    //         labels: {
    //           enabled: false
    //         },
    //         startOnTick: false,
    //         endOnTick: false,
    //         title: {
    //           text: null
    //         }
    //       },
    //       legend: {
    //         enabled: false
    //       },
    //       yAxis: {
    //         tickPositions: [0],
    //         endOnTick: false,
    //         startOnTick: false,
    //         title: {
    //           text: null
    //         },
    //         min: 0,
    //         labels: {
    //           enabled: false
    //         }
    //       },
    //       tooltip: {
    //         hideDelay: 0,
    //         outside: true,
    //         shared: true,
    //         xDateFormat: '%d-%b-%Y'
    //       },
    //       plotOptions: {
    //         series: {
    //           animation: false,
    //           lineWidth: 1,
    //           shadow: false,
    //           states: {
    //             hover: {
    //               lineWidth: 1
    //             }
    //           },
    //           marker: {
    //             radius: 1,
    //             states: {
    //               hover: {
    //                 radius: 2
    //               }
    //             }
    //           },
    //           fillOpacity: 0.25
    //         },
    //         column: {
    //           negativeColor: "#910000",
    //           borderColor: "silver"
    //         }
    //       }
    //     }
    //   }
    // }
  }]);
  return _default;
}(Controller);
/**
* Create a constructor for sparklines that takes some sensible defaults and merges in the individual
* chart options.
*/
/*
window.Highcharts.SparkLine = function (a, b, c) {
console.log("defining1");
var hasRenderToArg = typeof a === 'string' || a.nodeName,
    options = arguments[hasRenderToArg ? 1 : 0],
    defaultOptions = {
        chart: {
            renderTo: (options.chart && options.chart.renderTo) || this,
            backgroundColor: null,
            borderWidth: 0,
            type: 'area',
            margin: [2, 0, 2, 0],
            width: 120,
            height: 20,
            style: {
                overflow: 'visible'
            },
             // small optimalization, saves 1-2 ms each sparkline
            skipClone: true
        },
        title: {
            text: ''
        },
        credits: {
            enabled: false
        },
        xAxis: {
            labels: {
                enabled: false
            },
            title: {
                text: null
            },
            startOnTick: false,
            endOnTick: false,
            tickPositions: []
        },
        yAxis: {
            endOnTick: false,
            startOnTick: false,
            labels: {
                enabled: false
            },
            title: {
                text: null
            },
            tickPositions: [0]
        },
        legend: {
            enabled: false
        },
        tooltip: {
            hideDelay: 0,
            outside: true,
            shared: true
        },
        plotOptions: {
            series: {
                animation: false,
                lineWidth: 1,
                shadow: false,
                states: {
                    hover: {
                        lineWidth: 1
                    }
                },
                marker: {
                    radius: 1,
                    states: {
                        hover: {
                            radius: 2
                        }
                    }
                },
                fillOpacity: 0.25
            },
            column: {
                negativeColor: '#910000',
                borderColor: 'silver'
            }
        }
    };
 options = Highcharts.merge(defaultOptions, options);
 return hasRenderToArg ?
    new Highcharts.Chart(a, options, c) :
    new Highcharts.Chart(options, b)
}
 */
_defineProperty$x(_default$k, "targets", ["chart"]);

// Controller to enable collapsing elements of a nav/menu to for example
// allow a more dense menu that can simplifies by hiding/collapsing sections.
//
// Example slim markup:
//
// div(data-controller="collapsible" data-collapsible-open-class="open")
//   a(data-action="collapsible#open" data-collapsible-target="link" href="#") X
//   div.collapsible(data-collapsible-target="section")
//     p XXX
//   a(data-action="collapsible#open" data-collapsible-target="link" href="#") Y
//   div.collapsible(data-collapsible-target="section")
//     p YYY
var _default$j = /*#__PURE__*/function (_Controller) {
  _inherits$w(_default, _Controller);
  var _super = _createSuper$w(_default);
  function _default() {
    _classCallCheck$x(this, _default);
    return _super.apply(this, arguments);
  }
  _createClass$x(_default, [{
    key: "connect",
    value: function connect() {
      // TODO: We could support an initial open section here for example.
    }

    // When a user clicks on a link with the target of "link", we determine its index,
    // hide all "section" targets initially, then just show the section with the
    // current index. This is a similar approach to the one we take with the tabs controller.
  }, {
    key: "open",
    value: function open(event) {
      var _this = this;
      var index = this.linkTargets.indexOf(event.currentTarget);
      this.sectionTargets.forEach(function (elem, idx) {
        elem.classList.remove(_this.openClass);
        if (idx == index) {
          elem.classList.add(_this.openClass);
        }
      });
    }
  }]);
  return _default;
}(Controller);
_defineProperty$x(_default$j, "targets", ["section", "link"]);
_defineProperty$x(_default$j, "classes", ["open"]);

var _default$i = /*#__PURE__*/function (_Controller) {
  _inherits$w(_default, _Controller);
  var _super = _createSuper$w(_default);
  function _default() {
    _classCallCheck$x(this, _default);
    return _super.apply(this, arguments);
  }
  _createClass$x(_default, [{
    key: "handleSelectChange",
    value: function handleSelectChange() {
      this.populateSelect(this.sourceTarget.value);
    }
  }, {
    key: "populateSelect",
    value: function populateSelect(sourceId) {
      var _this = this;
      var targetId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      fetch("/".concat(this.data.get("sourceRoutePart"), "/").concat(sourceId, "/").concat(this.data.get("targetRoutePart"), ".json"), {
        credentials: "same-origin"
      }).then(function (response) {
        return response.json();
      }).then(function (data) {
        var selectBox = _this.targetTarget;
        selectBox.innerHTML = "";
        selectBox.appendChild(document.createElement("option")); // blank option
        data.forEach(function (item) {
          var opt = document.createElement("option");
          opt.value = item.id;
          opt.innerHTML = item[_this.data.get("displayAttribute")];
          opt.selected = parseInt(targetId) === item.id;
          selectBox.appendChild(opt);
        });
      });
    }
  }]);
  return _default;
}(Controller);
_defineProperty$x(_default$i, "targets", ["source", "target"]);

// Used with patient attachments aka linked files.
var _default$h = /*#__PURE__*/function (_Controller) {
  _inherits$w(_default, _Controller);
  var _super = _createSuper$w(_default);
  function _default() {
    _classCallCheck$x(this, _default);
    return _super.apply(this, arguments);
  }
  _createClass$x(_default, [{
    key: "toggleFileInputs",
    value:
    // When the attachment type changes we examine a data attribute on the selected option
    // and show/hide the relevant file input (a text input if its an external stored, otherwise
    // a conventional file input).
    function toggleFileInputs(event) {
      var selectedOption = event.target.querySelector("option:checked");
      var storeFileExternally = "true" == selectedOption.getAttribute("data-store-file-externally");
      this.fileBrowserTarget.style.display = storeFileExternally ? "none" : "block";
      this.externalLocationTarget.style.display = storeFileExternally ? "block" : "none";
    }
  }]);
  return _default;
}(Controller);
_defineProperty$x(_default$h, "targets", ["fileBrowser", "externalLocation"]);

/**!
 * Sortable 1.15.0
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty$w(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _typeof$z(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$z = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof$z = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }
  return _typeof$z(obj);
}
function _defineProperty$w(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
var version = "1.15.0";
function userAgent(pattern) {
  if (typeof window !== 'undefined' && window.navigator) {
    return !! /*@__PURE__*/navigator.userAgent.match(pattern);
  }
}
var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
var Edge = userAgent(/Edge/i);
var FireFox = userAgent(/firefox/i);
var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
var IOS = userAgent(/iP(ad|od|hone)/i);
var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);
var captureMode = {
  capture: false,
  passive: false
};
function on(el, event, fn) {
  el.addEventListener(event, fn, !IE11OrLess && captureMode);
}
function off(el, event, fn) {
  el.removeEventListener(event, fn, !IE11OrLess && captureMode);
}
function matches( /**HTMLElement*/
el, /**String*/
selector) {
  if (!selector) return;
  selector[0] === '>' && (selector = selector.substring(1));
  if (el) {
    try {
      if (el.matches) {
        return el.matches(selector);
      } else if (el.msMatchesSelector) {
        return el.msMatchesSelector(selector);
      } else if (el.webkitMatchesSelector) {
        return el.webkitMatchesSelector(selector);
      }
    } catch (_) {
      return false;
    }
  }
  return false;
}
function getParentOrHost(el) {
  return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
}
function closest( /**HTMLElement*/
el, /**String*/
selector, /**HTMLElement*/
ctx, includeCTX) {
  if (el) {
    ctx = ctx || document;
    do {
      if (selector != null && (selector[0] === '>' ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {
        return el;
      }
      if (el === ctx) break;
      /* jshint boss:true */
    } while (el = getParentOrHost(el));
  }
  return null;
}
var R_SPACE = /\s+/g;
function toggleClass$1(el, name, state) {
  if (el && name) {
    if (el.classList) {
      el.classList[state ? 'add' : 'remove'](name);
    } else {
      var className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');
      el.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');
    }
  }
}
function css(el, prop, val) {
  var style = el && el.style;
  if (style) {
    if (val === void 0) {
      if (document.defaultView && document.defaultView.getComputedStyle) {
        val = document.defaultView.getComputedStyle(el, '');
      } else if (el.currentStyle) {
        val = el.currentStyle;
      }
      return prop === void 0 ? val : val[prop];
    } else {
      if (!(prop in style) && prop.indexOf('webkit') === -1) {
        prop = '-webkit-' + prop;
      }
      style[prop] = val + (typeof val === 'string' ? '' : 'px');
    }
  }
}
function matrix(el, selfOnly) {
  var appliedTransforms = '';
  if (typeof el === 'string') {
    appliedTransforms = el;
  } else {
    do {
      var transform = css(el, 'transform');
      if (transform && transform !== 'none') {
        appliedTransforms = transform + ' ' + appliedTransforms;
      }
      /* jshint boss:true */
    } while (!selfOnly && (el = el.parentNode));
  }
  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  /*jshint -W056 */

  return matrixFn && new matrixFn(appliedTransforms);
}
function find(ctx, tagName, iterator) {
  if (ctx) {
    var list = ctx.getElementsByTagName(tagName),
      i = 0,
      n = list.length;
    if (iterator) {
      for (; i < n; i++) {
        iterator(list[i], i);
      }
    }
    return list;
  }
  return [];
}
function getWindowScrollingElement() {
  var scrollingElement = document.scrollingElement;
  if (scrollingElement) {
    return scrollingElement;
  } else {
    return document.documentElement;
  }
}
/**
 * Returns the "bounding client rect" of given element
 * @param  {HTMLElement} el                       The element whose boundingClientRect is wanted
 * @param  {[Boolean]} relativeToContainingBlock  Whether the rect should be relative to the containing block of (including) the container
 * @param  {[Boolean]} relativeToNonStaticParent  Whether the rect should be relative to the relative parent of (including) the contaienr
 * @param  {[Boolean]} undoScale                  Whether the container's scale() should be undone
 * @param  {[HTMLElement]} container              The parent the element will be placed in
 * @return {Object}                               The boundingClientRect of el, with specified adjustments
 */

function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
  if (!el.getBoundingClientRect && el !== window) return;
  var elRect, top, left, bottom, right, height, width;
  if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {
    elRect = el.getBoundingClientRect();
    top = elRect.top;
    left = elRect.left;
    bottom = elRect.bottom;
    right = elRect.right;
    height = elRect.height;
    width = elRect.width;
  } else {
    top = 0;
    left = 0;
    bottom = window.innerHeight;
    right = window.innerWidth;
    height = window.innerHeight;
    width = window.innerWidth;
  }
  if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
    // Adjust for translate()
    container = container || el.parentNode; // solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)
    // Not needed on <= IE11

    if (!IE11OrLess) {
      do {
        if (container && container.getBoundingClientRect && (css(container, 'transform') !== 'none' || relativeToNonStaticParent && css(container, 'position') !== 'static')) {
          var containerRect = container.getBoundingClientRect(); // Set relative to edges of padding box of container

          top -= containerRect.top + parseInt(css(container, 'border-top-width'));
          left -= containerRect.left + parseInt(css(container, 'border-left-width'));
          bottom = top + elRect.height;
          right = left + elRect.width;
          break;
        }
        /* jshint boss:true */
      } while (container = container.parentNode);
    }
  }
  if (undoScale && el !== window) {
    // Adjust for scale()
    var elMatrix = matrix(container || el),
      scaleX = elMatrix && elMatrix.a,
      scaleY = elMatrix && elMatrix.d;
    if (elMatrix) {
      top /= scaleY;
      left /= scaleX;
      width /= scaleX;
      height /= scaleY;
      bottom = top + height;
      right = left + width;
    }
  }
  return {
    top: top,
    left: left,
    bottom: bottom,
    right: right,
    width: width,
    height: height
  };
}
/**
 * Checks if a side of an element is scrolled past a side of its parents
 * @param  {HTMLElement}  el           The element who's side being scrolled out of view is in question
 * @param  {String}       elSide       Side of the element in question ('top', 'left', 'right', 'bottom')
 * @param  {String}       parentSide   Side of the parent in question ('top', 'left', 'right', 'bottom')
 * @return {HTMLElement}               The parent scroll element that the el's side is scrolled past, or null if there is no such element
 */

function isScrolledPast(el, elSide, parentSide) {
  var parent = getParentAutoScrollElement(el, true),
    elSideVal = getRect(el)[elSide];
  /* jshint boss:true */

  while (parent) {
    var parentSideVal = getRect(parent)[parentSide],
      visible = void 0;
    if (parentSide === 'top' || parentSide === 'left') {
      visible = elSideVal >= parentSideVal;
    } else {
      visible = elSideVal <= parentSideVal;
    }
    if (!visible) return parent;
    if (parent === getWindowScrollingElement()) break;
    parent = getParentAutoScrollElement(parent, false);
  }
  return false;
}
/**
 * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)
 * and non-draggable elements
 * @param  {HTMLElement} el       The parent element
 * @param  {Number} childNum      The index of the child
 * @param  {Object} options       Parent Sortable's options
 * @return {HTMLElement}          The child at index childNum, or null if not found
 */

function getChild(el, childNum, options, includeDragEl) {
  var currentChild = 0,
    i = 0,
    children = el.children;
  while (i < children.length) {
    if (children[i].style.display !== 'none' && children[i] !== Sortable.ghost && (includeDragEl || children[i] !== Sortable.dragged) && closest(children[i], options.draggable, el, false)) {
      if (currentChild === childNum) {
        return children[i];
      }
      currentChild++;
    }
    i++;
  }
  return null;
}
/**
 * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)
 * @param  {HTMLElement} el       Parent element
 * @param  {selector} selector    Any other elements that should be ignored
 * @return {HTMLElement}          The last child, ignoring ghostEl
 */

function lastChild(el, selector) {
  var last = el.lastElementChild;
  while (last && (last === Sortable.ghost || css(last, 'display') === 'none' || selector && !matches(last, selector))) {
    last = last.previousElementSibling;
  }
  return last || null;
}
/**
 * Returns the index of an element within its parent for a selected set of
 * elements
 * @param  {HTMLElement} el
 * @param  {selector} selector
 * @return {number}
 */

function index$1(el, selector) {
  var index = 0;
  if (!el || !el.parentNode) {
    return -1;
  }
  /* jshint boss:true */

  while (el = el.previousElementSibling) {
    if (el.nodeName.toUpperCase() !== 'TEMPLATE' && el !== Sortable.clone && (!selector || matches(el, selector))) {
      index++;
    }
  }
  return index;
}
/**
 * Returns the scroll offset of the given element, added with all the scroll offsets of parent elements.
 * The value is returned in real pixels.
 * @param  {HTMLElement} el
 * @return {Array}             Offsets in the format of [left, top]
 */

function getRelativeScrollOffset(el) {
  var offsetLeft = 0,
    offsetTop = 0,
    winScroller = getWindowScrollingElement();
  if (el) {
    do {
      var elMatrix = matrix(el),
        scaleX = elMatrix.a,
        scaleY = elMatrix.d;
      offsetLeft += el.scrollLeft * scaleX;
      offsetTop += el.scrollTop * scaleY;
    } while (el !== winScroller && (el = el.parentNode));
  }
  return [offsetLeft, offsetTop];
}
/**
 * Returns the index of the object within the given array
 * @param  {Array} arr   Array that may or may not hold the object
 * @param  {Object} obj  An object that has a key-value pair unique to and identical to a key-value pair in the object you want to find
 * @return {Number}      The index of the object in the array, or -1
 */

function indexOfObject(arr, obj) {
  for (var i in arr) {
    if (!arr.hasOwnProperty(i)) continue;
    for (var key in obj) {
      if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);
    }
  }
  return -1;
}
function getParentAutoScrollElement(el, includeSelf) {
  // skip to window
  if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();
  var elem = el;
  var gotSelf = false;
  do {
    // we don't need to get elem css if it isn't even overflowing in the first place (performance)
    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
      var elemCSS = css(elem);
      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == 'auto' || elemCSS.overflowX == 'scroll') || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == 'auto' || elemCSS.overflowY == 'scroll')) {
        if (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();
        if (gotSelf || includeSelf) return elem;
        gotSelf = true;
      }
    }
    /* jshint boss:true */
  } while (elem = elem.parentNode);
  return getWindowScrollingElement();
}
function extend$1(dst, src) {
  if (dst && src) {
    for (var key in src) {
      if (src.hasOwnProperty(key)) {
        dst[key] = src[key];
      }
    }
  }
  return dst;
}
function isRectEqual(rect1, rect2) {
  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
}
var _throttleTimeout;
function throttle(callback, ms) {
  return function () {
    if (!_throttleTimeout) {
      var args = arguments,
        _this = this;
      if (args.length === 1) {
        callback.call(_this, args[0]);
      } else {
        callback.apply(_this, args);
      }
      _throttleTimeout = setTimeout(function () {
        _throttleTimeout = void 0;
      }, ms);
    }
  };
}
function cancelThrottle() {
  clearTimeout(_throttleTimeout);
  _throttleTimeout = void 0;
}
function scrollBy(el, x, y) {
  el.scrollLeft += x;
  el.scrollTop += y;
}
function clone(el) {
  var Polymer = window.Polymer;
  var $ = window.jQuery || window.Zepto;
  if (Polymer && Polymer.dom) {
    return Polymer.dom(el).cloneNode(true);
  } else if ($) {
    return $(el).clone(true)[0];
  } else {
    return el.cloneNode(true);
  }
}
var expando = 'Sortable' + new Date().getTime();
function AnimationStateManager() {
  var animationStates = [],
    animationCallbackId;
  return {
    captureAnimationState: function captureAnimationState() {
      animationStates = [];
      if (!this.options.animation) return;
      var children = [].slice.call(this.el.children);
      children.forEach(function (child) {
        if (css(child, 'display') === 'none' || child === Sortable.ghost) return;
        animationStates.push({
          target: child,
          rect: getRect(child)
        });
        var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect); // If animating: compensate for current animation

        if (child.thisAnimationDuration) {
          var childMatrix = matrix(child, true);
          if (childMatrix) {
            fromRect.top -= childMatrix.f;
            fromRect.left -= childMatrix.e;
          }
        }
        child.fromRect = fromRect;
      });
    },
    addAnimationState: function addAnimationState(state) {
      animationStates.push(state);
    },
    removeAnimationState: function removeAnimationState(target) {
      animationStates.splice(indexOfObject(animationStates, {
        target: target
      }), 1);
    },
    animateAll: function animateAll(callback) {
      var _this = this;
      if (!this.options.animation) {
        clearTimeout(animationCallbackId);
        if (typeof callback === 'function') callback();
        return;
      }
      var animating = false,
        animationTime = 0;
      animationStates.forEach(function (state) {
        var time = 0,
          target = state.target,
          fromRect = target.fromRect,
          toRect = getRect(target),
          prevFromRect = target.prevFromRect,
          prevToRect = target.prevToRect,
          animatingRect = state.rect,
          targetMatrix = matrix(target, true);
        if (targetMatrix) {
          // Compensate for current animation
          toRect.top -= targetMatrix.f;
          toRect.left -= targetMatrix.e;
        }
        target.toRect = toRect;
        if (target.thisAnimationDuration) {
          // Could also check if animatingRect is between fromRect and toRect
          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) &&
          // Make sure animatingRect is on line between toRect & fromRect
          (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
            // If returning to same place as started from animation and on same axis
            time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
          }
        } // if fromRect != toRect: animate

        if (!isRectEqual(toRect, fromRect)) {
          target.prevFromRect = fromRect;
          target.prevToRect = toRect;
          if (!time) {
            time = _this.options.animation;
          }
          _this.animate(target, animatingRect, toRect, time);
        }
        if (time) {
          animating = true;
          animationTime = Math.max(animationTime, time);
          clearTimeout(target.animationResetTimer);
          target.animationResetTimer = setTimeout(function () {
            target.animationTime = 0;
            target.prevFromRect = null;
            target.fromRect = null;
            target.prevToRect = null;
            target.thisAnimationDuration = null;
          }, time);
          target.thisAnimationDuration = time;
        }
      });
      clearTimeout(animationCallbackId);
      if (!animating) {
        if (typeof callback === 'function') callback();
      } else {
        animationCallbackId = setTimeout(function () {
          if (typeof callback === 'function') callback();
        }, animationTime);
      }
      animationStates = [];
    },
    animate: function animate(target, currentRect, toRect, duration) {
      if (duration) {
        css(target, 'transition', '');
        css(target, 'transform', '');
        var elMatrix = matrix(this.el),
          scaleX = elMatrix && elMatrix.a,
          scaleY = elMatrix && elMatrix.d,
          translateX = (currentRect.left - toRect.left) / (scaleX || 1),
          translateY = (currentRect.top - toRect.top) / (scaleY || 1);
        target.animatingX = !!translateX;
        target.animatingY = !!translateY;
        css(target, 'transform', 'translate3d(' + translateX + 'px,' + translateY + 'px,0)');
        this.forRepaintDummy = repaint(target); // repaint

        css(target, 'transition', 'transform ' + duration + 'ms' + (this.options.easing ? ' ' + this.options.easing : ''));
        css(target, 'transform', 'translate3d(0,0,0)');
        typeof target.animated === 'number' && clearTimeout(target.animated);
        target.animated = setTimeout(function () {
          css(target, 'transition', '');
          css(target, 'transform', '');
          target.animated = false;
          target.animatingX = false;
          target.animatingY = false;
        }, duration);
      }
    }
  };
}
function repaint(target) {
  return target.offsetWidth;
}
function calculateRealTime(animatingRect, fromRect, toRect, options) {
  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
}
var plugins = [];
var defaults$1 = {
  initializeByDefault: true
};
var PluginManager = {
  mount: function mount(plugin) {
    // Set default static properties
    for (var option in defaults$1) {
      if (defaults$1.hasOwnProperty(option) && !(option in plugin)) {
        plugin[option] = defaults$1[option];
      }
    }
    plugins.forEach(function (p) {
      if (p.pluginName === plugin.pluginName) {
        throw "Sortable: Cannot mount plugin ".concat(plugin.pluginName, " more than once");
      }
    });
    plugins.push(plugin);
  },
  pluginEvent: function pluginEvent(eventName, sortable, evt) {
    var _this = this;
    this.eventCanceled = false;
    evt.cancel = function () {
      _this.eventCanceled = true;
    };
    var eventNameGlobal = eventName + 'Global';
    plugins.forEach(function (plugin) {
      if (!sortable[plugin.pluginName]) return; // Fire global events if it exists in this sortable

      if (sortable[plugin.pluginName][eventNameGlobal]) {
        sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({
          sortable: sortable
        }, evt));
      } // Only fire plugin event if plugin is enabled in this sortable,
      // and plugin has event defined

      if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
        sortable[plugin.pluginName][eventName](_objectSpread2({
          sortable: sortable
        }, evt));
      }
    });
  },
  initializePlugins: function initializePlugins(sortable, el, defaults, options) {
    plugins.forEach(function (plugin) {
      var pluginName = plugin.pluginName;
      if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;
      var initialized = new plugin(sortable, el, sortable.options);
      initialized.sortable = sortable;
      initialized.options = sortable.options;
      sortable[pluginName] = initialized; // Add default options from plugin

      _extends(defaults, initialized.defaults);
    });
    for (var option in sortable.options) {
      if (!sortable.options.hasOwnProperty(option)) continue;
      var modified = this.modifyOption(sortable, option, sortable.options[option]);
      if (typeof modified !== 'undefined') {
        sortable.options[option] = modified;
      }
    }
  },
  getEventProperties: function getEventProperties(name, sortable) {
    var eventProperties = {};
    plugins.forEach(function (plugin) {
      if (typeof plugin.eventProperties !== 'function') return;
      _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));
    });
    return eventProperties;
  },
  modifyOption: function modifyOption(sortable, name, value) {
    var modifiedValue;
    plugins.forEach(function (plugin) {
      // Plugin must exist on the Sortable
      if (!sortable[plugin.pluginName]) return; // If static option listener exists for this option, call in the context of the Sortable's instance of this plugin

      if (plugin.optionListeners && typeof plugin.optionListeners[name] === 'function') {
        modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);
      }
    });
    return modifiedValue;
  }
};
function dispatchEvent$1(_ref) {
  var sortable = _ref.sortable,
    rootEl = _ref.rootEl,
    name = _ref.name,
    targetEl = _ref.targetEl,
    cloneEl = _ref.cloneEl,
    toEl = _ref.toEl,
    fromEl = _ref.fromEl,
    oldIndex = _ref.oldIndex,
    newIndex = _ref.newIndex,
    oldDraggableIndex = _ref.oldDraggableIndex,
    newDraggableIndex = _ref.newDraggableIndex,
    originalEvent = _ref.originalEvent,
    putSortable = _ref.putSortable,
    extraEventProperties = _ref.extraEventProperties;
  sortable = sortable || rootEl && rootEl[expando];
  if (!sortable) return;
  var evt,
    options = sortable.options,
    onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1); // Support for new CustomEvent feature

  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent(name, {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent('Event');
    evt.initEvent(name, true, true);
  }
  evt.to = toEl || rootEl;
  evt.from = fromEl || rootEl;
  evt.item = targetEl || rootEl;
  evt.clone = cloneEl;
  evt.oldIndex = oldIndex;
  evt.newIndex = newIndex;
  evt.oldDraggableIndex = oldDraggableIndex;
  evt.newDraggableIndex = newDraggableIndex;
  evt.originalEvent = originalEvent;
  evt.pullMode = putSortable ? putSortable.lastPutMode : undefined;
  var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));
  for (var option in allEventProperties) {
    evt[option] = allEventProperties[option];
  }
  if (rootEl) {
    rootEl.dispatchEvent(evt);
  }
  if (options[onName]) {
    options[onName].call(sortable, evt);
  }
}
var _excluded = ["evt"];
var pluginEvent = function pluginEvent(eventName, sortable) {
  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
    originalEvent = _ref.evt,
    data = _objectWithoutProperties(_ref, _excluded);
  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
    dragEl: dragEl,
    parentEl: parentEl,
    ghostEl: ghostEl,
    rootEl: rootEl,
    nextEl: nextEl,
    lastDownEl: lastDownEl,
    cloneEl: cloneEl,
    cloneHidden: cloneHidden,
    dragStarted: moved,
    putSortable: putSortable,
    activeSortable: Sortable.active,
    originalEvent: originalEvent,
    oldIndex: oldIndex,
    oldDraggableIndex: oldDraggableIndex,
    newIndex: newIndex,
    newDraggableIndex: newDraggableIndex,
    hideGhostForTarget: _hideGhostForTarget,
    unhideGhostForTarget: _unhideGhostForTarget,
    cloneNowHidden: function cloneNowHidden() {
      cloneHidden = true;
    },
    cloneNowShown: function cloneNowShown() {
      cloneHidden = false;
    },
    dispatchSortableEvent: function dispatchSortableEvent(name) {
      _dispatchEvent({
        sortable: sortable,
        name: name,
        originalEvent: originalEvent
      });
    }
  }, data));
};
function _dispatchEvent(info) {
  dispatchEvent$1(_objectSpread2({
    putSortable: putSortable,
    cloneEl: cloneEl,
    targetEl: dragEl,
    rootEl: rootEl,
    oldIndex: oldIndex,
    oldDraggableIndex: oldDraggableIndex,
    newIndex: newIndex,
    newDraggableIndex: newDraggableIndex
  }, info));
}
var dragEl,
  parentEl,
  ghostEl,
  rootEl,
  nextEl,
  lastDownEl,
  cloneEl,
  cloneHidden,
  oldIndex,
  newIndex,
  oldDraggableIndex,
  newDraggableIndex,
  activeGroup,
  putSortable,
  awaitingDragStarted = false,
  ignoreNextClick = false,
  sortables = [],
  tapEvt,
  touchEvt,
  lastDx,
  lastDy,
  tapDistanceLeft,
  tapDistanceTop,
  moved,
  lastTarget,
  lastDirection,
  pastFirstInvertThresh = false,
  isCircumstantialInvert = false,
  targetMoveDistance,
  // For positioning ghost absolutely
  ghostRelativeParent,
  ghostRelativeParentInitialScroll = [],
  // (left, top)
  _silent = false,
  savedInputChecked = [];
/** @const */

var documentExists = typeof document !== 'undefined',
  PositionGhostAbsolutely = IOS,
  CSSFloatProperty = Edge || IE11OrLess ? 'cssFloat' : 'float',
  // This will not pass for IE9, because IE9 DnD only works on anchors
  supportDraggable = documentExists && !ChromeForAndroid && !IOS && 'draggable' in document.createElement('div'),
  supportCssPointerEvents = function () {
    if (!documentExists) return; // false when <= IE11

    if (IE11OrLess) {
      return false;
    }
    var el = document.createElement('x');
    el.style.cssText = 'pointer-events:auto';
    return el.style.pointerEvents === 'auto';
  }(),
  _detectDirection = function _detectDirection(el, options) {
    var elCSS = css(el),
      elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth),
      child1 = getChild(el, 0, options),
      child2 = getChild(el, 1, options),
      firstChildCSS = child1 && css(child1),
      secondChildCSS = child2 && css(child2),
      firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width,
      secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;
    if (elCSS.display === 'flex') {
      return elCSS.flexDirection === 'column' || elCSS.flexDirection === 'column-reverse' ? 'vertical' : 'horizontal';
    }
    if (elCSS.display === 'grid') {
      return elCSS.gridTemplateColumns.split(' ').length <= 1 ? 'vertical' : 'horizontal';
    }
    if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== 'none') {
      var touchingSideChild2 = firstChildCSS["float"] === 'left' ? 'left' : 'right';
      return child2 && (secondChildCSS.clear === 'both' || secondChildCSS.clear === touchingSideChild2) ? 'vertical' : 'horizontal';
    }
    return child1 && (firstChildCSS.display === 'block' || firstChildCSS.display === 'flex' || firstChildCSS.display === 'table' || firstChildCSS.display === 'grid' || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === 'none' || child2 && elCSS[CSSFloatProperty] === 'none' && firstChildWidth + secondChildWidth > elWidth) ? 'vertical' : 'horizontal';
  },
  _dragElInRowColumn = function _dragElInRowColumn(dragRect, targetRect, vertical) {
    var dragElS1Opp = vertical ? dragRect.left : dragRect.top,
      dragElS2Opp = vertical ? dragRect.right : dragRect.bottom,
      dragElOppLength = vertical ? dragRect.width : dragRect.height,
      targetS1Opp = vertical ? targetRect.left : targetRect.top,
      targetS2Opp = vertical ? targetRect.right : targetRect.bottom,
      targetOppLength = vertical ? targetRect.width : targetRect.height;
    return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
  },
  /**
   * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.
   * @param  {Number} x      X position
   * @param  {Number} y      Y position
   * @return {HTMLElement}   Element of the first found nearest Sortable
   */
  _detectNearestEmptySortable = function _detectNearestEmptySortable(x, y) {
    var ret;
    sortables.some(function (sortable) {
      var threshold = sortable[expando].options.emptyInsertThreshold;
      if (!threshold || lastChild(sortable)) return;
      var rect = getRect(sortable),
        insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold,
        insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;
      if (insideHorizontally && insideVertically) {
        return ret = sortable;
      }
    });
    return ret;
  },
  _prepareGroup = function _prepareGroup(options) {
    function toFn(value, pull) {
      return function (to, from, dragEl, evt) {
        var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;
        if (value == null && (pull || sameGroup)) {
          // Default pull value
          // Default pull and put value if same group
          return true;
        } else if (value == null || value === false) {
          return false;
        } else if (pull && value === 'clone') {
          return value;
        } else if (typeof value === 'function') {
          return toFn(value(to, from, dragEl, evt), pull)(to, from, dragEl, evt);
        } else {
          var otherGroup = (pull ? to : from).options.group.name;
          return value === true || typeof value === 'string' && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
        }
      };
    }
    var group = {};
    var originalGroup = options.group;
    if (!originalGroup || _typeof$z(originalGroup) != 'object') {
      originalGroup = {
        name: originalGroup
      };
    }
    group.name = originalGroup.name;
    group.checkPull = toFn(originalGroup.pull, true);
    group.checkPut = toFn(originalGroup.put);
    group.revertClone = originalGroup.revertClone;
    options.group = group;
  },
  _hideGhostForTarget = function _hideGhostForTarget() {
    if (!supportCssPointerEvents && ghostEl) {
      css(ghostEl, 'display', 'none');
    }
  },
  _unhideGhostForTarget = function _unhideGhostForTarget() {
    if (!supportCssPointerEvents && ghostEl) {
      css(ghostEl, 'display', '');
    }
  }; // #1184 fix - Prevent click event on fallback if dragged but item not changed position

if (documentExists && !ChromeForAndroid) {
  document.addEventListener('click', function (evt) {
    if (ignoreNextClick) {
      evt.preventDefault();
      evt.stopPropagation && evt.stopPropagation();
      evt.stopImmediatePropagation && evt.stopImmediatePropagation();
      ignoreNextClick = false;
      return false;
    }
  }, true);
}
var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent(evt) {
  if (dragEl) {
    evt = evt.touches ? evt.touches[0] : evt;
    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);
    if (nearest) {
      // Create imitation event
      var event = {};
      for (var i in evt) {
        if (evt.hasOwnProperty(i)) {
          event[i] = evt[i];
        }
      }
      event.target = event.rootEl = nearest;
      event.preventDefault = void 0;
      event.stopPropagation = void 0;
      nearest[expando]._onDragOver(event);
    }
  }
};
var _checkOutsideTargetEl = function _checkOutsideTargetEl(evt) {
  if (dragEl) {
    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
  }
};
/**
 * @class  Sortable
 * @param  {HTMLElement}  el
 * @param  {Object}       [options]
 */

function Sortable(el, options) {
  if (!(el && el.nodeType && el.nodeType === 1)) {
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
  }
  this.el = el; // root element

  this.options = options = _extends({}, options); // Export instance

  el[expando] = this;
  var defaults = {
    group: null,
    sort: true,
    disabled: false,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(el.nodeName) ? '>li' : '>*',
    swapThreshold: 1,
    // percentage; 0 <= x <= 1
    invertSwap: false,
    // invert always
    invertedSwapThreshold: null,
    // will be set to same as swapThreshold if default
    removeCloneOnHide: true,
    direction: function direction() {
      return _detectDirection(el, this.options);
    },
    ghostClass: 'sortable-ghost',
    chosenClass: 'sortable-chosen',
    dragClass: 'sortable-drag',
    ignore: 'a, img',
    filter: null,
    preventOnFilter: true,
    animation: 0,
    easing: null,
    setData: function setData(dataTransfer, dragEl) {
      dataTransfer.setData('Text', dragEl.textContent);
    },
    dropBubble: false,
    dragoverBubble: false,
    dataIdAttr: 'data-id',
    delay: 0,
    delayOnTouchOnly: false,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: false,
    fallbackClass: 'sortable-fallback',
    fallbackOnBody: false,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    supportPointer: Sortable.supportPointer !== false && 'PointerEvent' in window && !Safari,
    emptyInsertThreshold: 5
  };
  PluginManager.initializePlugins(this, el, defaults); // Set default options

  for (var name in defaults) {
    !(name in options) && (options[name] = defaults[name]);
  }
  _prepareGroup(options); // Bind all private methods

  for (var fn in this) {
    if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
      this[fn] = this[fn].bind(this);
    }
  } // Setup drag mode

  this.nativeDraggable = options.forceFallback ? false : supportDraggable;
  if (this.nativeDraggable) {
    // Touch start threshold cannot be greater than the native dragstart threshold
    this.options.touchStartThreshold = 1;
  } // Bind events

  if (options.supportPointer) {
    on(el, 'pointerdown', this._onTapStart);
  } else {
    on(el, 'mousedown', this._onTapStart);
    on(el, 'touchstart', this._onTapStart);
  }
  if (this.nativeDraggable) {
    on(el, 'dragover', this);
    on(el, 'dragenter', this);
  }
  sortables.push(this.el); // Restore sorting

  options.store && options.store.get && this.sort(options.store.get(this) || []); // Add animation state manager

  _extends(this, AnimationStateManager());
}
Sortable.prototype = /** @lends Sortable.prototype */
{
  constructor: Sortable,
  _isOutsideThisEl: function _isOutsideThisEl(target) {
    if (!this.el.contains(target) && target !== this.el) {
      lastTarget = null;
    }
  },
  _getDirection: function _getDirection(evt, target) {
    return typeof this.options.direction === 'function' ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
  },
  _onTapStart: function _onTapStart( /** Event|TouchEvent */
  evt) {
    if (!evt.cancelable) return;
    var _this = this,
      el = this.el,
      options = this.options,
      preventOnFilter = options.preventOnFilter,
      type = evt.type,
      touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === 'touch' && evt,
      target = (touch || evt).target,
      originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target,
      filter = options.filter;
    _saveInputCheckedState(el); // Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.

    if (dragEl) {
      return;
    }
    if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
      return; // only left button and enabled
    } // cancel dnd if original target is content editable

    if (originalTarget.isContentEditable) {
      return;
    } // Safari ignores further event handling after mousedown

    if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === 'SELECT') {
      return;
    }
    target = closest(target, options.draggable, el, false);
    if (target && target.animated) {
      return;
    }
    if (lastDownEl === target) {
      // Ignoring duplicate `down`
      return;
    } // Get the index of the dragged element within its parent

    oldIndex = index$1(target);
    oldDraggableIndex = index$1(target, options.draggable); // Check filter

    if (typeof filter === 'function') {
      if (filter.call(this, evt, target, this)) {
        _dispatchEvent({
          sortable: _this,
          rootEl: originalTarget,
          name: 'filter',
          targetEl: target,
          toEl: el,
          fromEl: el
        });
        pluginEvent('filter', _this, {
          evt: evt
        });
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return; // cancel dnd
      }
    } else if (filter) {
      filter = filter.split(',').some(function (criteria) {
        criteria = closest(originalTarget, criteria.trim(), el, false);
        if (criteria) {
          _dispatchEvent({
            sortable: _this,
            rootEl: criteria,
            name: 'filter',
            targetEl: target,
            fromEl: el,
            toEl: el
          });
          pluginEvent('filter', _this, {
            evt: evt
          });
          return true;
        }
      });
      if (filter) {
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return; // cancel dnd
      }
    }

    if (options.handle && !closest(originalTarget, options.handle, el, false)) {
      return;
    } // Prepare `dragstart`

    this._prepareDragStart(evt, touch, target);
  },
  _prepareDragStart: function _prepareDragStart( /** Event */
  evt, /** Touch */
  touch, /** HTMLElement */
  target) {
    var _this = this,
      el = _this.el,
      options = _this.options,
      ownerDocument = el.ownerDocument,
      dragStartFn;
    if (target && !dragEl && target.parentNode === el) {
      var dragRect = getRect(target);
      rootEl = el;
      dragEl = target;
      parentEl = dragEl.parentNode;
      nextEl = dragEl.nextSibling;
      lastDownEl = target;
      activeGroup = options.group;
      Sortable.dragged = dragEl;
      tapEvt = {
        target: dragEl,
        clientX: (touch || evt).clientX,
        clientY: (touch || evt).clientY
      };
      tapDistanceLeft = tapEvt.clientX - dragRect.left;
      tapDistanceTop = tapEvt.clientY - dragRect.top;
      this._lastX = (touch || evt).clientX;
      this._lastY = (touch || evt).clientY;
      dragEl.style['will-change'] = 'all';
      dragStartFn = function dragStartFn() {
        pluginEvent('delayEnded', _this, {
          evt: evt
        });
        if (Sortable.eventCanceled) {
          _this._onDrop();
          return;
        } // Delayed drag has been triggered
        // we can re-enable the events: touchmove/mousemove

        _this._disableDelayedDragEvents();
        if (!FireFox && _this.nativeDraggable) {
          dragEl.draggable = true;
        } // Bind the events: dragstart/dragend

        _this._triggerDragStart(evt, touch); // Drag start event

        _dispatchEvent({
          sortable: _this,
          name: 'choose',
          originalEvent: evt
        }); // Chosen item

        toggleClass$1(dragEl, options.chosenClass, true);
      }; // Disable "draggable"

      options.ignore.split(',').forEach(function (criteria) {
        find(dragEl, criteria.trim(), _disableDraggable);
      });
      on(ownerDocument, 'dragover', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'mousemove', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'touchmove', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'mouseup', _this._onDrop);
      on(ownerDocument, 'touchend', _this._onDrop);
      on(ownerDocument, 'touchcancel', _this._onDrop); // Make dragEl draggable (must be before delay for FireFox)

      if (FireFox && this.nativeDraggable) {
        this.options.touchStartThreshold = 4;
        dragEl.draggable = true;
      }
      pluginEvent('delayStart', this, {
        evt: evt
      }); // Delay is impossible for native DnD in Edge or IE

      if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
        if (Sortable.eventCanceled) {
          this._onDrop();
          return;
        } // If the user moves the pointer or let go the click or touch
        // before the delay has been reached:
        // disable the delayed drag

        on(ownerDocument, 'mouseup', _this._disableDelayedDrag);
        on(ownerDocument, 'touchend', _this._disableDelayedDrag);
        on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);
        on(ownerDocument, 'mousemove', _this._delayedDragTouchMoveHandler);
        on(ownerDocument, 'touchmove', _this._delayedDragTouchMoveHandler);
        options.supportPointer && on(ownerDocument, 'pointermove', _this._delayedDragTouchMoveHandler);
        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
      } else {
        dragStartFn();
      }
    }
  },
  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler( /** TouchEvent|PointerEvent **/
  e) {
    var touch = e.touches ? e.touches[0] : e;
    if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
      this._disableDelayedDrag();
    }
  },
  _disableDelayedDrag: function _disableDelayedDrag() {
    dragEl && _disableDraggable(dragEl);
    clearTimeout(this._dragStartTimer);
    this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function _disableDelayedDragEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, 'mouseup', this._disableDelayedDrag);
    off(ownerDocument, 'touchend', this._disableDelayedDrag);
    off(ownerDocument, 'touchcancel', this._disableDelayedDrag);
    off(ownerDocument, 'mousemove', this._delayedDragTouchMoveHandler);
    off(ownerDocument, 'touchmove', this._delayedDragTouchMoveHandler);
    off(ownerDocument, 'pointermove', this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function _triggerDragStart( /** Event */
  evt, /** Touch */
  touch) {
    touch = touch || evt.pointerType == 'touch' && evt;
    if (!this.nativeDraggable || touch) {
      if (this.options.supportPointer) {
        on(document, 'pointermove', this._onTouchMove);
      } else if (touch) {
        on(document, 'touchmove', this._onTouchMove);
      } else {
        on(document, 'mousemove', this._onTouchMove);
      }
    } else {
      on(dragEl, 'dragend', this);
      on(rootEl, 'dragstart', this._onDragStart);
    }
    try {
      if (document.selection) {
        // Timeout neccessary for IE9
        _nextTick(function () {
          document.selection.empty();
        });
      } else {
        window.getSelection().removeAllRanges();
      }
    } catch (err) {}
  },
  _dragStarted: function _dragStarted(fallback, evt) {
    awaitingDragStarted = false;
    if (rootEl && dragEl) {
      pluginEvent('dragStarted', this, {
        evt: evt
      });
      if (this.nativeDraggable) {
        on(document, 'dragover', _checkOutsideTargetEl);
      }
      var options = this.options; // Apply effect

      !fallback && toggleClass$1(dragEl, options.dragClass, false);
      toggleClass$1(dragEl, options.ghostClass, true);
      Sortable.active = this;
      fallback && this._appendGhost(); // Drag start event

      _dispatchEvent({
        sortable: this,
        name: 'start',
        originalEvent: evt
      });
    } else {
      this._nulling();
    }
  },
  _emulateDragOver: function _emulateDragOver() {
    if (touchEvt) {
      this._lastX = touchEvt.clientX;
      this._lastY = touchEvt.clientY;
      _hideGhostForTarget();
      var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
      var parent = target;
      while (target && target.shadowRoot) {
        target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        if (target === parent) break;
        parent = target;
      }
      dragEl.parentNode[expando]._isOutsideThisEl(target);
      if (parent) {
        do {
          if (parent[expando]) {
            var inserted = void 0;
            inserted = parent[expando]._onDragOver({
              clientX: touchEvt.clientX,
              clientY: touchEvt.clientY,
              target: target,
              rootEl: parent
            });
            if (inserted && !this.options.dragoverBubble) {
              break;
            }
          }
          target = parent; // store last element
        }
        /* jshint boss:true */ while (parent = parent.parentNode);
      }
      _unhideGhostForTarget();
    }
  },
  _onTouchMove: function _onTouchMove( /**TouchEvent*/
  evt) {
    if (tapEvt) {
      var options = this.options,
        fallbackTolerance = options.fallbackTolerance,
        fallbackOffset = options.fallbackOffset,
        touch = evt.touches ? evt.touches[0] : evt,
        ghostMatrix = ghostEl && matrix(ghostEl, true),
        scaleX = ghostEl && ghostMatrix && ghostMatrix.a,
        scaleY = ghostEl && ghostMatrix && ghostMatrix.d,
        relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent),
        dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1),
        dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1); // only set the status to dragging, when we are actually dragging

      if (!Sortable.active && !awaitingDragStarted) {
        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
          return;
        }
        this._onDragStart(evt, true);
      }
      if (ghostEl) {
        if (ghostMatrix) {
          ghostMatrix.e += dx - (lastDx || 0);
          ghostMatrix.f += dy - (lastDy || 0);
        } else {
          ghostMatrix = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: dx,
            f: dy
          };
        }
        var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
        css(ghostEl, 'webkitTransform', cssMatrix);
        css(ghostEl, 'mozTransform', cssMatrix);
        css(ghostEl, 'msTransform', cssMatrix);
        css(ghostEl, 'transform', cssMatrix);
        lastDx = dx;
        lastDy = dy;
        touchEvt = touch;
      }
      evt.cancelable && evt.preventDefault();
    }
  },
  _appendGhost: function _appendGhost() {
    // Bug if using scale(): https://stackoverflow.com/questions/2637058
    // Not being adjusted for
    if (!ghostEl) {
      var container = this.options.fallbackOnBody ? document.body : rootEl,
        rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container),
        options = this.options; // Position absolutely

      if (PositionGhostAbsolutely) {
        // Get relatively positioned parent
        ghostRelativeParent = container;
        while (css(ghostRelativeParent, 'position') === 'static' && css(ghostRelativeParent, 'transform') === 'none' && ghostRelativeParent !== document) {
          ghostRelativeParent = ghostRelativeParent.parentNode;
        }
        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
          if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();
          rect.top += ghostRelativeParent.scrollTop;
          rect.left += ghostRelativeParent.scrollLeft;
        } else {
          ghostRelativeParent = getWindowScrollingElement();
        }
        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
      }
      ghostEl = dragEl.cloneNode(true);
      toggleClass$1(ghostEl, options.ghostClass, false);
      toggleClass$1(ghostEl, options.fallbackClass, true);
      toggleClass$1(ghostEl, options.dragClass, true);
      css(ghostEl, 'transition', '');
      css(ghostEl, 'transform', '');
      css(ghostEl, 'box-sizing', 'border-box');
      css(ghostEl, 'margin', 0);
      css(ghostEl, 'top', rect.top);
      css(ghostEl, 'left', rect.left);
      css(ghostEl, 'width', rect.width);
      css(ghostEl, 'height', rect.height);
      css(ghostEl, 'opacity', '0.8');
      css(ghostEl, 'position', PositionGhostAbsolutely ? 'absolute' : 'fixed');
      css(ghostEl, 'zIndex', '100000');
      css(ghostEl, 'pointerEvents', 'none');
      Sortable.ghost = ghostEl;
      container.appendChild(ghostEl); // Set transform-origin

      css(ghostEl, 'transform-origin', tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + '% ' + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + '%');
    }
  },
  _onDragStart: function _onDragStart( /**Event*/
  evt, /**boolean*/
  fallback) {
    var _this = this;
    var dataTransfer = evt.dataTransfer;
    var options = _this.options;
    pluginEvent('dragStart', this, {
      evt: evt
    });
    if (Sortable.eventCanceled) {
      this._onDrop();
      return;
    }
    pluginEvent('setupClone', this);
    if (!Sortable.eventCanceled) {
      cloneEl = clone(dragEl);
      cloneEl.removeAttribute("id");
      cloneEl.draggable = false;
      cloneEl.style['will-change'] = '';
      this._hideClone();
      toggleClass$1(cloneEl, this.options.chosenClass, false);
      Sortable.clone = cloneEl;
    } // #1143: IFrame support workaround

    _this.cloneId = _nextTick(function () {
      pluginEvent('clone', _this);
      if (Sortable.eventCanceled) return;
      if (!_this.options.removeCloneOnHide) {
        rootEl.insertBefore(cloneEl, dragEl);
      }
      _this._hideClone();
      _dispatchEvent({
        sortable: _this,
        name: 'clone'
      });
    });
    !fallback && toggleClass$1(dragEl, options.dragClass, true); // Set proper drop events

    if (fallback) {
      ignoreNextClick = true;
      _this._loopId = setInterval(_this._emulateDragOver, 50);
    } else {
      // Undo what was set in _prepareDragStart before drag started
      off(document, 'mouseup', _this._onDrop);
      off(document, 'touchend', _this._onDrop);
      off(document, 'touchcancel', _this._onDrop);
      if (dataTransfer) {
        dataTransfer.effectAllowed = 'move';
        options.setData && options.setData.call(_this, dataTransfer, dragEl);
      }
      on(document, 'drop', _this); // #1276 fix:

      css(dragEl, 'transform', 'translateZ(0)');
    }
    awaitingDragStarted = true;
    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
    on(document, 'selectstart', _this);
    moved = true;
    if (Safari) {
      css(document.body, 'user-select', 'none');
    }
  },
  // Returns true - if no further action is needed (either inserted or another condition)
  _onDragOver: function _onDragOver( /**Event*/
  evt) {
    var el = this.el,
      target = evt.target,
      dragRect,
      targetRect,
      revert,
      options = this.options,
      group = options.group,
      activeSortable = Sortable.active,
      isOwner = activeGroup === group,
      canSort = options.sort,
      fromSortable = putSortable || activeSortable,
      vertical,
      _this = this,
      completedFired = false;
    if (_silent) return;
    function dragOverEvent(name, extra) {
      pluginEvent(name, _this, _objectSpread2({
        evt: evt,
        isOwner: isOwner,
        axis: vertical ? 'vertical' : 'horizontal',
        revert: revert,
        dragRect: dragRect,
        targetRect: targetRect,
        canSort: canSort,
        fromSortable: fromSortable,
        target: target,
        completed: completed,
        onMove: function onMove(target, after) {
          return _onMove(rootEl, el, dragEl, dragRect, target, getRect(target), evt, after);
        },
        changed: changed
      }, extra));
    } // Capture animation state

    function capture() {
      dragOverEvent('dragOverAnimationCapture');
      _this.captureAnimationState();
      if (_this !== fromSortable) {
        fromSortable.captureAnimationState();
      }
    } // Return invocation when dragEl is inserted (or completed)

    function completed(insertion) {
      dragOverEvent('dragOverCompleted', {
        insertion: insertion
      });
      if (insertion) {
        // Clones must be hidden before folding animation to capture dragRectAbsolute properly
        if (isOwner) {
          activeSortable._hideClone();
        } else {
          activeSortable._showClone(_this);
        }
        if (_this !== fromSortable) {
          // Set ghost class to new sortable's ghost class
          toggleClass$1(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
          toggleClass$1(dragEl, options.ghostClass, true);
        }
        if (putSortable !== _this && _this !== Sortable.active) {
          putSortable = _this;
        } else if (_this === Sortable.active && putSortable) {
          putSortable = null;
        } // Animation

        if (fromSortable === _this) {
          _this._ignoreWhileAnimating = target;
        }
        _this.animateAll(function () {
          dragOverEvent('dragOverAnimationComplete');
          _this._ignoreWhileAnimating = null;
        });
        if (_this !== fromSortable) {
          fromSortable.animateAll();
          fromSortable._ignoreWhileAnimating = null;
        }
      } // Null lastTarget if it is not inside a previously swapped element

      if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
        lastTarget = null;
      } // no bubbling and not fallback

      if (!options.dragoverBubble && !evt.rootEl && target !== document) {
        dragEl.parentNode[expando]._isOutsideThisEl(evt.target); // Do not detect for empty insert if already inserted

        !insertion && nearestEmptyInsertDetectEvent(evt);
      }
      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
      return completedFired = true;
    } // Call when dragEl has been inserted

    function changed() {
      newIndex = index$1(dragEl);
      newDraggableIndex = index$1(dragEl, options.draggable);
      _dispatchEvent({
        sortable: _this,
        name: 'change',
        toEl: el,
        newIndex: newIndex,
        newDraggableIndex: newDraggableIndex,
        originalEvent: evt
      });
    }
    if (evt.preventDefault !== void 0) {
      evt.cancelable && evt.preventDefault();
    }
    target = closest(target, options.draggable, el, true);
    dragOverEvent('dragOver');
    if (Sortable.eventCanceled) return completedFired;
    if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
      return completed(false);
    }
    ignoreNextClick = false;
    if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) // Reverting item into the original list
    : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
      vertical = this._getDirection(evt, target) === 'vertical';
      dragRect = getRect(dragEl);
      dragOverEvent('dragOverValid');
      if (Sortable.eventCanceled) return completedFired;
      if (revert) {
        parentEl = rootEl; // actualization

        capture();
        this._hideClone();
        dragOverEvent('revert');
        if (!Sortable.eventCanceled) {
          if (nextEl) {
            rootEl.insertBefore(dragEl, nextEl);
          } else {
            rootEl.appendChild(dragEl);
          }
        }
        return completed(true);
      }
      var elLastChild = lastChild(el, options.draggable);
      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
        // Insert to end of list
        // If already at end of list: Do not insert
        if (elLastChild === dragEl) {
          return completed(false);
        } // if there is a last element, it is the target

        if (elLastChild && el === evt.target) {
          target = elLastChild;
        }
        if (target) {
          targetRect = getRect(target);
        }
        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
          capture();
          if (elLastChild && elLastChild.nextSibling) {
            // the last draggable element is not the last node
            el.insertBefore(dragEl, elLastChild.nextSibling);
          } else {
            el.appendChild(dragEl);
          }
          parentEl = el; // actualization

          changed();
          return completed(true);
        }
      } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
        // Insert to start of list
        var firstChild = getChild(el, 0, options, true);
        if (firstChild === dragEl) {
          return completed(false);
        }
        target = firstChild;
        targetRect = getRect(target);
        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {
          capture();
          el.insertBefore(dragEl, firstChild);
          parentEl = el; // actualization

          changed();
          return completed(true);
        }
      } else if (target.parentNode === el) {
        targetRect = getRect(target);
        var direction = 0,
          targetBeforeFirstSwap,
          differentLevel = dragEl.parentNode !== el,
          differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical),
          side1 = vertical ? 'top' : 'left',
          scrolledPastTop = isScrolledPast(target, 'top', 'top') || isScrolledPast(dragEl, 'top', 'top'),
          scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;
        if (lastTarget !== target) {
          targetBeforeFirstSwap = targetRect[side1];
          pastFirstInvertThresh = false;
          isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
        }
        direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
        var sibling;
        if (direction !== 0) {
          // Check if target is beside dragEl in respective direction (ignoring hidden elements)
          var dragIndex = index$1(dragEl);
          do {
            dragIndex -= direction;
            sibling = parentEl.children[dragIndex];
          } while (sibling && (css(sibling, 'display') === 'none' || sibling === ghostEl));
        } // If dragEl is already beside target: Do not insert

        if (direction === 0 || sibling === target) {
          return completed(false);
        }
        lastTarget = target;
        lastDirection = direction;
        var nextSibling = target.nextElementSibling,
          after = false;
        after = direction === 1;
        var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);
        if (moveVector !== false) {
          if (moveVector === 1 || moveVector === -1) {
            after = moveVector === 1;
          }
          _silent = true;
          setTimeout(_unsilent, 30);
          capture();
          if (after && !nextSibling) {
            el.appendChild(dragEl);
          } else {
            target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
          } // Undo chrome's scroll adjustment (has no effect on other browsers)

          if (scrolledPastTop) {
            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
          }
          parentEl = dragEl.parentNode; // actualization
          // must be done before animation

          if (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {
            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
          }
          changed();
          return completed(true);
        }
      }
      if (el.contains(dragEl)) {
        return completed(false);
      }
    }
    return false;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function _offMoveEvents() {
    off(document, 'mousemove', this._onTouchMove);
    off(document, 'touchmove', this._onTouchMove);
    off(document, 'pointermove', this._onTouchMove);
    off(document, 'dragover', nearestEmptyInsertDetectEvent);
    off(document, 'mousemove', nearestEmptyInsertDetectEvent);
    off(document, 'touchmove', nearestEmptyInsertDetectEvent);
  },
  _offUpEvents: function _offUpEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, 'mouseup', this._onDrop);
    off(ownerDocument, 'touchend', this._onDrop);
    off(ownerDocument, 'pointerup', this._onDrop);
    off(ownerDocument, 'touchcancel', this._onDrop);
    off(document, 'selectstart', this);
  },
  _onDrop: function _onDrop( /**Event*/
  evt) {
    var el = this.el,
      options = this.options; // Get the index of the dragged element within its parent

    newIndex = index$1(dragEl);
    newDraggableIndex = index$1(dragEl, options.draggable);
    pluginEvent('drop', this, {
      evt: evt
    });
    parentEl = dragEl && dragEl.parentNode; // Get again after plugin event

    newIndex = index$1(dragEl);
    newDraggableIndex = index$1(dragEl, options.draggable);
    if (Sortable.eventCanceled) {
      this._nulling();
      return;
    }
    awaitingDragStarted = false;
    isCircumstantialInvert = false;
    pastFirstInvertThresh = false;
    clearInterval(this._loopId);
    clearTimeout(this._dragStartTimer);
    _cancelNextTick(this.cloneId);
    _cancelNextTick(this._dragStartId); // Unbind events

    if (this.nativeDraggable) {
      off(document, 'drop', this);
      off(el, 'dragstart', this._onDragStart);
    }
    this._offMoveEvents();
    this._offUpEvents();
    if (Safari) {
      css(document.body, 'user-select', '');
    }
    css(dragEl, 'transform', '');
    if (evt) {
      if (moved) {
        evt.cancelable && evt.preventDefault();
        !options.dropBubble && evt.stopPropagation();
      }
      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);
      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {
        // Remove clone(s)
        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
      }
      if (dragEl) {
        if (this.nativeDraggable) {
          off(dragEl, 'dragend', this);
        }
        _disableDraggable(dragEl);
        dragEl.style['will-change'] = ''; // Remove classes
        // ghostClass is added in dragStarted

        if (moved && !awaitingDragStarted) {
          toggleClass$1(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
        }
        toggleClass$1(dragEl, this.options.chosenClass, false); // Drag stop event

        _dispatchEvent({
          sortable: this,
          name: 'unchoose',
          toEl: parentEl,
          newIndex: null,
          newDraggableIndex: null,
          originalEvent: evt
        });
        if (rootEl !== parentEl) {
          if (newIndex >= 0) {
            // Add event
            _dispatchEvent({
              rootEl: parentEl,
              name: 'add',
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            }); // Remove event

            _dispatchEvent({
              sortable: this,
              name: 'remove',
              toEl: parentEl,
              originalEvent: evt
            }); // drag from one list and drop into another

            _dispatchEvent({
              rootEl: parentEl,
              name: 'sort',
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: 'sort',
              toEl: parentEl,
              originalEvent: evt
            });
          }
          putSortable && putSortable.save();
        } else {
          if (newIndex !== oldIndex) {
            if (newIndex >= 0) {
              // drag & drop within the same list
              _dispatchEvent({
                sortable: this,
                name: 'update',
                toEl: parentEl,
                originalEvent: evt
              });
              _dispatchEvent({
                sortable: this,
                name: 'sort',
                toEl: parentEl,
                originalEvent: evt
              });
            }
          }
        }
        if (Sortable.active) {
          /* jshint eqnull:true */
          if (newIndex == null || newIndex === -1) {
            newIndex = oldIndex;
            newDraggableIndex = oldDraggableIndex;
          }
          _dispatchEvent({
            sortable: this,
            name: 'end',
            toEl: parentEl,
            originalEvent: evt
          }); // Save sorting

          this.save();
        }
      }
    }
    this._nulling();
  },
  _nulling: function _nulling() {
    pluginEvent('nulling', this);
    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
    savedInputChecked.forEach(function (el) {
      el.checked = true;
    });
    savedInputChecked.length = lastDx = lastDy = 0;
  },
  handleEvent: function handleEvent( /**Event*/
  evt) {
    switch (evt.type) {
      case 'drop':
      case 'dragend':
        this._onDrop(evt);
        break;
      case 'dragenter':
      case 'dragover':
        if (dragEl) {
          this._onDragOver(evt);
          _globalDragOver(evt);
        }
        break;
      case 'selectstart':
        evt.preventDefault();
        break;
    }
  },
  /**
   * Serializes the item into an array of string.
   * @returns {String[]}
   */
  toArray: function toArray() {
    var order = [],
      el,
      children = this.el.children,
      i = 0,
      n = children.length,
      options = this.options;
    for (; i < n; i++) {
      el = children[i];
      if (closest(el, options.draggable, this.el, false)) {
        order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
      }
    }
    return order;
  },
  /**
   * Sorts the elements according to the array.
   * @param  {String[]}  order  order of the items
   */
  sort: function sort(order, useAnimation) {
    var items = {},
      rootEl = this.el;
    this.toArray().forEach(function (id, i) {
      var el = rootEl.children[i];
      if (closest(el, this.options.draggable, rootEl, false)) {
        items[id] = el;
      }
    }, this);
    useAnimation && this.captureAnimationState();
    order.forEach(function (id) {
      if (items[id]) {
        rootEl.removeChild(items[id]);
        rootEl.appendChild(items[id]);
      }
    });
    useAnimation && this.animateAll();
  },
  /**
   * Save the current sorting
   */
  save: function save() {
    var store = this.options.store;
    store && store.set && store.set(this);
  },
  /**
   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
   * @param   {HTMLElement}  el
   * @param   {String}       [selector]  default: `options.draggable`
   * @returns {HTMLElement|null}
   */
  closest: function closest$1(el, selector) {
    return closest(el, selector || this.options.draggable, this.el, false);
  },
  /**
   * Set/get option
   * @param   {string} name
   * @param   {*}      [value]
   * @returns {*}
   */
  option: function option(name, value) {
    var options = this.options;
    if (value === void 0) {
      return options[name];
    } else {
      var modifiedValue = PluginManager.modifyOption(this, name, value);
      if (typeof modifiedValue !== 'undefined') {
        options[name] = modifiedValue;
      } else {
        options[name] = value;
      }
      if (name === 'group') {
        _prepareGroup(options);
      }
    }
  },
  /**
   * Destroy
   */
  destroy: function destroy() {
    pluginEvent('destroy', this);
    var el = this.el;
    el[expando] = null;
    off(el, 'mousedown', this._onTapStart);
    off(el, 'touchstart', this._onTapStart);
    off(el, 'pointerdown', this._onTapStart);
    if (this.nativeDraggable) {
      off(el, 'dragover', this);
      off(el, 'dragenter', this);
    } // Remove draggable attributes

    Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {
      el.removeAttribute('draggable');
    });
    this._onDrop();
    this._disableDelayedDragEvents();
    sortables.splice(sortables.indexOf(this.el), 1);
    this.el = el = null;
  },
  _hideClone: function _hideClone() {
    if (!cloneHidden) {
      pluginEvent('hideClone', this);
      if (Sortable.eventCanceled) return;
      css(cloneEl, 'display', 'none');
      if (this.options.removeCloneOnHide && cloneEl.parentNode) {
        cloneEl.parentNode.removeChild(cloneEl);
      }
      cloneHidden = true;
    }
  },
  _showClone: function _showClone(putSortable) {
    if (putSortable.lastPutMode !== 'clone') {
      this._hideClone();
      return;
    }
    if (cloneHidden) {
      pluginEvent('showClone', this);
      if (Sortable.eventCanceled) return; // show clone at dragEl or original position

      if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
        rootEl.insertBefore(cloneEl, dragEl);
      } else if (nextEl) {
        rootEl.insertBefore(cloneEl, nextEl);
      } else {
        rootEl.appendChild(cloneEl);
      }
      if (this.options.group.revertClone) {
        this.animate(dragEl, cloneEl);
      }
      css(cloneEl, 'display', '');
      cloneHidden = false;
    }
  }
};
function _globalDragOver( /**Event*/
evt) {
  if (evt.dataTransfer) {
    evt.dataTransfer.dropEffect = 'move';
  }
  evt.cancelable && evt.preventDefault();
}
function _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
  var evt,
    sortable = fromEl[expando],
    onMoveFn = sortable.options.onMove,
    retVal; // Support for new CustomEvent feature

  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent('move', {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent('Event');
    evt.initEvent('move', true, true);
  }
  evt.to = toEl;
  evt.from = fromEl;
  evt.dragged = dragEl;
  evt.draggedRect = dragRect;
  evt.related = targetEl || toEl;
  evt.relatedRect = targetRect || getRect(toEl);
  evt.willInsertAfter = willInsertAfter;
  evt.originalEvent = originalEvent;
  fromEl.dispatchEvent(evt);
  if (onMoveFn) {
    retVal = onMoveFn.call(sortable, evt, originalEvent);
  }
  return retVal;
}
function _disableDraggable(el) {
  el.draggable = false;
}
function _unsilent() {
  _silent = false;
}
function _ghostIsFirst(evt, vertical, sortable) {
  var rect = getRect(getChild(sortable.el, 0, sortable.options, true));
  var spacer = 10;
  return vertical ? evt.clientX < rect.left - spacer || evt.clientY < rect.top && evt.clientX < rect.right : evt.clientY < rect.top - spacer || evt.clientY < rect.bottom && evt.clientX < rect.left;
}
function _ghostIsLast(evt, vertical, sortable) {
  var rect = getRect(lastChild(sortable.el, sortable.options.draggable));
  var spacer = 10;
  return vertical ? evt.clientX > rect.right + spacer || evt.clientX <= rect.right && evt.clientY > rect.bottom && evt.clientX >= rect.left : evt.clientX > rect.right && evt.clientY > rect.top || evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer;
}
function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
  var mouseOnAxis = vertical ? evt.clientY : evt.clientX,
    targetLength = vertical ? targetRect.height : targetRect.width,
    targetS1 = vertical ? targetRect.top : targetRect.left,
    targetS2 = vertical ? targetRect.bottom : targetRect.right,
    invert = false;
  if (!invertSwap) {
    // Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold
    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
      // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2
      // check if past first invert threshold on side opposite of lastDirection
      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
        // past first invert threshold, do not restrict inverted threshold to dragEl shadow
        pastFirstInvertThresh = true;
      }
      if (!pastFirstInvertThresh) {
        // dragEl shadow (target move distance shadow)
        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow
        : mouseOnAxis > targetS2 - targetMoveDistance) {
          return -lastDirection;
        }
      } else {
        invert = true;
      }
    } else {
      // Regular
      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
        return _getInsertDirection(target);
      }
    }
  }
  invert = invert || invertSwap;
  if (invert) {
    // Invert of regular
    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
    }
  }
  return 0;
}
/**
 * Gets the direction dragEl must be swapped relative to target in order to make it
 * seem that dragEl has been "inserted" into that element's position
 * @param  {HTMLElement} target       The target whose position dragEl is being inserted at
 * @return {Number}                   Direction dragEl must be swapped
 */

function _getInsertDirection(target) {
  if (index$1(dragEl) < index$1(target)) {
    return 1;
  } else {
    return -1;
  }
}
/**
 * Generate id
 * @param   {HTMLElement} el
 * @returns {String}
 * @private
 */

function _generateId(el) {
  var str = el.tagName + el.className + el.src + el.href + el.textContent,
    i = str.length,
    sum = 0;
  while (i--) {
    sum += str.charCodeAt(i);
  }
  return sum.toString(36);
}
function _saveInputCheckedState(root) {
  savedInputChecked.length = 0;
  var inputs = root.getElementsByTagName('input');
  var idx = inputs.length;
  while (idx--) {
    var el = inputs[idx];
    el.checked && savedInputChecked.push(el);
  }
}
function _nextTick(fn) {
  return setTimeout(fn, 0);
}
function _cancelNextTick(id) {
  return clearTimeout(id);
} // Fixed #973:

if (documentExists) {
  on(document, 'touchmove', function (evt) {
    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
      evt.preventDefault();
    }
  });
} // Export utils

Sortable.utils = {
  on: on,
  off: off,
  css: css,
  find: find,
  is: function is(el, selector) {
    return !!closest(el, selector, el, false);
  },
  extend: extend$1,
  throttle: throttle,
  closest: closest,
  toggleClass: toggleClass$1,
  clone: clone,
  index: index$1,
  nextTick: _nextTick,
  cancelNextTick: _cancelNextTick,
  detectDirection: _detectDirection,
  getChild: getChild
};
/**
 * Get the Sortable instance of an element
 * @param  {HTMLElement} element The element
 * @return {Sortable|undefined}         The instance of Sortable
 */

Sortable.get = function (element) {
  return element[expando];
};
/**
 * Mount a plugin to Sortable
 * @param  {...SortablePlugin|SortablePlugin[]} plugins       Plugins being mounted
 */

Sortable.mount = function () {
  for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
    plugins[_key] = arguments[_key];
  }
  if (plugins[0].constructor === Array) plugins = plugins[0];
  plugins.forEach(function (plugin) {
    if (!plugin.prototype || !plugin.prototype.constructor) {
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
    }
    if (plugin.utils) Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);
    PluginManager.mount(plugin);
  });
};
/**
 * Create sortable instance
 * @param {HTMLElement}  el
 * @param {Object}      [options]
 */

Sortable.create = function (el, options) {
  return new Sortable(el, options);
}; // Export

Sortable.version = version;
var autoScrolls = [],
  scrollEl,
  scrollRootEl,
  scrolling = false,
  lastAutoScrollX,
  lastAutoScrollY,
  touchEvt$1,
  pointerElemChangedInterval;
function AutoScrollPlugin() {
  function AutoScroll() {
    this.defaults = {
      scroll: true,
      forceAutoScrollFallback: false,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: true
    }; // Bind all private methods

    for (var fn in this) {
      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
        this[fn] = this[fn].bind(this);
      }
    }
  }
  AutoScroll.prototype = {
    dragStarted: function dragStarted(_ref) {
      var originalEvent = _ref.originalEvent;
      if (this.sortable.nativeDraggable) {
        on(document, 'dragover', this._handleAutoScroll);
      } else {
        if (this.options.supportPointer) {
          on(document, 'pointermove', this._handleFallbackAutoScroll);
        } else if (originalEvent.touches) {
          on(document, 'touchmove', this._handleFallbackAutoScroll);
        } else {
          on(document, 'mousemove', this._handleFallbackAutoScroll);
        }
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref2) {
      var originalEvent = _ref2.originalEvent;

      // For when bubbling is canceled and using fallback (fallback 'touchmove' always reached)
      if (!this.options.dragOverBubble && !originalEvent.rootEl) {
        this._handleAutoScroll(originalEvent);
      }
    },
    drop: function drop() {
      if (this.sortable.nativeDraggable) {
        off(document, 'dragover', this._handleAutoScroll);
      } else {
        off(document, 'pointermove', this._handleFallbackAutoScroll);
        off(document, 'touchmove', this._handleFallbackAutoScroll);
        off(document, 'mousemove', this._handleFallbackAutoScroll);
      }
      clearPointerElemChangedInterval();
      clearAutoScrolls();
      cancelThrottle();
    },
    nulling: function nulling() {
      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
      autoScrolls.length = 0;
    },
    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
      this._handleAutoScroll(evt, true);
    },
    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
      var _this = this;
      var x = (evt.touches ? evt.touches[0] : evt).clientX,
        y = (evt.touches ? evt.touches[0] : evt).clientY,
        elem = document.elementFromPoint(x, y);
      touchEvt$1 = evt; // IE does not seem to have native autoscroll,
      // Edge's autoscroll seems too conditional,
      // MACOS Safari does not have autoscroll,
      // Firefox and Chrome are good

      if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
        autoScroll(evt, this.options, elem, fallback); // Listener for pointer element change

        var ogElemScroller = getParentAutoScrollElement(elem, true);
        if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {
          pointerElemChangedInterval && clearPointerElemChangedInterval(); // Detect for pointer elem change, emulating native DnD behaviour

          pointerElemChangedInterval = setInterval(function () {
            var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);
            if (newElem !== ogElemScroller) {
              ogElemScroller = newElem;
              clearAutoScrolls();
            }
            autoScroll(evt, _this.options, newElem, fallback);
          }, 10);
          lastAutoScrollX = x;
          lastAutoScrollY = y;
        }
      } else {
        // if DnD is enabled (and browser has good autoscrolling), first autoscroll will already scroll, so get parent autoscroll of first autoscroll
        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
          clearAutoScrolls();
          return;
        }
        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
      }
    }
  };
  return _extends(AutoScroll, {
    pluginName: 'scroll',
    initializeByDefault: true
  });
}
function clearAutoScrolls() {
  autoScrolls.forEach(function (autoScroll) {
    clearInterval(autoScroll.pid);
  });
  autoScrolls = [];
}
function clearPointerElemChangedInterval() {
  clearInterval(pointerElemChangedInterval);
}
var autoScroll = throttle(function (evt, options, rootEl, isFallback) {
  // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521
  if (!options.scroll) return;
  var x = (evt.touches ? evt.touches[0] : evt).clientX,
    y = (evt.touches ? evt.touches[0] : evt).clientY,
    sens = options.scrollSensitivity,
    speed = options.scrollSpeed,
    winScroller = getWindowScrollingElement();
  var scrollThisInstance = false,
    scrollCustomFn; // New scroll root, set scrollEl

  if (scrollRootEl !== rootEl) {
    scrollRootEl = rootEl;
    clearAutoScrolls();
    scrollEl = options.scroll;
    scrollCustomFn = options.scrollFn;
    if (scrollEl === true) {
      scrollEl = getParentAutoScrollElement(rootEl, true);
    }
  }
  var layersOut = 0;
  var currentParent = scrollEl;
  do {
    var el = currentParent,
      rect = getRect(el),
      top = rect.top,
      bottom = rect.bottom,
      left = rect.left,
      right = rect.right,
      width = rect.width,
      height = rect.height,
      canScrollX = void 0,
      canScrollY = void 0,
      scrollWidth = el.scrollWidth,
      scrollHeight = el.scrollHeight,
      elCSS = css(el),
      scrollPosX = el.scrollLeft,
      scrollPosY = el.scrollTop;
    if (el === winScroller) {
      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll' || elCSS.overflowX === 'visible');
      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll' || elCSS.overflowY === 'visible');
    } else {
      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll');
      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll');
    }
    var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);
    var vy = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);
    if (!autoScrolls[layersOut]) {
      for (var i = 0; i <= layersOut; i++) {
        if (!autoScrolls[i]) {
          autoScrolls[i] = {};
        }
      }
    }
    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
      autoScrolls[layersOut].el = el;
      autoScrolls[layersOut].vx = vx;
      autoScrolls[layersOut].vy = vy;
      clearInterval(autoScrolls[layersOut].pid);
      if (vx != 0 || vy != 0) {
        scrollThisInstance = true;
        /* jshint loopfunc:true */

        autoScrolls[layersOut].pid = setInterval(function () {
          // emulate drag over during autoscroll (fallback), emulating native DnD behaviour
          if (isFallback && this.layer === 0) {
            Sortable.active._onTouchMove(touchEvt$1); // To move ghost if it is positioned absolutely
          }

          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;
          if (typeof scrollCustomFn === 'function') {
            if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== 'continue') {
              return;
            }
          }
          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
        }.bind({
          layer: layersOut
        }), 24);
      }
    }
    layersOut++;
  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));
  scrolling = scrollThisInstance; // in case another function catches scrolling as false in between when it is not
}, 30);
var drop = function drop(_ref) {
  var originalEvent = _ref.originalEvent,
    putSortable = _ref.putSortable,
    dragEl = _ref.dragEl,
    activeSortable = _ref.activeSortable,
    dispatchSortableEvent = _ref.dispatchSortableEvent,
    hideGhostForTarget = _ref.hideGhostForTarget,
    unhideGhostForTarget = _ref.unhideGhostForTarget;
  if (!originalEvent) return;
  var toSortable = putSortable || activeSortable;
  hideGhostForTarget();
  var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
  var target = document.elementFromPoint(touch.clientX, touch.clientY);
  unhideGhostForTarget();
  if (toSortable && !toSortable.el.contains(target)) {
    dispatchSortableEvent('spill');
    this.onSpill({
      dragEl: dragEl,
      putSortable: putSortable
    });
  }
};
function Revert() {}
Revert.prototype = {
  startIndex: null,
  dragStart: function dragStart(_ref2) {
    var oldDraggableIndex = _ref2.oldDraggableIndex;
    this.startIndex = oldDraggableIndex;
  },
  onSpill: function onSpill(_ref3) {
    var dragEl = _ref3.dragEl,
      putSortable = _ref3.putSortable;
    this.sortable.captureAnimationState();
    if (putSortable) {
      putSortable.captureAnimationState();
    }
    var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);
    if (nextSibling) {
      this.sortable.el.insertBefore(dragEl, nextSibling);
    } else {
      this.sortable.el.appendChild(dragEl);
    }
    this.sortable.animateAll();
    if (putSortable) {
      putSortable.animateAll();
    }
  },
  drop: drop
};
_extends(Revert, {
  pluginName: 'revertOnSpill'
});
function Remove() {}
Remove.prototype = {
  onSpill: function onSpill(_ref4) {
    var dragEl = _ref4.dragEl,
      putSortable = _ref4.putSortable;
    var parentSortable = putSortable || this.sortable;
    parentSortable.captureAnimationState();
    dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);
    parentSortable.animateAll();
  },
  drop: drop
};
_extends(Remove, {
  pluginName: 'removeOnSpill'
});
Sortable.mount(new AutoScrollPlugin());
Sortable.mount(Remove, Revert);

//
// Inspired by https://gorails.com/episodes/rails-drag-and-drop-sortable
//
// Annotate html as follows:
//
// <div data-controller="sortable" data-sortable-url=move_some_resource_path(id: ":id")>
//   <% items.each do |item| %>
//     <div data-id=item.id>...</div>
//   <% end %>
// </div>
var _default$g = /*#__PURE__*/function (_Controller) {
  _inherits$w(_default, _Controller);
  var _super = _createSuper$w(_default);
  function _default() {
    _classCallCheck$x(this, _default);
    return _super.apply(this, arguments);
  }
  _createClass$x(_default, [{
    key: "connect",
    value: function connect() {
      this.sortable = Sortable.create(this.element, {
        handle: ".handle",
        animation: 150,
        onEnd: this.end.bind(this)
      });
    }
  }, {
    key: "end",
    value: function end(event) {
      var url = this.data.get("url");

      // No direct server persistance
      if (!url) return;
      var id = event.item.dataset.id;
      var data = new FormData();
      data.append("position", event.newIndex + 1);
      Rails.ajax({
        url: url.replace(":id", id),
        type: "PATCH",
        data: data
      });
    }
  }]);
  return _default;
}(Controller);

var Rails$1 = window.Rails;
var _default$f = /*#__PURE__*/function (_Controller) {
  _inherits$w(_default, _Controller);
  var _super = _createSuper$w(_default);
  function _default() {
    _classCallCheck$x(this, _default);
    return _super.apply(this, arguments);
  }
  _createClass$x(_default, [{
    key: "refresh",
    value: function refresh(event) {
      event.preventDefault();
      var selectedOption = this.element.options[this.element.selectedIndex];
      var url = selectedOption.dataset.source;
      Rails$1.ajax({
        type: "GET",
        url: url,
        dataType: "application/js"
      });
    }

    /*
    When each option in a select has data-show and/or data-hide attributes
    specifying the ids (currently only one id supported) of elements to show or
    hide. Used for example when selecting an option should show a certain UI element
    and other options should hide it. Used e.g. on the AKI alerts filter form for the
    specific data option.
    */
  }, {
    key: "showhide",
    value: function showhide(event) {
      var _document$querySelect, _document$querySelect2;
      var selectedOption = this.element.options[this.element.selectedIndex];
      var idsToShow = selectedOption.dataset.show;
      var idsToHide = selectedOption.dataset.hide;
      (_document$querySelect = document.querySelector("#" + idsToShow)) === null || _document$querySelect === void 0 ? void 0 : _document$querySelect.classList.remove("hidden");
      (_document$querySelect2 = document.querySelector("#" + idsToHide)) === null || _document$querySelect2 === void 0 ? void 0 : _document$querySelect2.classList.add("hidden");
    }
  }]);
  return _default;
}(Controller);

// Set all radio inputs within the controller's element to checked if their
// value = matchValue (eg "no" in the case of tristate Yes No Uknown radio
// groups).
// Example usage:
// div(data-controller="radio-reset" data-radio-reset-match-value="no")
//   input(type="radio" value="yes" ..)
//   input(type="radio" value="no" ..)
//   ...
var _default$e = /*#__PURE__*/function (_Controller) {
  _inherits$w(_default, _Controller);
  var _super = _createSuper$w(_default);
  function _default() {
    _classCallCheck$x(this, _default);
    return _super.apply(this, arguments);
  }
  _createClass$x(_default, [{
    key: "reset_all",
    value: function reset_all(event) {
      var that = this;
      var radioInputs = Array.prototype.slice.call(this.element.querySelectorAll("input[type='radio']"));
      radioInputs.forEach(function (a) {
        if (a.value == that.matchValue) {
          a.checked = true;
        }
      });
    }
  }]);
  return _default;
}(Controller);
_defineProperty$x(_default$e, "values", {
  match: String
});

var _default$d = /*#__PURE__*/function (_Controller) {
  _inherits$w(_default, _Controller);
  var _super = _createSuper$w(_default);
  function _default() {
    _classCallCheck$x(this, _default);
    return _super.apply(this, arguments);
  }
  _createClass$x(_default, [{
    key: "showhide",
    value:
    // element we are going to show/hide
    // attributeToTest: Name of the boolean data attribute on the selected option that determines if
    //                  the displayable target shoule be visible or not

    /*
    For a SELECT, find the chosen option, and the data atribute we need (a boolean eg "true" whose
    name is in the attributeToTest value).  Hide or show the target element according to the boolean
    'test' attribute.
    */
    function showhide(event) {
      event.preventDefault();
      if (event.target.tagName.toUpperCase() == "SELECT") {
        var selectedOption = event.target.options[event.target.selectedIndex];
        var display = selectedOption.dataset[this.attributeToTestValue] == "true" ? "block" : "none";
        this.displayableTarget.style.display = display;
      }
    }
  }]);
  return _default;
}(Controller);
_defineProperty$x(_default$d, "targets", ["displayable"]);
_defineProperty$x(_default$d, "values", {
  attributeToTest: String
});

function generateID() {
  return Math.random().toString(36).substring(2, 10);
}
function hasClassInTree(element, className) {
  function hasClass(e, c) {
    if (c && e && e.classList && e.classList.contains(c)) {
      return e;
    }
    if (c && e && e.dataset && e.dataset.id && e.dataset.id === className) {
      return e;
    }
    return null;
  }
  function parentByClass(e, c) {
    if (!e || e === document) {
      return null;
    } else if (hasClass(e, c)) {
      return e;
    } else {
      return parentByClass(e.parentNode, c);
    }
  }
  return hasClass(element, className) || parentByClass(element, className);
}
function debounce$2(func, wait = 50, immediate = false) {
  let timeout;
  return function (...args) {
    const context = self;
    const later = () => {
      timeout = null;
      if (!immediate) {
        func.apply(context, args);
      }
    };
    const callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow) {
      func.apply(context, args);
    }
  };
}
function isEqual(a, b) {
  return JSON.stringify(a) === JSON.stringify(b);
}
function kebabCase(str) {
  const result = str.replace(/[A-Z\u00C0-\u00D6\u00D8-\u00DE]/g, match => '-' + match.toLowerCase());
  return str[0] === str[0].toUpperCase() ? result.substring(1) : result;
}
class Settings {
  constructor(settings) {
    this.id = '';
    this.style = '';
    this.class = [];
    this.isMultiple = false;
    this.isOpen = false;
    this.isFullOpen = false;
    this.intervalMove = null;
    if (!settings) {
      settings = {};
    }
    this.id = 'ss-' + generateID();
    this.style = settings.style || '';
    this.class = settings.class || [];
    this.disabled = settings.disabled !== undefined ? settings.disabled : false;
    this.alwaysOpen = settings.alwaysOpen !== undefined ? settings.alwaysOpen : false;
    this.showSearch = settings.showSearch !== undefined ? settings.showSearch : true;
    this.searchPlaceholder = settings.searchPlaceholder || 'Search';
    this.searchText = settings.searchText || 'No Results';
    this.searchingText = settings.searchingText || 'Searching...';
    this.searchHighlight = settings.searchHighlight !== undefined ? settings.searchHighlight : false;
    this.closeOnSelect = settings.closeOnSelect !== undefined ? settings.closeOnSelect : true;
    this.contentLocation = settings.contentLocation || document.body;
    this.contentPosition = settings.contentPosition || 'absolute';
    this.openPosition = settings.openPosition || 'auto';
    this.placeholderText = settings.placeholderText !== undefined ? settings.placeholderText : 'Select Value';
    this.allowDeselect = settings.allowDeselect !== undefined ? settings.allowDeselect : false;
    this.hideSelected = settings.hideSelected !== undefined ? settings.hideSelected : false;
    this.showOptionTooltips = settings.showOptionTooltips !== undefined ? settings.showOptionTooltips : false;
    this.minSelected = settings.minSelected || 0;
    this.maxSelected = settings.maxSelected || 1000;
    this.timeoutDelay = settings.timeoutDelay || 200;
    this.maxValuesShown = settings.maxValuesShown || 20;
    this.maxValuesMessage = settings.maxValuesMessage || '{number} selected';
  }
}
class Optgroup {
  constructor(optgroup) {
    this.id = !optgroup.id || optgroup.id === '' ? generateID() : optgroup.id;
    this.label = optgroup.label || '';
    this.selectAll = optgroup.selectAll === undefined ? false : optgroup.selectAll;
    this.closable = optgroup.closable || 'off';
    this.options = [];
    if (optgroup.options) {
      for (const o of optgroup.options) {
        this.options.push(new Option(o));
      }
    }
  }
}
class Option {
  constructor(option) {
    this.id = !option.id || option.id === '' ? generateID() : option.id;
    this.value = option.value === undefined ? option.text : option.value;
    this.text = option.text || '';
    this.html = option.html || '';
    this.selected = option.selected !== undefined ? option.selected : false;
    this.display = option.display !== undefined ? option.display : true;
    this.disabled = option.disabled !== undefined ? option.disabled : false;
    this.mandatory = option.mandatory !== undefined ? option.mandatory : false;
    this.placeholder = option.placeholder !== undefined ? option.placeholder : false;
    this.class = option.class || '';
    this.style = option.style || '';
    this.data = option.data || {};
  }
}
class Store {
  constructor(type, data) {
    this.selectType = 'single';
    this.data = [];
    this.selectType = type;
    this.setData(data);
  }
  validateDataArray(data) {
    if (!Array.isArray(data)) {
      return new Error('Data must be an array');
    }
    for (let dataObj of data) {
      if (dataObj instanceof Optgroup || 'label' in dataObj) {
        if (!('label' in dataObj)) {
          return new Error('Optgroup must have a label');
        }
        if ('options' in dataObj && dataObj.options) {
          for (let option of dataObj.options) {
            return this.validateOption(option);
          }
        }
      } else if (dataObj instanceof Option || 'text' in dataObj) {
        return this.validateOption(dataObj);
      } else {
        return new Error('Data object must be a valid optgroup or option');
      }
    }
    return null;
  }
  validateOption(option) {
    if (!('text' in option)) {
      return new Error('Option must have a text');
    }
    return null;
  }
  partialToFullData(data) {
    let dataFinal = [];
    data.forEach(dataObj => {
      if (dataObj instanceof Optgroup || 'label' in dataObj) {
        let optOptions = [];
        if ('options' in dataObj && dataObj.options) {
          dataObj.options.forEach(option => {
            optOptions.push(new Option(option));
          });
        }
        if (optOptions.length > 0) {
          dataFinal.push(new Optgroup(dataObj));
        }
      }
      if (dataObj instanceof Option || 'text' in dataObj) {
        dataFinal.push(new Option(dataObj));
      }
    });
    return dataFinal;
  }
  setData(data) {
    this.data = this.partialToFullData(data);
    if (this.selectType === 'single') {
      this.setSelectedBy('value', this.getSelected());
    }
  }
  getData() {
    return this.filter(null, true);
  }
  getDataOptions() {
    return this.filter(null, false);
  }
  addOption(option) {
    this.setData(this.getData().concat(new Option(option)));
  }
  setSelectedBy(selectedType, selectedValues) {
    let firstOption = null;
    let hasSelected = false;
    for (let dataObj of this.data) {
      if (dataObj instanceof Optgroup) {
        for (let option of dataObj.options) {
          if (!firstOption) {
            firstOption = option;
          }
          option.selected = hasSelected ? false : selectedValues.includes(option[selectedType]);
          if (option.selected && this.selectType === 'single') {
            hasSelected = true;
          }
        }
      }
      if (dataObj instanceof Option) {
        if (!firstOption) {
          firstOption = dataObj;
        }
        dataObj.selected = hasSelected ? false : selectedValues.includes(dataObj[selectedType]);
        if (dataObj.selected && this.selectType === 'single') {
          hasSelected = true;
        }
      }
    }
    if (this.selectType === 'single' && firstOption && !hasSelected) {
      firstOption.selected = true;
    }
  }
  getSelected() {
    let selectedOptions = this.getSelectedOptions();
    let selectedValues = [];
    selectedOptions.forEach(option => {
      selectedValues.push(option.value);
    });
    return selectedValues;
  }
  getSelectedOptions() {
    return this.filter(opt => {
      return opt.selected;
    }, false);
  }
  getSelectedIDs() {
    let selectedOptions = this.getSelectedOptions();
    let selectedIDs = [];
    selectedOptions.forEach(op => {
      selectedIDs.push(op.id);
    });
    return selectedIDs;
  }
  getOptgroupByID(id) {
    for (let dataObj of this.data) {
      if (dataObj instanceof Optgroup && dataObj.id === id) {
        return dataObj;
      }
    }
    return null;
  }
  getOptionByID(id) {
    let options = this.filter(opt => {
      return opt.id === id;
    }, false);
    return options.length ? options[0] : null;
  }
  search(search, searchFilter) {
    search = search.trim();
    if (search === '') {
      return this.getData();
    }
    return this.filter(opt => {
      return searchFilter(opt, search);
    }, true);
  }
  filter(filter, includeOptgroup) {
    const dataSearch = [];
    this.data.forEach(dataObj => {
      if (dataObj instanceof Optgroup) {
        let optOptions = [];
        dataObj.options.forEach(option => {
          if (!filter || filter(option)) {
            if (!includeOptgroup) {
              dataSearch.push(new Option(option));
            } else {
              optOptions.push(new Option(option));
            }
          }
        });
        if (optOptions.length > 0) {
          let optgroup = new Optgroup(dataObj);
          optgroup.options = optOptions;
          dataSearch.push(optgroup);
        }
      }
      if (dataObj instanceof Option) {
        if (!filter || filter(dataObj)) {
          dataSearch.push(new Option(dataObj));
        }
      }
    });
    return dataSearch;
  }
}
class Render {
  constructor(settings, store, callbacks) {
    this.classes = {
      main: 'ss-main',
      placeholder: 'ss-placeholder',
      values: 'ss-values',
      single: 'ss-single',
      max: 'ss-max',
      value: 'ss-value',
      valueText: 'ss-value-text',
      valueDelete: 'ss-value-delete',
      valueOut: 'ss-value-out',
      deselect: 'ss-deselect',
      deselectPath: 'M10,10 L90,90 M10,90 L90,10',
      arrow: 'ss-arrow',
      arrowClose: 'M10,30 L50,70 L90,30',
      arrowOpen: 'M10,70 L50,30 L90,70',
      content: 'ss-content',
      openAbove: 'ss-open-above',
      openBelow: 'ss-open-below',
      search: 'ss-search',
      searchHighlighter: 'ss-search-highlight',
      searching: 'ss-searching',
      addable: 'ss-addable',
      addablePath: 'M50,10 L50,90 M10,50 L90,50',
      list: 'ss-list',
      optgroup: 'ss-optgroup',
      optgroupLabel: 'ss-optgroup-label',
      optgroupLabelText: 'ss-optgroup-label-text',
      optgroupActions: 'ss-optgroup-actions',
      optgroupSelectAll: 'ss-selectall',
      optgroupSelectAllBox: 'M60,10 L10,10 L10,90 L90,90 L90,50',
      optgroupSelectAllCheck: 'M30,45 L50,70 L90,10',
      optgroupClosable: 'ss-closable',
      option: 'ss-option',
      optionDelete: 'M10,10 L90,90 M10,90 L90,10',
      highlighted: 'ss-highlighted',
      open: 'ss-open',
      close: 'ss-close',
      selected: 'ss-selected',
      error: 'ss-error',
      disabled: 'ss-disabled',
      hide: 'ss-hide'
    };
    this.store = store;
    this.settings = settings;
    this.callbacks = callbacks;
    this.main = this.mainDiv();
    this.content = this.contentDiv();
    this.updateClassStyles();
    this.updateAriaAttributes();
    this.settings.contentLocation.appendChild(this.content.main);
  }
  enable() {
    this.main.main.classList.remove(this.classes.disabled);
    this.content.search.input.disabled = false;
  }
  disable() {
    this.main.main.classList.add(this.classes.disabled);
    this.content.search.input.disabled = true;
  }
  open() {
    this.main.arrow.path.setAttribute('d', this.classes.arrowOpen);
    this.main.main.classList.add(this.settings.openPosition === 'up' ? this.classes.openAbove : this.classes.openBelow);
    this.main.main.setAttribute('aria-expanded', 'true');
    this.moveContent();
    const selectedOptions = this.store.getSelectedOptions();
    if (selectedOptions.length) {
      const selectedId = selectedOptions[selectedOptions.length - 1].id;
      const selectedOption = this.content.list.querySelector('[data-id="' + selectedId + '"]');
      if (selectedOption) {
        this.ensureElementInView(this.content.list, selectedOption);
      }
    }
  }
  close() {
    this.main.main.classList.remove(this.classes.openAbove);
    this.main.main.classList.remove(this.classes.openBelow);
    this.main.main.setAttribute('aria-expanded', 'false');
    this.content.main.classList.remove(this.classes.openAbove);
    this.content.main.classList.remove(this.classes.openBelow);
    this.main.arrow.path.setAttribute('d', this.classes.arrowClose);
  }
  updateClassStyles() {
    this.main.main.className = '';
    this.main.main.removeAttribute('style');
    this.content.main.className = '';
    this.content.main.removeAttribute('style');
    this.main.main.classList.add(this.classes.main);
    this.content.main.classList.add(this.classes.content);
    if (this.settings.style !== '') {
      this.content.main.style.cssText = this.settings.style;
    }
    if (this.settings.class.length) {
      for (const c of this.settings.class) {
        if (c.trim() !== '') {
          this.main.main.classList.add(c.trim());
          this.content.main.classList.add(c.trim());
        }
      }
    }
    if (this.settings.contentPosition === 'relative') {
      this.content.main.classList.add('ss-' + this.settings.contentPosition);
    }
  }
  updateAriaAttributes() {
    this.main.main.role = 'combobox';
    this.main.main.setAttribute('aria-haspopup', 'listbox');
    this.main.main.setAttribute('aria-controls', this.content.main.id);
    this.main.main.setAttribute('aria-expanded', 'false');
    this.content.main.setAttribute('role', 'listbox');
  }
  mainDiv() {
    const main = document.createElement('div');
    main.dataset.id = this.settings.id;
    main.id = this.settings.id;
    main.tabIndex = 0;
    main.onkeydown = e => {
      switch (e.key) {
        case 'ArrowUp':
        case 'ArrowDown':
          this.callbacks.open();
          e.key === 'ArrowDown' ? this.highlight('down') : this.highlight('up');
          return false;
        case 'Tab':
          this.callbacks.close();
          return true;
        case 'Enter':
        case ' ':
          this.callbacks.open();
          const highlighted = this.content.list.querySelector('.' + this.classes.highlighted);
          if (highlighted) {
            highlighted.click();
          }
          return false;
        case 'Escape':
          this.callbacks.close();
          return false;
      }
    };
    main.onclick = e => {
      if (this.settings.disabled) {
        return;
      }
      this.settings.isOpen ? this.callbacks.close() : this.callbacks.open();
    };
    const values = document.createElement('div');
    values.classList.add(this.classes.values);
    main.appendChild(values);
    const deselect = document.createElement('div');
    deselect.classList.add(this.classes.deselect);
    if (!this.settings.allowDeselect || this.settings.isMultiple) {
      deselect.classList.add(this.classes.hide);
    }
    deselect.onclick = e => {
      e.stopPropagation();
      if (this.settings.disabled) {
        return;
      }
      let shouldDelete = true;
      const before = this.store.getSelectedOptions();
      const after = [];
      if (this.callbacks.beforeChange) {
        shouldDelete = this.callbacks.beforeChange(after, before) === true;
      }
      if (shouldDelete) {
        this.callbacks.setSelected([''], false);
        if (this.settings.closeOnSelect) {
          this.callbacks.close();
        }
        if (this.callbacks.afterChange) {
          this.callbacks.afterChange(after);
        }
      }
    };
    const deselectSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    deselectSvg.setAttribute('viewBox', '0 0 100 100');
    const deselectPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    deselectPath.setAttribute('d', this.classes.deselectPath);
    deselectSvg.appendChild(deselectPath);
    deselect.appendChild(deselectSvg);
    main.appendChild(deselect);
    const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    arrow.classList.add(this.classes.arrow);
    arrow.setAttribute('viewBox', '0 0 100 100');
    const arrowPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    arrowPath.setAttribute('d', this.classes.arrowClose);
    if (this.settings.alwaysOpen) {
      arrow.classList.add(this.classes.hide);
    }
    arrow.appendChild(arrowPath);
    main.appendChild(arrow);
    return {
      main: main,
      values: values,
      deselect: {
        main: deselect,
        svg: deselectSvg,
        path: deselectPath
      },
      arrow: {
        main: arrow,
        path: arrowPath
      }
    };
  }
  mainFocus(eventType) {
    if (eventType !== 'click') {
      this.main.main.focus({
        preventScroll: true
      });
    }
  }
  placeholder() {
    const placeholderOption = this.store.filter(o => o.placeholder, false);
    let placeholderText = this.settings.placeholderText;
    if (placeholderOption.length) {
      if (placeholderOption[0].html !== '') {
        placeholderText = placeholderOption[0].html;
      } else if (placeholderOption[0].text !== '') {
        placeholderText = placeholderOption[0].text;
      }
    }
    const placeholder = document.createElement('div');
    placeholder.classList.add(this.classes.placeholder);
    placeholder.innerHTML = placeholderText;
    return placeholder;
  }
  renderValues() {
    if (!this.settings.isMultiple) {
      this.renderSingleValue();
      return;
    }
    this.renderMultipleValues();
  }
  renderSingleValue() {
    const selected = this.store.filter(o => {
      return o.selected && !o.placeholder;
    }, false);
    const selectedSingle = selected.length > 0 ? selected[0] : null;
    if (!selectedSingle) {
      this.main.values.innerHTML = this.placeholder().outerHTML;
    } else {
      const singleValue = document.createElement('div');
      singleValue.classList.add(this.classes.single);
      singleValue.innerHTML = selectedSingle.html ? selectedSingle.html : selectedSingle.text;
      this.main.values.innerHTML = singleValue.outerHTML;
    }
    if (!this.settings.allowDeselect || !selected.length) {
      this.main.deselect.main.classList.add(this.classes.hide);
    } else {
      this.main.deselect.main.classList.remove(this.classes.hide);
    }
  }
  renderMultipleValues() {
    let currentNodes = this.main.values.childNodes;
    let selectedOptions = this.store.filter(opt => {
      return opt.selected && opt.display;
    }, false);
    if (selectedOptions.length === 0) {
      this.main.values.innerHTML = this.placeholder().outerHTML;
      return;
    } else {
      const placeholder = this.main.values.querySelector('.' + this.classes.placeholder);
      if (placeholder) {
        placeholder.remove();
      }
    }
    if (selectedOptions.length > this.settings.maxValuesShown) {
      const singleValue = document.createElement('div');
      singleValue.classList.add(this.classes.max);
      singleValue.textContent = this.settings.maxValuesMessage.replace('{number}', selectedOptions.length.toString());
      this.main.values.innerHTML = singleValue.outerHTML;
      return;
    } else {
      const maxValuesMessage = this.main.values.querySelector('.' + this.classes.max);
      if (maxValuesMessage) {
        maxValuesMessage.remove();
      }
    }
    let removeNodes = [];
    for (let i = 0; i < currentNodes.length; i++) {
      const node = currentNodes[i];
      const id = node.getAttribute('data-id');
      if (id) {
        const found = selectedOptions.filter(opt => {
          return opt.id === id;
        }, false);
        if (!found.length) {
          removeNodes.push(node);
        }
      }
    }
    for (const n of removeNodes) {
      n.classList.add(this.classes.valueOut);
      setTimeout(() => {
        this.main.values.removeChild(n);
      }, 100);
    }
    currentNodes = this.main.values.childNodes;
    for (let d = 0; d < selectedOptions.length; d++) {
      let shouldAdd = true;
      for (let i = 0; i < currentNodes.length; i++) {
        if (selectedOptions[d].id === String(currentNodes[i].dataset.id)) {
          shouldAdd = false;
        }
      }
      if (shouldAdd) {
        if (currentNodes.length === 0) {
          this.main.values.appendChild(this.multipleValue(selectedOptions[d]));
        } else if (d === 0) {
          this.main.values.insertBefore(this.multipleValue(selectedOptions[d]), currentNodes[d]);
        } else {
          currentNodes[d - 1].insertAdjacentElement('afterend', this.multipleValue(selectedOptions[d]));
        }
      }
    }
  }
  multipleValue(option) {
    const value = document.createElement('div');
    value.classList.add(this.classes.value);
    value.dataset.id = option.id;
    const text = document.createElement('div');
    text.classList.add(this.classes.valueText);
    text.innerHTML = option.text;
    value.appendChild(text);
    if (!option.mandatory) {
      const deleteDiv = document.createElement('div');
      deleteDiv.classList.add(this.classes.valueDelete);
      deleteDiv.onclick = e => {
        e.preventDefault();
        e.stopPropagation();
        if (this.settings.disabled) {
          return;
        }
        let shouldDelete = true;
        const before = this.store.getSelectedOptions();
        const after = before.filter(o => {
          return o.selected && o.id !== option.id;
        }, true);
        if (this.settings.minSelected && after.length < this.settings.minSelected) {
          return;
        }
        if (this.callbacks.beforeChange) {
          shouldDelete = this.callbacks.beforeChange(after, before) === true;
        }
        if (shouldDelete) {
          let selectedValues = [];
          for (const o of after) {
            if (o instanceof Optgroup) {
              for (const c of o.options) {
                selectedValues.push(c.value);
              }
            }
            if (o instanceof Option) {
              selectedValues.push(o.value);
            }
          }
          this.callbacks.setSelected(selectedValues, false);
          if (this.settings.closeOnSelect) {
            this.callbacks.close();
          }
          if (this.callbacks.afterChange) {
            this.callbacks.afterChange(after);
          }
        }
      };
      const deleteSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      deleteSvg.setAttribute('viewBox', '0 0 100 100');
      const deletePath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      deletePath.setAttribute('d', this.classes.optionDelete);
      deleteSvg.appendChild(deletePath);
      deleteDiv.appendChild(deleteSvg);
      value.appendChild(deleteDiv);
    }
    return value;
  }
  contentDiv() {
    const main = document.createElement('div');
    main.dataset.id = this.settings.id;
    main.id = this.settings.id;
    const search = this.searchDiv();
    main.appendChild(search.main);
    const list = this.listDiv();
    main.appendChild(list);
    return {
      main: main,
      search: search,
      list: list
    };
  }
  moveContent() {
    if (this.settings.contentPosition === 'relative') {
      this.moveContentBelow();
      return;
    }
    if (this.settings.openPosition === 'down') {
      this.moveContentBelow();
      return;
    } else if (this.settings.openPosition === 'up') {
      this.moveContentAbove();
      return;
    }
    if (this.putContent() === 'up') {
      this.moveContentAbove();
    } else {
      this.moveContentBelow();
    }
  }
  searchDiv() {
    const main = document.createElement('div');
    const input = document.createElement('input');
    const addable = document.createElement('div');
    main.classList.add(this.classes.search);
    const searchReturn = {
      main,
      input
    };
    if (!this.settings.showSearch) {
      main.classList.add(this.classes.hide);
      input.readOnly = true;
    }
    input.type = 'search';
    input.placeholder = this.settings.searchPlaceholder;
    input.tabIndex = -1;
    input.setAttribute('aria-label', this.settings.searchPlaceholder);
    input.setAttribute('autocapitalize', 'off');
    input.setAttribute('autocomplete', 'off');
    input.setAttribute('autocorrect', 'off');
    input.oninput = debounce$2(e => {
      this.callbacks.search(e.target.value);
    }, 100);
    input.onkeydown = e => {
      switch (e.key) {
        case 'ArrowUp':
        case 'ArrowDown':
          e.key === 'ArrowDown' ? this.highlight('down') : this.highlight('up');
          return false;
        case 'Tab':
          this.callbacks.close();
          return true;
        case 'Escape':
          this.callbacks.close();
          return false;
        case 'Enter':
        case ' ':
          if (this.callbacks.addable && e.ctrlKey) {
            addable.click();
            return false;
          } else {
            const highlighted = this.content.list.querySelector('.' + this.classes.highlighted);
            if (highlighted) {
              highlighted.click();
              return false;
            }
          }
          return true;
      }
    };
    main.appendChild(input);
    if (this.callbacks.addable) {
      addable.classList.add(this.classes.addable);
      const plus = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      plus.setAttribute('viewBox', '0 0 100 100');
      const plusPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      plusPath.setAttribute('d', this.classes.addablePath);
      plus.appendChild(plusPath);
      addable.appendChild(plus);
      addable.onclick = e => {
        e.preventDefault();
        e.stopPropagation();
        if (!this.callbacks.addable) {
          return;
        }
        const inputValue = this.content.search.input.value.trim();
        if (inputValue === '') {
          this.content.search.input.focus();
          return;
        }
        const runFinish = oo => {
          let newOption = new Option(oo);
          this.callbacks.addOption(newOption);
          if (this.settings.isMultiple) {
            let values = this.store.getSelected();
            values.push(newOption.value);
            this.callbacks.setSelected(values, true);
          } else {
            this.callbacks.setSelected([newOption.value], true);
          }
          this.callbacks.search('');
          if (this.settings.closeOnSelect) {
            setTimeout(() => {
              this.callbacks.close();
            }, 100);
          }
        };
        const addableValue = this.callbacks.addable(inputValue);
        if (addableValue instanceof Promise) {
          addableValue.then(value => {
            if (typeof value === 'string') {
              runFinish({
                text: value,
                value: value
              });
            } else {
              runFinish(value);
            }
          });
        } else if (typeof addableValue === 'string') {
          runFinish({
            text: addableValue,
            value: addableValue
          });
        } else {
          runFinish(addableValue);
        }
        return;
      };
      main.appendChild(addable);
      searchReturn.addable = {
        main: addable,
        svg: plus,
        path: plusPath
      };
    }
    return searchReturn;
  }
  searchFocus() {
    this.content.search.input.focus();
  }
  getOptions(notPlaceholder = false, notDisabled = false, notHidden = false) {
    let query = '.' + this.classes.option;
    if (notPlaceholder) {
      query += ':not(.' + this.classes.placeholder + ')';
    }
    if (notDisabled) {
      query += ':not(.' + this.classes.disabled + ')';
    }
    if (notHidden) {
      query += ':not(.' + this.classes.hide + ')';
    }
    return Array.from(this.content.list.querySelectorAll(query));
  }
  highlight(dir) {
    const options = this.getOptions(true, true, true);
    if (options.length === 0) {
      return;
    }
    if (options.length === 1) {
      if (!options[0].classList.contains(this.classes.highlighted)) {
        options[0].classList.add(this.classes.highlighted);
        return;
      }
    }
    for (let i = 0; i < options.length; i++) {
      if (options[i].classList.contains(this.classes.highlighted)) {
        const prevOption = options[i];
        prevOption.classList.remove(this.classes.highlighted);
        const prevParent = prevOption.parentElement;
        if (prevParent && prevParent.classList.contains(this.classes.open)) {
          const optgroupLabel = prevParent.querySelector('.' + this.classes.optgroupLabel);
          if (optgroupLabel) {
            optgroupLabel.click();
          }
        }
        let selectOption = options[dir === 'down' ? i + 1 < options.length ? i + 1 : 0 : i - 1 >= 0 ? i - 1 : options.length - 1];
        selectOption.classList.add(this.classes.highlighted);
        this.ensureElementInView(this.content.list, selectOption);
        const selectParent = selectOption.parentElement;
        if (selectParent && selectParent.classList.contains(this.classes.close)) {
          const optgroupLabel = selectParent.querySelector('.' + this.classes.optgroupLabel);
          if (optgroupLabel) {
            optgroupLabel.click();
          }
        }
        return;
      }
    }
    options[dir === 'down' ? 0 : options.length - 1].classList.add(this.classes.highlighted);
    this.ensureElementInView(this.content.list, options[dir === 'down' ? 0 : options.length - 1]);
  }
  listDiv() {
    const options = document.createElement('div');
    options.classList.add(this.classes.list);
    return options;
  }
  renderError(error) {
    this.content.list.innerHTML = '';
    const errorDiv = document.createElement('div');
    errorDiv.classList.add(this.classes.error);
    errorDiv.textContent = error;
    this.content.list.appendChild(errorDiv);
  }
  renderSearching() {
    this.content.list.innerHTML = '';
    const searchingDiv = document.createElement('div');
    searchingDiv.classList.add(this.classes.searching);
    searchingDiv.textContent = this.settings.searchingText;
    this.content.list.appendChild(searchingDiv);
  }
  renderOptions(data) {
    this.content.list.innerHTML = '';
    if (data.length === 0) {
      const noResults = document.createElement('div');
      noResults.classList.add(this.classes.search);
      noResults.innerHTML = this.settings.searchText;
      this.content.list.appendChild(noResults);
      return;
    }
    for (const d of data) {
      if (d instanceof Optgroup) {
        const optgroupEl = document.createElement('div');
        optgroupEl.classList.add(this.classes.optgroup);
        const optgroupLabel = document.createElement('div');
        optgroupLabel.classList.add(this.classes.optgroupLabel);
        optgroupEl.appendChild(optgroupLabel);
        const optgroupLabelText = document.createElement('div');
        optgroupLabelText.classList.add(this.classes.optgroupLabelText);
        optgroupLabelText.textContent = d.label;
        optgroupLabel.appendChild(optgroupLabelText);
        const optgroupActions = document.createElement('div');
        optgroupActions.classList.add(this.classes.optgroupActions);
        optgroupLabel.appendChild(optgroupActions);
        if (this.settings.isMultiple && d.selectAll) {
          const selectAll = document.createElement('div');
          selectAll.classList.add(this.classes.optgroupSelectAll);
          let allSelected = true;
          for (const o of d.options) {
            if (!o.selected) {
              allSelected = false;
              break;
            }
          }
          if (allSelected) {
            selectAll.classList.add(this.classes.selected);
          }
          const selectAllText = document.createElement('span');
          selectAllText.textContent = 'Select All';
          selectAll.appendChild(selectAllText);
          const selectAllSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
          selectAllSvg.setAttribute('viewBox', '0 0 100 100');
          selectAll.appendChild(selectAllSvg);
          const selectAllBox = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          selectAllBox.setAttribute('d', this.classes.optgroupSelectAllBox);
          selectAllSvg.appendChild(selectAllBox);
          const selectAllCheck = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          selectAllCheck.setAttribute('d', this.classes.optgroupSelectAllCheck);
          selectAllSvg.appendChild(selectAllCheck);
          selectAll.addEventListener('click', e => {
            e.preventDefault();
            e.stopPropagation();
            const currentSelected = this.store.getSelected();
            if (allSelected) {
              const newSelected = currentSelected.filter(s => {
                for (const o of d.options) {
                  if (s === o.value) {
                    return false;
                  }
                }
                return true;
              });
              this.callbacks.setSelected(newSelected, true);
              return;
            } else {
              const newSelected = currentSelected.concat(d.options.map(o => o.value));
              this.callbacks.setSelected(newSelected, true);
            }
          });
          optgroupActions.appendChild(selectAll);
        }
        if (d.closable !== 'off') {
          const optgroupClosable = document.createElement('div');
          optgroupClosable.classList.add(this.classes.optgroupClosable);
          const optgroupClosableSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
          optgroupClosableSvg.setAttribute('viewBox', '0 0 100 100');
          optgroupClosableSvg.classList.add(this.classes.arrow);
          optgroupClosable.appendChild(optgroupClosableSvg);
          const optgroupClosableArrow = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          optgroupClosableSvg.appendChild(optgroupClosableArrow);
          if (d.options.some(o => o.selected) || this.content.search.input.value.trim() !== '') {
            optgroupClosable.classList.add(this.classes.open);
            optgroupClosableArrow.setAttribute('d', this.classes.arrowOpen);
          } else if (d.closable === 'open') {
            optgroupEl.classList.add(this.classes.open);
            optgroupClosableArrow.setAttribute('d', this.classes.arrowOpen);
          } else if (d.closable === 'close') {
            optgroupEl.classList.add(this.classes.close);
            optgroupClosableArrow.setAttribute('d', this.classes.arrowClose);
          }
          optgroupLabel.addEventListener('click', e => {
            e.preventDefault();
            e.stopPropagation();
            if (optgroupEl.classList.contains(this.classes.close)) {
              optgroupEl.classList.remove(this.classes.close);
              optgroupEl.classList.add(this.classes.open);
              optgroupClosableArrow.setAttribute('d', this.classes.arrowOpen);
            } else {
              optgroupEl.classList.remove(this.classes.open);
              optgroupEl.classList.add(this.classes.close);
              optgroupClosableArrow.setAttribute('d', this.classes.arrowClose);
            }
          });
          optgroupActions.appendChild(optgroupClosable);
        }
        optgroupEl.appendChild(optgroupLabel);
        for (const o of d.options) {
          optgroupEl.appendChild(this.option(o));
        }
        this.content.list.appendChild(optgroupEl);
      }
      if (d instanceof Option) {
        this.content.list.appendChild(this.option(d));
      }
    }
  }
  option(option) {
    if (option.placeholder) {
      const placeholder = document.createElement('div');
      placeholder.classList.add(this.classes.option);
      placeholder.classList.add(this.classes.hide);
      return placeholder;
    }
    const optionEl = document.createElement('div');
    optionEl.dataset.id = option.id;
    optionEl.id = option.id;
    optionEl.classList.add(this.classes.option);
    optionEl.setAttribute('role', 'option');
    if (option.class) {
      option.class.split(' ').forEach(dataClass => {
        optionEl.classList.add(dataClass);
      });
    }
    if (option.style) {
      optionEl.style.cssText = option.style;
    }
    if (this.settings.searchHighlight && this.content.search.input.value.trim() !== '') {
      optionEl.innerHTML = this.highlightText(option.html !== '' ? option.html : option.text, this.content.search.input.value, this.classes.searchHighlighter);
    } else if (option.html !== '') {
      optionEl.innerHTML = option.html;
    } else {
      optionEl.textContent = option.text;
    }
    if (this.settings.showOptionTooltips && optionEl.textContent) {
      optionEl.setAttribute('title', optionEl.textContent);
    }
    if (!option.display) {
      optionEl.classList.add(this.classes.hide);
    }
    if (option.disabled) {
      optionEl.classList.add(this.classes.disabled);
    }
    if (option.selected && this.settings.hideSelected) {
      optionEl.classList.add(this.classes.hide);
    }
    if (option.selected) {
      optionEl.classList.add(this.classes.selected);
      optionEl.setAttribute('aria-selected', 'true');
      this.main.main.setAttribute('aria-activedescendant', optionEl.id);
    } else {
      optionEl.classList.remove(this.classes.selected);
      optionEl.setAttribute('aria-selected', 'false');
    }
    optionEl.addEventListener('click', e => {
      e.preventDefault();
      e.stopPropagation();
      const selectedOptions = this.store.getSelected();
      const element = e.currentTarget;
      const elementID = String(element.dataset.id);
      if (option.disabled || option.selected && !this.settings.allowDeselect) {
        return;
      }
      if (this.settings.isMultiple && this.settings.maxSelected <= selectedOptions.length && !option.selected || this.settings.isMultiple && this.settings.minSelected >= selectedOptions.length && option.selected) {
        return;
      }
      let shouldUpdate = false;
      const before = this.store.getSelectedOptions();
      let after = [];
      if (this.settings.isMultiple) {
        if (option.selected) {
          after = before.filter(o => o.id !== elementID);
        } else {
          after = before.concat(option);
        }
      }
      if (!this.settings.isMultiple) {
        if (option.selected) {
          after = [];
        } else {
          after = [option];
        }
      }
      if (!this.callbacks.beforeChange) {
        shouldUpdate = true;
      }
      if (this.callbacks.beforeChange) {
        if (this.callbacks.beforeChange(after, before) === false) {
          shouldUpdate = false;
        } else {
          shouldUpdate = true;
        }
      }
      if (shouldUpdate) {
        if (!this.store.getOptionByID(elementID)) {
          this.callbacks.addOption(option);
        }
        this.callbacks.setSelected(after.map(o => o.value), false);
        if (this.settings.closeOnSelect) {
          this.callbacks.close();
        }
        if (this.callbacks.afterChange) {
          this.callbacks.afterChange(after);
        }
      }
    });
    return optionEl;
  }
  destroy() {
    this.main.main.remove();
    this.content.main.remove();
  }
  highlightText(str, search, className) {
    let completedString = str;
    const regex = new RegExp('(' + search.trim() + ')(?![^<]*>[^<>]*</)', 'i');
    if (!str.match(regex)) {
      return str;
    }
    const matchStartPosition = str.match(regex).index;
    const matchEndPosition = matchStartPosition + str.match(regex)[0].toString().length;
    const originalTextFoundByRegex = str.substring(matchStartPosition, matchEndPosition);
    completedString = completedString.replace(regex, `<mark class="${className}">${originalTextFoundByRegex}</mark>`);
    return completedString;
  }
  moveContentAbove() {
    const mainHeight = this.main.main.offsetHeight;
    const contentHeight = this.content.main.offsetHeight;
    this.main.main.classList.remove(this.classes.openBelow);
    this.main.main.classList.add(this.classes.openAbove);
    this.content.main.classList.remove(this.classes.openBelow);
    this.content.main.classList.add(this.classes.openAbove);
    const containerRect = this.main.main.getBoundingClientRect();
    this.content.main.style.margin = '-' + (mainHeight + contentHeight - 1) + 'px 0px 0px 0px';
    this.content.main.style.top = containerRect.top + containerRect.height + window.scrollY + 'px';
    this.content.main.style.left = containerRect.left + window.scrollX + 'px';
    this.content.main.style.width = containerRect.width + 'px';
  }
  moveContentBelow() {
    this.main.main.classList.remove(this.classes.openAbove);
    this.main.main.classList.add(this.classes.openBelow);
    this.content.main.classList.remove(this.classes.openAbove);
    this.content.main.classList.add(this.classes.openBelow);
    const containerRect = this.main.main.getBoundingClientRect();
    this.content.main.style.margin = '-1px 0px 0px 0px';
    if (this.settings.contentPosition !== 'relative') {
      this.content.main.style.top = containerRect.top + containerRect.height + window.scrollY + 'px';
      this.content.main.style.left = containerRect.left + window.scrollX + 'px';
      this.content.main.style.width = containerRect.width + 'px';
    }
  }
  ensureElementInView(container, element) {
    const cTop = container.scrollTop + container.offsetTop;
    const cBottom = cTop + container.clientHeight;
    const eTop = element.offsetTop;
    const eBottom = eTop + element.clientHeight;
    if (eTop < cTop) {
      container.scrollTop -= cTop - eTop;
    } else if (eBottom > cBottom) {
      container.scrollTop += eBottom - cBottom;
    }
  }
  putContent() {
    const mainHeight = this.main.main.offsetHeight;
    const mainRect = this.main.main.getBoundingClientRect();
    const contentHeight = this.content.main.offsetHeight;
    const spaceBelow = window.innerHeight - (mainRect.top + mainHeight);
    if (spaceBelow <= contentHeight) {
      if (mainRect.top > contentHeight) {
        return 'up';
      } else {
        return 'down';
      }
    }
    return 'down';
  }
}
class Select {
  constructor(select) {
    this.listen = false;
    this.observer = null;
    this.select = select;
    this.select.addEventListener('change', this.valueChange.bind(this), {
      passive: true
    });
    this.observer = new MutationObserver(this.observeCall.bind(this));
    this.changeListen(true);
  }
  enable() {
    this.select.disabled = false;
  }
  disable() {
    this.select.disabled = true;
  }
  hideUI() {
    this.select.tabIndex = -1;
    this.select.style.display = 'none';
    this.select.setAttribute('aria-hidden', 'true');
  }
  showUI() {
    this.select.removeAttribute('tabindex');
    this.select.style.display = '';
    this.select.removeAttribute('aria-hidden');
  }
  changeListen(listen) {
    this.listen = listen;
    if (listen) {
      if (this.observer) {
        this.observer.observe(this.select, {
          subtree: true,
          childList: true,
          attributes: true
        });
      }
    }
    if (!listen) {
      if (this.observer) {
        this.observer.disconnect();
      }
    }
  }
  valueChange(ev) {
    if (this.listen && this.onValueChange) {
      this.onValueChange(this.getSelectedValues());
    }
    return true;
  }
  observeCall(mutations) {
    if (!this.listen) {
      return;
    }
    let classChanged = false;
    let disabledChanged = false;
    let optgroupOptionChanged = false;
    for (const m of mutations) {
      if (m.target === this.select) {
        if (m.attributeName === 'disabled') {
          disabledChanged = true;
        }
        if (m.attributeName === 'class') {
          classChanged = true;
        }
      }
      if (m.target.nodeName === 'OPTGROUP' || m.target.nodeName === 'OPTION') {
        optgroupOptionChanged = true;
      }
    }
    if (classChanged && this.onClassChange) {
      this.onClassChange(this.select.className.split(' '));
    }
    if (disabledChanged && this.onDisabledChange) {
      this.changeListen(false);
      this.onDisabledChange(this.select.disabled);
      this.changeListen(true);
    }
    if (optgroupOptionChanged && this.onOptionsChange) {
      this.changeListen(false);
      this.onOptionsChange(this.getData());
      this.changeListen(true);
    }
  }
  getData() {
    let data = [];
    const nodes = this.select.childNodes;
    for (const n of nodes) {
      if (n.nodeName === 'OPTGROUP') {
        data.push(this.getDataFromOptgroup(n));
      }
      if (n.nodeName === 'OPTION') {
        data.push(this.getDataFromOption(n));
      }
    }
    return data;
  }
  getDataFromOptgroup(optgroup) {
    let data = {
      id: optgroup.id,
      label: optgroup.label,
      selectAll: optgroup.dataset ? optgroup.dataset.selectall === 'true' : false,
      closable: optgroup.dataset ? optgroup.dataset.closable : 'off',
      options: []
    };
    const options = optgroup.childNodes;
    for (const o of options) {
      if (o.nodeName === 'OPTION') {
        data.options.push(this.getDataFromOption(o));
      }
    }
    return data;
  }
  getDataFromOption(option) {
    return {
      id: option.id,
      value: option.value,
      text: option.text,
      html: option.dataset && option.dataset.html ? option.dataset.html : '',
      selected: option.selected,
      display: option.style.display === 'none' ? false : true,
      disabled: option.disabled,
      mandatory: option.dataset ? option.dataset.mandatory === 'true' : false,
      placeholder: option.dataset.placeholder === 'true',
      class: option.className,
      style: option.style.cssText,
      data: option.dataset
    };
  }
  getSelectedValues() {
    let values = [];
    const options = this.select.childNodes;
    for (const o of options) {
      if (o.nodeName === 'OPTGROUP') {
        const optgroupOptions = o.childNodes;
        for (const oo of optgroupOptions) {
          if (oo.nodeName === 'OPTION') {
            const option = oo;
            if (option.selected) {
              values.push(option.value);
            }
          }
        }
      }
      if (o.nodeName === 'OPTION') {
        const option = o;
        if (option.selected) {
          values.push(option.value);
        }
      }
    }
    return values;
  }
  setSelected(value) {
    this.changeListen(false);
    const options = this.select.childNodes;
    for (const o of options) {
      if (o.nodeName === 'OPTGROUP') {
        const optgroup = o;
        const optgroupOptions = optgroup.childNodes;
        for (const oo of optgroupOptions) {
          if (oo.nodeName === 'OPTION') {
            const option = oo;
            option.selected = value.includes(option.value);
          }
        }
      }
      if (o.nodeName === 'OPTION') {
        const option = o;
        option.selected = value.includes(option.value);
      }
    }
    this.changeListen(true);
  }
  updateSelect(id, style, classes) {
    this.changeListen(false);
    if (id) {
      this.select.dataset.id = id;
    }
    if (style) {
      this.select.style.cssText = style;
    }
    if (classes) {
      this.select.className = '';
      classes.forEach(c => {
        if (c.trim() !== '') {
          this.select.classList.add(c.trim());
        }
      });
    }
    this.changeListen(true);
  }
  updateOptions(data) {
    this.changeListen(false);
    this.select.innerHTML = '';
    for (const d of data) {
      if (d instanceof Optgroup) {
        this.select.appendChild(this.createOptgroup(d));
      }
      if (d instanceof Option) {
        this.select.appendChild(this.createOption(d));
      }
    }
    this.select.dispatchEvent(new Event('change'));
    this.changeListen(true);
  }
  createOptgroup(optgroup) {
    const optgroupEl = document.createElement('optgroup');
    optgroupEl.id = optgroup.id;
    optgroupEl.label = optgroup.label;
    if (optgroup.selectAll) {
      optgroupEl.dataset.selectAll = 'true';
    }
    if (optgroup.closable !== 'off') {
      optgroupEl.dataset.closable = optgroup.closable;
    }
    if (optgroup.options) {
      for (const o of optgroup.options) {
        optgroupEl.appendChild(this.createOption(o));
      }
    }
    return optgroupEl;
  }
  createOption(info) {
    const optionEl = document.createElement('option');
    optionEl.id = info.id;
    optionEl.value = info.value;
    optionEl.innerHTML = info.text;
    if (info.html !== '') {
      optionEl.setAttribute('data-html', info.html);
    }
    if (info.selected) {
      optionEl.selected = info.selected;
    }
    if (info.disabled) {
      optionEl.disabled = true;
    }
    if (info.display === false) {
      optionEl.style.display = 'none';
    }
    if (info.placeholder) {
      optionEl.setAttribute('data-placeholder', 'true');
    }
    if (info.mandatory) {
      optionEl.setAttribute('data-mandatory', 'true');
    }
    if (info.class) {
      info.class.split(' ').forEach(optionClass => {
        optionEl.classList.add(optionClass);
      });
    }
    if (info.data && typeof info.data === 'object') {
      Object.keys(info.data).forEach(key => {
        optionEl.setAttribute('data-' + kebabCase(key), info.data[key]);
      });
    }
    return optionEl;
  }
  destroy() {
    this.changeListen(false);
    this.select.removeEventListener('change', this.valueChange.bind(this));
    if (this.observer) {
      this.observer.disconnect();
      this.observer = null;
    }
    delete this.select.dataset.id;
    this.showUI();
  }
}
class SlimSelect {
  constructor(config) {
    var _a;
    this.events = {
      search: undefined,
      searchFilter: (opt, search) => {
        return opt.text.toLowerCase().indexOf(search.toLowerCase()) !== -1;
      },
      addable: undefined,
      beforeChange: undefined,
      afterChange: undefined,
      beforeOpen: undefined,
      afterOpen: undefined,
      beforeClose: undefined,
      afterClose: undefined
    };
    this.windowResize = debounce$2(() => {
      if (!this.settings.isOpen && !this.settings.isFullOpen) {
        return;
      }
      this.render.moveContent();
    });
    this.windowScroll = debounce$2(() => {
      if (!this.settings.isOpen && !this.settings.isFullOpen) {
        return;
      }
      this.render.moveContent();
    });
    this.documentClick = e => {
      if (!this.settings.isOpen) {
        return;
      }
      if (e.target && !hasClassInTree(e.target, this.settings.id)) {
        this.close(e.type);
      }
    };
    this.windowVisibilityChange = () => {
      if (document.hidden) {
        this.close();
      }
    };
    this.selectEl = typeof config.select === 'string' ? document.querySelector(config.select) : config.select;
    if (!this.selectEl) {
      if (config.events && config.events.error) {
        config.events.error(new Error('Could not find select element'));
      }
      return;
    }
    if (this.selectEl.tagName !== 'SELECT') {
      if (config.events && config.events.error) {
        config.events.error(new Error('Element isnt of type select'));
      }
      return;
    }
    if (this.selectEl.dataset.ssid) {
      this.destroy();
    }
    this.settings = new Settings(config.settings);
    const debounceEvents = ['afterChange', 'beforeOpen', 'afterOpen', 'beforeClose', 'afterClose'];
    for (const key in config.events) {
      if (!config.events.hasOwnProperty(key)) {
        continue;
      }
      if (debounceEvents.indexOf(key) !== -1) {
        this.events[key] = debounce$2(config.events[key], 100);
      } else {
        this.events[key] = config.events[key];
      }
    }
    this.settings.disabled = ((_a = config.settings) === null || _a === void 0 ? void 0 : _a.disabled) ? config.settings.disabled : this.selectEl.disabled;
    this.settings.isMultiple = this.selectEl.multiple;
    this.settings.style = this.selectEl.style.cssText;
    this.settings.class = this.selectEl.className.split(' ');
    this.select = new Select(this.selectEl);
    this.select.updateSelect(this.settings.id, this.settings.style, this.settings.class);
    this.select.hideUI();
    this.select.onValueChange = values => {
      this.setSelected(values);
    };
    this.select.onClassChange = classes => {
      this.settings.class = classes;
      this.render.updateClassStyles();
    };
    this.select.onDisabledChange = disabled => {
      if (disabled) {
        this.disable();
      } else {
        this.enable();
      }
    };
    this.select.onOptionsChange = data => {
      this.setData(data);
    };
    this.store = new Store(this.settings.isMultiple ? 'multiple' : 'single', config.data ? config.data : this.select.getData());
    if (config.data) {
      this.select.updateOptions(this.store.getData());
    }
    const callbacks = {
      open: this.open.bind(this),
      close: this.close.bind(this),
      addable: this.events.addable ? this.events.addable : undefined,
      setSelected: this.setSelected.bind(this),
      addOption: this.addOption.bind(this),
      search: this.search.bind(this),
      beforeChange: this.events.beforeChange,
      afterChange: this.events.afterChange
    };
    this.render = new Render(this.settings, this.store, callbacks);
    this.render.renderValues();
    this.render.renderOptions(this.store.getData());
    const selectAriaLabel = this.selectEl.getAttribute('aria-label');
    const selectAriaLabelledBy = this.selectEl.getAttribute('aria-labelledby');
    if (selectAriaLabel) {
      this.render.main.main.setAttribute('aria-label', selectAriaLabel);
    } else if (selectAriaLabelledBy) {
      this.render.main.main.setAttribute('aria-labelledby', selectAriaLabelledBy);
    }
    if (this.selectEl.parentNode) {
      this.selectEl.parentNode.insertBefore(this.render.main.main, this.selectEl.nextSibling);
    }
    document.addEventListener('click', this.documentClick);
    window.addEventListener('resize', this.windowResize, false);
    if (this.settings.openPosition === 'auto') {
      window.addEventListener('scroll', this.windowScroll, false);
    }
    document.addEventListener('visibilitychange', this.windowVisibilityChange);
    if (this.settings.disabled) {
      this.disable();
    }
    if (this.settings.alwaysOpen) {
      this.open();
    }
    this.selectEl.slim = this;
  }
  enable() {
    this.settings.disabled = false;
    this.select.enable();
    this.render.enable();
  }
  disable() {
    this.settings.disabled = true;
    this.select.disable();
    this.render.disable();
  }
  getData() {
    return this.store.getData();
  }
  setData(data) {
    const selected = this.store.getSelected();
    const err = this.store.validateDataArray(data);
    if (err) {
      if (this.events.error) {
        this.events.error(err);
      }
      return;
    }
    this.store.setData(data);
    const dataClean = this.store.getData();
    this.select.updateOptions(dataClean);
    this.render.renderValues();
    this.render.renderOptions(dataClean);
    if (this.events.afterChange && !isEqual(selected, this.store.getSelected())) {
      this.events.afterChange(this.store.getSelectedOptions());
    }
  }
  getSelected() {
    return this.store.getSelected();
  }
  setSelected(value, runAfterChange = true) {
    const selected = this.store.getSelected();
    this.store.setSelectedBy('value', Array.isArray(value) ? value : [value]);
    const data = this.store.getData();
    this.select.updateOptions(data);
    this.render.renderValues();
    if (this.render.content.search.input.value !== '') {
      this.search(this.render.content.search.input.value);
    } else {
      this.render.renderOptions(data);
    }
    if (runAfterChange && this.events.afterChange && !isEqual(selected, this.store.getSelected())) {
      this.events.afterChange(this.store.getSelectedOptions());
    }
  }
  addOption(option) {
    const selected = this.store.getSelected();
    if (!this.store.getDataOptions().some(o => {
      var _a;
      return o.value === ((_a = option.value) !== null && _a !== void 0 ? _a : option.text);
    })) {
      this.store.addOption(option);
    }
    const data = this.store.getData();
    this.select.updateOptions(data);
    this.render.renderValues();
    this.render.renderOptions(data);
    if (this.events.afterChange && !isEqual(selected, this.store.getSelected())) {
      this.events.afterChange(this.store.getSelectedOptions());
    }
  }
  open() {
    if (this.settings.disabled || this.settings.isOpen) {
      return;
    }
    if (this.events.beforeOpen) {
      this.events.beforeOpen();
    }
    this.render.open();
    if (this.settings.showSearch) {
      this.render.searchFocus();
    }
    this.settings.isOpen = true;
    setTimeout(() => {
      if (this.events.afterOpen) {
        this.events.afterOpen();
      }
      if (this.settings.isOpen) {
        this.settings.isFullOpen = true;
      }
    }, this.settings.timeoutDelay);
    if (this.settings.contentPosition === 'absolute') {
      if (this.settings.intervalMove) {
        clearInterval(this.settings.intervalMove);
      }
      this.settings.intervalMove = setInterval(this.render.moveContent.bind(this.render), 500);
    }
  }
  close(eventType = null) {
    if (!this.settings.isOpen || this.settings.alwaysOpen) {
      return;
    }
    if (this.events.beforeClose) {
      this.events.beforeClose();
    }
    this.render.close();
    if (this.render.content.search.input.value !== '') {
      this.search('');
    }
    this.render.mainFocus(eventType);
    this.settings.isOpen = false;
    this.settings.isFullOpen = false;
    setTimeout(() => {
      if (this.events.afterClose) {
        this.events.afterClose();
      }
    }, this.settings.timeoutDelay);
    if (this.settings.intervalMove) {
      clearInterval(this.settings.intervalMove);
    }
  }
  search(value) {
    if (this.render.content.search.input.value !== value) {
      this.render.content.search.input.value = value;
    }
    if (!this.events.search) {
      this.render.renderOptions(value === '' ? this.store.getData() : this.store.search(value, this.events.searchFilter));
      return;
    }
    this.render.renderSearching();
    const searchResp = this.events.search(value, this.store.getSelectedOptions());
    if (searchResp instanceof Promise) {
      searchResp.then(data => {
        this.render.renderOptions(this.store.partialToFullData(data));
      }).catch(err => {
        this.render.renderError(typeof err === 'string' ? err : err.message);
      });
      return;
    } else if (Array.isArray(searchResp)) {
      this.render.renderOptions(this.store.partialToFullData(searchResp));
    } else {
      this.render.renderError('Search event must return a promise or an array of data');
    }
  }
  destroy() {
    document.removeEventListener('click', this.documentClick);
    window.removeEventListener('resize', this.windowResize, false);
    if (this.settings.openPosition === 'auto') {
      window.removeEventListener('scroll', this.windowScroll, false);
    }
    document.removeEventListener('visibilitychange', this.windowVisibilityChange);
    this.store.setData([]);
    this.render.destroy();
    this.select.destroy();
  }
}

var _default$c = /*#__PURE__*/function (_Controller) {
  _inherits$w(_default, _Controller);
  var _super = _createSuper$w(_default);
  function _default() {
    _classCallCheck$x(this, _default);
    return _super.apply(this, arguments);
  }
  _createClass$x(_default, [{
    key: "connect",
    value: function connect() {
      this.slimselect = new SlimSelect(_objectSpread2$1({
        select: this.element
      }, this.optionsValue));
    }
  }, {
    key: "disconnect",
    value: function disconnect() {
      this.slimselect.destroy();
    }
  }]);
  return _default;
}(Controller);
_defineProperty$x(_default$c, "values", {
  options: Object
});

var _default$b = /*#__PURE__*/function (_Controller) {
  _inherits$w(_default, _Controller);
  var _super = _createSuper$w(_default);
  function _default() {
    _classCallCheck$x(this, _default);
    return _super.apply(this, arguments);
  }
  _createClass$x(_default, [{
    key: "connect",
    value: function connect() {
      // The class we should toggle on the container
      this.toggleClass = this.data.get("class") || "hidden";

      // The ID of the background to hide/remove
      this.backgroundId = this.data.get("backgroundId") || "modal-background";

      // The HTML for the background element
      this.backgroundHtml = this.data.get("backgroundHtml") || this._backgroundHTML();

      // Let the user close the modal by clicking on the background
      this.allowBackgroundClose = (this.data.get("allowBackgroundClose") || "true") === "true";

      // Prevent the default action of the clicked element (following a link for example) when opening the modal
      this.preventDefaultActionOpening = (this.data.get("preventDefaultActionOpening") || "true") === "true";

      // Prevent the default action of the clicked element (following a link for example) when closing the modal
      this.preventDefaultActionClosing = (this.data.get("preventDefaultActionClosing") || "true") === "true";
    }
  }, {
    key: "disconnect",
    value: function disconnect() {
      this.close();
    }
  }, {
    key: "open",
    value: function open(e) {
      if (this.hasTurboFrameTarget) {
        this.turboFrameTarget.src = e.target.href;
      }
      if (this.preventDefaultActionOpening) {
        e.preventDefault();
      }
      if (e.target.blur) {
        e.target.blur();
      }

      // Lock the scroll and save current scroll position
      this.lockScroll();

      // Unhide the modal
      this.containerTarget.classList.remove(this.toggleClass);

      // Insert the background
      if (!this.data.get("disable-backdrop")) {
        document.body.insertAdjacentHTML("beforeend", this.backgroundHtml);
        this.background = document.querySelector("#".concat(this.backgroundId));
      }
    }
  }, {
    key: "close",
    value: function close(e) {
      if (e && this.preventDefaultActionClosing) {
        e.preventDefault();
      }

      // Unlock the scroll and restore previous scroll position
      this.unlockScroll();

      // Hide the modal
      this.containerTarget.classList.add(this.toggleClass);

      // Remove the background
      if (this.background) {
        this.background.remove();
      }
    }
  }, {
    key: "closeBackground",
    value: function closeBackground(e) {
      if (this.allowBackgroundClose && e.target === this.containerTarget) {
        this.close(e);
      }
    }
  }, {
    key: "closeWithKeyboard",
    value: function closeWithKeyboard(e) {
      if (e.keyCode === 27 && !this.containerTarget.classList.contains(this.toggleClass)) {
        this.close(e);
      }
    }
  }, {
    key: "_backgroundHTML",
    value: function _backgroundHTML() {
      return "<div id=\"".concat(this.backgroundId, "\" class=\"fixed top-0 left-0 w-full h-full\" style=\"background-color: ").concat(this.backdropColorValue, "; z-index: 9998;\"></div>");
    }
  }, {
    key: "lockScroll",
    value: function lockScroll() {
      // Add right padding to the body so the page doesn't shift
      // when we disable scrolling
      var scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
      document.body.style.paddingRight = "".concat(scrollbarWidth, "px");

      // Add classes to body to fix its position
      document.body.classList.add("fixed", "inset-x-0", "overflow-hidden");
      if (this.restoreScrollValue) {
        // Save the scroll position
        this.saveScrollPosition();

        // Add negative top position in order for body to stay in place
        document.body.style.top = "-".concat(this.scrollPosition, "px");
      }
    }
  }, {
    key: "unlockScroll",
    value: function unlockScroll() {
      // Remove tweaks for scrollbar
      document.body.style.paddingRight = null;

      // Remove classes from body to unfix position
      document.body.classList.remove("fixed", "inset-x-0", "overflow-hidden");

      // Restore the scroll position of the body before it got locked
      if (this.restoreScrollValue) {
        this.restoreScrollPosition();

        // Remove the negative top inline style from body
        document.body.style.top = null;
      }
    }
  }, {
    key: "saveScrollPosition",
    value: function saveScrollPosition() {
      this.scrollPosition = window.pageYOffset || document.body.scrollTop;
    }
  }, {
    key: "restoreScrollPosition",
    value: function restoreScrollPosition() {
      if (this.scrollPosition === undefined) return;
      document.documentElement.scrollTop = this.scrollPosition;
    }
  }]);
  return _default;
}(Controller);
_defineProperty$x(_default$b, "targets", ["container", "turboFrame"]);
_defineProperty$x(_default$b, "values", {
  backdropColor: {
    type: String,
    default: "rgba(0, 0, 0, 0.8)"
  },
  restoreScroll: {
    type: Boolean,
    default: true
  }
});

/**
 * Returns a function, that, as long as it continues to be invoked, will not
 * be triggered. The function will be called after it stops being called for
 * N milliseconds. If `immediate` is passed, trigger the function on the
 * leading edge, instead of the trailing. The function also has a property 'clear' 
 * that is a function which will clear the timer to prevent previously scheduled executions. 
 *
 * @source underscore.js
 * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/
 * @param {Function} function to wrap
 * @param {Number} timeout in ms (`100`)
 * @param {Boolean} whether to execute at the beginning (`false`)
 * @api public
 */

function debounce$1(func, wait, immediate) {
  var timeout, args, context, timestamp, result;
  if (null == wait) wait = 100;
  function later() {
    var last = Date.now() - timestamp;
    if (last < wait && last >= 0) {
      timeout = setTimeout(later, wait - last);
    } else {
      timeout = null;
      if (!immediate) {
        result = func.apply(context, args);
        context = args = null;
      }
    }
  }
  var debounced = function () {
    context = this;
    args = arguments;
    timestamp = Date.now();
    var callNow = immediate && !timeout;
    if (!timeout) timeout = setTimeout(later, wait);
    if (callNow) {
      result = func.apply(context, args);
      context = args = null;
    }
    return result;
  };
  debounced.clear = function () {
    if (timeout) {
      clearTimeout(timeout);
      timeout = null;
    }
  };
  debounced.flush = function () {
    if (timeout) {
      result = func.apply(context, args);
      context = args = null;
      clearTimeout(timeout);
      timeout = null;
    }
  };
  return debounced;
}

// Adds compatibility for ES modules
debounce$1.debounce = debounce$1;
var debounce_1 = debounce$1;

/*  Adds auto-submit to a form using @hotwired turbo
    Submits the form associated with the input
    Debounces changes to prevent chatter when typing into a textfield.

    Example usage:
      form_for ..
        data: {
        turbo: true,
        turbo_frame: "drugs",
        turbo_advance: true,
        controller: "form"
        action: "input->form#submit"
      }

    - turbo_frame is id the turbo_frame_tag name to replace eg a paginated table
    - turbo_advance: true will add to history as they search
    - action: "input->form#submit" will need to change depending on input type eg
      select, radio, but will cause the form to submit
*/
var _default$a = /*#__PURE__*/function (_Controller) {
  _inherits$w(_default, _Controller);
  var _super = _createSuper$w(_default);
  function _default() {
    _classCallCheck$x(this, _default);
    return _super.apply(this, arguments);
  }
  _createClass$x(_default, [{
    key: "initialize",
    value: function initialize() {
      this.submit = debounce_1(this.submit.bind(this), 300);
    }
  }, {
    key: "submit",
    value: function submit(event) {
      event.target.form.requestSubmit();
    }
  }]);
  return _default;
}(Controller);

/*  Allows to submit an form that's different to the
   form the input is attached to. All fields that are
   part of the main form at submitted to the alternative
   form.

   Example:

   Define an empty form outside of the current form:

  = form_with url: search_url, id: "inner_drug_select_form", data: { turbo_frame: "inner_drug_select_form_frame" }, method: :get do |select_form|

  Then, specify an action that will trigger the submit of the "empty" form:

  = simple_form_for prescription, url: update_url do |f|
    = f.input_field :field,
      as: :toggle,
      data: { "action": "change->alternative-form-submitter#submit" }
*/
var _default$9 = /*#__PURE__*/function (_Controller) {
  _inherits$w(_default, _Controller);
  var _super = _createSuper$w(_default);
  function _default() {
    _classCallCheck$x(this, _default);
    return _super.apply(this, arguments);
  }
  _createClass$x(_default, [{
    key: "submit",
    value: function submit(event) {
      var targetForm = document.getElementById(event.target.dataset.alternativeForm) || this.formTarget;
      Array.from(event.target.form.elements).forEach(function (element) {
        element.setAttribute("form", targetForm.id);
      });
      targetForm.requestSubmit();
      Array.from(event.target.form.elements).forEach(function (element) {
        element.removeAttribute("form");
      });
    }
  }]);
  return _default;
}(Controller);
_defineProperty$x(_default$9, "targets", ["form"]);

// Inspired by https://www.youtube.com/watch?v=gk_qDsKMIrM&t=528s
var _default$8 = /*#__PURE__*/function (_Controller) {
  _inherits$w(_default, _Controller);
  var _super = _createSuper$w(_default);
  function _default() {
    _classCallCheck$x(this, _default);
    return _super.apply(this, arguments);
  }
  _createClass$x(_default, [{
    key: "connect",
    value: function connect() {
      var _this = this;
      setTimeout(function () {
        _this.dismiss();
      }, 5000);
    }
  }, {
    key: "dismiss",
    value: function dismiss() {
      this.element.remove();
    }
  }]);
  return _default;
}(Controller);

var HOOKS = ["onChange", "onClose", "onDayCreate", "onDestroy", "onKeyDown", "onMonthChange", "onOpen", "onParseConfig", "onReady", "onValueUpdate", "onYearChange", "onPreCalendarPosition"];
var defaults = {
  _disable: [],
  allowInput: false,
  allowInvalidPreload: false,
  altFormat: "F j, Y",
  altInput: false,
  altInputClass: "form-control input",
  animate: typeof window === "object" && window.navigator.userAgent.indexOf("MSIE") === -1,
  ariaDateFormat: "F j, Y",
  autoFillDefaultTime: true,
  clickOpens: true,
  closeOnSelect: true,
  conjunction: ", ",
  dateFormat: "Y-m-d",
  defaultHour: 12,
  defaultMinute: 0,
  defaultSeconds: 0,
  disable: [],
  disableMobile: false,
  enableSeconds: false,
  enableTime: false,
  errorHandler: function (err) {
    return typeof console !== "undefined" && console.warn(err);
  },
  getWeek: function (givenDate) {
    var date = new Date(givenDate.getTime());
    date.setHours(0, 0, 0, 0);
    date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7);
    var week1 = new Date(date.getFullYear(), 0, 4);
    return 1 + Math.round(((date.getTime() - week1.getTime()) / 86400000 - 3 + (week1.getDay() + 6) % 7) / 7);
  },
  hourIncrement: 1,
  ignoredFocusElements: [],
  inline: false,
  locale: "default",
  minuteIncrement: 5,
  mode: "single",
  monthSelectorType: "dropdown",
  nextArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>",
  noCalendar: false,
  now: new Date(),
  onChange: [],
  onClose: [],
  onDayCreate: [],
  onDestroy: [],
  onKeyDown: [],
  onMonthChange: [],
  onOpen: [],
  onParseConfig: [],
  onReady: [],
  onValueUpdate: [],
  onYearChange: [],
  onPreCalendarPosition: [],
  plugins: [],
  position: "auto",
  positionElement: undefined,
  prevArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>",
  shorthandCurrentMonth: false,
  showMonths: 1,
  static: false,
  time_24hr: false,
  weekNumbers: false,
  wrap: false
};

var english = {
  weekdays: {
    shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    longhand: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
  },
  months: {
    shorthand: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    longhand: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
  },
  daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
  firstDayOfWeek: 0,
  ordinal: function (nth) {
    var s = nth % 100;
    if (s > 3 && s < 21) return "th";
    switch (s % 10) {
      case 1:
        return "st";
      case 2:
        return "nd";
      case 3:
        return "rd";
      default:
        return "th";
    }
  },
  rangeSeparator: " to ",
  weekAbbreviation: "Wk",
  scrollTitle: "Scroll to increment",
  toggleTitle: "Click to toggle",
  amPM: ["AM", "PM"],
  yearAriaLabel: "Year",
  monthAriaLabel: "Month",
  hourAriaLabel: "Hour",
  minuteAriaLabel: "Minute",
  time_24hr: false
};

var pad = function (number, length) {
  if (length === void 0) {
    length = 2;
  }
  return ("000" + number).slice(length * -1);
};
var int = function (bool) {
  return bool === true ? 1 : 0;
};
function debounce(fn, wait) {
  var t;
  return function () {
    var _this = this;
    var args = arguments;
    clearTimeout(t);
    t = setTimeout(function () {
      return fn.apply(_this, args);
    }, wait);
  };
}
var arrayify = function (obj) {
  return obj instanceof Array ? obj : [obj];
};

function toggleClass(elem, className, bool) {
  if (bool === true) return elem.classList.add(className);
  elem.classList.remove(className);
}
function createElement(tag, className, content) {
  var e = window.document.createElement(tag);
  className = className || "";
  content = content || "";
  e.className = className;
  if (content !== undefined) e.textContent = content;
  return e;
}
function clearNode(node) {
  while (node.firstChild) node.removeChild(node.firstChild);
}
function findParent(node, condition) {
  if (condition(node)) return node;else if (node.parentNode) return findParent(node.parentNode, condition);
  return undefined;
}
function createNumberInput(inputClassName, opts) {
  var wrapper = createElement("div", "numInputWrapper"),
    numInput = createElement("input", "numInput " + inputClassName),
    arrowUp = createElement("span", "arrowUp"),
    arrowDown = createElement("span", "arrowDown");
  if (navigator.userAgent.indexOf("MSIE 9.0") === -1) {
    numInput.type = "number";
  } else {
    numInput.type = "text";
    numInput.pattern = "\\d*";
  }
  if (opts !== undefined) for (var key in opts) numInput.setAttribute(key, opts[key]);
  wrapper.appendChild(numInput);
  wrapper.appendChild(arrowUp);
  wrapper.appendChild(arrowDown);
  return wrapper;
}
function getEventTarget(event) {
  try {
    if (typeof event.composedPath === "function") {
      var path = event.composedPath();
      return path[0];
    }
    return event.target;
  } catch (error) {
    return event.target;
  }
}

var doNothing = function () {
  return undefined;
};
var monthToStr = function (monthNumber, shorthand, locale) {
  return locale.months[shorthand ? "shorthand" : "longhand"][monthNumber];
};
var revFormat = {
  D: doNothing,
  F: function (dateObj, monthName, locale) {
    dateObj.setMonth(locale.months.longhand.indexOf(monthName));
  },
  G: function (dateObj, hour) {
    dateObj.setHours((dateObj.getHours() >= 12 ? 12 : 0) + parseFloat(hour));
  },
  H: function (dateObj, hour) {
    dateObj.setHours(parseFloat(hour));
  },
  J: function (dateObj, day) {
    dateObj.setDate(parseFloat(day));
  },
  K: function (dateObj, amPM, locale) {
    dateObj.setHours(dateObj.getHours() % 12 + 12 * int(new RegExp(locale.amPM[1], "i").test(amPM)));
  },
  M: function (dateObj, shortMonth, locale) {
    dateObj.setMonth(locale.months.shorthand.indexOf(shortMonth));
  },
  S: function (dateObj, seconds) {
    dateObj.setSeconds(parseFloat(seconds));
  },
  U: function (_, unixSeconds) {
    return new Date(parseFloat(unixSeconds) * 1000);
  },
  W: function (dateObj, weekNum, locale) {
    var weekNumber = parseInt(weekNum);
    var date = new Date(dateObj.getFullYear(), 0, 2 + (weekNumber - 1) * 7, 0, 0, 0, 0);
    date.setDate(date.getDate() - date.getDay() + locale.firstDayOfWeek);
    return date;
  },
  Y: function (dateObj, year) {
    dateObj.setFullYear(parseFloat(year));
  },
  Z: function (_, ISODate) {
    return new Date(ISODate);
  },
  d: function (dateObj, day) {
    dateObj.setDate(parseFloat(day));
  },
  h: function (dateObj, hour) {
    dateObj.setHours((dateObj.getHours() >= 12 ? 12 : 0) + parseFloat(hour));
  },
  i: function (dateObj, minutes) {
    dateObj.setMinutes(parseFloat(minutes));
  },
  j: function (dateObj, day) {
    dateObj.setDate(parseFloat(day));
  },
  l: doNothing,
  m: function (dateObj, month) {
    dateObj.setMonth(parseFloat(month) - 1);
  },
  n: function (dateObj, month) {
    dateObj.setMonth(parseFloat(month) - 1);
  },
  s: function (dateObj, seconds) {
    dateObj.setSeconds(parseFloat(seconds));
  },
  u: function (_, unixMillSeconds) {
    return new Date(parseFloat(unixMillSeconds));
  },
  w: doNothing,
  y: function (dateObj, year) {
    dateObj.setFullYear(2000 + parseFloat(year));
  }
};
var tokenRegex = {
  D: "",
  F: "",
  G: "(\\d\\d|\\d)",
  H: "(\\d\\d|\\d)",
  J: "(\\d\\d|\\d)\\w+",
  K: "",
  M: "",
  S: "(\\d\\d|\\d)",
  U: "(.+)",
  W: "(\\d\\d|\\d)",
  Y: "(\\d{4})",
  Z: "(.+)",
  d: "(\\d\\d|\\d)",
  h: "(\\d\\d|\\d)",
  i: "(\\d\\d|\\d)",
  j: "(\\d\\d|\\d)",
  l: "",
  m: "(\\d\\d|\\d)",
  n: "(\\d\\d|\\d)",
  s: "(\\d\\d|\\d)",
  u: "(.+)",
  w: "(\\d\\d|\\d)",
  y: "(\\d{2})"
};
var formats = {
  Z: function (date) {
    return date.toISOString();
  },
  D: function (date, locale, options) {
    return locale.weekdays.shorthand[formats.w(date, locale, options)];
  },
  F: function (date, locale, options) {
    return monthToStr(formats.n(date, locale, options) - 1, false, locale);
  },
  G: function (date, locale, options) {
    return pad(formats.h(date, locale, options));
  },
  H: function (date) {
    return pad(date.getHours());
  },
  J: function (date, locale) {
    return locale.ordinal !== undefined ? date.getDate() + locale.ordinal(date.getDate()) : date.getDate();
  },
  K: function (date, locale) {
    return locale.amPM[int(date.getHours() > 11)];
  },
  M: function (date, locale) {
    return monthToStr(date.getMonth(), true, locale);
  },
  S: function (date) {
    return pad(date.getSeconds());
  },
  U: function (date) {
    return date.getTime() / 1000;
  },
  W: function (date, _, options) {
    return options.getWeek(date);
  },
  Y: function (date) {
    return pad(date.getFullYear(), 4);
  },
  d: function (date) {
    return pad(date.getDate());
  },
  h: function (date) {
    return date.getHours() % 12 ? date.getHours() % 12 : 12;
  },
  i: function (date) {
    return pad(date.getMinutes());
  },
  j: function (date) {
    return date.getDate();
  },
  l: function (date, locale) {
    return locale.weekdays.longhand[date.getDay()];
  },
  m: function (date) {
    return pad(date.getMonth() + 1);
  },
  n: function (date) {
    return date.getMonth() + 1;
  },
  s: function (date) {
    return date.getSeconds();
  },
  u: function (date) {
    return date.getTime();
  },
  w: function (date) {
    return date.getDay();
  },
  y: function (date) {
    return String(date.getFullYear()).substring(2);
  }
};

var createDateFormatter = function (_a) {
  var _b = _a.config,
    config = _b === void 0 ? defaults : _b,
    _c = _a.l10n,
    l10n = _c === void 0 ? english : _c,
    _d = _a.isMobile,
    isMobile = _d === void 0 ? false : _d;
  return function (dateObj, frmt, overrideLocale) {
    var locale = overrideLocale || l10n;
    if (config.formatDate !== undefined && !isMobile) {
      return config.formatDate(dateObj, frmt, locale);
    }
    return frmt.split("").map(function (c, i, arr) {
      return formats[c] && arr[i - 1] !== "\\" ? formats[c](dateObj, locale, config) : c !== "\\" ? c : "";
    }).join("");
  };
};
var createDateParser = function (_a) {
  var _b = _a.config,
    config = _b === void 0 ? defaults : _b,
    _c = _a.l10n,
    l10n = _c === void 0 ? english : _c;
  return function (date, givenFormat, timeless, customLocale) {
    if (date !== 0 && !date) return undefined;
    var locale = customLocale || l10n;
    var parsedDate;
    var dateOrig = date;
    if (date instanceof Date) parsedDate = new Date(date.getTime());else if (typeof date !== "string" && date.toFixed !== undefined) parsedDate = new Date(date);else if (typeof date === "string") {
      var format = givenFormat || (config || defaults).dateFormat;
      var datestr = String(date).trim();
      if (datestr === "today") {
        parsedDate = new Date();
        timeless = true;
      } else if (config && config.parseDate) {
        parsedDate = config.parseDate(date, format);
      } else if (/Z$/.test(datestr) || /GMT$/.test(datestr)) {
        parsedDate = new Date(date);
      } else {
        var matched = void 0,
          ops = [];
        for (var i = 0, matchIndex = 0, regexStr = ""; i < format.length; i++) {
          var token = format[i];
          var isBackSlash = token === "\\";
          var escaped = format[i - 1] === "\\" || isBackSlash;
          if (tokenRegex[token] && !escaped) {
            regexStr += tokenRegex[token];
            var match = new RegExp(regexStr).exec(date);
            if (match && (matched = true)) {
              ops[token !== "Y" ? "push" : "unshift"]({
                fn: revFormat[token],
                val: match[++matchIndex]
              });
            }
          } else if (!isBackSlash) regexStr += ".";
        }
        parsedDate = !config || !config.noCalendar ? new Date(new Date().getFullYear(), 0, 1, 0, 0, 0, 0) : new Date(new Date().setHours(0, 0, 0, 0));
        ops.forEach(function (_a) {
          var fn = _a.fn,
            val = _a.val;
          return parsedDate = fn(parsedDate, val, locale) || parsedDate;
        });
        parsedDate = matched ? parsedDate : undefined;
      }
    }
    if (!(parsedDate instanceof Date && !isNaN(parsedDate.getTime()))) {
      config.errorHandler(new Error("Invalid date provided: " + dateOrig));
      return undefined;
    }
    if (timeless === true) parsedDate.setHours(0, 0, 0, 0);
    return parsedDate;
  };
};
function compareDates(date1, date2, timeless) {
  if (timeless === void 0) {
    timeless = true;
  }
  if (timeless !== false) {
    return new Date(date1.getTime()).setHours(0, 0, 0, 0) - new Date(date2.getTime()).setHours(0, 0, 0, 0);
  }
  return date1.getTime() - date2.getTime();
}
var isBetween = function (ts, ts1, ts2) {
  return ts > Math.min(ts1, ts2) && ts < Math.max(ts1, ts2);
};
var calculateSecondsSinceMidnight = function (hours, minutes, seconds) {
  return hours * 3600 + minutes * 60 + seconds;
};
var parseSeconds = function (secondsSinceMidnight) {
  var hours = Math.floor(secondsSinceMidnight / 3600),
    minutes = (secondsSinceMidnight - hours * 3600) / 60;
  return [hours, minutes, secondsSinceMidnight - hours * 3600 - minutes * 60];
};
var duration = {
  DAY: 86400000
};
function getDefaultHours(config) {
  var hours = config.defaultHour;
  var minutes = config.defaultMinute;
  var seconds = config.defaultSeconds;
  if (config.minDate !== undefined) {
    var minHour = config.minDate.getHours();
    var minMinutes = config.minDate.getMinutes();
    var minSeconds = config.minDate.getSeconds();
    if (hours < minHour) {
      hours = minHour;
    }
    if (hours === minHour && minutes < minMinutes) {
      minutes = minMinutes;
    }
    if (hours === minHour && minutes === minMinutes && seconds < minSeconds) seconds = config.minDate.getSeconds();
  }
  if (config.maxDate !== undefined) {
    var maxHr = config.maxDate.getHours();
    var maxMinutes = config.maxDate.getMinutes();
    hours = Math.min(hours, maxHr);
    if (hours === maxHr) minutes = Math.min(maxMinutes, minutes);
    if (hours === maxHr && minutes === maxMinutes) seconds = config.maxDate.getSeconds();
  }
  return {
    hours: hours,
    minutes: minutes,
    seconds: seconds
  };
}

if (typeof Object.assign !== "function") {
  Object.assign = function (target) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    if (!target) {
      throw TypeError("Cannot convert undefined or null to object");
    }
    var _loop_1 = function (source) {
      if (source) {
        Object.keys(source).forEach(function (key) {
          return target[key] = source[key];
        });
      }
    };
    for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
      var source = args_1[_a];
      _loop_1(source);
    }
    return target;
  };
}

var __assign = window && window.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var __spreadArrays = window && window.__spreadArrays || function () {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];
  return r;
};
var DEBOUNCED_CHANGE_MS = 300;
function FlatpickrInstance(element, instanceConfig) {
  var self = {
    config: __assign(__assign({}, defaults), flatpickr.defaultConfig),
    l10n: english
  };
  self.parseDate = createDateParser({
    config: self.config,
    l10n: self.l10n
  });
  self._handlers = [];
  self.pluginElements = [];
  self.loadedPlugins = [];
  self._bind = bind;
  self._setHoursFromDate = setHoursFromDate;
  self._positionCalendar = positionCalendar;
  self.changeMonth = changeMonth;
  self.changeYear = changeYear;
  self.clear = clear;
  self.close = close;
  self.onMouseOver = onMouseOver;
  self._createElement = createElement;
  self.createDay = createDay;
  self.destroy = destroy;
  self.isEnabled = isEnabled;
  self.jumpToDate = jumpToDate;
  self.updateValue = updateValue;
  self.open = open;
  self.redraw = redraw;
  self.set = set;
  self.setDate = setDate;
  self.toggle = toggle;
  function setupHelperFunctions() {
    self.utils = {
      getDaysInMonth: function (month, yr) {
        if (month === void 0) {
          month = self.currentMonth;
        }
        if (yr === void 0) {
          yr = self.currentYear;
        }
        if (month === 1 && (yr % 4 === 0 && yr % 100 !== 0 || yr % 400 === 0)) return 29;
        return self.l10n.daysInMonth[month];
      }
    };
  }
  function init() {
    self.element = self.input = element;
    self.isOpen = false;
    parseConfig();
    setupLocale();
    setupInputs();
    setupDates();
    setupHelperFunctions();
    if (!self.isMobile) build();
    bindEvents();
    if (self.selectedDates.length || self.config.noCalendar) {
      if (self.config.enableTime) {
        setHoursFromDate(self.config.noCalendar ? self.latestSelectedDateObj : undefined);
      }
      updateValue(false);
    }
    setCalendarWidth();
    var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    if (!self.isMobile && isSafari) {
      positionCalendar();
    }
    triggerEvent("onReady");
  }
  function getClosestActiveElement() {
    var _a;
    return ((_a = self.calendarContainer) === null || _a === void 0 ? void 0 : _a.getRootNode()).activeElement || document.activeElement;
  }
  function bindToInstance(fn) {
    return fn.bind(self);
  }
  function setCalendarWidth() {
    var config = self.config;
    if (config.weekNumbers === false && config.showMonths === 1) {
      return;
    } else if (config.noCalendar !== true) {
      window.requestAnimationFrame(function () {
        if (self.calendarContainer !== undefined) {
          self.calendarContainer.style.visibility = "hidden";
          self.calendarContainer.style.display = "block";
        }
        if (self.daysContainer !== undefined) {
          var daysWidth = (self.days.offsetWidth + 1) * config.showMonths;
          self.daysContainer.style.width = daysWidth + "px";
          self.calendarContainer.style.width = daysWidth + (self.weekWrapper !== undefined ? self.weekWrapper.offsetWidth : 0) + "px";
          self.calendarContainer.style.removeProperty("visibility");
          self.calendarContainer.style.removeProperty("display");
        }
      });
    }
  }
  function updateTime(e) {
    if (self.selectedDates.length === 0) {
      var defaultDate = self.config.minDate === undefined || compareDates(new Date(), self.config.minDate) >= 0 ? new Date() : new Date(self.config.minDate.getTime());
      var defaults = getDefaultHours(self.config);
      defaultDate.setHours(defaults.hours, defaults.minutes, defaults.seconds, defaultDate.getMilliseconds());
      self.selectedDates = [defaultDate];
      self.latestSelectedDateObj = defaultDate;
    }
    if (e !== undefined && e.type !== "blur") {
      timeWrapper(e);
    }
    var prevValue = self._input.value;
    setHoursFromInputs();
    updateValue();
    if (self._input.value !== prevValue) {
      self._debouncedChange();
    }
  }
  function ampm2military(hour, amPM) {
    return hour % 12 + 12 * int(amPM === self.l10n.amPM[1]);
  }
  function military2ampm(hour) {
    switch (hour % 24) {
      case 0:
      case 12:
        return 12;
      default:
        return hour % 12;
    }
  }
  function setHoursFromInputs() {
    if (self.hourElement === undefined || self.minuteElement === undefined) return;
    var hours = (parseInt(self.hourElement.value.slice(-2), 10) || 0) % 24,
      minutes = (parseInt(self.minuteElement.value, 10) || 0) % 60,
      seconds = self.secondElement !== undefined ? (parseInt(self.secondElement.value, 10) || 0) % 60 : 0;
    if (self.amPM !== undefined) {
      hours = ampm2military(hours, self.amPM.textContent);
    }
    var limitMinHours = self.config.minTime !== undefined || self.config.minDate && self.minDateHasTime && self.latestSelectedDateObj && compareDates(self.latestSelectedDateObj, self.config.minDate, true) === 0;
    var limitMaxHours = self.config.maxTime !== undefined || self.config.maxDate && self.maxDateHasTime && self.latestSelectedDateObj && compareDates(self.latestSelectedDateObj, self.config.maxDate, true) === 0;
    if (self.config.maxTime !== undefined && self.config.minTime !== undefined && self.config.minTime > self.config.maxTime) {
      var minBound = calculateSecondsSinceMidnight(self.config.minTime.getHours(), self.config.minTime.getMinutes(), self.config.minTime.getSeconds());
      var maxBound = calculateSecondsSinceMidnight(self.config.maxTime.getHours(), self.config.maxTime.getMinutes(), self.config.maxTime.getSeconds());
      var currentTime = calculateSecondsSinceMidnight(hours, minutes, seconds);
      if (currentTime > maxBound && currentTime < minBound) {
        var result = parseSeconds(minBound);
        hours = result[0];
        minutes = result[1];
        seconds = result[2];
      }
    } else {
      if (limitMaxHours) {
        var maxTime = self.config.maxTime !== undefined ? self.config.maxTime : self.config.maxDate;
        hours = Math.min(hours, maxTime.getHours());
        if (hours === maxTime.getHours()) minutes = Math.min(minutes, maxTime.getMinutes());
        if (minutes === maxTime.getMinutes()) seconds = Math.min(seconds, maxTime.getSeconds());
      }
      if (limitMinHours) {
        var minTime = self.config.minTime !== undefined ? self.config.minTime : self.config.minDate;
        hours = Math.max(hours, minTime.getHours());
        if (hours === minTime.getHours() && minutes < minTime.getMinutes()) minutes = minTime.getMinutes();
        if (minutes === minTime.getMinutes()) seconds = Math.max(seconds, minTime.getSeconds());
      }
    }
    setHours(hours, minutes, seconds);
  }
  function setHoursFromDate(dateObj) {
    var date = dateObj || self.latestSelectedDateObj;
    if (date && date instanceof Date) {
      setHours(date.getHours(), date.getMinutes(), date.getSeconds());
    }
  }
  function setHours(hours, minutes, seconds) {
    if (self.latestSelectedDateObj !== undefined) {
      self.latestSelectedDateObj.setHours(hours % 24, minutes, seconds || 0, 0);
    }
    if (!self.hourElement || !self.minuteElement || self.isMobile) return;
    self.hourElement.value = pad(!self.config.time_24hr ? (12 + hours) % 12 + 12 * int(hours % 12 === 0) : hours);
    self.minuteElement.value = pad(minutes);
    if (self.amPM !== undefined) self.amPM.textContent = self.l10n.amPM[int(hours >= 12)];
    if (self.secondElement !== undefined) self.secondElement.value = pad(seconds);
  }
  function onYearInput(event) {
    var eventTarget = getEventTarget(event);
    var year = parseInt(eventTarget.value) + (event.delta || 0);
    if (year / 1000 > 1 || event.key === "Enter" && !/[^\d]/.test(year.toString())) {
      changeYear(year);
    }
  }
  function bind(element, event, handler, options) {
    if (event instanceof Array) return event.forEach(function (ev) {
      return bind(element, ev, handler, options);
    });
    if (element instanceof Array) return element.forEach(function (el) {
      return bind(el, event, handler, options);
    });
    element.addEventListener(event, handler, options);
    self._handlers.push({
      remove: function () {
        return element.removeEventListener(event, handler, options);
      }
    });
  }
  function triggerChange() {
    triggerEvent("onChange");
  }
  function bindEvents() {
    if (self.config.wrap) {
      ["open", "close", "toggle", "clear"].forEach(function (evt) {
        Array.prototype.forEach.call(self.element.querySelectorAll("[data-" + evt + "]"), function (el) {
          return bind(el, "click", self[evt]);
        });
      });
    }
    if (self.isMobile) {
      setupMobile();
      return;
    }
    var debouncedResize = debounce(onResize, 50);
    self._debouncedChange = debounce(triggerChange, DEBOUNCED_CHANGE_MS);
    if (self.daysContainer && !/iPhone|iPad|iPod/i.test(navigator.userAgent)) bind(self.daysContainer, "mouseover", function (e) {
      if (self.config.mode === "range") onMouseOver(getEventTarget(e));
    });
    bind(self._input, "keydown", onKeyDown);
    if (self.calendarContainer !== undefined) {
      bind(self.calendarContainer, "keydown", onKeyDown);
    }
    if (!self.config.inline && !self.config.static) bind(window, "resize", debouncedResize);
    if (window.ontouchstart !== undefined) bind(window.document, "touchstart", documentClick);else bind(window.document, "mousedown", documentClick);
    bind(window.document, "focus", documentClick, {
      capture: true
    });
    if (self.config.clickOpens === true) {
      bind(self._input, "focus", self.open);
      bind(self._input, "click", self.open);
    }
    if (self.daysContainer !== undefined) {
      bind(self.monthNav, "click", onMonthNavClick);
      bind(self.monthNav, ["keyup", "increment"], onYearInput);
      bind(self.daysContainer, "click", selectDate);
    }
    if (self.timeContainer !== undefined && self.minuteElement !== undefined && self.hourElement !== undefined) {
      var selText = function (e) {
        return getEventTarget(e).select();
      };
      bind(self.timeContainer, ["increment"], updateTime);
      bind(self.timeContainer, "blur", updateTime, {
        capture: true
      });
      bind(self.timeContainer, "click", timeIncrement);
      bind([self.hourElement, self.minuteElement], ["focus", "click"], selText);
      if (self.secondElement !== undefined) bind(self.secondElement, "focus", function () {
        return self.secondElement && self.secondElement.select();
      });
      if (self.amPM !== undefined) {
        bind(self.amPM, "click", function (e) {
          updateTime(e);
        });
      }
    }
    if (self.config.allowInput) {
      bind(self._input, "blur", onBlur);
    }
  }
  function jumpToDate(jumpDate, triggerChange) {
    var jumpTo = jumpDate !== undefined ? self.parseDate(jumpDate) : self.latestSelectedDateObj || (self.config.minDate && self.config.minDate > self.now ? self.config.minDate : self.config.maxDate && self.config.maxDate < self.now ? self.config.maxDate : self.now);
    var oldYear = self.currentYear;
    var oldMonth = self.currentMonth;
    try {
      if (jumpTo !== undefined) {
        self.currentYear = jumpTo.getFullYear();
        self.currentMonth = jumpTo.getMonth();
      }
    } catch (e) {
      e.message = "Invalid date supplied: " + jumpTo;
      self.config.errorHandler(e);
    }
    if (triggerChange && self.currentYear !== oldYear) {
      triggerEvent("onYearChange");
      buildMonthSwitch();
    }
    if (triggerChange && (self.currentYear !== oldYear || self.currentMonth !== oldMonth)) {
      triggerEvent("onMonthChange");
    }
    self.redraw();
  }
  function timeIncrement(e) {
    var eventTarget = getEventTarget(e);
    if (~eventTarget.className.indexOf("arrow")) incrementNumInput(e, eventTarget.classList.contains("arrowUp") ? 1 : -1);
  }
  function incrementNumInput(e, delta, inputElem) {
    var target = e && getEventTarget(e);
    var input = inputElem || target && target.parentNode && target.parentNode.firstChild;
    var event = createEvent("increment");
    event.delta = delta;
    input && input.dispatchEvent(event);
  }
  function build() {
    var fragment = window.document.createDocumentFragment();
    self.calendarContainer = createElement("div", "flatpickr-calendar");
    self.calendarContainer.tabIndex = -1;
    if (!self.config.noCalendar) {
      fragment.appendChild(buildMonthNav());
      self.innerContainer = createElement("div", "flatpickr-innerContainer");
      if (self.config.weekNumbers) {
        var _a = buildWeeks(),
          weekWrapper = _a.weekWrapper,
          weekNumbers = _a.weekNumbers;
        self.innerContainer.appendChild(weekWrapper);
        self.weekNumbers = weekNumbers;
        self.weekWrapper = weekWrapper;
      }
      self.rContainer = createElement("div", "flatpickr-rContainer");
      self.rContainer.appendChild(buildWeekdays());
      if (!self.daysContainer) {
        self.daysContainer = createElement("div", "flatpickr-days");
        self.daysContainer.tabIndex = -1;
      }
      buildDays();
      self.rContainer.appendChild(self.daysContainer);
      self.innerContainer.appendChild(self.rContainer);
      fragment.appendChild(self.innerContainer);
    }
    if (self.config.enableTime) {
      fragment.appendChild(buildTime());
    }
    toggleClass(self.calendarContainer, "rangeMode", self.config.mode === "range");
    toggleClass(self.calendarContainer, "animate", self.config.animate === true);
    toggleClass(self.calendarContainer, "multiMonth", self.config.showMonths > 1);
    self.calendarContainer.appendChild(fragment);
    var customAppend = self.config.appendTo !== undefined && self.config.appendTo.nodeType !== undefined;
    if (self.config.inline || self.config.static) {
      self.calendarContainer.classList.add(self.config.inline ? "inline" : "static");
      if (self.config.inline) {
        if (!customAppend && self.element.parentNode) self.element.parentNode.insertBefore(self.calendarContainer, self._input.nextSibling);else if (self.config.appendTo !== undefined) self.config.appendTo.appendChild(self.calendarContainer);
      }
      if (self.config.static) {
        var wrapper = createElement("div", "flatpickr-wrapper");
        if (self.element.parentNode) self.element.parentNode.insertBefore(wrapper, self.element);
        wrapper.appendChild(self.element);
        if (self.altInput) wrapper.appendChild(self.altInput);
        wrapper.appendChild(self.calendarContainer);
      }
    }
    if (!self.config.static && !self.config.inline) (self.config.appendTo !== undefined ? self.config.appendTo : window.document.body).appendChild(self.calendarContainer);
  }
  function createDay(className, date, _dayNumber, i) {
    var dateIsEnabled = isEnabled(date, true),
      dayElement = createElement("span", className, date.getDate().toString());
    dayElement.dateObj = date;
    dayElement.$i = i;
    dayElement.setAttribute("aria-label", self.formatDate(date, self.config.ariaDateFormat));
    if (className.indexOf("hidden") === -1 && compareDates(date, self.now) === 0) {
      self.todayDateElem = dayElement;
      dayElement.classList.add("today");
      dayElement.setAttribute("aria-current", "date");
    }
    if (dateIsEnabled) {
      dayElement.tabIndex = -1;
      if (isDateSelected(date)) {
        dayElement.classList.add("selected");
        self.selectedDateElem = dayElement;
        if (self.config.mode === "range") {
          toggleClass(dayElement, "startRange", self.selectedDates[0] && compareDates(date, self.selectedDates[0], true) === 0);
          toggleClass(dayElement, "endRange", self.selectedDates[1] && compareDates(date, self.selectedDates[1], true) === 0);
          if (className === "nextMonthDay") dayElement.classList.add("inRange");
        }
      }
    } else {
      dayElement.classList.add("flatpickr-disabled");
    }
    if (self.config.mode === "range") {
      if (isDateInRange(date) && !isDateSelected(date)) dayElement.classList.add("inRange");
    }
    if (self.weekNumbers && self.config.showMonths === 1 && className !== "prevMonthDay" && i % 7 === 6) {
      self.weekNumbers.insertAdjacentHTML("beforeend", "<span class='flatpickr-day'>" + self.config.getWeek(date) + "</span>");
    }
    triggerEvent("onDayCreate", dayElement);
    return dayElement;
  }
  function focusOnDayElem(targetNode) {
    targetNode.focus();
    if (self.config.mode === "range") onMouseOver(targetNode);
  }
  function getFirstAvailableDay(delta) {
    var startMonth = delta > 0 ? 0 : self.config.showMonths - 1;
    var endMonth = delta > 0 ? self.config.showMonths : -1;
    for (var m = startMonth; m != endMonth; m += delta) {
      var month = self.daysContainer.children[m];
      var startIndex = delta > 0 ? 0 : month.children.length - 1;
      var endIndex = delta > 0 ? month.children.length : -1;
      for (var i = startIndex; i != endIndex; i += delta) {
        var c = month.children[i];
        if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj)) return c;
      }
    }
    return undefined;
  }
  function getNextAvailableDay(current, delta) {
    var givenMonth = current.className.indexOf("Month") === -1 ? current.dateObj.getMonth() : self.currentMonth;
    var endMonth = delta > 0 ? self.config.showMonths : -1;
    var loopDelta = delta > 0 ? 1 : -1;
    for (var m = givenMonth - self.currentMonth; m != endMonth; m += loopDelta) {
      var month = self.daysContainer.children[m];
      var startIndex = givenMonth - self.currentMonth === m ? current.$i + delta : delta < 0 ? month.children.length - 1 : 0;
      var numMonthDays = month.children.length;
      for (var i = startIndex; i >= 0 && i < numMonthDays && i != (delta > 0 ? numMonthDays : -1); i += loopDelta) {
        var c = month.children[i];
        if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj) && Math.abs(current.$i - i) >= Math.abs(delta)) return focusOnDayElem(c);
      }
    }
    self.changeMonth(loopDelta);
    focusOnDay(getFirstAvailableDay(loopDelta), 0);
    return undefined;
  }
  function focusOnDay(current, offset) {
    var activeElement = getClosestActiveElement();
    var dayFocused = isInView(activeElement || document.body);
    var startElem = current !== undefined ? current : dayFocused ? activeElement : self.selectedDateElem !== undefined && isInView(self.selectedDateElem) ? self.selectedDateElem : self.todayDateElem !== undefined && isInView(self.todayDateElem) ? self.todayDateElem : getFirstAvailableDay(offset > 0 ? 1 : -1);
    if (startElem === undefined) {
      self._input.focus();
    } else if (!dayFocused) {
      focusOnDayElem(startElem);
    } else {
      getNextAvailableDay(startElem, offset);
    }
  }
  function buildMonthDays(year, month) {
    var firstOfMonth = (new Date(year, month, 1).getDay() - self.l10n.firstDayOfWeek + 7) % 7;
    var prevMonthDays = self.utils.getDaysInMonth((month - 1 + 12) % 12, year);
    var daysInMonth = self.utils.getDaysInMonth(month, year),
      days = window.document.createDocumentFragment(),
      isMultiMonth = self.config.showMonths > 1,
      prevMonthDayClass = isMultiMonth ? "prevMonthDay hidden" : "prevMonthDay",
      nextMonthDayClass = isMultiMonth ? "nextMonthDay hidden" : "nextMonthDay";
    var dayNumber = prevMonthDays + 1 - firstOfMonth,
      dayIndex = 0;
    for (; dayNumber <= prevMonthDays; dayNumber++, dayIndex++) {
      days.appendChild(createDay("flatpickr-day " + prevMonthDayClass, new Date(year, month - 1, dayNumber), dayNumber, dayIndex));
    }
    for (dayNumber = 1; dayNumber <= daysInMonth; dayNumber++, dayIndex++) {
      days.appendChild(createDay("flatpickr-day", new Date(year, month, dayNumber), dayNumber, dayIndex));
    }
    for (var dayNum = daysInMonth + 1; dayNum <= 42 - firstOfMonth && (self.config.showMonths === 1 || dayIndex % 7 !== 0); dayNum++, dayIndex++) {
      days.appendChild(createDay("flatpickr-day " + nextMonthDayClass, new Date(year, month + 1, dayNum % daysInMonth), dayNum, dayIndex));
    }
    var dayContainer = createElement("div", "dayContainer");
    dayContainer.appendChild(days);
    return dayContainer;
  }
  function buildDays() {
    if (self.daysContainer === undefined) {
      return;
    }
    clearNode(self.daysContainer);
    if (self.weekNumbers) clearNode(self.weekNumbers);
    var frag = document.createDocumentFragment();
    for (var i = 0; i < self.config.showMonths; i++) {
      var d = new Date(self.currentYear, self.currentMonth, 1);
      d.setMonth(self.currentMonth + i);
      frag.appendChild(buildMonthDays(d.getFullYear(), d.getMonth()));
    }
    self.daysContainer.appendChild(frag);
    self.days = self.daysContainer.firstChild;
    if (self.config.mode === "range" && self.selectedDates.length === 1) {
      onMouseOver();
    }
  }
  function buildMonthSwitch() {
    if (self.config.showMonths > 1 || self.config.monthSelectorType !== "dropdown") return;
    var shouldBuildMonth = function (month) {
      if (self.config.minDate !== undefined && self.currentYear === self.config.minDate.getFullYear() && month < self.config.minDate.getMonth()) {
        return false;
      }
      return !(self.config.maxDate !== undefined && self.currentYear === self.config.maxDate.getFullYear() && month > self.config.maxDate.getMonth());
    };
    self.monthsDropdownContainer.tabIndex = -1;
    self.monthsDropdownContainer.innerHTML = "";
    for (var i = 0; i < 12; i++) {
      if (!shouldBuildMonth(i)) continue;
      var month = createElement("option", "flatpickr-monthDropdown-month");
      month.value = new Date(self.currentYear, i).getMonth().toString();
      month.textContent = monthToStr(i, self.config.shorthandCurrentMonth, self.l10n);
      month.tabIndex = -1;
      if (self.currentMonth === i) {
        month.selected = true;
      }
      self.monthsDropdownContainer.appendChild(month);
    }
  }
  function buildMonth() {
    var container = createElement("div", "flatpickr-month");
    var monthNavFragment = window.document.createDocumentFragment();
    var monthElement;
    if (self.config.showMonths > 1 || self.config.monthSelectorType === "static") {
      monthElement = createElement("span", "cur-month");
    } else {
      self.monthsDropdownContainer = createElement("select", "flatpickr-monthDropdown-months");
      self.monthsDropdownContainer.setAttribute("aria-label", self.l10n.monthAriaLabel);
      bind(self.monthsDropdownContainer, "change", function (e) {
        var target = getEventTarget(e);
        var selectedMonth = parseInt(target.value, 10);
        self.changeMonth(selectedMonth - self.currentMonth);
        triggerEvent("onMonthChange");
      });
      buildMonthSwitch();
      monthElement = self.monthsDropdownContainer;
    }
    var yearInput = createNumberInput("cur-year", {
      tabindex: "-1"
    });
    var yearElement = yearInput.getElementsByTagName("input")[0];
    yearElement.setAttribute("aria-label", self.l10n.yearAriaLabel);
    if (self.config.minDate) {
      yearElement.setAttribute("min", self.config.minDate.getFullYear().toString());
    }
    if (self.config.maxDate) {
      yearElement.setAttribute("max", self.config.maxDate.getFullYear().toString());
      yearElement.disabled = !!self.config.minDate && self.config.minDate.getFullYear() === self.config.maxDate.getFullYear();
    }
    var currentMonth = createElement("div", "flatpickr-current-month");
    currentMonth.appendChild(monthElement);
    currentMonth.appendChild(yearInput);
    monthNavFragment.appendChild(currentMonth);
    container.appendChild(monthNavFragment);
    return {
      container: container,
      yearElement: yearElement,
      monthElement: monthElement
    };
  }
  function buildMonths() {
    clearNode(self.monthNav);
    self.monthNav.appendChild(self.prevMonthNav);
    if (self.config.showMonths) {
      self.yearElements = [];
      self.monthElements = [];
    }
    for (var m = self.config.showMonths; m--;) {
      var month = buildMonth();
      self.yearElements.push(month.yearElement);
      self.monthElements.push(month.monthElement);
      self.monthNav.appendChild(month.container);
    }
    self.monthNav.appendChild(self.nextMonthNav);
  }
  function buildMonthNav() {
    self.monthNav = createElement("div", "flatpickr-months");
    self.yearElements = [];
    self.monthElements = [];
    self.prevMonthNav = createElement("span", "flatpickr-prev-month");
    self.prevMonthNav.innerHTML = self.config.prevArrow;
    self.nextMonthNav = createElement("span", "flatpickr-next-month");
    self.nextMonthNav.innerHTML = self.config.nextArrow;
    buildMonths();
    Object.defineProperty(self, "_hidePrevMonthArrow", {
      get: function () {
        return self.__hidePrevMonthArrow;
      },
      set: function (bool) {
        if (self.__hidePrevMonthArrow !== bool) {
          toggleClass(self.prevMonthNav, "flatpickr-disabled", bool);
          self.__hidePrevMonthArrow = bool;
        }
      }
    });
    Object.defineProperty(self, "_hideNextMonthArrow", {
      get: function () {
        return self.__hideNextMonthArrow;
      },
      set: function (bool) {
        if (self.__hideNextMonthArrow !== bool) {
          toggleClass(self.nextMonthNav, "flatpickr-disabled", bool);
          self.__hideNextMonthArrow = bool;
        }
      }
    });
    self.currentYearElement = self.yearElements[0];
    updateNavigationCurrentMonth();
    return self.monthNav;
  }
  function buildTime() {
    self.calendarContainer.classList.add("hasTime");
    if (self.config.noCalendar) self.calendarContainer.classList.add("noCalendar");
    var defaults = getDefaultHours(self.config);
    self.timeContainer = createElement("div", "flatpickr-time");
    self.timeContainer.tabIndex = -1;
    var separator = createElement("span", "flatpickr-time-separator", ":");
    var hourInput = createNumberInput("flatpickr-hour", {
      "aria-label": self.l10n.hourAriaLabel
    });
    self.hourElement = hourInput.getElementsByTagName("input")[0];
    var minuteInput = createNumberInput("flatpickr-minute", {
      "aria-label": self.l10n.minuteAriaLabel
    });
    self.minuteElement = minuteInput.getElementsByTagName("input")[0];
    self.hourElement.tabIndex = self.minuteElement.tabIndex = -1;
    self.hourElement.value = pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getHours() : self.config.time_24hr ? defaults.hours : military2ampm(defaults.hours));
    self.minuteElement.value = pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getMinutes() : defaults.minutes);
    self.hourElement.setAttribute("step", self.config.hourIncrement.toString());
    self.minuteElement.setAttribute("step", self.config.minuteIncrement.toString());
    self.hourElement.setAttribute("min", self.config.time_24hr ? "0" : "1");
    self.hourElement.setAttribute("max", self.config.time_24hr ? "23" : "12");
    self.hourElement.setAttribute("maxlength", "2");
    self.minuteElement.setAttribute("min", "0");
    self.minuteElement.setAttribute("max", "59");
    self.minuteElement.setAttribute("maxlength", "2");
    self.timeContainer.appendChild(hourInput);
    self.timeContainer.appendChild(separator);
    self.timeContainer.appendChild(minuteInput);
    if (self.config.time_24hr) self.timeContainer.classList.add("time24hr");
    if (self.config.enableSeconds) {
      self.timeContainer.classList.add("hasSeconds");
      var secondInput = createNumberInput("flatpickr-second");
      self.secondElement = secondInput.getElementsByTagName("input")[0];
      self.secondElement.value = pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getSeconds() : defaults.seconds);
      self.secondElement.setAttribute("step", self.minuteElement.getAttribute("step"));
      self.secondElement.setAttribute("min", "0");
      self.secondElement.setAttribute("max", "59");
      self.secondElement.setAttribute("maxlength", "2");
      self.timeContainer.appendChild(createElement("span", "flatpickr-time-separator", ":"));
      self.timeContainer.appendChild(secondInput);
    }
    if (!self.config.time_24hr) {
      self.amPM = createElement("span", "flatpickr-am-pm", self.l10n.amPM[int((self.latestSelectedDateObj ? self.hourElement.value : self.config.defaultHour) > 11)]);
      self.amPM.title = self.l10n.toggleTitle;
      self.amPM.tabIndex = -1;
      self.timeContainer.appendChild(self.amPM);
    }
    return self.timeContainer;
  }
  function buildWeekdays() {
    if (!self.weekdayContainer) self.weekdayContainer = createElement("div", "flatpickr-weekdays");else clearNode(self.weekdayContainer);
    for (var i = self.config.showMonths; i--;) {
      var container = createElement("div", "flatpickr-weekdaycontainer");
      self.weekdayContainer.appendChild(container);
    }
    updateWeekdays();
    return self.weekdayContainer;
  }
  function updateWeekdays() {
    if (!self.weekdayContainer) {
      return;
    }
    var firstDayOfWeek = self.l10n.firstDayOfWeek;
    var weekdays = __spreadArrays(self.l10n.weekdays.shorthand);
    if (firstDayOfWeek > 0 && firstDayOfWeek < weekdays.length) {
      weekdays = __spreadArrays(weekdays.splice(firstDayOfWeek, weekdays.length), weekdays.splice(0, firstDayOfWeek));
    }
    for (var i = self.config.showMonths; i--;) {
      self.weekdayContainer.children[i].innerHTML = "\n      <span class='flatpickr-weekday'>\n        " + weekdays.join("</span><span class='flatpickr-weekday'>") + "\n      </span>\n      ";
    }
  }
  function buildWeeks() {
    self.calendarContainer.classList.add("hasWeeks");
    var weekWrapper = createElement("div", "flatpickr-weekwrapper");
    weekWrapper.appendChild(createElement("span", "flatpickr-weekday", self.l10n.weekAbbreviation));
    var weekNumbers = createElement("div", "flatpickr-weeks");
    weekWrapper.appendChild(weekNumbers);
    return {
      weekWrapper: weekWrapper,
      weekNumbers: weekNumbers
    };
  }
  function changeMonth(value, isOffset) {
    if (isOffset === void 0) {
      isOffset = true;
    }
    var delta = isOffset ? value : value - self.currentMonth;
    if (delta < 0 && self._hidePrevMonthArrow === true || delta > 0 && self._hideNextMonthArrow === true) return;
    self.currentMonth += delta;
    if (self.currentMonth < 0 || self.currentMonth > 11) {
      self.currentYear += self.currentMonth > 11 ? 1 : -1;
      self.currentMonth = (self.currentMonth + 12) % 12;
      triggerEvent("onYearChange");
      buildMonthSwitch();
    }
    buildDays();
    triggerEvent("onMonthChange");
    updateNavigationCurrentMonth();
  }
  function clear(triggerChangeEvent, toInitial) {
    if (triggerChangeEvent === void 0) {
      triggerChangeEvent = true;
    }
    if (toInitial === void 0) {
      toInitial = true;
    }
    self.input.value = "";
    if (self.altInput !== undefined) self.altInput.value = "";
    if (self.mobileInput !== undefined) self.mobileInput.value = "";
    self.selectedDates = [];
    self.latestSelectedDateObj = undefined;
    if (toInitial === true) {
      self.currentYear = self._initialDate.getFullYear();
      self.currentMonth = self._initialDate.getMonth();
    }
    if (self.config.enableTime === true) {
      var _a = getDefaultHours(self.config),
        hours = _a.hours,
        minutes = _a.minutes,
        seconds = _a.seconds;
      setHours(hours, minutes, seconds);
    }
    self.redraw();
    if (triggerChangeEvent) triggerEvent("onChange");
  }
  function close() {
    self.isOpen = false;
    if (!self.isMobile) {
      if (self.calendarContainer !== undefined) {
        self.calendarContainer.classList.remove("open");
      }
      if (self._input !== undefined) {
        self._input.classList.remove("active");
      }
    }
    triggerEvent("onClose");
  }
  function destroy() {
    if (self.config !== undefined) triggerEvent("onDestroy");
    for (var i = self._handlers.length; i--;) {
      self._handlers[i].remove();
    }
    self._handlers = [];
    if (self.mobileInput) {
      if (self.mobileInput.parentNode) self.mobileInput.parentNode.removeChild(self.mobileInput);
      self.mobileInput = undefined;
    } else if (self.calendarContainer && self.calendarContainer.parentNode) {
      if (self.config.static && self.calendarContainer.parentNode) {
        var wrapper = self.calendarContainer.parentNode;
        wrapper.lastChild && wrapper.removeChild(wrapper.lastChild);
        if (wrapper.parentNode) {
          while (wrapper.firstChild) wrapper.parentNode.insertBefore(wrapper.firstChild, wrapper);
          wrapper.parentNode.removeChild(wrapper);
        }
      } else self.calendarContainer.parentNode.removeChild(self.calendarContainer);
    }
    if (self.altInput) {
      self.input.type = "text";
      if (self.altInput.parentNode) self.altInput.parentNode.removeChild(self.altInput);
      delete self.altInput;
    }
    if (self.input) {
      self.input.type = self.input._type;
      self.input.classList.remove("flatpickr-input");
      self.input.removeAttribute("readonly");
    }
    ["_showTimeInput", "latestSelectedDateObj", "_hideNextMonthArrow", "_hidePrevMonthArrow", "__hideNextMonthArrow", "__hidePrevMonthArrow", "isMobile", "isOpen", "selectedDateElem", "minDateHasTime", "maxDateHasTime", "days", "daysContainer", "_input", "_positionElement", "innerContainer", "rContainer", "monthNav", "todayDateElem", "calendarContainer", "weekdayContainer", "prevMonthNav", "nextMonthNav", "monthsDropdownContainer", "currentMonthElement", "currentYearElement", "navigationCurrentMonth", "selectedDateElem", "config"].forEach(function (k) {
      try {
        delete self[k];
      } catch (_) {}
    });
  }
  function isCalendarElem(elem) {
    return self.calendarContainer.contains(elem);
  }
  function documentClick(e) {
    if (self.isOpen && !self.config.inline) {
      var eventTarget_1 = getEventTarget(e);
      var isCalendarElement = isCalendarElem(eventTarget_1);
      var isInput = eventTarget_1 === self.input || eventTarget_1 === self.altInput || self.element.contains(eventTarget_1) || e.path && e.path.indexOf && (~e.path.indexOf(self.input) || ~e.path.indexOf(self.altInput));
      var lostFocus = !isInput && !isCalendarElement && !isCalendarElem(e.relatedTarget);
      var isIgnored = !self.config.ignoredFocusElements.some(function (elem) {
        return elem.contains(eventTarget_1);
      });
      if (lostFocus && isIgnored) {
        if (self.config.allowInput) {
          self.setDate(self._input.value, false, self.config.altInput ? self.config.altFormat : self.config.dateFormat);
        }
        if (self.timeContainer !== undefined && self.minuteElement !== undefined && self.hourElement !== undefined && self.input.value !== "" && self.input.value !== undefined) {
          updateTime();
        }
        self.close();
        if (self.config && self.config.mode === "range" && self.selectedDates.length === 1) self.clear(false);
      }
    }
  }
  function changeYear(newYear) {
    if (!newYear || self.config.minDate && newYear < self.config.minDate.getFullYear() || self.config.maxDate && newYear > self.config.maxDate.getFullYear()) return;
    var newYearNum = newYear,
      isNewYear = self.currentYear !== newYearNum;
    self.currentYear = newYearNum || self.currentYear;
    if (self.config.maxDate && self.currentYear === self.config.maxDate.getFullYear()) {
      self.currentMonth = Math.min(self.config.maxDate.getMonth(), self.currentMonth);
    } else if (self.config.minDate && self.currentYear === self.config.minDate.getFullYear()) {
      self.currentMonth = Math.max(self.config.minDate.getMonth(), self.currentMonth);
    }
    if (isNewYear) {
      self.redraw();
      triggerEvent("onYearChange");
      buildMonthSwitch();
    }
  }
  function isEnabled(date, timeless) {
    var _a;
    if (timeless === void 0) {
      timeless = true;
    }
    var dateToCheck = self.parseDate(date, undefined, timeless);
    if (self.config.minDate && dateToCheck && compareDates(dateToCheck, self.config.minDate, timeless !== undefined ? timeless : !self.minDateHasTime) < 0 || self.config.maxDate && dateToCheck && compareDates(dateToCheck, self.config.maxDate, timeless !== undefined ? timeless : !self.maxDateHasTime) > 0) return false;
    if (!self.config.enable && self.config.disable.length === 0) return true;
    if (dateToCheck === undefined) return false;
    var bool = !!self.config.enable,
      array = (_a = self.config.enable) !== null && _a !== void 0 ? _a : self.config.disable;
    for (var i = 0, d = void 0; i < array.length; i++) {
      d = array[i];
      if (typeof d === "function" && d(dateToCheck)) return bool;else if (d instanceof Date && dateToCheck !== undefined && d.getTime() === dateToCheck.getTime()) return bool;else if (typeof d === "string") {
        var parsed = self.parseDate(d, undefined, true);
        return parsed && parsed.getTime() === dateToCheck.getTime() ? bool : !bool;
      } else if (typeof d === "object" && dateToCheck !== undefined && d.from && d.to && dateToCheck.getTime() >= d.from.getTime() && dateToCheck.getTime() <= d.to.getTime()) return bool;
    }
    return !bool;
  }
  function isInView(elem) {
    if (self.daysContainer !== undefined) return elem.className.indexOf("hidden") === -1 && elem.className.indexOf("flatpickr-disabled") === -1 && self.daysContainer.contains(elem);
    return false;
  }
  function onBlur(e) {
    var isInput = e.target === self._input;
    var valueChanged = self._input.value.trimEnd() !== getDateStr();
    if (isInput && valueChanged && !(e.relatedTarget && isCalendarElem(e.relatedTarget))) {
      self.setDate(self._input.value, true, e.target === self.altInput ? self.config.altFormat : self.config.dateFormat);
    }
  }
  function onKeyDown(e) {
    var eventTarget = getEventTarget(e);
    var isInput = self.config.wrap ? element.contains(eventTarget) : eventTarget === self._input;
    var allowInput = self.config.allowInput;
    var allowKeydown = self.isOpen && (!allowInput || !isInput);
    var allowInlineKeydown = self.config.inline && isInput && !allowInput;
    if (e.keyCode === 13 && isInput) {
      if (allowInput) {
        self.setDate(self._input.value, true, eventTarget === self.altInput ? self.config.altFormat : self.config.dateFormat);
        self.close();
        return eventTarget.blur();
      } else {
        self.open();
      }
    } else if (isCalendarElem(eventTarget) || allowKeydown || allowInlineKeydown) {
      var isTimeObj = !!self.timeContainer && self.timeContainer.contains(eventTarget);
      switch (e.keyCode) {
        case 13:
          if (isTimeObj) {
            e.preventDefault();
            updateTime();
            focusAndClose();
          } else selectDate(e);
          break;
        case 27:
          e.preventDefault();
          focusAndClose();
          break;
        case 8:
        case 46:
          if (isInput && !self.config.allowInput) {
            e.preventDefault();
            self.clear();
          }
          break;
        case 37:
        case 39:
          if (!isTimeObj && !isInput) {
            e.preventDefault();
            var activeElement = getClosestActiveElement();
            if (self.daysContainer !== undefined && (allowInput === false || activeElement && isInView(activeElement))) {
              var delta_1 = e.keyCode === 39 ? 1 : -1;
              if (!e.ctrlKey) focusOnDay(undefined, delta_1);else {
                e.stopPropagation();
                changeMonth(delta_1);
                focusOnDay(getFirstAvailableDay(1), 0);
              }
            }
          } else if (self.hourElement) self.hourElement.focus();
          break;
        case 38:
        case 40:
          e.preventDefault();
          var delta = e.keyCode === 40 ? 1 : -1;
          if (self.daysContainer && eventTarget.$i !== undefined || eventTarget === self.input || eventTarget === self.altInput) {
            if (e.ctrlKey) {
              e.stopPropagation();
              changeYear(self.currentYear - delta);
              focusOnDay(getFirstAvailableDay(1), 0);
            } else if (!isTimeObj) focusOnDay(undefined, delta * 7);
          } else if (eventTarget === self.currentYearElement) {
            changeYear(self.currentYear - delta);
          } else if (self.config.enableTime) {
            if (!isTimeObj && self.hourElement) self.hourElement.focus();
            updateTime(e);
            self._debouncedChange();
          }
          break;
        case 9:
          if (isTimeObj) {
            var elems = [self.hourElement, self.minuteElement, self.secondElement, self.amPM].concat(self.pluginElements).filter(function (x) {
              return x;
            });
            var i = elems.indexOf(eventTarget);
            if (i !== -1) {
              var target = elems[i + (e.shiftKey ? -1 : 1)];
              e.preventDefault();
              (target || self._input).focus();
            }
          } else if (!self.config.noCalendar && self.daysContainer && self.daysContainer.contains(eventTarget) && e.shiftKey) {
            e.preventDefault();
            self._input.focus();
          }
          break;
      }
    }
    if (self.amPM !== undefined && eventTarget === self.amPM) {
      switch (e.key) {
        case self.l10n.amPM[0].charAt(0):
        case self.l10n.amPM[0].charAt(0).toLowerCase():
          self.amPM.textContent = self.l10n.amPM[0];
          setHoursFromInputs();
          updateValue();
          break;
        case self.l10n.amPM[1].charAt(0):
        case self.l10n.amPM[1].charAt(0).toLowerCase():
          self.amPM.textContent = self.l10n.amPM[1];
          setHoursFromInputs();
          updateValue();
          break;
      }
    }
    if (isInput || isCalendarElem(eventTarget)) {
      triggerEvent("onKeyDown", e);
    }
  }
  function onMouseOver(elem, cellClass) {
    if (cellClass === void 0) {
      cellClass = "flatpickr-day";
    }
    if (self.selectedDates.length !== 1 || elem && (!elem.classList.contains(cellClass) || elem.classList.contains("flatpickr-disabled"))) return;
    var hoverDate = elem ? elem.dateObj.getTime() : self.days.firstElementChild.dateObj.getTime(),
      initialDate = self.parseDate(self.selectedDates[0], undefined, true).getTime(),
      rangeStartDate = Math.min(hoverDate, self.selectedDates[0].getTime()),
      rangeEndDate = Math.max(hoverDate, self.selectedDates[0].getTime());
    var containsDisabled = false;
    var minRange = 0,
      maxRange = 0;
    for (var t = rangeStartDate; t < rangeEndDate; t += duration.DAY) {
      if (!isEnabled(new Date(t), true)) {
        containsDisabled = containsDisabled || t > rangeStartDate && t < rangeEndDate;
        if (t < initialDate && (!minRange || t > minRange)) minRange = t;else if (t > initialDate && (!maxRange || t < maxRange)) maxRange = t;
      }
    }
    var hoverableCells = Array.from(self.rContainer.querySelectorAll("*:nth-child(-n+" + self.config.showMonths + ") > ." + cellClass));
    hoverableCells.forEach(function (dayElem) {
      var date = dayElem.dateObj;
      var timestamp = date.getTime();
      var outOfRange = minRange > 0 && timestamp < minRange || maxRange > 0 && timestamp > maxRange;
      if (outOfRange) {
        dayElem.classList.add("notAllowed");
        ["inRange", "startRange", "endRange"].forEach(function (c) {
          dayElem.classList.remove(c);
        });
        return;
      } else if (containsDisabled && !outOfRange) return;
      ["startRange", "inRange", "endRange", "notAllowed"].forEach(function (c) {
        dayElem.classList.remove(c);
      });
      if (elem !== undefined) {
        elem.classList.add(hoverDate <= self.selectedDates[0].getTime() ? "startRange" : "endRange");
        if (initialDate < hoverDate && timestamp === initialDate) dayElem.classList.add("startRange");else if (initialDate > hoverDate && timestamp === initialDate) dayElem.classList.add("endRange");
        if (timestamp >= minRange && (maxRange === 0 || timestamp <= maxRange) && isBetween(timestamp, initialDate, hoverDate)) dayElem.classList.add("inRange");
      }
    });
  }
  function onResize() {
    if (self.isOpen && !self.config.static && !self.config.inline) positionCalendar();
  }
  function open(e, positionElement) {
    if (positionElement === void 0) {
      positionElement = self._positionElement;
    }
    if (self.isMobile === true) {
      if (e) {
        e.preventDefault();
        var eventTarget = getEventTarget(e);
        if (eventTarget) {
          eventTarget.blur();
        }
      }
      if (self.mobileInput !== undefined) {
        self.mobileInput.focus();
        self.mobileInput.click();
      }
      triggerEvent("onOpen");
      return;
    } else if (self._input.disabled || self.config.inline) {
      return;
    }
    var wasOpen = self.isOpen;
    self.isOpen = true;
    if (!wasOpen) {
      self.calendarContainer.classList.add("open");
      self._input.classList.add("active");
      triggerEvent("onOpen");
      positionCalendar(positionElement);
    }
    if (self.config.enableTime === true && self.config.noCalendar === true) {
      if (self.config.allowInput === false && (e === undefined || !self.timeContainer.contains(e.relatedTarget))) {
        setTimeout(function () {
          return self.hourElement.select();
        }, 50);
      }
    }
  }
  function minMaxDateSetter(type) {
    return function (date) {
      var dateObj = self.config["_" + type + "Date"] = self.parseDate(date, self.config.dateFormat);
      var inverseDateObj = self.config["_" + (type === "min" ? "max" : "min") + "Date"];
      if (dateObj !== undefined) {
        self[type === "min" ? "minDateHasTime" : "maxDateHasTime"] = dateObj.getHours() > 0 || dateObj.getMinutes() > 0 || dateObj.getSeconds() > 0;
      }
      if (self.selectedDates) {
        self.selectedDates = self.selectedDates.filter(function (d) {
          return isEnabled(d);
        });
        if (!self.selectedDates.length && type === "min") setHoursFromDate(dateObj);
        updateValue();
      }
      if (self.daysContainer) {
        redraw();
        if (dateObj !== undefined) self.currentYearElement[type] = dateObj.getFullYear().toString();else self.currentYearElement.removeAttribute(type);
        self.currentYearElement.disabled = !!inverseDateObj && dateObj !== undefined && inverseDateObj.getFullYear() === dateObj.getFullYear();
      }
    };
  }
  function parseConfig() {
    var boolOpts = ["wrap", "weekNumbers", "allowInput", "allowInvalidPreload", "clickOpens", "time_24hr", "enableTime", "noCalendar", "altInput", "shorthandCurrentMonth", "inline", "static", "enableSeconds", "disableMobile"];
    var userConfig = __assign(__assign({}, JSON.parse(JSON.stringify(element.dataset || {}))), instanceConfig);
    var formats = {};
    self.config.parseDate = userConfig.parseDate;
    self.config.formatDate = userConfig.formatDate;
    Object.defineProperty(self.config, "enable", {
      get: function () {
        return self.config._enable;
      },
      set: function (dates) {
        self.config._enable = parseDateRules(dates);
      }
    });
    Object.defineProperty(self.config, "disable", {
      get: function () {
        return self.config._disable;
      },
      set: function (dates) {
        self.config._disable = parseDateRules(dates);
      }
    });
    var timeMode = userConfig.mode === "time";
    if (!userConfig.dateFormat && (userConfig.enableTime || timeMode)) {
      var defaultDateFormat = flatpickr.defaultConfig.dateFormat || defaults.dateFormat;
      formats.dateFormat = userConfig.noCalendar || timeMode ? "H:i" + (userConfig.enableSeconds ? ":S" : "") : defaultDateFormat + " H:i" + (userConfig.enableSeconds ? ":S" : "");
    }
    if (userConfig.altInput && (userConfig.enableTime || timeMode) && !userConfig.altFormat) {
      var defaultAltFormat = flatpickr.defaultConfig.altFormat || defaults.altFormat;
      formats.altFormat = userConfig.noCalendar || timeMode ? "h:i" + (userConfig.enableSeconds ? ":S K" : " K") : defaultAltFormat + (" h:i" + (userConfig.enableSeconds ? ":S" : "") + " K");
    }
    Object.defineProperty(self.config, "minDate", {
      get: function () {
        return self.config._minDate;
      },
      set: minMaxDateSetter("min")
    });
    Object.defineProperty(self.config, "maxDate", {
      get: function () {
        return self.config._maxDate;
      },
      set: minMaxDateSetter("max")
    });
    var minMaxTimeSetter = function (type) {
      return function (val) {
        self.config[type === "min" ? "_minTime" : "_maxTime"] = self.parseDate(val, "H:i:S");
      };
    };
    Object.defineProperty(self.config, "minTime", {
      get: function () {
        return self.config._minTime;
      },
      set: minMaxTimeSetter("min")
    });
    Object.defineProperty(self.config, "maxTime", {
      get: function () {
        return self.config._maxTime;
      },
      set: minMaxTimeSetter("max")
    });
    if (userConfig.mode === "time") {
      self.config.noCalendar = true;
      self.config.enableTime = true;
    }
    Object.assign(self.config, formats, userConfig);
    for (var i = 0; i < boolOpts.length; i++) self.config[boolOpts[i]] = self.config[boolOpts[i]] === true || self.config[boolOpts[i]] === "true";
    HOOKS.filter(function (hook) {
      return self.config[hook] !== undefined;
    }).forEach(function (hook) {
      self.config[hook] = arrayify(self.config[hook] || []).map(bindToInstance);
    });
    self.isMobile = !self.config.disableMobile && !self.config.inline && self.config.mode === "single" && !self.config.disable.length && !self.config.enable && !self.config.weekNumbers && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    for (var i = 0; i < self.config.plugins.length; i++) {
      var pluginConf = self.config.plugins[i](self) || {};
      for (var key in pluginConf) {
        if (HOOKS.indexOf(key) > -1) {
          self.config[key] = arrayify(pluginConf[key]).map(bindToInstance).concat(self.config[key]);
        } else if (typeof userConfig[key] === "undefined") self.config[key] = pluginConf[key];
      }
    }
    if (!userConfig.altInputClass) {
      self.config.altInputClass = getInputElem().className + " " + self.config.altInputClass;
    }
    triggerEvent("onParseConfig");
  }
  function getInputElem() {
    return self.config.wrap ? element.querySelector("[data-input]") : element;
  }
  function setupLocale() {
    if (typeof self.config.locale !== "object" && typeof flatpickr.l10ns[self.config.locale] === "undefined") self.config.errorHandler(new Error("flatpickr: invalid locale " + self.config.locale));
    self.l10n = __assign(__assign({}, flatpickr.l10ns.default), typeof self.config.locale === "object" ? self.config.locale : self.config.locale !== "default" ? flatpickr.l10ns[self.config.locale] : undefined);
    tokenRegex.D = "(" + self.l10n.weekdays.shorthand.join("|") + ")";
    tokenRegex.l = "(" + self.l10n.weekdays.longhand.join("|") + ")";
    tokenRegex.M = "(" + self.l10n.months.shorthand.join("|") + ")";
    tokenRegex.F = "(" + self.l10n.months.longhand.join("|") + ")";
    tokenRegex.K = "(" + self.l10n.amPM[0] + "|" + self.l10n.amPM[1] + "|" + self.l10n.amPM[0].toLowerCase() + "|" + self.l10n.amPM[1].toLowerCase() + ")";
    var userConfig = __assign(__assign({}, instanceConfig), JSON.parse(JSON.stringify(element.dataset || {})));
    if (userConfig.time_24hr === undefined && flatpickr.defaultConfig.time_24hr === undefined) {
      self.config.time_24hr = self.l10n.time_24hr;
    }
    self.formatDate = createDateFormatter(self);
    self.parseDate = createDateParser({
      config: self.config,
      l10n: self.l10n
    });
  }
  function positionCalendar(customPositionElement) {
    if (typeof self.config.position === "function") {
      return void self.config.position(self, customPositionElement);
    }
    if (self.calendarContainer === undefined) return;
    triggerEvent("onPreCalendarPosition");
    var positionElement = customPositionElement || self._positionElement;
    var calendarHeight = Array.prototype.reduce.call(self.calendarContainer.children, function (acc, child) {
        return acc + child.offsetHeight;
      }, 0),
      calendarWidth = self.calendarContainer.offsetWidth,
      configPos = self.config.position.split(" "),
      configPosVertical = configPos[0],
      configPosHorizontal = configPos.length > 1 ? configPos[1] : null,
      inputBounds = positionElement.getBoundingClientRect(),
      distanceFromBottom = window.innerHeight - inputBounds.bottom,
      showOnTop = configPosVertical === "above" || configPosVertical !== "below" && distanceFromBottom < calendarHeight && inputBounds.top > calendarHeight;
    var top = window.pageYOffset + inputBounds.top + (!showOnTop ? positionElement.offsetHeight + 2 : -calendarHeight - 2);
    toggleClass(self.calendarContainer, "arrowTop", !showOnTop);
    toggleClass(self.calendarContainer, "arrowBottom", showOnTop);
    if (self.config.inline) return;
    var left = window.pageXOffset + inputBounds.left;
    var isCenter = false;
    var isRight = false;
    if (configPosHorizontal === "center") {
      left -= (calendarWidth - inputBounds.width) / 2;
      isCenter = true;
    } else if (configPosHorizontal === "right") {
      left -= calendarWidth - inputBounds.width;
      isRight = true;
    }
    toggleClass(self.calendarContainer, "arrowLeft", !isCenter && !isRight);
    toggleClass(self.calendarContainer, "arrowCenter", isCenter);
    toggleClass(self.calendarContainer, "arrowRight", isRight);
    var right = window.document.body.offsetWidth - (window.pageXOffset + inputBounds.right);
    var rightMost = left + calendarWidth > window.document.body.offsetWidth;
    var centerMost = right + calendarWidth > window.document.body.offsetWidth;
    toggleClass(self.calendarContainer, "rightMost", rightMost);
    if (self.config.static) return;
    self.calendarContainer.style.top = top + "px";
    if (!rightMost) {
      self.calendarContainer.style.left = left + "px";
      self.calendarContainer.style.right = "auto";
    } else if (!centerMost) {
      self.calendarContainer.style.left = "auto";
      self.calendarContainer.style.right = right + "px";
    } else {
      var doc = getDocumentStyleSheet();
      if (doc === undefined) return;
      var bodyWidth = window.document.body.offsetWidth;
      var centerLeft = Math.max(0, bodyWidth / 2 - calendarWidth / 2);
      var centerBefore = ".flatpickr-calendar.centerMost:before";
      var centerAfter = ".flatpickr-calendar.centerMost:after";
      var centerIndex = doc.cssRules.length;
      var centerStyle = "{left:" + inputBounds.left + "px;right:auto;}";
      toggleClass(self.calendarContainer, "rightMost", false);
      toggleClass(self.calendarContainer, "centerMost", true);
      doc.insertRule(centerBefore + "," + centerAfter + centerStyle, centerIndex);
      self.calendarContainer.style.left = centerLeft + "px";
      self.calendarContainer.style.right = "auto";
    }
  }
  function getDocumentStyleSheet() {
    var editableSheet = null;
    for (var i = 0; i < document.styleSheets.length; i++) {
      var sheet = document.styleSheets[i];
      if (!sheet.cssRules) continue;
      try {
        sheet.cssRules;
      } catch (err) {
        continue;
      }
      editableSheet = sheet;
      break;
    }
    return editableSheet != null ? editableSheet : createStyleSheet();
  }
  function createStyleSheet() {
    var style = document.createElement("style");
    document.head.appendChild(style);
    return style.sheet;
  }
  function redraw() {
    if (self.config.noCalendar || self.isMobile) return;
    buildMonthSwitch();
    updateNavigationCurrentMonth();
    buildDays();
  }
  function focusAndClose() {
    self._input.focus();
    if (window.navigator.userAgent.indexOf("MSIE") !== -1 || navigator.msMaxTouchPoints !== undefined) {
      setTimeout(self.close, 0);
    } else {
      self.close();
    }
  }
  function selectDate(e) {
    e.preventDefault();
    e.stopPropagation();
    var isSelectable = function (day) {
      return day.classList && day.classList.contains("flatpickr-day") && !day.classList.contains("flatpickr-disabled") && !day.classList.contains("notAllowed");
    };
    var t = findParent(getEventTarget(e), isSelectable);
    if (t === undefined) return;
    var target = t;
    var selectedDate = self.latestSelectedDateObj = new Date(target.dateObj.getTime());
    var shouldChangeMonth = (selectedDate.getMonth() < self.currentMonth || selectedDate.getMonth() > self.currentMonth + self.config.showMonths - 1) && self.config.mode !== "range";
    self.selectedDateElem = target;
    if (self.config.mode === "single") self.selectedDates = [selectedDate];else if (self.config.mode === "multiple") {
      var selectedIndex = isDateSelected(selectedDate);
      if (selectedIndex) self.selectedDates.splice(parseInt(selectedIndex), 1);else self.selectedDates.push(selectedDate);
    } else if (self.config.mode === "range") {
      if (self.selectedDates.length === 2) {
        self.clear(false, false);
      }
      self.latestSelectedDateObj = selectedDate;
      self.selectedDates.push(selectedDate);
      if (compareDates(selectedDate, self.selectedDates[0], true) !== 0) self.selectedDates.sort(function (a, b) {
        return a.getTime() - b.getTime();
      });
    }
    setHoursFromInputs();
    if (shouldChangeMonth) {
      var isNewYear = self.currentYear !== selectedDate.getFullYear();
      self.currentYear = selectedDate.getFullYear();
      self.currentMonth = selectedDate.getMonth();
      if (isNewYear) {
        triggerEvent("onYearChange");
        buildMonthSwitch();
      }
      triggerEvent("onMonthChange");
    }
    updateNavigationCurrentMonth();
    buildDays();
    updateValue();
    if (!shouldChangeMonth && self.config.mode !== "range" && self.config.showMonths === 1) focusOnDayElem(target);else if (self.selectedDateElem !== undefined && self.hourElement === undefined) {
      self.selectedDateElem && self.selectedDateElem.focus();
    }
    if (self.hourElement !== undefined) self.hourElement !== undefined && self.hourElement.focus();
    if (self.config.closeOnSelect) {
      var single = self.config.mode === "single" && !self.config.enableTime;
      var range = self.config.mode === "range" && self.selectedDates.length === 2 && !self.config.enableTime;
      if (single || range) {
        focusAndClose();
      }
    }
    triggerChange();
  }
  var CALLBACKS = {
    locale: [setupLocale, updateWeekdays],
    showMonths: [buildMonths, setCalendarWidth, buildWeekdays],
    minDate: [jumpToDate],
    maxDate: [jumpToDate],
    positionElement: [updatePositionElement],
    clickOpens: [function () {
      if (self.config.clickOpens === true) {
        bind(self._input, "focus", self.open);
        bind(self._input, "click", self.open);
      } else {
        self._input.removeEventListener("focus", self.open);
        self._input.removeEventListener("click", self.open);
      }
    }]
  };
  function set(option, value) {
    if (option !== null && typeof option === "object") {
      Object.assign(self.config, option);
      for (var key in option) {
        if (CALLBACKS[key] !== undefined) CALLBACKS[key].forEach(function (x) {
          return x();
        });
      }
    } else {
      self.config[option] = value;
      if (CALLBACKS[option] !== undefined) CALLBACKS[option].forEach(function (x) {
        return x();
      });else if (HOOKS.indexOf(option) > -1) self.config[option] = arrayify(value);
    }
    self.redraw();
    updateValue(true);
  }
  function setSelectedDate(inputDate, format) {
    var dates = [];
    if (inputDate instanceof Array) dates = inputDate.map(function (d) {
      return self.parseDate(d, format);
    });else if (inputDate instanceof Date || typeof inputDate === "number") dates = [self.parseDate(inputDate, format)];else if (typeof inputDate === "string") {
      switch (self.config.mode) {
        case "single":
        case "time":
          dates = [self.parseDate(inputDate, format)];
          break;
        case "multiple":
          dates = inputDate.split(self.config.conjunction).map(function (date) {
            return self.parseDate(date, format);
          });
          break;
        case "range":
          dates = inputDate.split(self.l10n.rangeSeparator).map(function (date) {
            return self.parseDate(date, format);
          });
          break;
      }
    } else self.config.errorHandler(new Error("Invalid date supplied: " + JSON.stringify(inputDate)));
    self.selectedDates = self.config.allowInvalidPreload ? dates : dates.filter(function (d) {
      return d instanceof Date && isEnabled(d, false);
    });
    if (self.config.mode === "range") self.selectedDates.sort(function (a, b) {
      return a.getTime() - b.getTime();
    });
  }
  function setDate(date, triggerChange, format) {
    if (triggerChange === void 0) {
      triggerChange = false;
    }
    if (format === void 0) {
      format = self.config.dateFormat;
    }
    if (date !== 0 && !date || date instanceof Array && date.length === 0) return self.clear(triggerChange);
    setSelectedDate(date, format);
    self.latestSelectedDateObj = self.selectedDates[self.selectedDates.length - 1];
    self.redraw();
    jumpToDate(undefined, triggerChange);
    setHoursFromDate();
    if (self.selectedDates.length === 0) {
      self.clear(false);
    }
    updateValue(triggerChange);
    if (triggerChange) triggerEvent("onChange");
  }
  function parseDateRules(arr) {
    return arr.slice().map(function (rule) {
      if (typeof rule === "string" || typeof rule === "number" || rule instanceof Date) {
        return self.parseDate(rule, undefined, true);
      } else if (rule && typeof rule === "object" && rule.from && rule.to) return {
        from: self.parseDate(rule.from, undefined),
        to: self.parseDate(rule.to, undefined)
      };
      return rule;
    }).filter(function (x) {
      return x;
    });
  }
  function setupDates() {
    self.selectedDates = [];
    self.now = self.parseDate(self.config.now) || new Date();
    var preloadedDate = self.config.defaultDate || ((self.input.nodeName === "INPUT" || self.input.nodeName === "TEXTAREA") && self.input.placeholder && self.input.value === self.input.placeholder ? null : self.input.value);
    if (preloadedDate) setSelectedDate(preloadedDate, self.config.dateFormat);
    self._initialDate = self.selectedDates.length > 0 ? self.selectedDates[0] : self.config.minDate && self.config.minDate.getTime() > self.now.getTime() ? self.config.minDate : self.config.maxDate && self.config.maxDate.getTime() < self.now.getTime() ? self.config.maxDate : self.now;
    self.currentYear = self._initialDate.getFullYear();
    self.currentMonth = self._initialDate.getMonth();
    if (self.selectedDates.length > 0) self.latestSelectedDateObj = self.selectedDates[0];
    if (self.config.minTime !== undefined) self.config.minTime = self.parseDate(self.config.minTime, "H:i");
    if (self.config.maxTime !== undefined) self.config.maxTime = self.parseDate(self.config.maxTime, "H:i");
    self.minDateHasTime = !!self.config.minDate && (self.config.minDate.getHours() > 0 || self.config.minDate.getMinutes() > 0 || self.config.minDate.getSeconds() > 0);
    self.maxDateHasTime = !!self.config.maxDate && (self.config.maxDate.getHours() > 0 || self.config.maxDate.getMinutes() > 0 || self.config.maxDate.getSeconds() > 0);
  }
  function setupInputs() {
    self.input = getInputElem();
    if (!self.input) {
      self.config.errorHandler(new Error("Invalid input element specified"));
      return;
    }
    self.input._type = self.input.type;
    self.input.type = "text";
    self.input.classList.add("flatpickr-input");
    self._input = self.input;
    if (self.config.altInput) {
      self.altInput = createElement(self.input.nodeName, self.config.altInputClass);
      self._input = self.altInput;
      self.altInput.placeholder = self.input.placeholder;
      self.altInput.disabled = self.input.disabled;
      self.altInput.required = self.input.required;
      self.altInput.tabIndex = self.input.tabIndex;
      self.altInput.type = "text";
      self.input.setAttribute("type", "hidden");
      if (!self.config.static && self.input.parentNode) self.input.parentNode.insertBefore(self.altInput, self.input.nextSibling);
    }
    if (!self.config.allowInput) self._input.setAttribute("readonly", "readonly");
    updatePositionElement();
  }
  function updatePositionElement() {
    self._positionElement = self.config.positionElement || self._input;
  }
  function setupMobile() {
    var inputType = self.config.enableTime ? self.config.noCalendar ? "time" : "datetime-local" : "date";
    self.mobileInput = createElement("input", self.input.className + " flatpickr-mobile");
    self.mobileInput.tabIndex = 1;
    self.mobileInput.type = inputType;
    self.mobileInput.disabled = self.input.disabled;
    self.mobileInput.required = self.input.required;
    self.mobileInput.placeholder = self.input.placeholder;
    self.mobileFormatStr = inputType === "datetime-local" ? "Y-m-d\\TH:i:S" : inputType === "date" ? "Y-m-d" : "H:i:S";
    if (self.selectedDates.length > 0) {
      self.mobileInput.defaultValue = self.mobileInput.value = self.formatDate(self.selectedDates[0], self.mobileFormatStr);
    }
    if (self.config.minDate) self.mobileInput.min = self.formatDate(self.config.minDate, "Y-m-d");
    if (self.config.maxDate) self.mobileInput.max = self.formatDate(self.config.maxDate, "Y-m-d");
    if (self.input.getAttribute("step")) self.mobileInput.step = String(self.input.getAttribute("step"));
    self.input.type = "hidden";
    if (self.altInput !== undefined) self.altInput.type = "hidden";
    try {
      if (self.input.parentNode) self.input.parentNode.insertBefore(self.mobileInput, self.input.nextSibling);
    } catch (_a) {}
    bind(self.mobileInput, "change", function (e) {
      self.setDate(getEventTarget(e).value, false, self.mobileFormatStr);
      triggerEvent("onChange");
      triggerEvent("onClose");
    });
  }
  function toggle(e) {
    if (self.isOpen === true) return self.close();
    self.open(e);
  }
  function triggerEvent(event, data) {
    if (self.config === undefined) return;
    var hooks = self.config[event];
    if (hooks !== undefined && hooks.length > 0) {
      for (var i = 0; hooks[i] && i < hooks.length; i++) hooks[i](self.selectedDates, self.input.value, self, data);
    }
    if (event === "onChange") {
      self.input.dispatchEvent(createEvent("change"));
      self.input.dispatchEvent(createEvent("input"));
    }
  }
  function createEvent(name) {
    var e = document.createEvent("Event");
    e.initEvent(name, true, true);
    return e;
  }
  function isDateSelected(date) {
    for (var i = 0; i < self.selectedDates.length; i++) {
      var selectedDate = self.selectedDates[i];
      if (selectedDate instanceof Date && compareDates(selectedDate, date) === 0) return "" + i;
    }
    return false;
  }
  function isDateInRange(date) {
    if (self.config.mode !== "range" || self.selectedDates.length < 2) return false;
    return compareDates(date, self.selectedDates[0]) >= 0 && compareDates(date, self.selectedDates[1]) <= 0;
  }
  function updateNavigationCurrentMonth() {
    if (self.config.noCalendar || self.isMobile || !self.monthNav) return;
    self.yearElements.forEach(function (yearElement, i) {
      var d = new Date(self.currentYear, self.currentMonth, 1);
      d.setMonth(self.currentMonth + i);
      if (self.config.showMonths > 1 || self.config.monthSelectorType === "static") {
        self.monthElements[i].textContent = monthToStr(d.getMonth(), self.config.shorthandCurrentMonth, self.l10n) + " ";
      } else {
        self.monthsDropdownContainer.value = d.getMonth().toString();
      }
      yearElement.value = d.getFullYear().toString();
    });
    self._hidePrevMonthArrow = self.config.minDate !== undefined && (self.currentYear === self.config.minDate.getFullYear() ? self.currentMonth <= self.config.minDate.getMonth() : self.currentYear < self.config.minDate.getFullYear());
    self._hideNextMonthArrow = self.config.maxDate !== undefined && (self.currentYear === self.config.maxDate.getFullYear() ? self.currentMonth + 1 > self.config.maxDate.getMonth() : self.currentYear > self.config.maxDate.getFullYear());
  }
  function getDateStr(specificFormat) {
    var format = specificFormat || (self.config.altInput ? self.config.altFormat : self.config.dateFormat);
    return self.selectedDates.map(function (dObj) {
      return self.formatDate(dObj, format);
    }).filter(function (d, i, arr) {
      return self.config.mode !== "range" || self.config.enableTime || arr.indexOf(d) === i;
    }).join(self.config.mode !== "range" ? self.config.conjunction : self.l10n.rangeSeparator);
  }
  function updateValue(triggerChange) {
    if (triggerChange === void 0) {
      triggerChange = true;
    }
    if (self.mobileInput !== undefined && self.mobileFormatStr) {
      self.mobileInput.value = self.latestSelectedDateObj !== undefined ? self.formatDate(self.latestSelectedDateObj, self.mobileFormatStr) : "";
    }
    self.input.value = getDateStr(self.config.dateFormat);
    if (self.altInput !== undefined) {
      self.altInput.value = getDateStr(self.config.altFormat);
    }
    if (triggerChange !== false) triggerEvent("onValueUpdate");
  }
  function onMonthNavClick(e) {
    var eventTarget = getEventTarget(e);
    var isPrevMonth = self.prevMonthNav.contains(eventTarget);
    var isNextMonth = self.nextMonthNav.contains(eventTarget);
    if (isPrevMonth || isNextMonth) {
      changeMonth(isPrevMonth ? -1 : 1);
    } else if (self.yearElements.indexOf(eventTarget) >= 0) {
      eventTarget.select();
    } else if (eventTarget.classList.contains("arrowUp")) {
      self.changeYear(self.currentYear + 1);
    } else if (eventTarget.classList.contains("arrowDown")) {
      self.changeYear(self.currentYear - 1);
    }
  }
  function timeWrapper(e) {
    e.preventDefault();
    var isKeyDown = e.type === "keydown",
      eventTarget = getEventTarget(e),
      input = eventTarget;
    if (self.amPM !== undefined && eventTarget === self.amPM) {
      self.amPM.textContent = self.l10n.amPM[int(self.amPM.textContent === self.l10n.amPM[0])];
    }
    var min = parseFloat(input.getAttribute("min")),
      max = parseFloat(input.getAttribute("max")),
      step = parseFloat(input.getAttribute("step")),
      curValue = parseInt(input.value, 10),
      delta = e.delta || (isKeyDown ? e.which === 38 ? 1 : -1 : 0);
    var newValue = curValue + step * delta;
    if (typeof input.value !== "undefined" && input.value.length === 2) {
      var isHourElem = input === self.hourElement,
        isMinuteElem = input === self.minuteElement;
      if (newValue < min) {
        newValue = max + newValue + int(!isHourElem) + (int(isHourElem) && int(!self.amPM));
        if (isMinuteElem) incrementNumInput(undefined, -1, self.hourElement);
      } else if (newValue > max) {
        newValue = input === self.hourElement ? newValue - max - int(!self.amPM) : min;
        if (isMinuteElem) incrementNumInput(undefined, 1, self.hourElement);
      }
      if (self.amPM && isHourElem && (step === 1 ? newValue + curValue === 23 : Math.abs(newValue - curValue) > step)) {
        self.amPM.textContent = self.l10n.amPM[int(self.amPM.textContent === self.l10n.amPM[0])];
      }
      input.value = pad(newValue);
    }
  }
  init();
  return self;
}
function _flatpickr(nodeList, config) {
  var nodes = Array.prototype.slice.call(nodeList).filter(function (x) {
    return x instanceof HTMLElement;
  });
  var instances = [];
  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    try {
      if (node.getAttribute("data-fp-omit") !== null) continue;
      if (node._flatpickr !== undefined) {
        node._flatpickr.destroy();
        node._flatpickr = undefined;
      }
      node._flatpickr = FlatpickrInstance(node, config || {});
      instances.push(node._flatpickr);
    } catch (e) {
      console.error(e);
    }
  }
  return instances.length === 1 ? instances[0] : instances;
}
if (typeof HTMLElement !== "undefined" && typeof HTMLCollection !== "undefined" && typeof NodeList !== "undefined") {
  HTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function (config) {
    return _flatpickr(this, config);
  };
  HTMLElement.prototype.flatpickr = function (config) {
    return _flatpickr([this], config);
  };
}
var flatpickr = function (selector, config) {
  if (typeof selector === "string") {
    return _flatpickr(window.document.querySelectorAll(selector), config);
  } else if (selector instanceof Node) {
    return _flatpickr([selector], config);
  } else {
    return _flatpickr(selector, config);
  }
};
flatpickr.defaultConfig = {};
flatpickr.l10ns = {
  en: __assign({}, english),
  default: __assign({}, english)
};
flatpickr.localize = function (l10n) {
  flatpickr.l10ns.default = __assign(__assign({}, flatpickr.l10ns.default), l10n);
};
flatpickr.setDefaults = function (config) {
  flatpickr.defaultConfig = __assign(__assign({}, flatpickr.defaultConfig), config);
};
flatpickr.parseDate = createDateParser({});
flatpickr.formatDate = createDateFormatter({});
flatpickr.compareDates = compareDates;
if (typeof jQuery !== "undefined" && typeof jQuery.fn !== "undefined") {
  jQuery.fn.flatpickr = function (config) {
    return _flatpickr(this, config);
  };
}
Date.prototype.fp_incr = function (days) {
  return new Date(this.getFullYear(), this.getMonth(), this.getDate() + (typeof days === "string" ? parseInt(days, 10) : days));
};
if (typeof window !== "undefined") {
  window.flatpickr = flatpickr;
}

var _default$7 = {exports: {}};

(function (module, exports) {
	(function (global, factory) {
	  factory(exports) ;
	})(commonjsGlobal, function (exports) {

	  var english = {
	    weekdays: {
	      shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
	      longhand: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
	    },
	    months: {
	      shorthand: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
	      longhand: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
	    },
	    daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
	    firstDayOfWeek: 0,
	    ordinal: function (nth) {
	      var s = nth % 100;
	      if (s > 3 && s < 21) return "th";
	      switch (s % 10) {
	        case 1:
	          return "st";
	        case 2:
	          return "nd";
	        case 3:
	          return "rd";
	        default:
	          return "th";
	      }
	    },
	    rangeSeparator: " to ",
	    weekAbbreviation: "Wk",
	    scrollTitle: "Scroll to increment",
	    toggleTitle: "Click to toggle",
	    amPM: ["AM", "PM"],
	    yearAriaLabel: "Year",
	    monthAriaLabel: "Month",
	    hourAriaLabel: "Hour",
	    minuteAriaLabel: "Minute",
	    time_24hr: false
	  };
	  exports.default = english;
	  exports.english = english;
	  Object.defineProperty(exports, '__esModule', {
	    value: true
	  });
	});
} (_default$7, _default$7.exports));

function toInteger(dirtyNumber) {
  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    return NaN;
  }
  var number = Number(dirtyNumber);
  if (isNaN(number)) {
    return number;
  }
  return number < 0 ? Math.ceil(number) : Math.floor(number);
}

function requiredArgs(required, args) {
  if (args.length < required) {
    throw new TypeError(required + ' argument' + (required > 1 ? 's' : '') + ' required, but only ' + args.length + ' present');
  }
}

function _typeof$y(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$y = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof$y = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }
  return _typeof$y(obj);
}
/**
 * @name toDate
 * @category Common Helpers
 * @summary Convert the given argument to an instance of Date.
 *
 * @description
 * Convert the given argument to an instance of Date.
 *
 * If the argument is an instance of Date, the function returns its clone.
 *
 * If the argument is a number, it is treated as a timestamp.
 *
 * If the argument is none of the above, the function returns Invalid Date.
 *
 * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
 *
 * @param {Date|Number} argument - the value to convert
 * @returns {Date} the parsed date in the local time zone
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Clone the date:
 * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
 * //=> Tue Feb 11 2014 11:30:30
 *
 * @example
 * // Convert the timestamp to date:
 * const result = toDate(1392098430000)
 * //=> Tue Feb 11 2014 11:30:30
 */

function toDate(argument) {
  requiredArgs(1, arguments);
  var argStr = Object.prototype.toString.call(argument); // Clone the date

  if (argument instanceof Date || _typeof$y(argument) === 'object' && argStr === '[object Date]') {
    // Prevent the date to lose the milliseconds when passed to new Date() in IE10
    return new Date(argument.getTime());
  } else if (typeof argument === 'number' || argStr === '[object Number]') {
    return new Date(argument);
  } else {
    if ((typeof argument === 'string' || argStr === '[object String]') && typeof console !== 'undefined') {
      // eslint-disable-next-line no-console
      console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments"); // eslint-disable-next-line no-console

      console.warn(new Error().stack);
    }
    return new Date(NaN);
  }
}

/**
 * @name addMilliseconds
 * @category Millisecond Helpers
 * @summary Add the specified number of milliseconds to the given date.
 *
 * @description
 * Add the specified number of milliseconds to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of milliseconds to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the milliseconds added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add 750 milliseconds to 10 July 2014 12:45:30.000:
 * const result = addMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
 * //=> Thu Jul 10 2014 12:45:30.750
 */

function addMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var timestamp = toDate(dirtyDate).getTime();
  var amount = toInteger(dirtyAmount);
  return new Date(timestamp + amount);
}

var defaultOptions$1 = {};
function getDefaultOptions() {
  return defaultOptions$1;
}

/**
 * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.
 * They usually appear for dates that denote time before the timezones were introduced
 * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891
 * and GMT+01:00:00 after that date)
 *
 * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,
 * which would lead to incorrect calculations.
 *
 * This function returns the timezone offset in milliseconds that takes seconds in account.
 */
function getTimezoneOffsetInMilliseconds(date) {
  var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
  utcDate.setUTCFullYear(date.getFullYear());
  return date.getTime() - utcDate.getTime();
}

/**
 * Days in 1 week.
 *
 * @name daysInWeek
 * @constant
 * @type {number}
 * @default
 */
/**
 * Milliseconds in 1 minute
 *
 * @name millisecondsInMinute
 * @constant
 * @type {number}
 * @default
 */

var millisecondsInMinute = 60000;
/**
 * Milliseconds in 1 hour
 *
 * @name millisecondsInHour
 * @constant
 * @type {number}
 * @default
 */

var millisecondsInHour = 3600000;
/**
 * Milliseconds in 1 second
 *
 * @name millisecondsInSecond
 * @constant
 * @type {number}
 * @default
 */

var millisecondsInSecond = 1000;

function _typeof$x(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$x = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof$x = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }
  return _typeof$x(obj);
}
/**
 * @name isDate
 * @category Common Helpers
 * @summary Is the given value a date?
 *
 * @description
 * Returns true if the given value is an instance of Date. The function works for dates transferred across iframes.
 *
 * @param {*} value - the value to check
 * @returns {boolean} true if the given value is a date
 * @throws {TypeError} 1 arguments required
 *
 * @example
 * // For a valid date:
 * const result = isDate(new Date())
 * //=> true
 *
 * @example
 * // For an invalid date:
 * const result = isDate(new Date(NaN))
 * //=> true
 *
 * @example
 * // For some value:
 * const result = isDate('2014-02-31')
 * //=> false
 *
 * @example
 * // For an object:
 * const result = isDate({})
 * //=> false
 */

function isDate(value) {
  requiredArgs(1, arguments);
  return value instanceof Date || _typeof$x(value) === 'object' && Object.prototype.toString.call(value) === '[object Date]';
}

/**
 * @name isValid
 * @category Common Helpers
 * @summary Is the given date valid?
 *
 * @description
 * Returns false if argument is Invalid Date and true otherwise.
 * Argument is converted to Date using `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
 * Invalid Date is a Date, whose time value is NaN.
 *
 * Time value of Date: http://es5.github.io/#x15.9.1.1
 *
 * @param {*} date - the date to check
 * @returns {Boolean} the date is valid
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // For the valid date:
 * const result = isValid(new Date(2014, 1, 31))
 * //=> true
 *
 * @example
 * // For the value, convertable into a date:
 * const result = isValid(1393804800000)
 * //=> true
 *
 * @example
 * // For the invalid date:
 * const result = isValid(new Date(''))
 * //=> false
 */

function isValid(dirtyDate) {
  requiredArgs(1, arguments);
  if (!isDate(dirtyDate) && typeof dirtyDate !== 'number') {
    return false;
  }
  var date = toDate(dirtyDate);
  return !isNaN(Number(date));
}

/**
 * @name subMilliseconds
 * @category Millisecond Helpers
 * @summary Subtract the specified number of milliseconds from the given date.
 *
 * @description
 * Subtract the specified number of milliseconds from the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of milliseconds to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the milliseconds subtracted
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Subtract 750 milliseconds from 10 July 2014 12:45:30.000:
 * const result = subMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
 * //=> Thu Jul 10 2014 12:45:29.250
 */

function subMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, -amount);
}

function startOfUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}

function getUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var fourthOfJanuaryOfNextYear = new Date(0);
  fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = new Date(0);
  fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

function startOfUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var year = getUTCISOWeekYear(dirtyDate);
  var fourthOfJanuary = new Date(0);
  fourthOfJanuary.setUTCFullYear(year, 0, 4);
  fourthOfJanuary.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCISOWeek(fourthOfJanuary);
  return date;
}

var MILLISECONDS_IN_WEEK$1 = 604800000;
function getUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCISOWeek(date).getTime() - startOfUTCISOWeekYear(date).getTime(); // Round the number of days to the nearest integer
  // because the number of milliseconds in a week is not constant
  // (e.g. it's different in the week of the daylight saving time clock shift)

  return Math.round(diff / MILLISECONDS_IN_WEEK$1) + 1;
}

function startOfUTCWeek(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions = getDefaultOptions();
  var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}

function getUTCWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var defaultOptions = getDefaultOptions();
  var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
  }
  var firstWeekOfNextYear = new Date(0);
  firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, options);
  var firstWeekOfThisYear = new Date(0);
  firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, options);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

function startOfUTCWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions = getDefaultOptions();
  var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
  var year = getUTCWeekYear(dirtyDate, options);
  var firstWeek = new Date(0);
  firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCWeek(firstWeek, options);
  return date;
}

var MILLISECONDS_IN_WEEK = 604800000;
function getUTCWeek(dirtyDate, options) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCWeek(date, options).getTime() - startOfUTCWeekYear(date, options).getTime(); // Round the number of days to the nearest integer
  // because the number of milliseconds in a week is not constant
  // (e.g. it's different in the week of the daylight saving time clock shift)

  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
}

var dateLongFormatter = function dateLongFormatter(pattern, formatLong) {
  switch (pattern) {
    case 'P':
      return formatLong.date({
        width: 'short'
      });
    case 'PP':
      return formatLong.date({
        width: 'medium'
      });
    case 'PPP':
      return formatLong.date({
        width: 'long'
      });
    case 'PPPP':
    default:
      return formatLong.date({
        width: 'full'
      });
  }
};
var timeLongFormatter = function timeLongFormatter(pattern, formatLong) {
  switch (pattern) {
    case 'p':
      return formatLong.time({
        width: 'short'
      });
    case 'pp':
      return formatLong.time({
        width: 'medium'
      });
    case 'ppp':
      return formatLong.time({
        width: 'long'
      });
    case 'pppp':
    default:
      return formatLong.time({
        width: 'full'
      });
  }
};
var dateTimeLongFormatter = function dateTimeLongFormatter(pattern, formatLong) {
  var matchResult = pattern.match(/(P+)(p+)?/) || [];
  var datePattern = matchResult[1];
  var timePattern = matchResult[2];
  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong);
  }
  var dateTimeFormat;
  switch (datePattern) {
    case 'P':
      dateTimeFormat = formatLong.dateTime({
        width: 'short'
      });
      break;
    case 'PP':
      dateTimeFormat = formatLong.dateTime({
        width: 'medium'
      });
      break;
    case 'PPP':
      dateTimeFormat = formatLong.dateTime({
        width: 'long'
      });
      break;
    case 'PPPP':
    default:
      dateTimeFormat = formatLong.dateTime({
        width: 'full'
      });
      break;
  }
  return dateTimeFormat.replace('{{date}}', dateLongFormatter(datePattern, formatLong)).replace('{{time}}', timeLongFormatter(timePattern, formatLong));
};
var longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};

var protectedDayOfYearTokens = ['D', 'DD'];
var protectedWeekYearTokens = ['YY', 'YYYY'];
function isProtectedDayOfYearToken(token) {
  return protectedDayOfYearTokens.indexOf(token) !== -1;
}
function isProtectedWeekYearToken(token) {
  return protectedWeekYearTokens.indexOf(token) !== -1;
}
function throwProtectedError(token, format, input) {
  if (token === 'YYYY') {
    throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === 'YY') {
    throw new RangeError("Use `yy` instead of `YY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === 'D') {
    throw new RangeError("Use `d` instead of `D` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === 'DD') {
    throw new RangeError("Use `dd` instead of `DD` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  }
}

var formatDistanceLocale = {
  lessThanXSeconds: {
    one: 'less than a second',
    other: 'less than {{count}} seconds'
  },
  xSeconds: {
    one: '1 second',
    other: '{{count}} seconds'
  },
  halfAMinute: 'half a minute',
  lessThanXMinutes: {
    one: 'less than a minute',
    other: 'less than {{count}} minutes'
  },
  xMinutes: {
    one: '1 minute',
    other: '{{count}} minutes'
  },
  aboutXHours: {
    one: 'about 1 hour',
    other: 'about {{count}} hours'
  },
  xHours: {
    one: '1 hour',
    other: '{{count}} hours'
  },
  xDays: {
    one: '1 day',
    other: '{{count}} days'
  },
  aboutXWeeks: {
    one: 'about 1 week',
    other: 'about {{count}} weeks'
  },
  xWeeks: {
    one: '1 week',
    other: '{{count}} weeks'
  },
  aboutXMonths: {
    one: 'about 1 month',
    other: 'about {{count}} months'
  },
  xMonths: {
    one: '1 month',
    other: '{{count}} months'
  },
  aboutXYears: {
    one: 'about 1 year',
    other: 'about {{count}} years'
  },
  xYears: {
    one: '1 year',
    other: '{{count}} years'
  },
  overXYears: {
    one: 'over 1 year',
    other: 'over {{count}} years'
  },
  almostXYears: {
    one: 'almost 1 year',
    other: 'almost {{count}} years'
  }
};
var formatDistance = function formatDistance(token, count, options) {
  var result;
  var tokenValue = formatDistanceLocale[token];
  if (typeof tokenValue === 'string') {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace('{{count}}', count.toString());
  }
  if (options !== null && options !== void 0 && options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return 'in ' + result;
    } else {
      return result + ' ago';
    }
  }
  return result;
};

function buildFormatLongFn(args) {
  return function () {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    // TODO: Remove String()
    var width = options.width ? String(options.width) : args.defaultWidth;
    var format = args.formats[width] || args.formats[args.defaultWidth];
    return format;
  };
}

var dateFormats = {
  full: 'EEEE, MMMM do, y',
  long: 'MMMM do, y',
  medium: 'MMM d, y',
  short: 'MM/dd/yyyy'
};
var timeFormats = {
  full: 'h:mm:ss a zzzz',
  long: 'h:mm:ss a z',
  medium: 'h:mm:ss a',
  short: 'h:mm a'
};
var dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: '{{date}}, {{time}}',
  short: '{{date}}, {{time}}'
};
var formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: 'full'
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: 'full'
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: 'full'
  })
};

var formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: 'P'
};
var formatRelative = function formatRelative(token, _date, _baseDate, _options) {
  return formatRelativeLocale[token];
};

function buildLocalizeFn(args) {
  return function (dirtyIndex, options) {
    var context = options !== null && options !== void 0 && options.context ? String(options.context) : 'standalone';
    var valuesArray;
    if (context === 'formatting' && args.formattingValues) {
      var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      var width = options !== null && options !== void 0 && options.width ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      var _defaultWidth = args.defaultWidth;
      var _width = options !== null && options !== void 0 && options.width ? String(options.width) : args.defaultWidth;
      valuesArray = args.values[_width] || args.values[_defaultWidth];
    }
    var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex; // @ts-ignore: For some reason TypeScript just don't want to match it, no matter how hard we try. I challenge you to try to remove it!

    return valuesArray[index];
  };
}

var eraValues = {
  narrow: ['B', 'A'],
  abbreviated: ['BC', 'AD'],
  wide: ['Before Christ', 'Anno Domini']
};
var quarterValues = {
  narrow: ['1', '2', '3', '4'],
  abbreviated: ['Q1', 'Q2', 'Q3', 'Q4'],
  wide: ['1st quarter', '2nd quarter', '3rd quarter', '4th quarter']
}; // Note: in English, the names of days of the week and months are capitalized.
// If you are making a new locale based on this one, check if the same is true for the language you're working on.
// Generally, formatted dates should look like they are in the middle of a sentence,
// e.g. in Spanish language the weekdays and months should be in the lowercase.

var monthValues = {
  narrow: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
  abbreviated: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
  wide: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
};
var dayValues = {
  narrow: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
  short: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
  abbreviated: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
  wide: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
};
var dayPeriodValues = {
  narrow: {
    am: 'a',
    pm: 'p',
    midnight: 'mi',
    noon: 'n',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  },
  abbreviated: {
    am: 'AM',
    pm: 'PM',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  },
  wide: {
    am: 'a.m.',
    pm: 'p.m.',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: 'a',
    pm: 'p',
    midnight: 'mi',
    noon: 'n',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  },
  abbreviated: {
    am: 'AM',
    pm: 'PM',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  },
  wide: {
    am: 'a.m.',
    pm: 'p.m.',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  }
};
var ordinalNumber = function ordinalNumber(dirtyNumber, _options) {
  var number = Number(dirtyNumber); // If ordinal numbers depend on context, for example,
  // if they are different for different grammatical genders,
  // use `options.unit`.
  //
  // `unit` can be 'year', 'quarter', 'month', 'week', 'date', 'dayOfYear',
  // 'day', 'hour', 'minute', 'second'.

  var rem100 = number % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + 'st';
      case 2:
        return number + 'nd';
      case 3:
        return number + 'rd';
    }
  }
  return number + 'th';
};
var localize = {
  ordinalNumber: ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: 'wide'
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: 'wide',
    argumentCallback: function argumentCallback(quarter) {
      return quarter - 1;
    }
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: 'wide'
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: 'wide'
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: 'wide',
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: 'wide'
  })
};

function buildMatchFn(args) {
  return function (string) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var width = options.width;
    var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    var matchResult = string.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    var matchedString = matchResult[0];
    var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    var key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function (pattern) {
      return pattern.test(matchedString);
    }) : findKey(parsePatterns, function (pattern) {
      return pattern.test(matchedString);
    });
    var value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value: value,
      rest: rest
    };
  };
}
function findKey(object, predicate) {
  for (var key in object) {
    if (object.hasOwnProperty(key) && predicate(object[key])) {
      return key;
    }
  }
  return undefined;
}
function findIndex(array, predicate) {
  for (var key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }
  return undefined;
}

function buildMatchPatternFn(args) {
  return function (string) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var matchResult = string.match(args.matchPattern);
    if (!matchResult) return null;
    var matchedString = matchResult[0];
    var parseResult = string.match(args.parsePattern);
    if (!parseResult) return null;
    var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value: value,
      rest: rest
    };
  };
}

var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
};
var matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: function valueCallback(value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseEraPatterns,
    defaultParseWidth: 'any'
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: 'any',
    valueCallback: function valueCallback(index) {
      return index + 1;
    }
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: 'any'
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseDayPatterns,
    defaultParseWidth: 'any'
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: 'any',
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: 'any'
  })
};

/**
 * @type {Locale}
 * @category Locales
 * @summary English locale (United States).
 * @language English
 * @iso-639-2 eng
 * @author Sasha Koss [@kossnocorp]{@link https://github.com/kossnocorp}
 * @author Lesha Koss [@leshakoss]{@link https://github.com/leshakoss}
 */
var locale = {
  code: 'en-US',
  formatDistance: formatDistance,
  formatLong: formatLong,
  formatRelative: formatRelative,
  localize: localize,
  match: match,
  options: {
    weekStartsOn: 0
    /* Sunday */,

    firstWeekContainsDate: 1
  }
};

function assign(target, object) {
  if (target == null) {
    throw new TypeError('assign requires that input parameter not be null or undefined');
  }
  for (var property in object) {
    if (Object.prototype.hasOwnProperty.call(object, property)) {
      target[property] = object[property];
    }
  }
  return target;
}

function _typeof$w(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$w = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof$w = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }
  return _typeof$w(obj);
}
function _inherits$v(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf$v(subClass, superClass);
}
function _setPrototypeOf$v(o, p) {
  _setPrototypeOf$v = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf$v(o, p);
}
function _createSuper$v(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$v();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$v(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$v(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$v(this, result);
  };
}
function _possibleConstructorReturn$v(self, call) {
  if (call && (_typeof$w(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$v(self);
}
function _assertThisInitialized$v(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$v() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$v(o) {
  _getPrototypeOf$v = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$v(o);
}
function _classCallCheck$w(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$w(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$w(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$w(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$w(Constructor, staticProps);
  return Constructor;
}
function _defineProperty$v(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var TIMEZONE_UNIT_PRIORITY = 10;
var Setter = /*#__PURE__*/function () {
  function Setter() {
    _classCallCheck$w(this, Setter);
    _defineProperty$v(this, "subPriority", 0);
  }
  _createClass$w(Setter, [{
    key: "validate",
    value: function validate(_utcDate, _options) {
      return true;
    }
  }]);
  return Setter;
}();
var ValueSetter = /*#__PURE__*/function (_Setter) {
  _inherits$v(ValueSetter, _Setter);
  var _super = _createSuper$v(ValueSetter);
  function ValueSetter(value, validateValue, setValue, priority, subPriority) {
    var _this;
    _classCallCheck$w(this, ValueSetter);
    _this = _super.call(this);
    _this.value = value;
    _this.validateValue = validateValue;
    _this.setValue = setValue;
    _this.priority = priority;
    if (subPriority) {
      _this.subPriority = subPriority;
    }
    return _this;
  }
  _createClass$w(ValueSetter, [{
    key: "validate",
    value: function validate(utcDate, options) {
      return this.validateValue(utcDate, this.value, options);
    }
  }, {
    key: "set",
    value: function set(utcDate, flags, options) {
      return this.setValue(utcDate, flags, this.value, options);
    }
  }]);
  return ValueSetter;
}(Setter);
var DateToSystemTimezoneSetter = /*#__PURE__*/function (_Setter2) {
  _inherits$v(DateToSystemTimezoneSetter, _Setter2);
  var _super2 = _createSuper$v(DateToSystemTimezoneSetter);
  function DateToSystemTimezoneSetter() {
    var _this2;
    _classCallCheck$w(this, DateToSystemTimezoneSetter);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _super2.call.apply(_super2, [this].concat(args));
    _defineProperty$v(_assertThisInitialized$v(_this2), "priority", TIMEZONE_UNIT_PRIORITY);
    _defineProperty$v(_assertThisInitialized$v(_this2), "subPriority", -1);
    return _this2;
  }
  _createClass$w(DateToSystemTimezoneSetter, [{
    key: "set",
    value: function set(date, flags) {
      if (flags.timestampIsSet) {
        return date;
      }
      var convertedDate = new Date(0);
      convertedDate.setFullYear(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
      convertedDate.setHours(date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
      return convertedDate;
    }
  }]);
  return DateToSystemTimezoneSetter;
}(Setter);

function _classCallCheck$v(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$v(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$v(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$v(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$v(Constructor, staticProps);
  return Constructor;
}
var Parser = /*#__PURE__*/function () {
  function Parser() {
    _classCallCheck$v(this, Parser);
  }
  _createClass$v(Parser, [{
    key: "run",
    value: function run(dateString, token, match, options) {
      var result = this.parse(dateString, token, match, options);
      if (!result) {
        return null;
      }
      return {
        setter: new ValueSetter(result.value, this.validate, this.set, this.priority, this.subPriority),
        rest: result.rest
      };
    }
  }, {
    key: "validate",
    value: function validate(_utcDate, _value, _options) {
      return true;
    }
  }]);
  return Parser;
}();

function _typeof$v(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$v = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof$v = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }
  return _typeof$v(obj);
}
function _classCallCheck$u(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$u(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$u(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$u(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$u(Constructor, staticProps);
  return Constructor;
}
function _inherits$u(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf$u(subClass, superClass);
}
function _setPrototypeOf$u(o, p) {
  _setPrototypeOf$u = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf$u(o, p);
}
function _createSuper$u(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$u();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$u(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$u(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$u(this, result);
  };
}
function _possibleConstructorReturn$u(self, call) {
  if (call && (_typeof$v(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$u(self);
}
function _assertThisInitialized$u(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$u() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$u(o) {
  _getPrototypeOf$u = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$u(o);
}
function _defineProperty$u(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var EraParser = /*#__PURE__*/function (_Parser) {
  _inherits$u(EraParser, _Parser);
  var _super = _createSuper$u(EraParser);
  function EraParser() {
    var _this;
    _classCallCheck$u(this, EraParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$u(_assertThisInitialized$u(_this), "priority", 140);
    _defineProperty$u(_assertThisInitialized$u(_this), "incompatibleTokens", ['R', 'u', 't', 'T']);
    return _this;
  }
  _createClass$u(EraParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        // AD, BC
        case 'G':
        case 'GG':
        case 'GGG':
          return match.era(dateString, {
            width: 'abbreviated'
          }) || match.era(dateString, {
            width: 'narrow'
          });
        // A, B

        case 'GGGGG':
          return match.era(dateString, {
            width: 'narrow'
          });
        // Anno Domini, Before Christ

        case 'GGGG':
        default:
          return match.era(dateString, {
            width: 'wide'
          }) || match.era(dateString, {
            width: 'abbreviated'
          }) || match.era(dateString, {
            width: 'narrow'
          });
      }
    }
  }, {
    key: "set",
    value: function set(date, flags, value) {
      flags.era = value;
      date.setUTCFullYear(value, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return EraParser;
}(Parser);

var numericPatterns = {
  month: /^(1[0-2]|0?\d)/,
  // 0 to 12
  date: /^(3[0-1]|[0-2]?\d)/,
  // 0 to 31
  dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
  // 0 to 366
  week: /^(5[0-3]|[0-4]?\d)/,
  // 0 to 53
  hour23h: /^(2[0-3]|[0-1]?\d)/,
  // 0 to 23
  hour24h: /^(2[0-4]|[0-1]?\d)/,
  // 0 to 24
  hour11h: /^(1[0-1]|0?\d)/,
  // 0 to 11
  hour12h: /^(1[0-2]|0?\d)/,
  // 0 to 12
  minute: /^[0-5]?\d/,
  // 0 to 59
  second: /^[0-5]?\d/,
  // 0 to 59
  singleDigit: /^\d/,
  // 0 to 9
  twoDigits: /^\d{1,2}/,
  // 0 to 99
  threeDigits: /^\d{1,3}/,
  // 0 to 999
  fourDigits: /^\d{1,4}/,
  // 0 to 9999
  anyDigitsSigned: /^-?\d+/,
  singleDigitSigned: /^-?\d/,
  // 0 to 9, -0 to -9
  twoDigitsSigned: /^-?\d{1,2}/,
  // 0 to 99, -0 to -99
  threeDigitsSigned: /^-?\d{1,3}/,
  // 0 to 999, -0 to -999
  fourDigitsSigned: /^-?\d{1,4}/ // 0 to 9999, -0 to -9999
};

var timezonePatterns = {
  basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
  basic: /^([+-])(\d{2})(\d{2})|Z/,
  basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
  extended: /^([+-])(\d{2}):(\d{2})|Z/,
  extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};

function mapValue(parseFnResult, mapFn) {
  if (!parseFnResult) {
    return parseFnResult;
  }
  return {
    value: mapFn(parseFnResult.value),
    rest: parseFnResult.rest
  };
}
function parseNumericPattern(pattern, dateString) {
  var matchResult = dateString.match(pattern);
  if (!matchResult) {
    return null;
  }
  return {
    value: parseInt(matchResult[0], 10),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseTimezonePattern(pattern, dateString) {
  var matchResult = dateString.match(pattern);
  if (!matchResult) {
    return null;
  } // Input is 'Z'

  if (matchResult[0] === 'Z') {
    return {
      value: 0,
      rest: dateString.slice(1)
    };
  }
  var sign = matchResult[1] === '+' ? 1 : -1;
  var hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
  var minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
  var seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
  return {
    value: sign * (hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * millisecondsInSecond),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseAnyDigitsSigned(dateString) {
  return parseNumericPattern(numericPatterns.anyDigitsSigned, dateString);
}
function parseNDigits(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigit, dateString);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigits, dateString);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigits, dateString);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigits, dateString);
    default:
      return parseNumericPattern(new RegExp('^\\d{1,' + n + '}'), dateString);
  }
}
function parseNDigitsSigned(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigitSigned, dateString);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigitsSigned, dateString);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigitsSigned, dateString);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigitsSigned, dateString);
    default:
      return parseNumericPattern(new RegExp('^-?\\d{1,' + n + '}'), dateString);
  }
}
function dayPeriodEnumToHours(dayPeriod) {
  switch (dayPeriod) {
    case 'morning':
      return 4;
    case 'evening':
      return 17;
    case 'pm':
    case 'noon':
    case 'afternoon':
      return 12;
    case 'am':
    case 'midnight':
    case 'night':
    default:
      return 0;
  }
}
function normalizeTwoDigitYear(twoDigitYear, currentYear) {
  var isCommonEra = currentYear > 0; // Absolute number of the current year:
  // 1 -> 1 AC
  // 0 -> 1 BC
  // -1 -> 2 BC

  var absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
  var result;
  if (absCurrentYear <= 50) {
    result = twoDigitYear || 100;
  } else {
    var rangeEnd = absCurrentYear + 50;
    var rangeEndCentury = Math.floor(rangeEnd / 100) * 100;
    var isPreviousCentury = twoDigitYear >= rangeEnd % 100;
    result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
  }
  return isCommonEra ? result : 1 - result;
}
function isLeapYearIndex(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}

function _typeof$u(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$u = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof$u = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }
  return _typeof$u(obj);
}
function _classCallCheck$t(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$t(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$t(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$t(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$t(Constructor, staticProps);
  return Constructor;
}
function _inherits$t(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf$t(subClass, superClass);
}
function _setPrototypeOf$t(o, p) {
  _setPrototypeOf$t = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf$t(o, p);
}
function _createSuper$t(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$t();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$t(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$t(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$t(this, result);
  };
}
function _possibleConstructorReturn$t(self, call) {
  if (call && (_typeof$u(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$t(self);
}
function _assertThisInitialized$t(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$t() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$t(o) {
  _getPrototypeOf$t = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$t(o);
}
function _defineProperty$t(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
// From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_Patterns
// | Year     |     y | yy |   yyy |  yyyy | yyyyy |
// |----------|-------|----|-------|-------|-------|
// | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
// | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
// | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
// | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
// | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |
var YearParser = /*#__PURE__*/function (_Parser) {
  _inherits$t(YearParser, _Parser);
  var _super = _createSuper$t(YearParser);
  function YearParser() {
    var _this;
    _classCallCheck$t(this, YearParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$t(_assertThisInitialized$t(_this), "priority", 130);
    _defineProperty$t(_assertThisInitialized$t(_this), "incompatibleTokens", ['Y', 'R', 'u', 'w', 'I', 'i', 'e', 'c', 't', 'T']);
    return _this;
  }
  _createClass$t(YearParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      var valueCallback = function valueCallback(year) {
        return {
          year: year,
          isTwoDigitYear: token === 'yy'
        };
      };
      switch (token) {
        case 'y':
          return mapValue(parseNDigits(4, dateString), valueCallback);
        case 'yo':
          return mapValue(match.ordinalNumber(dateString, {
            unit: 'year'
          }), valueCallback);
        default:
          return mapValue(parseNDigits(token.length, dateString), valueCallback);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value.isTwoDigitYear || value.year > 0;
    }
  }, {
    key: "set",
    value: function set(date, flags, value) {
      var currentYear = date.getUTCFullYear();
      if (value.isTwoDigitYear) {
        var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
        date.setUTCFullYear(normalizedTwoDigitYear, 0, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }
      var year = !('era' in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date.setUTCFullYear(year, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return YearParser;
}(Parser);

function _typeof$t(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$t = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof$t = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }
  return _typeof$t(obj);
}
function _classCallCheck$s(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$s(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$s(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$s(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$s(Constructor, staticProps);
  return Constructor;
}
function _inherits$s(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf$s(subClass, superClass);
}
function _setPrototypeOf$s(o, p) {
  _setPrototypeOf$s = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf$s(o, p);
}
function _createSuper$s(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$s();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$s(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$s(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$s(this, result);
  };
}
function _possibleConstructorReturn$s(self, call) {
  if (call && (_typeof$t(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$s(self);
}
function _assertThisInitialized$s(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$s() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$s(o) {
  _getPrototypeOf$s = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$s(o);
}
function _defineProperty$s(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
// Local week-numbering year
var LocalWeekYearParser = /*#__PURE__*/function (_Parser) {
  _inherits$s(LocalWeekYearParser, _Parser);
  var _super = _createSuper$s(LocalWeekYearParser);
  function LocalWeekYearParser() {
    var _this;
    _classCallCheck$s(this, LocalWeekYearParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$s(_assertThisInitialized$s(_this), "priority", 130);
    _defineProperty$s(_assertThisInitialized$s(_this), "incompatibleTokens", ['y', 'R', 'u', 'Q', 'q', 'M', 'L', 'I', 'd', 'D', 'i', 't', 'T']);
    return _this;
  }
  _createClass$s(LocalWeekYearParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      var valueCallback = function valueCallback(year) {
        return {
          year: year,
          isTwoDigitYear: token === 'YY'
        };
      };
      switch (token) {
        case 'Y':
          return mapValue(parseNDigits(4, dateString), valueCallback);
        case 'Yo':
          return mapValue(match.ordinalNumber(dateString, {
            unit: 'year'
          }), valueCallback);
        default:
          return mapValue(parseNDigits(token.length, dateString), valueCallback);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value.isTwoDigitYear || value.year > 0;
    }
  }, {
    key: "set",
    value: function set(date, flags, value, options) {
      var currentYear = getUTCWeekYear(date, options);
      if (value.isTwoDigitYear) {
        var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
        date.setUTCFullYear(normalizedTwoDigitYear, 0, options.firstWeekContainsDate);
        date.setUTCHours(0, 0, 0, 0);
        return startOfUTCWeek(date, options);
      }
      var year = !('era' in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date.setUTCFullYear(year, 0, options.firstWeekContainsDate);
      date.setUTCHours(0, 0, 0, 0);
      return startOfUTCWeek(date, options);
    }
  }]);
  return LocalWeekYearParser;
}(Parser);

function _typeof$s(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$s = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof$s = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }
  return _typeof$s(obj);
}
function _classCallCheck$r(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$r(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$r(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$r(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$r(Constructor, staticProps);
  return Constructor;
}
function _inherits$r(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf$r(subClass, superClass);
}
function _setPrototypeOf$r(o, p) {
  _setPrototypeOf$r = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf$r(o, p);
}
function _createSuper$r(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$r();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$r(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$r(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$r(this, result);
  };
}
function _possibleConstructorReturn$r(self, call) {
  if (call && (_typeof$s(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$r(self);
}
function _assertThisInitialized$r(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$r() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$r(o) {
  _getPrototypeOf$r = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$r(o);
}
function _defineProperty$r(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

var ISOWeekYearParser = /*#__PURE__*/function (_Parser) {
  _inherits$r(ISOWeekYearParser, _Parser);
  var _super = _createSuper$r(ISOWeekYearParser);
  function ISOWeekYearParser() {
    var _this;
    _classCallCheck$r(this, ISOWeekYearParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$r(_assertThisInitialized$r(_this), "priority", 130);
    _defineProperty$r(_assertThisInitialized$r(_this), "incompatibleTokens", ['G', 'y', 'Y', 'u', 'Q', 'q', 'M', 'L', 'w', 'd', 'D', 'e', 'c', 't', 'T']);
    return _this;
  }
  _createClass$r(ISOWeekYearParser, [{
    key: "parse",
    value: function parse(dateString, token) {
      if (token === 'R') {
        return parseNDigitsSigned(4, dateString);
      }
      return parseNDigitsSigned(token.length, dateString);
    }
  }, {
    key: "set",
    value: function set(_date, _flags, value) {
      var firstWeekOfYear = new Date(0);
      firstWeekOfYear.setUTCFullYear(value, 0, 4);
      firstWeekOfYear.setUTCHours(0, 0, 0, 0);
      return startOfUTCISOWeek(firstWeekOfYear);
    }
  }]);
  return ISOWeekYearParser;
}(Parser);

function _typeof$r(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$r = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof$r = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }
  return _typeof$r(obj);
}
function _classCallCheck$q(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$q(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$q(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$q(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$q(Constructor, staticProps);
  return Constructor;
}
function _inherits$q(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf$q(subClass, superClass);
}
function _setPrototypeOf$q(o, p) {
  _setPrototypeOf$q = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf$q(o, p);
}
function _createSuper$q(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$q();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$q(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$q(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$q(this, result);
  };
}
function _possibleConstructorReturn$q(self, call) {
  if (call && (_typeof$r(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$q(self);
}
function _assertThisInitialized$q(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$q() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$q(o) {
  _getPrototypeOf$q = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$q(o);
}
function _defineProperty$q(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var ExtendedYearParser = /*#__PURE__*/function (_Parser) {
  _inherits$q(ExtendedYearParser, _Parser);
  var _super = _createSuper$q(ExtendedYearParser);
  function ExtendedYearParser() {
    var _this;
    _classCallCheck$q(this, ExtendedYearParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$q(_assertThisInitialized$q(_this), "priority", 130);
    _defineProperty$q(_assertThisInitialized$q(_this), "incompatibleTokens", ['G', 'y', 'Y', 'R', 'w', 'I', 'i', 'e', 'c', 't', 'T']);
    return _this;
  }
  _createClass$q(ExtendedYearParser, [{
    key: "parse",
    value: function parse(dateString, token) {
      if (token === 'u') {
        return parseNDigitsSigned(4, dateString);
      }
      return parseNDigitsSigned(token.length, dateString);
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCFullYear(value, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return ExtendedYearParser;
}(Parser);

function _typeof$q(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$q = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof$q = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }
  return _typeof$q(obj);
}
function _classCallCheck$p(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$p(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$p(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$p(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$p(Constructor, staticProps);
  return Constructor;
}
function _inherits$p(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf$p(subClass, superClass);
}
function _setPrototypeOf$p(o, p) {
  _setPrototypeOf$p = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf$p(o, p);
}
function _createSuper$p(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$p();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$p(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$p(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$p(this, result);
  };
}
function _possibleConstructorReturn$p(self, call) {
  if (call && (_typeof$q(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$p(self);
}
function _assertThisInitialized$p(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$p() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$p(o) {
  _getPrototypeOf$p = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$p(o);
}
function _defineProperty$p(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var QuarterParser = /*#__PURE__*/function (_Parser) {
  _inherits$p(QuarterParser, _Parser);
  var _super = _createSuper$p(QuarterParser);
  function QuarterParser() {
    var _this;
    _classCallCheck$p(this, QuarterParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$p(_assertThisInitialized$p(_this), "priority", 120);
    _defineProperty$p(_assertThisInitialized$p(_this), "incompatibleTokens", ['Y', 'R', 'q', 'M', 'L', 'w', 'I', 'd', 'D', 'i', 'e', 'c', 't', 'T']);
    return _this;
  }
  _createClass$p(QuarterParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        // 1, 2, 3, 4
        case 'Q':
        case 'QQ':
          // 01, 02, 03, 04
          return parseNDigits(token.length, dateString);
        // 1st, 2nd, 3rd, 4th

        case 'Qo':
          return match.ordinalNumber(dateString, {
            unit: 'quarter'
          });
        // Q1, Q2, Q3, Q4

        case 'QQQ':
          return match.quarter(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.quarter(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // 1, 2, 3, 4 (narrow quarter; could be not numerical)

        case 'QQQQQ':
          return match.quarter(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // 1st quarter, 2nd quarter, ...

        case 'QQQQ':
        default:
          return match.quarter(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.quarter(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.quarter(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 4;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMonth((value - 1) * 3, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return QuarterParser;
}(Parser);

function _typeof$p(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$p = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof$p = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }
  return _typeof$p(obj);
}
function _classCallCheck$o(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$o(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$o(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$o(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$o(Constructor, staticProps);
  return Constructor;
}
function _inherits$o(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf$o(subClass, superClass);
}
function _setPrototypeOf$o(o, p) {
  _setPrototypeOf$o = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf$o(o, p);
}
function _createSuper$o(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$o();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$o(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$o(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$o(this, result);
  };
}
function _possibleConstructorReturn$o(self, call) {
  if (call && (_typeof$p(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$o(self);
}
function _assertThisInitialized$o(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$o() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$o(o) {
  _getPrototypeOf$o = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$o(o);
}
function _defineProperty$o(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var StandAloneQuarterParser = /*#__PURE__*/function (_Parser) {
  _inherits$o(StandAloneQuarterParser, _Parser);
  var _super = _createSuper$o(StandAloneQuarterParser);
  function StandAloneQuarterParser() {
    var _this;
    _classCallCheck$o(this, StandAloneQuarterParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$o(_assertThisInitialized$o(_this), "priority", 120);
    _defineProperty$o(_assertThisInitialized$o(_this), "incompatibleTokens", ['Y', 'R', 'Q', 'M', 'L', 'w', 'I', 'd', 'D', 'i', 'e', 'c', 't', 'T']);
    return _this;
  }
  _createClass$o(StandAloneQuarterParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        // 1, 2, 3, 4
        case 'q':
        case 'qq':
          // 01, 02, 03, 04
          return parseNDigits(token.length, dateString);
        // 1st, 2nd, 3rd, 4th

        case 'qo':
          return match.ordinalNumber(dateString, {
            unit: 'quarter'
          });
        // Q1, Q2, Q3, Q4

        case 'qqq':
          return match.quarter(dateString, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.quarter(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
        // 1, 2, 3, 4 (narrow quarter; could be not numerical)

        case 'qqqqq':
          return match.quarter(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
        // 1st quarter, 2nd quarter, ...

        case 'qqqq':
        default:
          return match.quarter(dateString, {
            width: 'wide',
            context: 'standalone'
          }) || match.quarter(dateString, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.quarter(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 4;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMonth((value - 1) * 3, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return StandAloneQuarterParser;
}(Parser);

function _typeof$o(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$o = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof$o = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }
  return _typeof$o(obj);
}
function _classCallCheck$n(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$n(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$n(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$n(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$n(Constructor, staticProps);
  return Constructor;
}
function _inherits$n(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf$n(subClass, superClass);
}
function _setPrototypeOf$n(o, p) {
  _setPrototypeOf$n = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf$n(o, p);
}
function _createSuper$n(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$n();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$n(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$n(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$n(this, result);
  };
}
function _possibleConstructorReturn$n(self, call) {
  if (call && (_typeof$o(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$n(self);
}
function _assertThisInitialized$n(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$n() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$n(o) {
  _getPrototypeOf$n = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$n(o);
}
function _defineProperty$n(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var MonthParser = /*#__PURE__*/function (_Parser) {
  _inherits$n(MonthParser, _Parser);
  var _super = _createSuper$n(MonthParser);
  function MonthParser() {
    var _this;
    _classCallCheck$n(this, MonthParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$n(_assertThisInitialized$n(_this), "incompatibleTokens", ['Y', 'R', 'q', 'Q', 'L', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']);
    _defineProperty$n(_assertThisInitialized$n(_this), "priority", 110);
    return _this;
  }
  _createClass$n(MonthParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      var valueCallback = function valueCallback(value) {
        return value - 1;
      };
      switch (token) {
        // 1, 2, ..., 12
        case 'M':
          return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback);
        // 01, 02, ..., 12

        case 'MM':
          return mapValue(parseNDigits(2, dateString), valueCallback);
        // 1st, 2nd, ..., 12th

        case 'Mo':
          return mapValue(match.ordinalNumber(dateString, {
            unit: 'month'
          }), valueCallback);
        // Jan, Feb, ..., Dec

        case 'MMM':
          return match.month(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.month(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // J, F, ..., D

        case 'MMMMM':
          return match.month(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // January, February, ..., December

        case 'MMMM':
        default:
          return match.month(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.month(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.month(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 11;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMonth(value, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return MonthParser;
}(Parser);

function _typeof$n(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$n = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof$n = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }
  return _typeof$n(obj);
}
function _classCallCheck$m(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$m(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$m(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$m(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$m(Constructor, staticProps);
  return Constructor;
}
function _inherits$m(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf$m(subClass, superClass);
}
function _setPrototypeOf$m(o, p) {
  _setPrototypeOf$m = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf$m(o, p);
}
function _createSuper$m(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$m();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$m(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$m(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$m(this, result);
  };
}
function _possibleConstructorReturn$m(self, call) {
  if (call && (_typeof$n(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$m(self);
}
function _assertThisInitialized$m(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$m() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$m(o) {
  _getPrototypeOf$m = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$m(o);
}
function _defineProperty$m(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var StandAloneMonthParser = /*#__PURE__*/function (_Parser) {
  _inherits$m(StandAloneMonthParser, _Parser);
  var _super = _createSuper$m(StandAloneMonthParser);
  function StandAloneMonthParser() {
    var _this;
    _classCallCheck$m(this, StandAloneMonthParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$m(_assertThisInitialized$m(_this), "priority", 110);
    _defineProperty$m(_assertThisInitialized$m(_this), "incompatibleTokens", ['Y', 'R', 'q', 'Q', 'M', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']);
    return _this;
  }
  _createClass$m(StandAloneMonthParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      var valueCallback = function valueCallback(value) {
        return value - 1;
      };
      switch (token) {
        // 1, 2, ..., 12
        case 'L':
          return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback);
        // 01, 02, ..., 12

        case 'LL':
          return mapValue(parseNDigits(2, dateString), valueCallback);
        // 1st, 2nd, ..., 12th

        case 'Lo':
          return mapValue(match.ordinalNumber(dateString, {
            unit: 'month'
          }), valueCallback);
        // Jan, Feb, ..., Dec

        case 'LLL':
          return match.month(dateString, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.month(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
        // J, F, ..., D

        case 'LLLLL':
          return match.month(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
        // January, February, ..., December

        case 'LLLL':
        default:
          return match.month(dateString, {
            width: 'wide',
            context: 'standalone'
          }) || match.month(dateString, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.month(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 11;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMonth(value, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return StandAloneMonthParser;
}(Parser);

function setUTCWeek(dirtyDate, dirtyWeek, options) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var week = toInteger(dirtyWeek);
  var diff = getUTCWeek(date, options) - week;
  date.setUTCDate(date.getUTCDate() - diff * 7);
  return date;
}

function _typeof$m(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$m = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof$m = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }
  return _typeof$m(obj);
}
function _classCallCheck$l(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$l(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$l(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$l(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$l(Constructor, staticProps);
  return Constructor;
}
function _inherits$l(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf$l(subClass, superClass);
}
function _setPrototypeOf$l(o, p) {
  _setPrototypeOf$l = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf$l(o, p);
}
function _createSuper$l(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$l();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$l(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$l(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$l(this, result);
  };
}
function _possibleConstructorReturn$l(self, call) {
  if (call && (_typeof$m(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$l(self);
}
function _assertThisInitialized$l(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$l() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$l(o) {
  _getPrototypeOf$l = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$l(o);
}
function _defineProperty$l(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

var LocalWeekParser = /*#__PURE__*/function (_Parser) {
  _inherits$l(LocalWeekParser, _Parser);
  var _super = _createSuper$l(LocalWeekParser);
  function LocalWeekParser() {
    var _this;
    _classCallCheck$l(this, LocalWeekParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$l(_assertThisInitialized$l(_this), "priority", 100);
    _defineProperty$l(_assertThisInitialized$l(_this), "incompatibleTokens", ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'i', 't', 'T']);
    return _this;
  }
  _createClass$l(LocalWeekParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'w':
          return parseNumericPattern(numericPatterns.week, dateString);
        case 'wo':
          return match.ordinalNumber(dateString, {
            unit: 'week'
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 53;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value, options) {
      return startOfUTCWeek(setUTCWeek(date, value, options), options);
    }
  }]);
  return LocalWeekParser;
}(Parser);

function setUTCISOWeek(dirtyDate, dirtyISOWeek) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var isoWeek = toInteger(dirtyISOWeek);
  var diff = getUTCISOWeek(date) - isoWeek;
  date.setUTCDate(date.getUTCDate() - diff * 7);
  return date;
}

function _typeof$l(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$l = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof$l = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }
  return _typeof$l(obj);
}
function _classCallCheck$k(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$k(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$k(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$k(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$k(Constructor, staticProps);
  return Constructor;
}
function _inherits$k(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf$k(subClass, superClass);
}
function _setPrototypeOf$k(o, p) {
  _setPrototypeOf$k = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf$k(o, p);
}
function _createSuper$k(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$k();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$k(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$k(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$k(this, result);
  };
}
function _possibleConstructorReturn$k(self, call) {
  if (call && (_typeof$l(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$k(self);
}
function _assertThisInitialized$k(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$k() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$k(o) {
  _getPrototypeOf$k = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$k(o);
}
function _defineProperty$k(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

var ISOWeekParser = /*#__PURE__*/function (_Parser) {
  _inherits$k(ISOWeekParser, _Parser);
  var _super = _createSuper$k(ISOWeekParser);
  function ISOWeekParser() {
    var _this;
    _classCallCheck$k(this, ISOWeekParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$k(_assertThisInitialized$k(_this), "priority", 100);
    _defineProperty$k(_assertThisInitialized$k(_this), "incompatibleTokens", ['y', 'Y', 'u', 'q', 'Q', 'M', 'L', 'w', 'd', 'D', 'e', 'c', 't', 'T']);
    return _this;
  }
  _createClass$k(ISOWeekParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'I':
          return parseNumericPattern(numericPatterns.week, dateString);
        case 'Io':
          return match.ordinalNumber(dateString, {
            unit: 'week'
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 53;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      return startOfUTCISOWeek(setUTCISOWeek(date, value));
    }
  }]);
  return ISOWeekParser;
}(Parser);

function _typeof$k(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$k = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof$k = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }
  return _typeof$k(obj);
}
function _classCallCheck$j(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$j(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$j(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$j(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$j(Constructor, staticProps);
  return Constructor;
}
function _inherits$j(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf$j(subClass, superClass);
}
function _setPrototypeOf$j(o, p) {
  _setPrototypeOf$j = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf$j(o, p);
}
function _createSuper$j(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$j();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$j(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$j(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$j(this, result);
  };
}
function _possibleConstructorReturn$j(self, call) {
  if (call && (_typeof$k(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$j(self);
}
function _assertThisInitialized$j(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$j() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$j(o) {
  _getPrototypeOf$j = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$j(o);
}
function _defineProperty$j(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; // Day of the month

var DateParser = /*#__PURE__*/function (_Parser) {
  _inherits$j(DateParser, _Parser);
  var _super = _createSuper$j(DateParser);
  function DateParser() {
    var _this;
    _classCallCheck$j(this, DateParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$j(_assertThisInitialized$j(_this), "priority", 90);
    _defineProperty$j(_assertThisInitialized$j(_this), "subPriority", 1);
    _defineProperty$j(_assertThisInitialized$j(_this), "incompatibleTokens", ['Y', 'R', 'q', 'Q', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']);
    return _this;
  }
  _createClass$j(DateParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'd':
          return parseNumericPattern(numericPatterns.date, dateString);
        case 'do':
          return match.ordinalNumber(dateString, {
            unit: 'date'
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(date, value) {
      var year = date.getUTCFullYear();
      var isLeapYear = isLeapYearIndex(year);
      var month = date.getUTCMonth();
      if (isLeapYear) {
        return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
      } else {
        return value >= 1 && value <= DAYS_IN_MONTH[month];
      }
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCDate(value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return DateParser;
}(Parser);

function _typeof$j(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$j = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof$j = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }
  return _typeof$j(obj);
}
function _classCallCheck$i(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$i(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$i(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$i(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$i(Constructor, staticProps);
  return Constructor;
}
function _inherits$i(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf$i(subClass, superClass);
}
function _setPrototypeOf$i(o, p) {
  _setPrototypeOf$i = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf$i(o, p);
}
function _createSuper$i(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$i();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$i(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$i(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$i(this, result);
  };
}
function _possibleConstructorReturn$i(self, call) {
  if (call && (_typeof$j(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$i(self);
}
function _assertThisInitialized$i(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$i() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$i(o) {
  _getPrototypeOf$i = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$i(o);
}
function _defineProperty$i(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var DayOfYearParser = /*#__PURE__*/function (_Parser) {
  _inherits$i(DayOfYearParser, _Parser);
  var _super = _createSuper$i(DayOfYearParser);
  function DayOfYearParser() {
    var _this;
    _classCallCheck$i(this, DayOfYearParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$i(_assertThisInitialized$i(_this), "priority", 90);
    _defineProperty$i(_assertThisInitialized$i(_this), "subpriority", 1);
    _defineProperty$i(_assertThisInitialized$i(_this), "incompatibleTokens", ['Y', 'R', 'q', 'Q', 'M', 'L', 'w', 'I', 'd', 'E', 'i', 'e', 'c', 't', 'T']);
    return _this;
  }
  _createClass$i(DayOfYearParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'D':
        case 'DD':
          return parseNumericPattern(numericPatterns.dayOfYear, dateString);
        case 'Do':
          return match.ordinalNumber(dateString, {
            unit: 'date'
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(date, value) {
      var year = date.getUTCFullYear();
      var isLeapYear = isLeapYearIndex(year);
      if (isLeapYear) {
        return value >= 1 && value <= 366;
      } else {
        return value >= 1 && value <= 365;
      }
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMonth(0, value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return DayOfYearParser;
}(Parser);

function setUTCDay(dirtyDate, dirtyDay, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(2, arguments);
  var defaultOptions = getDefaultOptions();
  var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }
  var date = toDate(dirtyDate);
  var day = toInteger(dirtyDay);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}

function _typeof$i(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$i = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof$i = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }
  return _typeof$i(obj);
}
function _classCallCheck$h(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$h(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$h(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$h(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$h(Constructor, staticProps);
  return Constructor;
}
function _inherits$h(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf$h(subClass, superClass);
}
function _setPrototypeOf$h(o, p) {
  _setPrototypeOf$h = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf$h(o, p);
}
function _createSuper$h(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$h();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$h(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$h(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$h(this, result);
  };
}
function _possibleConstructorReturn$h(self, call) {
  if (call && (_typeof$i(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$h(self);
}
function _assertThisInitialized$h(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$h() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$h(o) {
  _getPrototypeOf$h = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$h(o);
}
function _defineProperty$h(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

var DayParser = /*#__PURE__*/function (_Parser) {
  _inherits$h(DayParser, _Parser);
  var _super = _createSuper$h(DayParser);
  function DayParser() {
    var _this;
    _classCallCheck$h(this, DayParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$h(_assertThisInitialized$h(_this), "priority", 90);
    _defineProperty$h(_assertThisInitialized$h(_this), "incompatibleTokens", ['D', 'i', 'e', 'c', 't', 'T']);
    return _this;
  }
  _createClass$h(DayParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        // Tue
        case 'E':
        case 'EE':
        case 'EEE':
          return match.day(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // T

        case 'EEEEE':
          return match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tu

        case 'EEEEEE':
          return match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tuesday

        case 'EEEE':
        default:
          return match.day(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 6;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return DayParser;
}(Parser);

function _typeof$h(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$h = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof$h = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }
  return _typeof$h(obj);
}
function _classCallCheck$g(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$g(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$g(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$g(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$g(Constructor, staticProps);
  return Constructor;
}
function _inherits$g(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf$g(subClass, superClass);
}
function _setPrototypeOf$g(o, p) {
  _setPrototypeOf$g = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf$g(o, p);
}
function _createSuper$g(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$g();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$g(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$g(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$g(this, result);
  };
}
function _possibleConstructorReturn$g(self, call) {
  if (call && (_typeof$h(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$g(self);
}
function _assertThisInitialized$g(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$g() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$g(o) {
  _getPrototypeOf$g = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$g(o);
}
function _defineProperty$g(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

var LocalDayParser = /*#__PURE__*/function (_Parser) {
  _inherits$g(LocalDayParser, _Parser);
  var _super = _createSuper$g(LocalDayParser);
  function LocalDayParser() {
    var _this;
    _classCallCheck$g(this, LocalDayParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$g(_assertThisInitialized$g(_this), "priority", 90);
    _defineProperty$g(_assertThisInitialized$g(_this), "incompatibleTokens", ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'E', 'i', 'c', 't', 'T']);
    return _this;
  }
  _createClass$g(LocalDayParser, [{
    key: "parse",
    value: function parse(dateString, token, match, options) {
      var valueCallback = function valueCallback(value) {
        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
      };
      switch (token) {
        // 3
        case 'e':
        case 'ee':
          // 03
          return mapValue(parseNDigits(token.length, dateString), valueCallback);
        // 3rd

        case 'eo':
          return mapValue(match.ordinalNumber(dateString, {
            unit: 'day'
          }), valueCallback);
        // Tue

        case 'eee':
          return match.day(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // T

        case 'eeeee':
          return match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tu

        case 'eeeeee':
          return match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tuesday

        case 'eeee':
        default:
          return match.day(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 6;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return LocalDayParser;
}(Parser);

function _typeof$g(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$g = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof$g = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }
  return _typeof$g(obj);
}
function _classCallCheck$f(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$f(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$f(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$f(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$f(Constructor, staticProps);
  return Constructor;
}
function _inherits$f(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf$f(subClass, superClass);
}
function _setPrototypeOf$f(o, p) {
  _setPrototypeOf$f = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf$f(o, p);
}
function _createSuper$f(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$f();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$f(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$f(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$f(this, result);
  };
}
function _possibleConstructorReturn$f(self, call) {
  if (call && (_typeof$g(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$f(self);
}
function _assertThisInitialized$f(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$f() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$f(o) {
  _getPrototypeOf$f = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$f(o);
}
function _defineProperty$f(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

var StandAloneLocalDayParser = /*#__PURE__*/function (_Parser) {
  _inherits$f(StandAloneLocalDayParser, _Parser);
  var _super = _createSuper$f(StandAloneLocalDayParser);
  function StandAloneLocalDayParser() {
    var _this;
    _classCallCheck$f(this, StandAloneLocalDayParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$f(_assertThisInitialized$f(_this), "priority", 90);
    _defineProperty$f(_assertThisInitialized$f(_this), "incompatibleTokens", ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'E', 'i', 'e', 't', 'T']);
    return _this;
  }
  _createClass$f(StandAloneLocalDayParser, [{
    key: "parse",
    value: function parse(dateString, token, match, options) {
      var valueCallback = function valueCallback(value) {
        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
      };
      switch (token) {
        // 3
        case 'c':
        case 'cc':
          // 03
          return mapValue(parseNDigits(token.length, dateString), valueCallback);
        // 3rd

        case 'co':
          return mapValue(match.ordinalNumber(dateString, {
            unit: 'day'
          }), valueCallback);
        // Tue

        case 'ccc':
          return match.day(dateString, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.day(dateString, {
            width: 'short',
            context: 'standalone'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
        // T

        case 'ccccc':
          return match.day(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
        // Tu

        case 'cccccc':
          return match.day(dateString, {
            width: 'short',
            context: 'standalone'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
        // Tuesday

        case 'cccc':
        default:
          return match.day(dateString, {
            width: 'wide',
            context: 'standalone'
          }) || match.day(dateString, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.day(dateString, {
            width: 'short',
            context: 'standalone'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 6;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return StandAloneLocalDayParser;
}(Parser);

function setUTCISODay(dirtyDate, dirtyDay) {
  requiredArgs(2, arguments);
  var day = toInteger(dirtyDay);
  if (day % 7 === 0) {
    day = day - 7;
  }
  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}

function _typeof$f(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$f = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof$f = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }
  return _typeof$f(obj);
}
function _classCallCheck$e(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$e(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$e(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$e(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$e(Constructor, staticProps);
  return Constructor;
}
function _inherits$e(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf$e(subClass, superClass);
}
function _setPrototypeOf$e(o, p) {
  _setPrototypeOf$e = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf$e(o, p);
}
function _createSuper$e(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$e();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$e(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$e(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$e(this, result);
  };
}
function _possibleConstructorReturn$e(self, call) {
  if (call && (_typeof$f(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$e(self);
}
function _assertThisInitialized$e(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$e() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$e(o) {
  _getPrototypeOf$e = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$e(o);
}
function _defineProperty$e(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

var ISODayParser = /*#__PURE__*/function (_Parser) {
  _inherits$e(ISODayParser, _Parser);
  var _super = _createSuper$e(ISODayParser);
  function ISODayParser() {
    var _this;
    _classCallCheck$e(this, ISODayParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$e(_assertThisInitialized$e(_this), "priority", 90);
    _defineProperty$e(_assertThisInitialized$e(_this), "incompatibleTokens", ['y', 'Y', 'u', 'q', 'Q', 'M', 'L', 'w', 'd', 'D', 'E', 'e', 'c', 't', 'T']);
    return _this;
  }
  _createClass$e(ISODayParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      var valueCallback = function valueCallback(value) {
        if (value === 0) {
          return 7;
        }
        return value;
      };
      switch (token) {
        // 2
        case 'i':
        case 'ii':
          // 02
          return parseNDigits(token.length, dateString);
        // 2nd

        case 'io':
          return match.ordinalNumber(dateString, {
            unit: 'day'
          });
        // Tue

        case 'iii':
          return mapValue(match.day(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          }), valueCallback);
        // T

        case 'iiiii':
          return mapValue(match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          }), valueCallback);
        // Tu

        case 'iiiiii':
          return mapValue(match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          }), valueCallback);
        // Tuesday

        case 'iiii':
        default:
          return mapValue(match.day(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          }), valueCallback);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 7;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date = setUTCISODay(date, value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return ISODayParser;
}(Parser);

function _typeof$e(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$e = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof$e = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }
  return _typeof$e(obj);
}
function _classCallCheck$d(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$d(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$d(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$d(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$d(Constructor, staticProps);
  return Constructor;
}
function _inherits$d(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf$d(subClass, superClass);
}
function _setPrototypeOf$d(o, p) {
  _setPrototypeOf$d = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf$d(o, p);
}
function _createSuper$d(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$d();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$d(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$d(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$d(this, result);
  };
}
function _possibleConstructorReturn$d(self, call) {
  if (call && (_typeof$e(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$d(self);
}
function _assertThisInitialized$d(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$d() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$d(o) {
  _getPrototypeOf$d = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$d(o);
}
function _defineProperty$d(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var AMPMParser = /*#__PURE__*/function (_Parser) {
  _inherits$d(AMPMParser, _Parser);
  var _super = _createSuper$d(AMPMParser);
  function AMPMParser() {
    var _this;
    _classCallCheck$d(this, AMPMParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$d(_assertThisInitialized$d(_this), "priority", 80);
    _defineProperty$d(_assertThisInitialized$d(_this), "incompatibleTokens", ['b', 'B', 'H', 'k', 't', 'T']);
    return _this;
  }
  _createClass$d(AMPMParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'a':
        case 'aa':
        case 'aaa':
          return match.dayPeriod(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        case 'aaaaa':
          return match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        case 'aaaa':
        default:
          return match.dayPeriod(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    }
  }]);
  return AMPMParser;
}(Parser);

function _typeof$d(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$d = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof$d = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }
  return _typeof$d(obj);
}
function _classCallCheck$c(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$c(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$c(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$c(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$c(Constructor, staticProps);
  return Constructor;
}
function _inherits$c(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf$c(subClass, superClass);
}
function _setPrototypeOf$c(o, p) {
  _setPrototypeOf$c = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf$c(o, p);
}
function _createSuper$c(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$c();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$c(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$c(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$c(this, result);
  };
}
function _possibleConstructorReturn$c(self, call) {
  if (call && (_typeof$d(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$c(self);
}
function _assertThisInitialized$c(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$c() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$c(o) {
  _getPrototypeOf$c = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$c(o);
}
function _defineProperty$c(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var AMPMMidnightParser = /*#__PURE__*/function (_Parser) {
  _inherits$c(AMPMMidnightParser, _Parser);
  var _super = _createSuper$c(AMPMMidnightParser);
  function AMPMMidnightParser() {
    var _this;
    _classCallCheck$c(this, AMPMMidnightParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$c(_assertThisInitialized$c(_this), "priority", 80);
    _defineProperty$c(_assertThisInitialized$c(_this), "incompatibleTokens", ['a', 'B', 'H', 'k', 't', 'T']);
    return _this;
  }
  _createClass$c(AMPMMidnightParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'b':
        case 'bb':
        case 'bbb':
          return match.dayPeriod(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        case 'bbbbb':
          return match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        case 'bbbb':
        default:
          return match.dayPeriod(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    }
  }]);
  return AMPMMidnightParser;
}(Parser);

function _typeof$c(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$c = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof$c = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }
  return _typeof$c(obj);
}
function _classCallCheck$b(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$b(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$b(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$b(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$b(Constructor, staticProps);
  return Constructor;
}
function _inherits$b(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf$b(subClass, superClass);
}
function _setPrototypeOf$b(o, p) {
  _setPrototypeOf$b = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf$b(o, p);
}
function _createSuper$b(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$b();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$b(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$b(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$b(this, result);
  };
}
function _possibleConstructorReturn$b(self, call) {
  if (call && (_typeof$c(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$b(self);
}
function _assertThisInitialized$b(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$b() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$b(o) {
  _getPrototypeOf$b = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$b(o);
}
function _defineProperty$b(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

var DayPeriodParser = /*#__PURE__*/function (_Parser) {
  _inherits$b(DayPeriodParser, _Parser);
  var _super = _createSuper$b(DayPeriodParser);
  function DayPeriodParser() {
    var _this;
    _classCallCheck$b(this, DayPeriodParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$b(_assertThisInitialized$b(_this), "priority", 80);
    _defineProperty$b(_assertThisInitialized$b(_this), "incompatibleTokens", ['a', 'b', 't', 'T']);
    return _this;
  }
  _createClass$b(DayPeriodParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'B':
        case 'BB':
        case 'BBB':
          return match.dayPeriod(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        case 'BBBBB':
          return match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        case 'BBBB':
        default:
          return match.dayPeriod(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    }
  }]);
  return DayPeriodParser;
}(Parser);

function _typeof$b(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$b = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof$b = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }
  return _typeof$b(obj);
}
function _classCallCheck$a(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$a(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$a(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$a(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$a(Constructor, staticProps);
  return Constructor;
}
function _inherits$a(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf$a(subClass, superClass);
}
function _setPrototypeOf$a(o, p) {
  _setPrototypeOf$a = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf$a(o, p);
}
function _createSuper$a(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$a();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$a(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$a(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$a(this, result);
  };
}
function _possibleConstructorReturn$a(self, call) {
  if (call && (_typeof$b(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$a(self);
}
function _assertThisInitialized$a(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$a() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$a(o) {
  _getPrototypeOf$a = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$a(o);
}
function _defineProperty$a(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var Hour1to12Parser = /*#__PURE__*/function (_Parser) {
  _inherits$a(Hour1to12Parser, _Parser);
  var _super = _createSuper$a(Hour1to12Parser);
  function Hour1to12Parser() {
    var _this;
    _classCallCheck$a(this, Hour1to12Parser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$a(_assertThisInitialized$a(_this), "priority", 70);
    _defineProperty$a(_assertThisInitialized$a(_this), "incompatibleTokens", ['H', 'K', 'k', 't', 'T']);
    return _this;
  }
  _createClass$a(Hour1to12Parser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'h':
          return parseNumericPattern(numericPatterns.hour12h, dateString);
        case 'ho':
          return match.ordinalNumber(dateString, {
            unit: 'hour'
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 12;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      var isPM = date.getUTCHours() >= 12;
      if (isPM && value < 12) {
        date.setUTCHours(value + 12, 0, 0, 0);
      } else if (!isPM && value === 12) {
        date.setUTCHours(0, 0, 0, 0);
      } else {
        date.setUTCHours(value, 0, 0, 0);
      }
      return date;
    }
  }]);
  return Hour1to12Parser;
}(Parser);

function _typeof$a(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$a = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof$a = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }
  return _typeof$a(obj);
}
function _classCallCheck$9(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$9(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$9(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$9(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$9(Constructor, staticProps);
  return Constructor;
}
function _inherits$9(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf$9(subClass, superClass);
}
function _setPrototypeOf$9(o, p) {
  _setPrototypeOf$9 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf$9(o, p);
}
function _createSuper$9(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$9();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$9(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$9(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$9(this, result);
  };
}
function _possibleConstructorReturn$9(self, call) {
  if (call && (_typeof$a(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$9(self);
}
function _assertThisInitialized$9(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$9() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$9(o) {
  _getPrototypeOf$9 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$9(o);
}
function _defineProperty$9(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var Hour0to23Parser = /*#__PURE__*/function (_Parser) {
  _inherits$9(Hour0to23Parser, _Parser);
  var _super = _createSuper$9(Hour0to23Parser);
  function Hour0to23Parser() {
    var _this;
    _classCallCheck$9(this, Hour0to23Parser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$9(_assertThisInitialized$9(_this), "priority", 70);
    _defineProperty$9(_assertThisInitialized$9(_this), "incompatibleTokens", ['a', 'b', 'h', 'K', 'k', 't', 'T']);
    return _this;
  }
  _createClass$9(Hour0to23Parser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'H':
          return parseNumericPattern(numericPatterns.hour23h, dateString);
        case 'Ho':
          return match.ordinalNumber(dateString, {
            unit: 'hour'
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 23;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCHours(value, 0, 0, 0);
      return date;
    }
  }]);
  return Hour0to23Parser;
}(Parser);

function _typeof$9(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$9 = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof$9 = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }
  return _typeof$9(obj);
}
function _classCallCheck$8(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$8(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$8(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$8(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$8(Constructor, staticProps);
  return Constructor;
}
function _inherits$8(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf$8(subClass, superClass);
}
function _setPrototypeOf$8(o, p) {
  _setPrototypeOf$8 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf$8(o, p);
}
function _createSuper$8(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$8();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$8(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$8(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$8(this, result);
  };
}
function _possibleConstructorReturn$8(self, call) {
  if (call && (_typeof$9(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$8(self);
}
function _assertThisInitialized$8(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$8() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$8(o) {
  _getPrototypeOf$8 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$8(o);
}
function _defineProperty$8(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var Hour0To11Parser = /*#__PURE__*/function (_Parser) {
  _inherits$8(Hour0To11Parser, _Parser);
  var _super = _createSuper$8(Hour0To11Parser);
  function Hour0To11Parser() {
    var _this;
    _classCallCheck$8(this, Hour0To11Parser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$8(_assertThisInitialized$8(_this), "priority", 70);
    _defineProperty$8(_assertThisInitialized$8(_this), "incompatibleTokens", ['h', 'H', 'k', 't', 'T']);
    return _this;
  }
  _createClass$8(Hour0To11Parser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'K':
          return parseNumericPattern(numericPatterns.hour11h, dateString);
        case 'Ko':
          return match.ordinalNumber(dateString, {
            unit: 'hour'
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 11;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      var isPM = date.getUTCHours() >= 12;
      if (isPM && value < 12) {
        date.setUTCHours(value + 12, 0, 0, 0);
      } else {
        date.setUTCHours(value, 0, 0, 0);
      }
      return date;
    }
  }]);
  return Hour0To11Parser;
}(Parser);

function _typeof$8(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$8 = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof$8 = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }
  return _typeof$8(obj);
}
function _classCallCheck$7(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$7(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$7(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$7(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$7(Constructor, staticProps);
  return Constructor;
}
function _inherits$7(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf$7(subClass, superClass);
}
function _setPrototypeOf$7(o, p) {
  _setPrototypeOf$7 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf$7(o, p);
}
function _createSuper$7(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$7();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$7(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$7(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$7(this, result);
  };
}
function _possibleConstructorReturn$7(self, call) {
  if (call && (_typeof$8(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$7(self);
}
function _assertThisInitialized$7(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$7() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$7(o) {
  _getPrototypeOf$7 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$7(o);
}
function _defineProperty$7(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var Hour1To24Parser = /*#__PURE__*/function (_Parser) {
  _inherits$7(Hour1To24Parser, _Parser);
  var _super = _createSuper$7(Hour1To24Parser);
  function Hour1To24Parser() {
    var _this;
    _classCallCheck$7(this, Hour1To24Parser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$7(_assertThisInitialized$7(_this), "priority", 70);
    _defineProperty$7(_assertThisInitialized$7(_this), "incompatibleTokens", ['a', 'b', 'h', 'H', 'K', 't', 'T']);
    return _this;
  }
  _createClass$7(Hour1To24Parser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'k':
          return parseNumericPattern(numericPatterns.hour24h, dateString);
        case 'ko':
          return match.ordinalNumber(dateString, {
            unit: 'hour'
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 24;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      var hours = value <= 24 ? value % 24 : value;
      date.setUTCHours(hours, 0, 0, 0);
      return date;
    }
  }]);
  return Hour1To24Parser;
}(Parser);

function _typeof$7(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$7 = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof$7 = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }
  return _typeof$7(obj);
}
function _classCallCheck$6(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$6(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$6(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$6(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$6(Constructor, staticProps);
  return Constructor;
}
function _inherits$6(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf$6(subClass, superClass);
}
function _setPrototypeOf$6(o, p) {
  _setPrototypeOf$6 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf$6(o, p);
}
function _createSuper$6(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$6();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$6(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$6(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$6(this, result);
  };
}
function _possibleConstructorReturn$6(self, call) {
  if (call && (_typeof$7(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$6(self);
}
function _assertThisInitialized$6(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$6() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$6(o) {
  _getPrototypeOf$6 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$6(o);
}
function _defineProperty$6(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var MinuteParser = /*#__PURE__*/function (_Parser) {
  _inherits$6(MinuteParser, _Parser);
  var _super = _createSuper$6(MinuteParser);
  function MinuteParser() {
    var _this;
    _classCallCheck$6(this, MinuteParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$6(_assertThisInitialized$6(_this), "priority", 60);
    _defineProperty$6(_assertThisInitialized$6(_this), "incompatibleTokens", ['t', 'T']);
    return _this;
  }
  _createClass$6(MinuteParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'm':
          return parseNumericPattern(numericPatterns.minute, dateString);
        case 'mo':
          return match.ordinalNumber(dateString, {
            unit: 'minute'
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 59;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMinutes(value, 0, 0);
      return date;
    }
  }]);
  return MinuteParser;
}(Parser);

function _typeof$6(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$6 = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof$6 = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }
  return _typeof$6(obj);
}
function _classCallCheck$5(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$5(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$5(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$5(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$5(Constructor, staticProps);
  return Constructor;
}
function _inherits$5(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf$5(subClass, superClass);
}
function _setPrototypeOf$5(o, p) {
  _setPrototypeOf$5 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf$5(o, p);
}
function _createSuper$5(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$5();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$5(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$5(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$5(this, result);
  };
}
function _possibleConstructorReturn$5(self, call) {
  if (call && (_typeof$6(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$5(self);
}
function _assertThisInitialized$5(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$5() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$5(o) {
  _getPrototypeOf$5 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$5(o);
}
function _defineProperty$5(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var SecondParser = /*#__PURE__*/function (_Parser) {
  _inherits$5(SecondParser, _Parser);
  var _super = _createSuper$5(SecondParser);
  function SecondParser() {
    var _this;
    _classCallCheck$5(this, SecondParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$5(_assertThisInitialized$5(_this), "priority", 50);
    _defineProperty$5(_assertThisInitialized$5(_this), "incompatibleTokens", ['t', 'T']);
    return _this;
  }
  _createClass$5(SecondParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 's':
          return parseNumericPattern(numericPatterns.second, dateString);
        case 'so':
          return match.ordinalNumber(dateString, {
            unit: 'second'
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 59;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCSeconds(value, 0);
      return date;
    }
  }]);
  return SecondParser;
}(Parser);

function _typeof$5(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$5 = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof$5 = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }
  return _typeof$5(obj);
}
function _classCallCheck$4(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$4(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$4(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$4(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$4(Constructor, staticProps);
  return Constructor;
}
function _inherits$4(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf$4(subClass, superClass);
}
function _setPrototypeOf$4(o, p) {
  _setPrototypeOf$4 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf$4(o, p);
}
function _createSuper$4(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$4();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$4(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$4(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$4(this, result);
  };
}
function _possibleConstructorReturn$4(self, call) {
  if (call && (_typeof$5(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$4(self);
}
function _assertThisInitialized$4(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$4() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$4(o) {
  _getPrototypeOf$4 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$4(o);
}
function _defineProperty$4(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var FractionOfSecondParser = /*#__PURE__*/function (_Parser) {
  _inherits$4(FractionOfSecondParser, _Parser);
  var _super = _createSuper$4(FractionOfSecondParser);
  function FractionOfSecondParser() {
    var _this;
    _classCallCheck$4(this, FractionOfSecondParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$4(_assertThisInitialized$4(_this), "priority", 30);
    _defineProperty$4(_assertThisInitialized$4(_this), "incompatibleTokens", ['t', 'T']);
    return _this;
  }
  _createClass$4(FractionOfSecondParser, [{
    key: "parse",
    value: function parse(dateString, token) {
      var valueCallback = function valueCallback(value) {
        return Math.floor(value * Math.pow(10, -token.length + 3));
      };
      return mapValue(parseNDigits(token.length, dateString), valueCallback);
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMilliseconds(value);
      return date;
    }
  }]);
  return FractionOfSecondParser;
}(Parser);

function _typeof$4(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$4 = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof$4 = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }
  return _typeof$4(obj);
}
function _classCallCheck$3(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$3(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$3(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$3(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$3(Constructor, staticProps);
  return Constructor;
}
function _inherits$3(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf$3(subClass, superClass);
}
function _setPrototypeOf$3(o, p) {
  _setPrototypeOf$3 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf$3(o, p);
}
function _createSuper$3(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$3();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$3(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$3(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$3(this, result);
  };
}
function _possibleConstructorReturn$3(self, call) {
  if (call && (_typeof$4(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$3(self);
}
function _assertThisInitialized$3(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$3() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$3(o) {
  _getPrototypeOf$3 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$3(o);
}
function _defineProperty$3(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

var ISOTimezoneWithZParser = /*#__PURE__*/function (_Parser) {
  _inherits$3(ISOTimezoneWithZParser, _Parser);
  var _super = _createSuper$3(ISOTimezoneWithZParser);
  function ISOTimezoneWithZParser() {
    var _this;
    _classCallCheck$3(this, ISOTimezoneWithZParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$3(_assertThisInitialized$3(_this), "priority", 10);
    _defineProperty$3(_assertThisInitialized$3(_this), "incompatibleTokens", ['t', 'T', 'x']);
    return _this;
  }
  _createClass$3(ISOTimezoneWithZParser, [{
    key: "parse",
    value: function parse(dateString, token) {
      switch (token) {
        case 'X':
          return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);
        case 'XX':
          return parseTimezonePattern(timezonePatterns.basic, dateString);
        case 'XXXX':
          return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);
        case 'XXXXX':
          return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);
        case 'XXX':
        default:
          return parseTimezonePattern(timezonePatterns.extended, dateString);
      }
    }
  }, {
    key: "set",
    value: function set(date, flags, value) {
      if (flags.timestampIsSet) {
        return date;
      }
      return new Date(date.getTime() - value);
    }
  }]);
  return ISOTimezoneWithZParser;
}(Parser);

function _typeof$3(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$3 = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof$3 = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }
  return _typeof$3(obj);
}
function _classCallCheck$2(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$2(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$2(Constructor, staticProps);
  return Constructor;
}
function _inherits$2(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf$2(subClass, superClass);
}
function _setPrototypeOf$2(o, p) {
  _setPrototypeOf$2 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf$2(o, p);
}
function _createSuper$2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$2();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$2(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$2(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$2(this, result);
  };
}
function _possibleConstructorReturn$2(self, call) {
  if (call && (_typeof$3(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$2(self);
}
function _assertThisInitialized$2(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$2() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$2(o) {
  _getPrototypeOf$2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$2(o);
}
function _defineProperty$2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

var ISOTimezoneParser = /*#__PURE__*/function (_Parser) {
  _inherits$2(ISOTimezoneParser, _Parser);
  var _super = _createSuper$2(ISOTimezoneParser);
  function ISOTimezoneParser() {
    var _this;
    _classCallCheck$2(this, ISOTimezoneParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$2(_assertThisInitialized$2(_this), "priority", 10);
    _defineProperty$2(_assertThisInitialized$2(_this), "incompatibleTokens", ['t', 'T', 'X']);
    return _this;
  }
  _createClass$2(ISOTimezoneParser, [{
    key: "parse",
    value: function parse(dateString, token) {
      switch (token) {
        case 'x':
          return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);
        case 'xx':
          return parseTimezonePattern(timezonePatterns.basic, dateString);
        case 'xxxx':
          return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);
        case 'xxxxx':
          return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);
        case 'xxx':
        default:
          return parseTimezonePattern(timezonePatterns.extended, dateString);
      }
    }
  }, {
    key: "set",
    value: function set(date, flags, value) {
      if (flags.timestampIsSet) {
        return date;
      }
      return new Date(date.getTime() - value);
    }
  }]);
  return ISOTimezoneParser;
}(Parser);

function _typeof$2(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$2 = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof$2 = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }
  return _typeof$2(obj);
}
function _classCallCheck$1(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$1(Constructor, staticProps);
  return Constructor;
}
function _inherits$1(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf$1(subClass, superClass);
}
function _setPrototypeOf$1(o, p) {
  _setPrototypeOf$1 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf$1(o, p);
}
function _createSuper$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$1(this, result);
  };
}
function _possibleConstructorReturn$1(self, call) {
  if (call && (_typeof$2(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$1(self);
}
function _assertThisInitialized$1(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$1(o) {
  _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$1(o);
}
function _defineProperty$1(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var TimestampSecondsParser = /*#__PURE__*/function (_Parser) {
  _inherits$1(TimestampSecondsParser, _Parser);
  var _super = _createSuper$1(TimestampSecondsParser);
  function TimestampSecondsParser() {
    var _this;
    _classCallCheck$1(this, TimestampSecondsParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$1(_assertThisInitialized$1(_this), "priority", 40);
    _defineProperty$1(_assertThisInitialized$1(_this), "incompatibleTokens", '*');
    return _this;
  }
  _createClass$1(TimestampSecondsParser, [{
    key: "parse",
    value: function parse(dateString) {
      return parseAnyDigitsSigned(dateString);
    }
  }, {
    key: "set",
    value: function set(_date, _flags, value) {
      return [new Date(value * 1000), {
        timestampIsSet: true
      }];
    }
  }]);
  return TimestampSecondsParser;
}(Parser);

function _typeof$1(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1 = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof$1 = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }
  return _typeof$1(obj);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _possibleConstructorReturn(self, call) {
  if (call && (_typeof$1(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var TimestampMillisecondsParser = /*#__PURE__*/function (_Parser) {
  _inherits(TimestampMillisecondsParser, _Parser);
  var _super = _createSuper(TimestampMillisecondsParser);
  function TimestampMillisecondsParser() {
    var _this;
    _classCallCheck(this, TimestampMillisecondsParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 20);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", '*');
    return _this;
  }
  _createClass(TimestampMillisecondsParser, [{
    key: "parse",
    value: function parse(dateString) {
      return parseAnyDigitsSigned(dateString);
    }
  }, {
    key: "set",
    value: function set(_date, _flags, value) {
      return [new Date(value), {
        timestampIsSet: true
      }];
    }
  }]);
  return TimestampMillisecondsParser;
}(Parser);

/*
 * |     | Unit                           |     | Unit                           |
 * |-----|--------------------------------|-----|--------------------------------|
 * |  a  | AM, PM                         |  A* | Milliseconds in day            |
 * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
 * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
 * |  d  | Day of month                   |  D  | Day of year                    |
 * |  e  | Local day of week              |  E  | Day of week                    |
 * |  f  |                                |  F* | Day of week in month           |
 * |  g* | Modified Julian day            |  G  | Era                            |
 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
 * |  i! | ISO day of week                |  I! | ISO week of year               |
 * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
 * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
 * |  l* | (deprecated)                   |  L  | Stand-alone month              |
 * |  m  | Minute                         |  M  | Month                          |
 * |  n  |                                |  N  |                                |
 * |  o! | Ordinal number modifier        |  O* | Timezone (GMT)                 |
 * |  p  |                                |  P  |                                |
 * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
 * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
 * |  s  | Second                         |  S  | Fraction of second             |
 * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
 * |  u  | Extended year                  |  U* | Cyclic year                    |
 * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
 * |  w  | Local week of year             |  W* | Week of month                  |
 * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
 * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
 * |  z* | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
 *
 * Letters marked by * are not implemented but reserved by Unicode standard.
 *
 * Letters marked by ! are non-standard, but implemented by date-fns:
 * - `o` modifies the previous token to turn it into an ordinal (see `parse` docs)
 * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
 *   i.e. 7 for Sunday, 1 for Monday, etc.
 * - `I` is ISO week of year, as opposed to `w` which is local week of year.
 * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
 *   `R` is supposed to be used in conjunction with `I` and `i`
 *   for universal ISO week-numbering date, whereas
 *   `Y` is supposed to be used in conjunction with `w` and `e`
 *   for week-numbering date specific to the locale.
 */

var parsers = {
  G: new EraParser(),
  y: new YearParser(),
  Y: new LocalWeekYearParser(),
  R: new ISOWeekYearParser(),
  u: new ExtendedYearParser(),
  Q: new QuarterParser(),
  q: new StandAloneQuarterParser(),
  M: new MonthParser(),
  L: new StandAloneMonthParser(),
  w: new LocalWeekParser(),
  I: new ISOWeekParser(),
  d: new DateParser(),
  D: new DayOfYearParser(),
  E: new DayParser(),
  e: new LocalDayParser(),
  c: new StandAloneLocalDayParser(),
  i: new ISODayParser(),
  a: new AMPMParser(),
  b: new AMPMMidnightParser(),
  B: new DayPeriodParser(),
  h: new Hour1to12Parser(),
  H: new Hour0to23Parser(),
  K: new Hour0To11Parser(),
  k: new Hour1To24Parser(),
  m: new MinuteParser(),
  s: new SecondParser(),
  S: new FractionOfSecondParser(),
  X: new ISOTimezoneWithZParser(),
  x: new ISOTimezoneParser(),
  t: new TimestampSecondsParser(),
  T: new TimestampMillisecondsParser()
};

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }
  return _typeof(obj);
}
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it;
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      var F = function F() {};
      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true,
    didErr = false,
    err;
  return {
    s: function s() {
      it = o[Symbol.iterator]();
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
// - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
//   (one of the certain letters followed by `o`)
// - (\w)\1* matches any sequences of the same letter
// - '' matches two quote characters in a row
// - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
//   except a single quote symbol, which ends the sequence.
//   Two quote characters do not end the sequence.
//   If there is no matching single quote
//   then the sequence will continue until the end of the string.
// - . matches any single character unmatched by previous parts of the RegExps

var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g; // This RegExp catches symbols escaped by quotes, and also
// sequences of symbols P, p, and the combinations like `PPPPPPPppppp`

var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'([^]*?)'?$/;
var doubleQuoteRegExp = /''/g;
var notWhitespaceRegExp = /\S/;
var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
/**
 * @name parse
 * @category Common Helpers
 * @summary Parse the date.
 *
 * @description
 * Return the date parsed from string using the given format string.
 *
 * > ⚠️ Please note that the `format` tokens differ from Moment.js and other libraries.
 * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * The characters in the format string wrapped between two single quotes characters (') are escaped.
 * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
 *
 * Format of the format string is based on Unicode Technical Standard #35:
 * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
 * with a few additions (see note 5 below the table).
 *
 * Not all tokens are compatible. Combinations that don't make sense or could lead to bugs are prohibited
 * and will throw `RangeError`. For example usage of 24-hour format token with AM/PM token will throw an exception:
 *
 * ```javascript
 * parse('23 AM', 'HH a', new Date())
 * //=> RangeError: The format string mustn't contain `HH` and `a` at the same time
 * ```
 *
 * See the compatibility table: https://docs.google.com/spreadsheets/d/e/2PACX-1vQOPU3xUhplll6dyoMmVUXHKl_8CRDs6_ueLmex3SoqwhuolkuN3O05l4rqx5h1dKX8eb46Ul-CCSrq/pubhtml?gid=0&single=true
 *
 * Accepted format string patterns:
 * | Unit                            |Prior| Pattern | Result examples                   | Notes |
 * |---------------------------------|-----|---------|-----------------------------------|-------|
 * | Era                             | 140 | G..GGG  | AD, BC                            |       |
 * |                                 |     | GGGG    | Anno Domini, Before Christ        | 2     |
 * |                                 |     | GGGGG   | A, B                              |       |
 * | Calendar year                   | 130 | y       | 44, 1, 1900, 2017, 9999           | 4     |
 * |                                 |     | yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
 * |                                 |     | yy      | 44, 01, 00, 17                    | 4     |
 * |                                 |     | yyy     | 044, 001, 123, 999                | 4     |
 * |                                 |     | yyyy    | 0044, 0001, 1900, 2017            | 4     |
 * |                                 |     | yyyyy   | ...                               | 2,4   |
 * | Local week-numbering year       | 130 | Y       | 44, 1, 1900, 2017, 9000           | 4     |
 * |                                 |     | Yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
 * |                                 |     | YY      | 44, 01, 00, 17                    | 4,6   |
 * |                                 |     | YYY     | 044, 001, 123, 999                | 4     |
 * |                                 |     | YYYY    | 0044, 0001, 1900, 2017            | 4,6   |
 * |                                 |     | YYYYY   | ...                               | 2,4   |
 * | ISO week-numbering year         | 130 | R       | -43, 1, 1900, 2017, 9999, -9999   | 4,5   |
 * |                                 |     | RR      | -43, 01, 00, 17                   | 4,5   |
 * |                                 |     | RRR     | -043, 001, 123, 999, -999         | 4,5   |
 * |                                 |     | RRRR    | -0043, 0001, 2017, 9999, -9999    | 4,5   |
 * |                                 |     | RRRRR   | ...                               | 2,4,5 |
 * | Extended year                   | 130 | u       | -43, 1, 1900, 2017, 9999, -999    | 4     |
 * |                                 |     | uu      | -43, 01, 99, -99                  | 4     |
 * |                                 |     | uuu     | -043, 001, 123, 999, -999         | 4     |
 * |                                 |     | uuuu    | -0043, 0001, 2017, 9999, -9999    | 4     |
 * |                                 |     | uuuuu   | ...                               | 2,4   |
 * | Quarter (formatting)            | 120 | Q       | 1, 2, 3, 4                        |       |
 * |                                 |     | Qo      | 1st, 2nd, 3rd, 4th                | 5     |
 * |                                 |     | QQ      | 01, 02, 03, 04                    |       |
 * |                                 |     | QQQ     | Q1, Q2, Q3, Q4                    |       |
 * |                                 |     | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 |     | QQQQQ   | 1, 2, 3, 4                        | 4     |
 * | Quarter (stand-alone)           | 120 | q       | 1, 2, 3, 4                        |       |
 * |                                 |     | qo      | 1st, 2nd, 3rd, 4th                | 5     |
 * |                                 |     | qq      | 01, 02, 03, 04                    |       |
 * |                                 |     | qqq     | Q1, Q2, Q3, Q4                    |       |
 * |                                 |     | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 |     | qqqqq   | 1, 2, 3, 4                        | 3     |
 * | Month (formatting)              | 110 | M       | 1, 2, ..., 12                     |       |
 * |                                 |     | Mo      | 1st, 2nd, ..., 12th               | 5     |
 * |                                 |     | MM      | 01, 02, ..., 12                   |       |
 * |                                 |     | MMM     | Jan, Feb, ..., Dec                |       |
 * |                                 |     | MMMM    | January, February, ..., December  | 2     |
 * |                                 |     | MMMMM   | J, F, ..., D                      |       |
 * | Month (stand-alone)             | 110 | L       | 1, 2, ..., 12                     |       |
 * |                                 |     | Lo      | 1st, 2nd, ..., 12th               | 5     |
 * |                                 |     | LL      | 01, 02, ..., 12                   |       |
 * |                                 |     | LLL     | Jan, Feb, ..., Dec                |       |
 * |                                 |     | LLLL    | January, February, ..., December  | 2     |
 * |                                 |     | LLLLL   | J, F, ..., D                      |       |
 * | Local week of year              | 100 | w       | 1, 2, ..., 53                     |       |
 * |                                 |     | wo      | 1st, 2nd, ..., 53th               | 5     |
 * |                                 |     | ww      | 01, 02, ..., 53                   |       |
 * | ISO week of year                | 100 | I       | 1, 2, ..., 53                     | 5     |
 * |                                 |     | Io      | 1st, 2nd, ..., 53th               | 5     |
 * |                                 |     | II      | 01, 02, ..., 53                   | 5     |
 * | Day of month                    |  90 | d       | 1, 2, ..., 31                     |       |
 * |                                 |     | do      | 1st, 2nd, ..., 31st               | 5     |
 * |                                 |     | dd      | 01, 02, ..., 31                   |       |
 * | Day of year                     |  90 | D       | 1, 2, ..., 365, 366               | 7     |
 * |                                 |     | Do      | 1st, 2nd, ..., 365th, 366th       | 5     |
 * |                                 |     | DD      | 01, 02, ..., 365, 366             | 7     |
 * |                                 |     | DDD     | 001, 002, ..., 365, 366           |       |
 * |                                 |     | DDDD    | ...                               | 2     |
 * | Day of week (formatting)        |  90 | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 |     | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | EEEEE   | M, T, W, T, F, S, S               |       |
 * |                                 |     | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | ISO day of week (formatting)    |  90 | i       | 1, 2, 3, ..., 7                   | 5     |
 * |                                 |     | io      | 1st, 2nd, ..., 7th                | 5     |
 * |                                 |     | ii      | 01, 02, ..., 07                   | 5     |
 * |                                 |     | iii     | Mon, Tue, Wed, ..., Sun           | 5     |
 * |                                 |     | iiii    | Monday, Tuesday, ..., Sunday      | 2,5   |
 * |                                 |     | iiiii   | M, T, W, T, F, S, S               | 5     |
 * |                                 |     | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 5     |
 * | Local day of week (formatting)  |  90 | e       | 2, 3, 4, ..., 1                   |       |
 * |                                 |     | eo      | 2nd, 3rd, ..., 1st                | 5     |
 * |                                 |     | ee      | 02, 03, ..., 01                   |       |
 * |                                 |     | eee     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 |     | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | eeeee   | M, T, W, T, F, S, S               |       |
 * |                                 |     | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | Local day of week (stand-alone) |  90 | c       | 2, 3, 4, ..., 1                   |       |
 * |                                 |     | co      | 2nd, 3rd, ..., 1st                | 5     |
 * |                                 |     | cc      | 02, 03, ..., 01                   |       |
 * |                                 |     | ccc     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 |     | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | ccccc   | M, T, W, T, F, S, S               |       |
 * |                                 |     | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | AM, PM                          |  80 | a..aaa  | AM, PM                            |       |
 * |                                 |     | aaaa    | a.m., p.m.                        | 2     |
 * |                                 |     | aaaaa   | a, p                              |       |
 * | AM, PM, noon, midnight          |  80 | b..bbb  | AM, PM, noon, midnight            |       |
 * |                                 |     | bbbb    | a.m., p.m., noon, midnight        | 2     |
 * |                                 |     | bbbbb   | a, p, n, mi                       |       |
 * | Flexible day period             |  80 | B..BBB  | at night, in the morning, ...     |       |
 * |                                 |     | BBBB    | at night, in the morning, ...     | 2     |
 * |                                 |     | BBBBB   | at night, in the morning, ...     |       |
 * | Hour [1-12]                     |  70 | h       | 1, 2, ..., 11, 12                 |       |
 * |                                 |     | ho      | 1st, 2nd, ..., 11th, 12th         | 5     |
 * |                                 |     | hh      | 01, 02, ..., 11, 12               |       |
 * | Hour [0-23]                     |  70 | H       | 0, 1, 2, ..., 23                  |       |
 * |                                 |     | Ho      | 0th, 1st, 2nd, ..., 23rd          | 5     |
 * |                                 |     | HH      | 00, 01, 02, ..., 23               |       |
 * | Hour [0-11]                     |  70 | K       | 1, 2, ..., 11, 0                  |       |
 * |                                 |     | Ko      | 1st, 2nd, ..., 11th, 0th          | 5     |
 * |                                 |     | KK      | 01, 02, ..., 11, 00               |       |
 * | Hour [1-24]                     |  70 | k       | 24, 1, 2, ..., 23                 |       |
 * |                                 |     | ko      | 24th, 1st, 2nd, ..., 23rd         | 5     |
 * |                                 |     | kk      | 24, 01, 02, ..., 23               |       |
 * | Minute                          |  60 | m       | 0, 1, ..., 59                     |       |
 * |                                 |     | mo      | 0th, 1st, ..., 59th               | 5     |
 * |                                 |     | mm      | 00, 01, ..., 59                   |       |
 * | Second                          |  50 | s       | 0, 1, ..., 59                     |       |
 * |                                 |     | so      | 0th, 1st, ..., 59th               | 5     |
 * |                                 |     | ss      | 00, 01, ..., 59                   |       |
 * | Seconds timestamp               |  40 | t       | 512969520                         |       |
 * |                                 |     | tt      | ...                               | 2     |
 * | Fraction of second              |  30 | S       | 0, 1, ..., 9                      |       |
 * |                                 |     | SS      | 00, 01, ..., 99                   |       |
 * |                                 |     | SSS     | 000, 001, ..., 999                |       |
 * |                                 |     | SSSS    | ...                               | 2     |
 * | Milliseconds timestamp          |  20 | T       | 512969520900                      |       |
 * |                                 |     | TT      | ...                               | 2     |
 * | Timezone (ISO-8601 w/ Z)        |  10 | X       | -08, +0530, Z                     |       |
 * |                                 |     | XX      | -0800, +0530, Z                   |       |
 * |                                 |     | XXX     | -08:00, +05:30, Z                 |       |
 * |                                 |     | XXXX    | -0800, +0530, Z, +123456          | 2     |
 * |                                 |     | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
 * | Timezone (ISO-8601 w/o Z)       |  10 | x       | -08, +0530, +00                   |       |
 * |                                 |     | xx      | -0800, +0530, +0000               |       |
 * |                                 |     | xxx     | -08:00, +05:30, +00:00            | 2     |
 * |                                 |     | xxxx    | -0800, +0530, +0000, +123456      |       |
 * |                                 |     | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
 * | Long localized date             |  NA | P       | 05/29/1453                        | 5,8   |
 * |                                 |     | PP      | May 29, 1453                      |       |
 * |                                 |     | PPP     | May 29th, 1453                    |       |
 * |                                 |     | PPPP    | Sunday, May 29th, 1453            | 2,5,8 |
 * | Long localized time             |  NA | p       | 12:00 AM                          | 5,8   |
 * |                                 |     | pp      | 12:00:00 AM                       |       |
 * | Combination of date and time    |  NA | Pp      | 05/29/1453, 12:00 AM              |       |
 * |                                 |     | PPpp    | May 29, 1453, 12:00:00 AM         |       |
 * |                                 |     | PPPpp   | May 29th, 1453 at ...             |       |
 * |                                 |     | PPPPpp  | Sunday, May 29th, 1453 at ...     | 2,5,8 |
 * Notes:
 * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
 *    are the same as "stand-alone" units, but are different in some languages.
 *    "Formatting" units are declined according to the rules of the language
 *    in the context of a date. "Stand-alone" units are always nominative singular.
 *    In `format` function, they will produce different result:
 *
 *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
 *
 *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
 *
 *    `parse` will try to match both formatting and stand-alone units interchangably.
 *
 * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
 *    the single quote characters (see below).
 *    If the sequence is longer than listed in table:
 *    - for numerical units (`yyyyyyyy`) `parse` will try to match a number
 *      as wide as the sequence
 *    - for text units (`MMMMMMMM`) `parse` will try to match the widest variation of the unit.
 *      These variations are marked with "2" in the last column of the table.
 *
 * 3. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
 *    These tokens represent the shortest form of the quarter.
 *
 * 4. The main difference between `y` and `u` patterns are B.C. years:
 *
 *    | Year | `y` | `u` |
 *    |------|-----|-----|
 *    | AC 1 |   1 |   1 |
 *    | BC 1 |   1 |   0 |
 *    | BC 2 |   2 |  -1 |
 *
 *    Also `yy` will try to guess the century of two digit year by proximity with `referenceDate`:
 *
 *    `parse('50', 'yy', new Date(2018, 0, 1)) //=> Sat Jan 01 2050 00:00:00`
 *
 *    `parse('75', 'yy', new Date(2018, 0, 1)) //=> Wed Jan 01 1975 00:00:00`
 *
 *    while `uu` will just assign the year as is:
 *
 *    `parse('50', 'uu', new Date(2018, 0, 1)) //=> Sat Jan 01 0050 00:00:00`
 *
 *    `parse('75', 'uu', new Date(2018, 0, 1)) //=> Tue Jan 01 0075 00:00:00`
 *
 *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
 *    except local week-numbering years are dependent on `options.weekStartsOn`
 *    and `options.firstWeekContainsDate` (compare [setISOWeekYear]{@link https://date-fns.org/docs/setISOWeekYear}
 *    and [setWeekYear]{@link https://date-fns.org/docs/setWeekYear}).
 *
 * 5. These patterns are not in the Unicode Technical Standard #35:
 *    - `i`: ISO day of week
 *    - `I`: ISO week of year
 *    - `R`: ISO week-numbering year
 *    - `o`: ordinal number modifier
 *    - `P`: long localized date
 *    - `p`: long localized time
 *
 * 6. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
 *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * 7. `D` and `DD` tokens represent days of the year but they are ofthen confused with days of the month.
 *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * 8. `P+` tokens do not have a defined priority since they are merely aliases to other tokens based
 *    on the given locale.
 *
 *    using `en-US` locale: `P` => `MM/dd/yyyy`
 *    using `en-US` locale: `p` => `hh:mm a`
 *    using `pt-BR` locale: `P` => `dd/MM/yyyy`
 *    using `pt-BR` locale: `p` => `HH:mm`
 *
 * Values will be assigned to the date in the descending order of its unit's priority.
 * Units of an equal priority overwrite each other in the order of appearance.
 *
 * If no values of higher priority are parsed (e.g. when parsing string 'January 1st' without a year),
 * the values will be taken from 3rd argument `referenceDate` which works as a context of parsing.
 *
 * `referenceDate` must be passed for correct work of the function.
 * If you're not sure which `referenceDate` to supply, create a new instance of Date:
 * `parse('02/11/2014', 'MM/dd/yyyy', new Date())`
 * In this case parsing will be done in the context of the current date.
 * If `referenceDate` is `Invalid Date` or a value not convertible to valid `Date`,
 * then `Invalid Date` will be returned.
 *
 * The result may vary by locale.
 *
 * If `formatString` matches with `dateString` but does not provides tokens, `referenceDate` will be returned.
 *
 * If parsing failed, `Invalid Date` will be returned.
 * Invalid Date is a Date, whose time value is NaN.
 * Time value of Date: http://es5.github.io/#x15.9.1.1
 *
 * @param {String} dateString - the string to parse
 * @param {String} formatString - the string of tokens
 * @param {Date|Number} referenceDate - defines values missing from the parsed dateString
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @param {1|2|3|4|5|6|7} [options.firstWeekContainsDate=1] - the day of January, which is always in the first week of the year
 * @param {Boolean} [options.useAdditionalWeekYearTokens=false] - if true, allows usage of the week-numbering year tokens `YY` and `YYYY`;
 *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @param {Boolean} [options.useAdditionalDayOfYearTokens=false] - if true, allows usage of the day of year tokens `D` and `DD`;
 *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @returns {Date} the parsed date
 * @throws {TypeError} 3 arguments required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
 * @throws {RangeError} `options.locale` must contain `match` property
 * @throws {RangeError} use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} format string contains an unescaped latin alphabet character
 *
 * @example
 * // Parse 11 February 2014 from middle-endian format:
 * var result = parse('02/11/2014', 'MM/dd/yyyy', new Date())
 * //=> Tue Feb 11 2014 00:00:00
 *
 * @example
 * // Parse 28th of February in Esperanto locale in the context of 2010 year:
 * import eo from 'date-fns/locale/eo'
 * var result = parse('28-a de februaro', "do 'de' MMMM", new Date(2010, 0, 1), {
 *   locale: eo
 * })
 * //=> Sun Feb 28 2010 00:00:00
 */

function parse(dirtyDateString, dirtyFormatString, dirtyReferenceDate, options) {
  var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;
  requiredArgs(3, arguments);
  var dateString = String(dirtyDateString);
  var formatString = String(dirtyFormatString);
  var defaultOptions = getDefaultOptions();
  var locale$1 = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions.locale) !== null && _ref !== void 0 ? _ref : locale;
  if (!locale$1.match) {
    throw new RangeError('locale must contain match property');
  }
  var firstWeekContainsDate = toInteger((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
  }
  var weekStartsOn = toInteger((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }
  if (formatString === '') {
    if (dateString === '') {
      return toDate(dirtyReferenceDate);
    } else {
      return new Date(NaN);
    }
  }
  var subFnOptions = {
    firstWeekContainsDate: firstWeekContainsDate,
    weekStartsOn: weekStartsOn,
    locale: locale$1
  }; // If timezone isn't specified, it will be set to the system timezone

  var setters = [new DateToSystemTimezoneSetter()];
  var tokens = formatString.match(longFormattingTokensRegExp).map(function (substring) {
    var firstCharacter = substring[0];
    if (firstCharacter in longFormatters) {
      var longFormatter = longFormatters[firstCharacter];
      return longFormatter(substring, locale$1.formatLong);
    }
    return substring;
  }).join('').match(formattingTokensRegExp);
  var usedTokens = [];
  var _iterator = _createForOfIteratorHelper(tokens),
    _step;
  try {
    var _loop = function _loop() {
      var token = _step.value;
      if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(token)) {
        throwProtectedError(token, formatString, dirtyDateString);
      }
      if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(token)) {
        throwProtectedError(token, formatString, dirtyDateString);
      }
      var firstCharacter = token[0];
      var parser = parsers[firstCharacter];
      if (parser) {
        var incompatibleTokens = parser.incompatibleTokens;
        if (Array.isArray(incompatibleTokens)) {
          var incompatibleToken = usedTokens.find(function (usedToken) {
            return incompatibleTokens.includes(usedToken.token) || usedToken.token === firstCharacter;
          });
          if (incompatibleToken) {
            throw new RangeError("The format string mustn't contain `".concat(incompatibleToken.fullToken, "` and `").concat(token, "` at the same time"));
          }
        } else if (parser.incompatibleTokens === '*' && usedTokens.length > 0) {
          throw new RangeError("The format string mustn't contain `".concat(token, "` and any other token at the same time"));
        }
        usedTokens.push({
          token: firstCharacter,
          fullToken: token
        });
        var parseResult = parser.run(dateString, token, locale$1.match, subFnOptions);
        if (!parseResult) {
          return {
            v: new Date(NaN)
          };
        }
        setters.push(parseResult.setter);
        dateString = parseResult.rest;
      } else {
        if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
          throw new RangeError('Format string contains an unescaped latin alphabet character `' + firstCharacter + '`');
        } // Replace two single quote characters with one single quote character

        if (token === "''") {
          token = "'";
        } else if (firstCharacter === "'") {
          token = cleanEscapedString(token);
        } // Cut token from string, or, if string doesn't match the token, return Invalid Date

        if (dateString.indexOf(token) === 0) {
          dateString = dateString.slice(token.length);
        } else {
          return {
            v: new Date(NaN)
          };
        }
      }
    };
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _ret = _loop();
      if (_typeof(_ret) === "object") return _ret.v;
    } // Check if the remaining input contains something other than whitespace
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  if (dateString.length > 0 && notWhitespaceRegExp.test(dateString)) {
    return new Date(NaN);
  }
  var uniquePrioritySetters = setters.map(function (setter) {
    return setter.priority;
  }).sort(function (a, b) {
    return b - a;
  }).filter(function (priority, index, array) {
    return array.indexOf(priority) === index;
  }).map(function (priority) {
    return setters.filter(function (setter) {
      return setter.priority === priority;
    }).sort(function (a, b) {
      return b.subPriority - a.subPriority;
    });
  }).map(function (setterArray) {
    return setterArray[0];
  });
  var date = toDate(dirtyReferenceDate);
  if (isNaN(date.getTime())) {
    return new Date(NaN);
  } // Convert the date in system timezone to the same date in UTC+00:00 timezone.

  var utcDate = subMilliseconds(date, getTimezoneOffsetInMilliseconds(date));
  var flags = {};
  var _iterator2 = _createForOfIteratorHelper(uniquePrioritySetters),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var setter = _step2.value;
      if (!setter.validate(utcDate, subFnOptions)) {
        return new Date(NaN);
      }
      var result = setter.set(utcDate, flags, subFnOptions); // Result is tuple (date, flags)

      if (Array.isArray(result)) {
        utcDate = result[0];
        assign(flags, result[1]); // Result is date
      } else {
        utcDate = result;
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  return utcDate;
}
function cleanEscapedString(input) {
  return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
}

/**
 * @name isMatch
 * @category Common Helpers
 * @summary validates the date string against given formats
 *
 * @description
 * Return the true if given date is string correct against the given format else
 * will return false.
 *
 * > ⚠️ Please note that the `format` tokens differ from Moment.js and other libraries.
 * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * The characters in the format string wrapped between two single quotes characters (') are escaped.
 * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
 *
 * Format of the format string is based on Unicode Technical Standard #35:
 * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
 * with a few additions (see note 5 below the table).
 *
 * Not all tokens are compatible. Combinations that don't make sense or could lead to bugs are prohibited
 * and will throw `RangeError`. For example usage of 24-hour format token with AM/PM token will throw an exception:
 *
 * ```javascript
 * isMatch('23 AM', 'HH a')
 * //=> RangeError: The format string mustn't contain `HH` and `a` at the same time
 * ```
 *
 * See the compatibility table: https://docs.google.com/spreadsheets/d/e/2PACX-1vQOPU3xUhplll6dyoMmVUXHKl_8CRDs6_ueLmex3SoqwhuolkuN3O05l4rqx5h1dKX8eb46Ul-CCSrq/pubhtml?gid=0&single=true
 *
 * Accepted format string patterns:
 * | Unit                            |Prior| Pattern | Result examples                   | Notes |
 * |---------------------------------|-----|---------|-----------------------------------|-------|
 * | Era                             | 140 | G..GGG  | AD, BC                            |       |
 * |                                 |     | GGGG    | Anno Domini, Before Christ        | 2     |
 * |                                 |     | GGGGG   | A, B                              |       |
 * | Calendar year                   | 130 | y       | 44, 1, 1900, 2017, 9999           | 4     |
 * |                                 |     | yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
 * |                                 |     | yy      | 44, 01, 00, 17                    | 4     |
 * |                                 |     | yyy     | 044, 001, 123, 999                | 4     |
 * |                                 |     | yyyy    | 0044, 0001, 1900, 2017            | 4     |
 * |                                 |     | yyyyy   | ...                               | 2,4   |
 * | Local week-numbering year       | 130 | Y       | 44, 1, 1900, 2017, 9000           | 4     |
 * |                                 |     | Yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
 * |                                 |     | YY      | 44, 01, 00, 17                    | 4,6   |
 * |                                 |     | YYY     | 044, 001, 123, 999                | 4     |
 * |                                 |     | YYYY    | 0044, 0001, 1900, 2017            | 4,6   |
 * |                                 |     | YYYYY   | ...                               | 2,4   |
 * | ISO week-numbering year         | 130 | R       | -43, 1, 1900, 2017, 9999, -9999   | 4,5   |
 * |                                 |     | RR      | -43, 01, 00, 17                   | 4,5   |
 * |                                 |     | RRR     | -043, 001, 123, 999, -999         | 4,5   |
 * |                                 |     | RRRR    | -0043, 0001, 2017, 9999, -9999    | 4,5   |
 * |                                 |     | RRRRR   | ...                               | 2,4,5 |
 * | Extended year                   | 130 | u       | -43, 1, 1900, 2017, 9999, -999    | 4     |
 * |                                 |     | uu      | -43, 01, 99, -99                  | 4     |
 * |                                 |     | uuu     | -043, 001, 123, 999, -999         | 4     |
 * |                                 |     | uuuu    | -0043, 0001, 2017, 9999, -9999    | 4     |
 * |                                 |     | uuuuu   | ...                               | 2,4   |
 * | Quarter (formatting)            | 120 | Q       | 1, 2, 3, 4                        |       |
 * |                                 |     | Qo      | 1st, 2nd, 3rd, 4th                | 5     |
 * |                                 |     | QQ      | 01, 02, 03, 04                    |       |
 * |                                 |     | QQQ     | Q1, Q2, Q3, Q4                    |       |
 * |                                 |     | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 |     | QQQQQ   | 1, 2, 3, 4                        | 4     |
 * | Quarter (stand-alone)           | 120 | q       | 1, 2, 3, 4                        |       |
 * |                                 |     | qo      | 1st, 2nd, 3rd, 4th                | 5     |
 * |                                 |     | qq      | 01, 02, 03, 04                    |       |
 * |                                 |     | qqq     | Q1, Q2, Q3, Q4                    |       |
 * |                                 |     | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 |     | qqqqq   | 1, 2, 3, 4                        | 3     |
 * | Month (formatting)              | 110 | M       | 1, 2, ..., 12                     |       |
 * |                                 |     | Mo      | 1st, 2nd, ..., 12th               | 5     |
 * |                                 |     | MM      | 01, 02, ..., 12                   |       |
 * |                                 |     | MMM     | Jan, Feb, ..., Dec                |       |
 * |                                 |     | MMMM    | January, February, ..., December  | 2     |
 * |                                 |     | MMMMM   | J, F, ..., D                      |       |
 * | Month (stand-alone)             | 110 | L       | 1, 2, ..., 12                     |       |
 * |                                 |     | Lo      | 1st, 2nd, ..., 12th               | 5     |
 * |                                 |     | LL      | 01, 02, ..., 12                   |       |
 * |                                 |     | LLL     | Jan, Feb, ..., Dec                |       |
 * |                                 |     | LLLL    | January, February, ..., December  | 2     |
 * |                                 |     | LLLLL   | J, F, ..., D                      |       |
 * | Local week of year              | 100 | w       | 1, 2, ..., 53                     |       |
 * |                                 |     | wo      | 1st, 2nd, ..., 53th               | 5     |
 * |                                 |     | ww      | 01, 02, ..., 53                   |       |
 * | ISO week of year                | 100 | I       | 1, 2, ..., 53                     | 5     |
 * |                                 |     | Io      | 1st, 2nd, ..., 53th               | 5     |
 * |                                 |     | II      | 01, 02, ..., 53                   | 5     |
 * | Day of month                    |  90 | d       | 1, 2, ..., 31                     |       |
 * |                                 |     | do      | 1st, 2nd, ..., 31st               | 5     |
 * |                                 |     | dd      | 01, 02, ..., 31                   |       |
 * | Day of year                     |  90 | D       | 1, 2, ..., 365, 366               | 7     |
 * |                                 |     | Do      | 1st, 2nd, ..., 365th, 366th       | 5     |
 * |                                 |     | DD      | 01, 02, ..., 365, 366             | 7     |
 * |                                 |     | DDD     | 001, 002, ..., 365, 366           |       |
 * |                                 |     | DDDD    | ...                               | 2     |
 * | Day of week (formatting)        |  90 | E..EEE  | Mon, Tue, Wed, ..., Su            |       |
 * |                                 |     | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | EEEEE   | M, T, W, T, F, S, S               |       |
 * |                                 |     | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | ISO day of week (formatting)    |  90 | i       | 1, 2, 3, ..., 7                   | 5     |
 * |                                 |     | io      | 1st, 2nd, ..., 7th                | 5     |
 * |                                 |     | ii      | 01, 02, ..., 07                   | 5     |
 * |                                 |     | iii     | Mon, Tue, Wed, ..., Su            | 5     |
 * |                                 |     | iiii    | Monday, Tuesday, ..., Sunday      | 2,5   |
 * |                                 |     | iiiii   | M, T, W, T, F, S, S               | 5     |
 * |                                 |     | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 5     |
 * | Local day of week (formatting)  |  90 | e       | 2, 3, 4, ..., 1                   |       |
 * |                                 |     | eo      | 2nd, 3rd, ..., 1st                | 5     |
 * |                                 |     | ee      | 02, 03, ..., 01                   |       |
 * |                                 |     | eee     | Mon, Tue, Wed, ..., Su            |       |
 * |                                 |     | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | eeeee   | M, T, W, T, F, S, S               |       |
 * |                                 |     | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | Local day of week (stand-alone) |  90 | c       | 2, 3, 4, ..., 1                   |       |
 * |                                 |     | co      | 2nd, 3rd, ..., 1st                | 5     |
 * |                                 |     | cc      | 02, 03, ..., 01                   |       |
 * |                                 |     | ccc     | Mon, Tue, Wed, ..., Su            |       |
 * |                                 |     | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | ccccc   | M, T, W, T, F, S, S               |       |
 * |                                 |     | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | AM, PM                          |  80 | a..aaa  | AM, PM                            |       |
 * |                                 |     | aaaa    | a.m., p.m.                        | 2     |
 * |                                 |     | aaaaa   | a, p                              |       |
 * | AM, PM, noon, midnight          |  80 | b..bbb  | AM, PM, noon, midnight            |       |
 * |                                 |     | bbbb    | a.m., p.m., noon, midnight        | 2     |
 * |                                 |     | bbbbb   | a, p, n, mi                       |       |
 * | Flexible day period             |  80 | B..BBB  | at night, in the morning, ...     |       |
 * |                                 |     | BBBB    | at night, in the morning, ...     | 2     |
 * |                                 |     | BBBBB   | at night, in the morning, ...     |       |
 * | Hour [1-12]                     |  70 | h       | 1, 2, ..., 11, 12                 |       |
 * |                                 |     | ho      | 1st, 2nd, ..., 11th, 12th         | 5     |
 * |                                 |     | hh      | 01, 02, ..., 11, 12               |       |
 * | Hour [0-23]                     |  70 | H       | 0, 1, 2, ..., 23                  |       |
 * |                                 |     | Ho      | 0th, 1st, 2nd, ..., 23rd          | 5     |
 * |                                 |     | HH      | 00, 01, 02, ..., 23               |       |
 * | Hour [0-11]                     |  70 | K       | 1, 2, ..., 11, 0                  |       |
 * |                                 |     | Ko      | 1st, 2nd, ..., 11th, 0th          | 5     |
 * |                                 |     | KK      | 01, 02, ..., 11, 00               |       |
 * | Hour [1-24]                     |  70 | k       | 24, 1, 2, ..., 23                 |       |
 * |                                 |     | ko      | 24th, 1st, 2nd, ..., 23rd         | 5     |
 * |                                 |     | kk      | 24, 01, 02, ..., 23               |       |
 * | Minute                          |  60 | m       | 0, 1, ..., 59                     |       |
 * |                                 |     | mo      | 0th, 1st, ..., 59th               | 5     |
 * |                                 |     | mm      | 00, 01, ..., 59                   |       |
 * | Second                          |  50 | s       | 0, 1, ..., 59                     |       |
 * |                                 |     | so      | 0th, 1st, ..., 59th               | 5     |
 * |                                 |     | ss      | 00, 01, ..., 59                   |       |
 * | Seconds timestamp               |  40 | t       | 512969520                         |       |
 * |                                 |     | tt      | ...                               | 2     |
 * | Fraction of second              |  30 | S       | 0, 1, ..., 9                      |       |
 * |                                 |     | SS      | 00, 01, ..., 99                   |       |
 * |                                 |     | SSS     | 000, 001, ..., 999                |       |
 * |                                 |     | SSSS    | ...                               | 2     |
 * | Milliseconds timestamp          |  20 | T       | 512969520900                      |       |
 * |                                 |     | TT      | ...                               | 2     |
 * | Timezone (ISO-8601 w/ Z)        |  10 | X       | -08, +0530, Z                     |       |
 * |                                 |     | XX      | -0800, +0530, Z                   |       |
 * |                                 |     | XXX     | -08:00, +05:30, Z                 |       |
 * |                                 |     | XXXX    | -0800, +0530, Z, +123456          | 2     |
 * |                                 |     | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
 * | Timezone (ISO-8601 w/o Z)       |  10 | x       | -08, +0530, +00                   |       |
 * |                                 |     | xx      | -0800, +0530, +0000               |       |
 * |                                 |     | xxx     | -08:00, +05:30, +00:00            | 2     |
 * |                                 |     | xxxx    | -0800, +0530, +0000, +123456      |       |
 * |                                 |     | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
 * | Long localized date             |  NA | P       | 05/29/1453                        | 5,8   |
 * |                                 |     | PP      | May 29, 1453                      |       |
 * |                                 |     | PPP     | May 29th, 1453                    |       |
 * |                                 |     | PPPP    | Sunday, May 29th, 1453            | 2,5,8 |
 * | Long localized time             |  NA | p       | 12:00 AM                          | 5,8   |
 * |                                 |     | pp      | 12:00:00 AM                       |       |
 * | Combination of date and time    |  NA | Pp      | 05/29/1453, 12:00 AM              |       |
 * |                                 |     | PPpp    | May 29, 1453, 12:00:00 AM         |       |
 * |                                 |     | PPPpp   | May 29th, 1453 at ...             |       |
 * |                                 |     | PPPPpp  | Sunday, May 29th, 1453 at ...     | 2,5,8 |
 * Notes:
 * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
 *    are the same as "stand-alone" units, but are different in some languages.
 *    "Formatting" units are declined according to the rules of the language
 *    in the context of a date. "Stand-alone" units are always nominative singular.
 *    In `format` function, they will produce different result:
 *
 *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
 *
 *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
 *
 *    `isMatch` will try to match both formatting and stand-alone units interchangably.
 *
 * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
 *    the single quote characters (see below).
 *    If the sequence is longer than listed in table:
 *    - for numerical units (`yyyyyyyy`) `isMatch` will try to match a number
 *      as wide as the sequence
 *    - for text units (`MMMMMMMM`) `isMatch` will try to match the widest variation of the unit.
 *      These variations are marked with "2" in the last column of the table.
 *
 * 3. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
 *    These tokens represent the shortest form of the quarter.
 *
 * 4. The main difference between `y` and `u` patterns are B.C. years:
 *
 *    | Year | `y` | `u` |
 *    |------|-----|-----|
 *    | AC 1 |   1 |   1 |
 *    | BC 1 |   1 |   0 |
 *    | BC 2 |   2 |  -1 |
 *
 *    Also `yy` will try to guess the century of two digit year by proximity with `referenceDate`:
 *
 *    `isMatch('50', 'yy') //=> true`
 *
 *    `isMatch('75', 'yy') //=> true`
 *
 *    while `uu` will use the year as is:
 *
 *    `isMatch('50', 'uu') //=> true`
 *
 *    `isMatch('75', 'uu') //=> true`
 *
 *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
 *    except local week-numbering years are dependent on `options.weekStartsOn`
 *    and `options.firstWeekContainsDate` (compare [setISOWeekYear]{@link https://date-fns.org/docs/setISOWeekYear}
 *    and [setWeekYear]{@link https://date-fns.org/docs/setWeekYear}).
 *
 * 5. These patterns are not in the Unicode Technical Standard #35:
 *    - `i`: ISO day of week
 *    - `I`: ISO week of year
 *    - `R`: ISO week-numbering year
 *    - `o`: ordinal number modifier
 *    - `P`: long localized date
 *    - `p`: long localized time
 *
 * 6. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
 *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * 7. `D` and `DD` tokens represent days of the year but they are ofthen confused with days of the month.
 *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * 8. `P+` tokens do not have a defined priority since they are merely aliases to other tokens based
 *    on the given locale.
 *
 *    using `en-US` locale: `P` => `MM/dd/yyyy`
 *    using `en-US` locale: `p` => `hh:mm a`
 *    using `pt-BR` locale: `P` => `dd/MM/yyyy`
 *    using `pt-BR` locale: `p` => `HH:mm`
 *
 * Values will be checked in the descending order of its unit's priority.
 * Units of an equal priority overwrite each other in the order of appearance.
 *
 * If no values of higher priority are matched (e.g. when matching string 'January 1st' without a year),
 * the values will be taken from today's using `new Date()` date which works as a context of parsing.
 *
 * The result may vary by locale.
 *
 * If `formatString` matches with `dateString` but does not provides tokens, `referenceDate` will be returned.
 *
 *
 *
 * @param {String} dateString - the date string to verify
 * @param {String} formatString - the string of tokens
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @param {1|2|3|4|5|6|7} [options.firstWeekContainsDate=1] - the day of January, which is always in the first week of the year
 * @param {Boolean} [options.useAdditionalWeekYearTokens=false] - if true, allows usage of the week-numbering year tokens `YY` and `YYYY`;
 *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @param {Boolean} [options.useAdditionalDayOfYearTokens=false] - if true, allows usage of the day of year tokens `D` and `DD`;
 *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @returns {Boolean}
 * @throws {TypeError} 2 arguments required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
 * @throws {RangeError} `options.locale` must contain `match` property
 * @throws {RangeError} use `yyyy` instead of `YYYY` for formatting years; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} use `yy` instead of `YY` for formatting years; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} use `d` instead of `D` for formatting days of the month; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} use `dd` instead of `DD` for formatting days of the month; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} format string contains an unescaped latin alphabet character
 *
 * @example
 * // Match 11 February 2014 from middle-endian format:
 * const result = isMatch('02/11/2014', 'MM/dd/yyyy')
 * //=> true
 *
 * @example
 * // Match 28th of February in Esperanto locale in the context of 2010 year:
 * import eo from 'date-fns/locale/eo'
 * const result = isMatch('28-a de februaro', "do 'de' MMMM", {
 *   locale: eo
 * })
 * //=> true
 */
function isMatch(dateString, formatString, options) {
  requiredArgs(2, arguments);
  return isValid(parse(dateString, formatString, new Date(), options));
}

var dateConfig = {
  parseDate: function parseDate(datestr, _format) {
    var pattern;
    if (isMatch(datestr, "dd-MM-yyyy")) {
      pattern = "dd-MM-yyyy";
    } else if (isMatch(datestr, "dd/MM/yyyy")) {
      pattern = "dd/MM/yyyy";
    } else if (isMatch(datestr, "dd MMM yyyy")) {
      pattern = "dd MMM yyyy";
    } else if (isMatch(datestr, "yyyy-MM-dd")) {
      pattern = "yyyy-MM-dd";
    } else {
      pattern = "dd-MMM-yyyy";
    }
    return parse(datestr, pattern, new Date());
  },
  locale: {
    firstDayOfWeek: 1,
    months: _objectSpread2$1(_objectSpread2$1({}, _default$7.exports.english.months), {}, {
      shorthand: [].concat(_toConsumableArray(_default$7.exports.english.months.shorthand), [
      // Allow users to input numbers in date field instead of Jan, Feb
      // Because we can't directly change `tokenRegex`, add the numbers to the
      // month shorthand locale, so they'll end up in the regexp string
      // See https://github.com/flatpickr/flatpickr/blob/614568f20daff9fdef906e8451876d8918c68d3c/src/index.ts#L2160
      // Alternative and cleaner approach would be to set our own `config.parseDate()` function
      // which has custom tokenRegex that fit our needs best.
      "01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"])
    })
  },
  dateFormat: "d-M-Y"
};
var timeConfig = {
  enableTime: true,
  noCalendar: true,
  time_24hr: true,
  dateFormat: "H:i"
};
var dateWithTimeConfig = {
  parseDate: function parseDate(datestr, _format) {
    var pattern;
    if (isMatch(datestr, "dd-MM-yyyy H:m")) {
      pattern = "dd-MM-yyyy H:m";
    } else if (isMatch(datestr, "dd/MM/yyyy H:m")) {
      pattern = "dd/MM/yyyy H:m";
    } else if (isMatch(datestr, "dd MMM yyyy H:m")) {
      pattern = "dd MMM yyyy H:m";
    } else if (isMatch(datestr, "yyyy-MM-dd H:m")) {
      pattern = "yyyy-MM-dd H:m";
    } else {
      pattern = "dd-MMM-yyyy H:m";
    }
    return parse(datestr, pattern, new Date());
  },
  enableTime: true,
  dateFormat: "d-M-Y H:i"
};
var _default$6 = /*#__PURE__*/function (_Controller) {
  _inherits$w(_default, _Controller);
  var _super = _createSuper$w(_default);
  function _default() {
    _classCallCheck$x(this, _default);
    return _super.apply(this, arguments);
  }
  _createClass$x(_default, [{
    key: "connect",
    value: function connect() {
      var config;
      if (this.dateWithTimeValue) {
        config = dateWithTimeConfig;
      } else if (this.timeOnlyValue) {
        config = timeConfig;
      } else {
        config = dateConfig;
      }
      config["maxDate"] = this.element.dataset.flatpickrMaxDate;
      config["minDate"] = this.element.dataset.flatpickrMinDate;
      config["allowInput"] = true;
      this.fp = flatpickr(this.element, config);
    }
  }, {
    key: "disconnect",
    value: function disconnect() {
      this.fp.destroy();
    }
  }]);
  return _default;
}(Controller);
_defineProperty$x(_default$6, "values", {
  timeOnly: Boolean,
  dateWithTime: Boolean
});

/*
  Adds a warning if selected value is not allowed
*/
var _default$5 = /*#__PURE__*/function (_Controller) {
  _inherits$w(_default, _Controller);
  var _super = _createSuper$w(_default);
  function _default() {
    _classCallCheck$x(this, _default);
    return _super.apply(this, arguments);
  }
  _createClass$x(_default, [{
    key: "connect",
    value: function connect() {
      this.toggleMessage();
    }
  }, {
    key: "change",
    value: function change() {
      this.toggleMessage();
    }
  }, {
    key: "toggleMessage",
    value: function toggleMessage() {
      if (this.notRecommendedValue.includes(this.inputTarget.value)) {
        this.messageTarget.classList.remove("hidden");
      } else {
        this.messageTarget.classList.add("hidden");
      }
    }
  }]);
  return _default;
}(Controller);
_defineProperty$x(_default$5, "values", {
  notRecommended: Array
});
_defineProperty$x(_default$5, "targets", ["input", "message"]);

var _default$4 = /*#__PURE__*/function (_Controller) {
  _inherits$w(_default, _Controller);
  var _super = _createSuper$w(_default);
  function _default() {
    _classCallCheck$x(this, _default);
    return _super.apply(this, arguments);
  }
  _createClass$x(_default, [{
    key: "change",
    value: function change() {
      var url = this.element.selectedOptions[0].dataset.frameUrl;
      var frame = document.getElementById(this.frameIdValue);
      frame.src = url;
    }
  }]);
  return _default;
}(Controller);
_defineProperty$x(_default$4, "values", {
  frameId: String
});

// Inspired by https://stackoverflow.com/a/56952952/4405214
var _default$3 = /*#__PURE__*/function (_Controller) {
  _inherits$w(_default, _Controller);
  var _super = _createSuper$w(_default);
  function _default() {
    _classCallCheck$x(this, _default);
    return _super.apply(this, arguments);
  }
  _createClass$x(_default, [{
    key: "connect",
    value: function connect() {
      this.doubleScroll(this.element);
    }
  }, {
    key: "doubleScroll",
    value: function doubleScroll(element) {
      var scrollbar = document.createElement("div");
      scrollbar.appendChild(document.createElement("div"));
      scrollbar.style.overflow = "auto";
      scrollbar.style.overflowY = "hidden";
      scrollbar.firstChild.style.width = element.scrollWidth + "px";
      scrollbar.firstChild.style.paddingTop = "1px";
      var running = false;
      // Keep scrollbar in sync when element size changes
      new ResizeObserver(function () {
        scrollbar.firstChild.style.width = element.scrollWidth + "px";
      }).observe(element);
      scrollbar.onscroll = function () {
        if (running) {
          running = false;
          return;
        }
        running = true;
        element.scrollLeft = scrollbar.scrollLeft;
      };
      element.onscroll = function () {
        if (running) {
          running = false;
          return;
        }
        running = true;
        scrollbar.scrollLeft = element.scrollLeft;
      };
      element.parentNode.insertBefore(scrollbar, element);
    }
  }]);
  return _default;
}(Controller);

var _default$2 = /*#__PURE__*/function (_Controller) {
  _inherits$w(_default, _Controller);
  var _super = _createSuper$w(_default);
  function _default() {
    _classCallCheck$x(this, _default);
    return _super.apply(this, arguments);
  }
  _createClass$x(_default, [{
    key: "initialize",
    value: function initialize() {
      this.change = debounce_1(this.change.bind(this), 1000);
    }
  }, {
    key: "change",
    value: function change(e) {
      var url = new URL(this.srcValue);
      url.searchParams.set(this.queryParamValue, e.target.value);
      this.turboframeTarget.src = url.toString();
    }
  }]);
  return _default;
}(Controller);
_defineProperty$x(_default$2, "targets", ["turboframe"]);
_defineProperty$x(_default$2, "values", {
  src: String,
  queryParam: String
});

var _default$1 = /*#__PURE__*/function (_Controller) {
  _inherits$w(_default, _Controller);
  var _super = _createSuper$w(_default);
  function _default() {
    _classCallCheck$x(this, _default);
    return _super.apply(this, arguments);
  }
  _createClass$x(_default, [{
    key: "connect",
    value: function connect() {
      this.open = false;
    }
  }, {
    key: "toggle",
    value: function toggle(event) {
      this.open === false ? this.show(event) : this.hide(event);
    }
  }, {
    key: "show",
    value: function show(event) {
      this.open = true;
      var target = event.target;
      target.innerHTML = this.lessTextValue;
      this.contentTarget.style.setProperty("--read-more-line-clamp", "'unset'");
      $('.mgrid > .row').masonry('layout');
    }
  }, {
    key: "hide",
    value: function hide(event) {
      this.open = false;
      var target = event.target;
      target.innerHTML = this.moreTextValue;
      this.contentTarget.style.removeProperty("--read-more-line-clamp");
      $('.mgrid > .row').masonry('layout');
    }
  }]);
  return _default;
}(Controller);
_defineProperty$x(_default$1, "targets", ["content"]);
_defineProperty$x(_default$1, "values", {
  moreText: String,
  lessText: String
});

var _default = /*#__PURE__*/function (_Controller) {
  _inherits$w(_default, _Controller);
  var _super = _createSuper$w(_default);
  function _default() {
    _classCallCheck$x(this, _default);
    return _super.apply(this, arguments);
  }
  _createClass$x(_default, [{
    key: "connect",
    value: function connect() {
      grid = this.element;
      // let rowHeight = parseInt(
      var rowHeight = parseInt(window.getComputedStyle(grid).getPropertyValue('grid-auto-rows'));
      var rowGap = parseInt(window.getComputedStyle(grid).getPropertyValue('grid-row-gap'));
      this.contentTargets.forEach(function (el) {
        var rowSpan = Math.ceil((el.querySelector(".content").getBoundingClientRect().height + rowGap) / (rowHeight + rowGap)) + 1;
        console.log(rowSpan);
        el.style.gridRowEnd = "span " + rowSpan;
      });
    }
  }]);
  return _default;
}(Controller);
_defineProperty$x(_default, "targets", ["content"]);

application.register("toggle", _default$z);
application.register("hd-prescription-administration", _default$v);
application.register("home-delivery-modal", _default$u);
application.register("snippets", _default$t);
application.register("letters-form", _default$s);
application.register("prescriptions", _default$r);
application.register("charts", _default$q);
application.register("session", _default$p);
application.register("simple-toggle", _default$o);
application.register("show-on-selected", _default$n);
application.register("tabs", _default$m);
application.register("pd-pet-chart", _default$l);
application.register("pathology-sparklines", _default$k);
application.register("collapsible", _default$j);
application.register("dependent-select", _default$i);
application.register("patient-attachments", _default$h);
application.register("sortable", _default$g);
application.register("select", _default$f);
application.register("radio-reset", _default$e);
application.register("conditional-display", _default$d);
application.register("slimselect", _default$c);
application.register("modal", _default$b);
application.register("form", _default$a);
application.register("alternative-form-submitter", _default$9);
application.register("flash", _default$8);
application.register("flatpickr", _default$6);
application.register("input-value-alerter", _default$5);
application.register("select-update-frame", _default$4);
application.register("clinics--bmi-calculator", _default$y);
application.register("clinics--weight-change-calculator", _default$x);
application.register("clinics--dietary-protein-calculator", _default$w);
application.register("add-top-horizontal-scrollbar", _default$3);
application.register("preview", _default$2);
application.register("read-more", _default$1);
application.register("grid-row-auto-span", _default);

/*
Turbo 7.2.5
Copyright © 2023 37signals LLC
 */
(function () {
  if (window.Reflect === undefined || window.customElements === undefined || window.customElements.polyfillWrapFlushCallback) {
    return;
  }
  const BuiltInHTMLElement = HTMLElement;
  const wrapperForTheName = {
    HTMLElement: function HTMLElement() {
      return Reflect.construct(BuiltInHTMLElement, [], this.constructor);
    }
  };
  window.HTMLElement = wrapperForTheName["HTMLElement"];
  HTMLElement.prototype = BuiltInHTMLElement.prototype;
  HTMLElement.prototype.constructor = HTMLElement;
  Object.setPrototypeOf(HTMLElement, BuiltInHTMLElement);
})();

/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2019 Javan Makhmali
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

(function (prototype) {
  if (typeof prototype.requestSubmit == "function") return;
  prototype.requestSubmit = function (submitter) {
    if (submitter) {
      validateSubmitter(submitter, this);
      submitter.click();
    } else {
      submitter = document.createElement("input");
      submitter.type = "submit";
      submitter.hidden = true;
      this.appendChild(submitter);
      submitter.click();
      this.removeChild(submitter);
    }
  };
  function validateSubmitter(submitter, form) {
    submitter instanceof HTMLElement || raise(TypeError, "parameter 1 is not of type 'HTMLElement'");
    submitter.type == "submit" || raise(TypeError, "The specified element is not a submit button");
    submitter.form == form || raise(DOMException, "The specified element is not owned by this form element", "NotFoundError");
  }
  function raise(errorConstructor, message, name) {
    throw new errorConstructor("Failed to execute 'requestSubmit' on 'HTMLFormElement': " + message + ".", name);
  }
})(HTMLFormElement.prototype);
const submittersByForm = new WeakMap();
function findSubmitterFromClickTarget(target) {
  const element = target instanceof Element ? target : target instanceof Node ? target.parentElement : null;
  const candidate = element ? element.closest("input, button") : null;
  return (candidate === null || candidate === void 0 ? void 0 : candidate.type) == "submit" ? candidate : null;
}
function clickCaptured(event) {
  const submitter = findSubmitterFromClickTarget(event.target);
  if (submitter && submitter.form) {
    submittersByForm.set(submitter.form, submitter);
  }
}
(function () {
  if ("submitter" in Event.prototype) return;
  let prototype;
  if ("SubmitEvent" in window && /Apple Computer/.test(navigator.vendor)) {
    prototype = window.SubmitEvent.prototype;
  } else if ("SubmitEvent" in window) {
    return;
  } else {
    prototype = window.Event.prototype;
  }
  addEventListener("click", clickCaptured, true);
  Object.defineProperty(prototype, "submitter", {
    get() {
      if (this.type == "submit" && this.target instanceof HTMLFormElement) {
        return submittersByForm.get(this.target);
      }
    }
  });
})();
var FrameLoadingStyle;
(function (FrameLoadingStyle) {
  FrameLoadingStyle["eager"] = "eager";
  FrameLoadingStyle["lazy"] = "lazy";
})(FrameLoadingStyle || (FrameLoadingStyle = {}));
class FrameElement extends HTMLElement {
  constructor() {
    super();
    this.loaded = Promise.resolve();
    this.delegate = new FrameElement.delegateConstructor(this);
  }
  static get observedAttributes() {
    return ["disabled", "complete", "loading", "src"];
  }
  connectedCallback() {
    this.delegate.connect();
  }
  disconnectedCallback() {
    this.delegate.disconnect();
  }
  reload() {
    return this.delegate.sourceURLReloaded();
  }
  attributeChangedCallback(name) {
    if (name == "loading") {
      this.delegate.loadingStyleChanged();
    } else if (name == "complete") {
      this.delegate.completeChanged();
    } else if (name == "src") {
      this.delegate.sourceURLChanged();
    } else {
      this.delegate.disabledChanged();
    }
  }
  get src() {
    return this.getAttribute("src");
  }
  set src(value) {
    if (value) {
      this.setAttribute("src", value);
    } else {
      this.removeAttribute("src");
    }
  }
  get loading() {
    return frameLoadingStyleFromString(this.getAttribute("loading") || "");
  }
  set loading(value) {
    if (value) {
      this.setAttribute("loading", value);
    } else {
      this.removeAttribute("loading");
    }
  }
  get disabled() {
    return this.hasAttribute("disabled");
  }
  set disabled(value) {
    if (value) {
      this.setAttribute("disabled", "");
    } else {
      this.removeAttribute("disabled");
    }
  }
  get autoscroll() {
    return this.hasAttribute("autoscroll");
  }
  set autoscroll(value) {
    if (value) {
      this.setAttribute("autoscroll", "");
    } else {
      this.removeAttribute("autoscroll");
    }
  }
  get complete() {
    return !this.delegate.isLoading;
  }
  get isActive() {
    return this.ownerDocument === document && !this.isPreview;
  }
  get isPreview() {
    var _a, _b;
    return (_b = (_a = this.ownerDocument) === null || _a === void 0 ? void 0 : _a.documentElement) === null || _b === void 0 ? void 0 : _b.hasAttribute("data-turbo-preview");
  }
}
function frameLoadingStyleFromString(style) {
  switch (style.toLowerCase()) {
    case "lazy":
      return FrameLoadingStyle.lazy;
    default:
      return FrameLoadingStyle.eager;
  }
}
function expandURL(locatable) {
  return new URL(locatable.toString(), document.baseURI);
}
function getAnchor(url) {
  let anchorMatch;
  if (url.hash) {
    return url.hash.slice(1);
  } else if (anchorMatch = url.href.match(/#(.*)$/)) {
    return anchorMatch[1];
  }
}
function getAction(form, submitter) {
  const action = (submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute("formaction")) || form.getAttribute("action") || form.action;
  return expandURL(action);
}
function getExtension(url) {
  return (getLastPathComponent(url).match(/\.[^.]*$/) || [])[0] || "";
}
function isHTML(url) {
  return !!getExtension(url).match(/^(?:|\.(?:htm|html|xhtml|php))$/);
}
function isPrefixedBy(baseURL, url) {
  const prefix = getPrefix(url);
  return baseURL.href === expandURL(prefix).href || baseURL.href.startsWith(prefix);
}
function locationIsVisitable(location, rootLocation) {
  return isPrefixedBy(location, rootLocation) && isHTML(location);
}
function getRequestURL(url) {
  const anchor = getAnchor(url);
  return anchor != null ? url.href.slice(0, -(anchor.length + 1)) : url.href;
}
function toCacheKey(url) {
  return getRequestURL(url);
}
function urlsAreEqual(left, right) {
  return expandURL(left).href == expandURL(right).href;
}
function getPathComponents(url) {
  return url.pathname.split("/").slice(1);
}
function getLastPathComponent(url) {
  return getPathComponents(url).slice(-1)[0];
}
function getPrefix(url) {
  return addTrailingSlash(url.origin + url.pathname);
}
function addTrailingSlash(value) {
  return value.endsWith("/") ? value : value + "/";
}
class FetchResponse {
  constructor(response) {
    this.response = response;
  }
  get succeeded() {
    return this.response.ok;
  }
  get failed() {
    return !this.succeeded;
  }
  get clientError() {
    return this.statusCode >= 400 && this.statusCode <= 499;
  }
  get serverError() {
    return this.statusCode >= 500 && this.statusCode <= 599;
  }
  get redirected() {
    return this.response.redirected;
  }
  get location() {
    return expandURL(this.response.url);
  }
  get isHTML() {
    return this.contentType && this.contentType.match(/^(?:text\/([^\s;,]+\b)?html|application\/xhtml\+xml)\b/);
  }
  get statusCode() {
    return this.response.status;
  }
  get contentType() {
    return this.header("Content-Type");
  }
  get responseText() {
    return this.response.clone().text();
  }
  get responseHTML() {
    if (this.isHTML) {
      return this.response.clone().text();
    } else {
      return Promise.resolve(undefined);
    }
  }
  header(name) {
    return this.response.headers.get(name);
  }
}
function activateScriptElement(element) {
  if (element.getAttribute("data-turbo-eval") == "false") {
    return element;
  } else {
    const createdScriptElement = document.createElement("script");
    const cspNonce = getMetaContent("csp-nonce");
    if (cspNonce) {
      createdScriptElement.nonce = cspNonce;
    }
    createdScriptElement.textContent = element.textContent;
    createdScriptElement.async = false;
    copyElementAttributes(createdScriptElement, element);
    return createdScriptElement;
  }
}
function copyElementAttributes(destinationElement, sourceElement) {
  for (const {
    name,
    value
  } of sourceElement.attributes) {
    destinationElement.setAttribute(name, value);
  }
}
function createDocumentFragment(html) {
  const template = document.createElement("template");
  template.innerHTML = html;
  return template.content;
}
function dispatch(eventName, {
  target,
  cancelable,
  detail
} = {}) {
  const event = new CustomEvent(eventName, {
    cancelable,
    bubbles: true,
    composed: true,
    detail
  });
  if (target && target.isConnected) {
    target.dispatchEvent(event);
  } else {
    document.documentElement.dispatchEvent(event);
  }
  return event;
}
function nextAnimationFrame() {
  return new Promise(resolve => requestAnimationFrame(() => resolve()));
}
function nextEventLoopTick() {
  return new Promise(resolve => setTimeout(() => resolve(), 0));
}
function nextMicrotask() {
  return Promise.resolve();
}
function parseHTMLDocument(html = "") {
  return new DOMParser().parseFromString(html, "text/html");
}
function unindent(strings, ...values) {
  const lines = interpolate(strings, values).replace(/^\n/, "").split("\n");
  const match = lines[0].match(/^\s+/);
  const indent = match ? match[0].length : 0;
  return lines.map(line => line.slice(indent)).join("\n");
}
function interpolate(strings, values) {
  return strings.reduce((result, string, i) => {
    const value = values[i] == undefined ? "" : values[i];
    return result + string + value;
  }, "");
}
function uuid() {
  return Array.from({
    length: 36
  }).map((_, i) => {
    if (i == 8 || i == 13 || i == 18 || i == 23) {
      return "-";
    } else if (i == 14) {
      return "4";
    } else if (i == 19) {
      return (Math.floor(Math.random() * 4) + 8).toString(16);
    } else {
      return Math.floor(Math.random() * 15).toString(16);
    }
  }).join("");
}
function getAttribute(attributeName, ...elements) {
  for (const value of elements.map(element => element === null || element === void 0 ? void 0 : element.getAttribute(attributeName))) {
    if (typeof value == "string") return value;
  }
  return null;
}
function hasAttribute(attributeName, ...elements) {
  return elements.some(element => element && element.hasAttribute(attributeName));
}
function markAsBusy(...elements) {
  for (const element of elements) {
    if (element.localName == "turbo-frame") {
      element.setAttribute("busy", "");
    }
    element.setAttribute("aria-busy", "true");
  }
}
function clearBusyState(...elements) {
  for (const element of elements) {
    if (element.localName == "turbo-frame") {
      element.removeAttribute("busy");
    }
    element.removeAttribute("aria-busy");
  }
}
function waitForLoad(element, timeoutInMilliseconds = 2000) {
  return new Promise(resolve => {
    const onComplete = () => {
      element.removeEventListener("error", onComplete);
      element.removeEventListener("load", onComplete);
      resolve();
    };
    element.addEventListener("load", onComplete, {
      once: true
    });
    element.addEventListener("error", onComplete, {
      once: true
    });
    setTimeout(resolve, timeoutInMilliseconds);
  });
}
function getHistoryMethodForAction(action) {
  switch (action) {
    case "replace":
      return history.replaceState;
    case "advance":
    case "restore":
      return history.pushState;
  }
}
function isAction(action) {
  return action == "advance" || action == "replace" || action == "restore";
}
function getVisitAction(...elements) {
  const action = getAttribute("data-turbo-action", ...elements);
  return isAction(action) ? action : null;
}
function getMetaElement(name) {
  return document.querySelector(`meta[name="${name}"]`);
}
function getMetaContent(name) {
  const element = getMetaElement(name);
  return element && element.content;
}
function setMetaContent(name, content) {
  let element = getMetaElement(name);
  if (!element) {
    element = document.createElement("meta");
    element.setAttribute("name", name);
    document.head.appendChild(element);
  }
  element.setAttribute("content", content);
  return element;
}
function findClosestRecursively(element, selector) {
  var _a;
  if (element instanceof Element) {
    return element.closest(selector) || findClosestRecursively(element.assignedSlot || ((_a = element.getRootNode()) === null || _a === void 0 ? void 0 : _a.host), selector);
  }
}
var FetchMethod;
(function (FetchMethod) {
  FetchMethod[FetchMethod["get"] = 0] = "get";
  FetchMethod[FetchMethod["post"] = 1] = "post";
  FetchMethod[FetchMethod["put"] = 2] = "put";
  FetchMethod[FetchMethod["patch"] = 3] = "patch";
  FetchMethod[FetchMethod["delete"] = 4] = "delete";
})(FetchMethod || (FetchMethod = {}));
function fetchMethodFromString(method) {
  switch (method.toLowerCase()) {
    case "get":
      return FetchMethod.get;
    case "post":
      return FetchMethod.post;
    case "put":
      return FetchMethod.put;
    case "patch":
      return FetchMethod.patch;
    case "delete":
      return FetchMethod.delete;
  }
}
class FetchRequest {
  constructor(delegate, method, location, body = new URLSearchParams(), target = null) {
    this.abortController = new AbortController();
    this.resolveRequestPromise = _value => {};
    this.delegate = delegate;
    this.method = method;
    this.headers = this.defaultHeaders;
    this.body = body;
    this.url = location;
    this.target = target;
  }
  get location() {
    return this.url;
  }
  get params() {
    return this.url.searchParams;
  }
  get entries() {
    return this.body ? Array.from(this.body.entries()) : [];
  }
  cancel() {
    this.abortController.abort();
  }
  async perform() {
    const {
      fetchOptions
    } = this;
    this.delegate.prepareRequest(this);
    await this.allowRequestToBeIntercepted(fetchOptions);
    try {
      this.delegate.requestStarted(this);
      const response = await fetch(this.url.href, fetchOptions);
      return await this.receive(response);
    } catch (error) {
      if (error.name !== "AbortError") {
        if (this.willDelegateErrorHandling(error)) {
          this.delegate.requestErrored(this, error);
        }
        throw error;
      }
    } finally {
      this.delegate.requestFinished(this);
    }
  }
  async receive(response) {
    const fetchResponse = new FetchResponse(response);
    const event = dispatch("turbo:before-fetch-response", {
      cancelable: true,
      detail: {
        fetchResponse
      },
      target: this.target
    });
    if (event.defaultPrevented) {
      this.delegate.requestPreventedHandlingResponse(this, fetchResponse);
    } else if (fetchResponse.succeeded) {
      this.delegate.requestSucceededWithResponse(this, fetchResponse);
    } else {
      this.delegate.requestFailedWithResponse(this, fetchResponse);
    }
    return fetchResponse;
  }
  get fetchOptions() {
    var _a;
    return {
      method: FetchMethod[this.method].toUpperCase(),
      credentials: "same-origin",
      headers: this.headers,
      redirect: "follow",
      body: this.isIdempotent ? null : this.body,
      signal: this.abortSignal,
      referrer: (_a = this.delegate.referrer) === null || _a === void 0 ? void 0 : _a.href
    };
  }
  get defaultHeaders() {
    return {
      Accept: "text/html, application/xhtml+xml"
    };
  }
  get isIdempotent() {
    return this.method == FetchMethod.get;
  }
  get abortSignal() {
    return this.abortController.signal;
  }
  acceptResponseType(mimeType) {
    this.headers["Accept"] = [mimeType, this.headers["Accept"]].join(", ");
  }
  async allowRequestToBeIntercepted(fetchOptions) {
    const requestInterception = new Promise(resolve => this.resolveRequestPromise = resolve);
    const event = dispatch("turbo:before-fetch-request", {
      cancelable: true,
      detail: {
        fetchOptions,
        url: this.url,
        resume: this.resolveRequestPromise
      },
      target: this.target
    });
    if (event.defaultPrevented) await requestInterception;
  }
  willDelegateErrorHandling(error) {
    const event = dispatch("turbo:fetch-request-error", {
      target: this.target,
      cancelable: true,
      detail: {
        request: this,
        error: error
      }
    });
    return !event.defaultPrevented;
  }
}
class AppearanceObserver {
  constructor(delegate, element) {
    this.started = false;
    this.intersect = entries => {
      const lastEntry = entries.slice(-1)[0];
      if (lastEntry === null || lastEntry === void 0 ? void 0 : lastEntry.isIntersecting) {
        this.delegate.elementAppearedInViewport(this.element);
      }
    };
    this.delegate = delegate;
    this.element = element;
    this.intersectionObserver = new IntersectionObserver(this.intersect);
  }
  start() {
    if (!this.started) {
      this.started = true;
      this.intersectionObserver.observe(this.element);
    }
  }
  stop() {
    if (this.started) {
      this.started = false;
      this.intersectionObserver.unobserve(this.element);
    }
  }
}
class StreamMessage {
  constructor(fragment) {
    this.fragment = importStreamElements(fragment);
  }
  static wrap(message) {
    if (typeof message == "string") {
      return new this(createDocumentFragment(message));
    } else {
      return message;
    }
  }
}
StreamMessage.contentType = "text/vnd.turbo-stream.html";
function importStreamElements(fragment) {
  for (const element of fragment.querySelectorAll("turbo-stream")) {
    const streamElement = document.importNode(element, true);
    for (const inertScriptElement of streamElement.templateElement.content.querySelectorAll("script")) {
      inertScriptElement.replaceWith(activateScriptElement(inertScriptElement));
    }
    element.replaceWith(streamElement);
  }
  return fragment;
}
var FormSubmissionState;
(function (FormSubmissionState) {
  FormSubmissionState[FormSubmissionState["initialized"] = 0] = "initialized";
  FormSubmissionState[FormSubmissionState["requesting"] = 1] = "requesting";
  FormSubmissionState[FormSubmissionState["waiting"] = 2] = "waiting";
  FormSubmissionState[FormSubmissionState["receiving"] = 3] = "receiving";
  FormSubmissionState[FormSubmissionState["stopping"] = 4] = "stopping";
  FormSubmissionState[FormSubmissionState["stopped"] = 5] = "stopped";
})(FormSubmissionState || (FormSubmissionState = {}));
var FormEnctype;
(function (FormEnctype) {
  FormEnctype["urlEncoded"] = "application/x-www-form-urlencoded";
  FormEnctype["multipart"] = "multipart/form-data";
  FormEnctype["plain"] = "text/plain";
})(FormEnctype || (FormEnctype = {}));
function formEnctypeFromString(encoding) {
  switch (encoding.toLowerCase()) {
    case FormEnctype.multipart:
      return FormEnctype.multipart;
    case FormEnctype.plain:
      return FormEnctype.plain;
    default:
      return FormEnctype.urlEncoded;
  }
}
class FormSubmission {
  constructor(delegate, formElement, submitter, mustRedirect = false) {
    this.state = FormSubmissionState.initialized;
    this.delegate = delegate;
    this.formElement = formElement;
    this.submitter = submitter;
    this.formData = buildFormData(formElement, submitter);
    this.location = expandURL(this.action);
    if (this.method == FetchMethod.get) {
      mergeFormDataEntries(this.location, [...this.body.entries()]);
    }
    this.fetchRequest = new FetchRequest(this, this.method, this.location, this.body, this.formElement);
    this.mustRedirect = mustRedirect;
  }
  static confirmMethod(message, _element, _submitter) {
    return Promise.resolve(confirm(message));
  }
  get method() {
    var _a;
    const method = ((_a = this.submitter) === null || _a === void 0 ? void 0 : _a.getAttribute("formmethod")) || this.formElement.getAttribute("method") || "";
    return fetchMethodFromString(method.toLowerCase()) || FetchMethod.get;
  }
  get action() {
    var _a;
    const formElementAction = typeof this.formElement.action === "string" ? this.formElement.action : null;
    if ((_a = this.submitter) === null || _a === void 0 ? void 0 : _a.hasAttribute("formaction")) {
      return this.submitter.getAttribute("formaction") || "";
    } else {
      return this.formElement.getAttribute("action") || formElementAction || "";
    }
  }
  get body() {
    if (this.enctype == FormEnctype.urlEncoded || this.method == FetchMethod.get) {
      return new URLSearchParams(this.stringFormData);
    } else {
      return this.formData;
    }
  }
  get enctype() {
    var _a;
    return formEnctypeFromString(((_a = this.submitter) === null || _a === void 0 ? void 0 : _a.getAttribute("formenctype")) || this.formElement.enctype);
  }
  get isIdempotent() {
    return this.fetchRequest.isIdempotent;
  }
  get stringFormData() {
    return [...this.formData].reduce((entries, [name, value]) => {
      return entries.concat(typeof value == "string" ? [[name, value]] : []);
    }, []);
  }
  async start() {
    const {
      initialized,
      requesting
    } = FormSubmissionState;
    const confirmationMessage = getAttribute("data-turbo-confirm", this.submitter, this.formElement);
    if (typeof confirmationMessage === "string") {
      const answer = await FormSubmission.confirmMethod(confirmationMessage, this.formElement, this.submitter);
      if (!answer) {
        return;
      }
    }
    if (this.state == initialized) {
      this.state = requesting;
      return this.fetchRequest.perform();
    }
  }
  stop() {
    const {
      stopping,
      stopped
    } = FormSubmissionState;
    if (this.state != stopping && this.state != stopped) {
      this.state = stopping;
      this.fetchRequest.cancel();
      return true;
    }
  }
  prepareRequest(request) {
    if (!request.isIdempotent) {
      const token = getCookieValue(getMetaContent("csrf-param")) || getMetaContent("csrf-token");
      if (token) {
        request.headers["X-CSRF-Token"] = token;
      }
    }
    if (this.requestAcceptsTurboStreamResponse(request)) {
      request.acceptResponseType(StreamMessage.contentType);
    }
  }
  requestStarted(_request) {
    var _a;
    this.state = FormSubmissionState.waiting;
    (_a = this.submitter) === null || _a === void 0 ? void 0 : _a.setAttribute("disabled", "");
    dispatch("turbo:submit-start", {
      target: this.formElement,
      detail: {
        formSubmission: this
      }
    });
    this.delegate.formSubmissionStarted(this);
  }
  requestPreventedHandlingResponse(request, response) {
    this.result = {
      success: response.succeeded,
      fetchResponse: response
    };
  }
  requestSucceededWithResponse(request, response) {
    if (response.clientError || response.serverError) {
      this.delegate.formSubmissionFailedWithResponse(this, response);
    } else if (this.requestMustRedirect(request) && responseSucceededWithoutRedirect(response)) {
      const error = new Error("Form responses must redirect to another location");
      this.delegate.formSubmissionErrored(this, error);
    } else {
      this.state = FormSubmissionState.receiving;
      this.result = {
        success: true,
        fetchResponse: response
      };
      this.delegate.formSubmissionSucceededWithResponse(this, response);
    }
  }
  requestFailedWithResponse(request, response) {
    this.result = {
      success: false,
      fetchResponse: response
    };
    this.delegate.formSubmissionFailedWithResponse(this, response);
  }
  requestErrored(request, error) {
    this.result = {
      success: false,
      error
    };
    this.delegate.formSubmissionErrored(this, error);
  }
  requestFinished(_request) {
    var _a;
    this.state = FormSubmissionState.stopped;
    (_a = this.submitter) === null || _a === void 0 ? void 0 : _a.removeAttribute("disabled");
    dispatch("turbo:submit-end", {
      target: this.formElement,
      detail: Object.assign({
        formSubmission: this
      }, this.result)
    });
    this.delegate.formSubmissionFinished(this);
  }
  requestMustRedirect(request) {
    return !request.isIdempotent && this.mustRedirect;
  }
  requestAcceptsTurboStreamResponse(request) {
    return !request.isIdempotent || hasAttribute("data-turbo-stream", this.submitter, this.formElement);
  }
}
function buildFormData(formElement, submitter) {
  const formData = new FormData(formElement);
  const name = submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute("name");
  const value = submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute("value");
  if (name) {
    formData.append(name, value || "");
  }
  return formData;
}
function getCookieValue(cookieName) {
  if (cookieName != null) {
    const cookies = document.cookie ? document.cookie.split("; ") : [];
    const cookie = cookies.find(cookie => cookie.startsWith(cookieName));
    if (cookie) {
      const value = cookie.split("=").slice(1).join("=");
      return value ? decodeURIComponent(value) : undefined;
    }
  }
}
function responseSucceededWithoutRedirect(response) {
  return response.statusCode == 200 && !response.redirected;
}
function mergeFormDataEntries(url, entries) {
  const searchParams = new URLSearchParams();
  for (const [name, value] of entries) {
    if (value instanceof File) continue;
    searchParams.append(name, value);
  }
  url.search = searchParams.toString();
  return url;
}
class Snapshot {
  constructor(element) {
    this.element = element;
  }
  get activeElement() {
    return this.element.ownerDocument.activeElement;
  }
  get children() {
    return [...this.element.children];
  }
  hasAnchor(anchor) {
    return this.getElementForAnchor(anchor) != null;
  }
  getElementForAnchor(anchor) {
    return anchor ? this.element.querySelector(`[id='${anchor}'], a[name='${anchor}']`) : null;
  }
  get isConnected() {
    return this.element.isConnected;
  }
  get firstAutofocusableElement() {
    const inertDisabledOrHidden = "[inert], :disabled, [hidden], details:not([open]), dialog:not([open])";
    for (const element of this.element.querySelectorAll("[autofocus]")) {
      if (element.closest(inertDisabledOrHidden) == null) return element;else continue;
    }
    return null;
  }
  get permanentElements() {
    return queryPermanentElementsAll(this.element);
  }
  getPermanentElementById(id) {
    return getPermanentElementById(this.element, id);
  }
  getPermanentElementMapForSnapshot(snapshot) {
    const permanentElementMap = {};
    for (const currentPermanentElement of this.permanentElements) {
      const {
        id
      } = currentPermanentElement;
      const newPermanentElement = snapshot.getPermanentElementById(id);
      if (newPermanentElement) {
        permanentElementMap[id] = [currentPermanentElement, newPermanentElement];
      }
    }
    return permanentElementMap;
  }
}
function getPermanentElementById(node, id) {
  return node.querySelector(`#${id}[data-turbo-permanent]`);
}
function queryPermanentElementsAll(node) {
  return node.querySelectorAll("[id][data-turbo-permanent]");
}
class FormSubmitObserver {
  constructor(delegate, eventTarget) {
    this.started = false;
    this.submitCaptured = () => {
      this.eventTarget.removeEventListener("submit", this.submitBubbled, false);
      this.eventTarget.addEventListener("submit", this.submitBubbled, false);
    };
    this.submitBubbled = event => {
      if (!event.defaultPrevented) {
        const form = event.target instanceof HTMLFormElement ? event.target : undefined;
        const submitter = event.submitter || undefined;
        if (form && submissionDoesNotDismissDialog(form, submitter) && submissionDoesNotTargetIFrame(form, submitter) && this.delegate.willSubmitForm(form, submitter)) {
          event.preventDefault();
          event.stopImmediatePropagation();
          this.delegate.formSubmitted(form, submitter);
        }
      }
    };
    this.delegate = delegate;
    this.eventTarget = eventTarget;
  }
  start() {
    if (!this.started) {
      this.eventTarget.addEventListener("submit", this.submitCaptured, true);
      this.started = true;
    }
  }
  stop() {
    if (this.started) {
      this.eventTarget.removeEventListener("submit", this.submitCaptured, true);
      this.started = false;
    }
  }
}
function submissionDoesNotDismissDialog(form, submitter) {
  const method = (submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute("formmethod")) || form.getAttribute("method");
  return method != "dialog";
}
function submissionDoesNotTargetIFrame(form, submitter) {
  if ((submitter === null || submitter === void 0 ? void 0 : submitter.hasAttribute("formtarget")) || form.hasAttribute("target")) {
    const target = (submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute("formtarget")) || form.target;
    for (const element of document.getElementsByName(target)) {
      if (element instanceof HTMLIFrameElement) return false;
    }
    return true;
  } else {
    return true;
  }
}
class View {
  constructor(delegate, element) {
    this.resolveRenderPromise = _value => {};
    this.resolveInterceptionPromise = _value => {};
    this.delegate = delegate;
    this.element = element;
  }
  scrollToAnchor(anchor) {
    const element = this.snapshot.getElementForAnchor(anchor);
    if (element) {
      this.scrollToElement(element);
      this.focusElement(element);
    } else {
      this.scrollToPosition({
        x: 0,
        y: 0
      });
    }
  }
  scrollToAnchorFromLocation(location) {
    this.scrollToAnchor(getAnchor(location));
  }
  scrollToElement(element) {
    element.scrollIntoView();
  }
  focusElement(element) {
    if (element instanceof HTMLElement) {
      if (element.hasAttribute("tabindex")) {
        element.focus();
      } else {
        element.setAttribute("tabindex", "-1");
        element.focus();
        element.removeAttribute("tabindex");
      }
    }
  }
  scrollToPosition({
    x,
    y
  }) {
    this.scrollRoot.scrollTo(x, y);
  }
  scrollToTop() {
    this.scrollToPosition({
      x: 0,
      y: 0
    });
  }
  get scrollRoot() {
    return window;
  }
  async render(renderer) {
    const {
      isPreview,
      shouldRender,
      newSnapshot: snapshot
    } = renderer;
    if (shouldRender) {
      try {
        this.renderPromise = new Promise(resolve => this.resolveRenderPromise = resolve);
        this.renderer = renderer;
        await this.prepareToRenderSnapshot(renderer);
        const renderInterception = new Promise(resolve => this.resolveInterceptionPromise = resolve);
        const options = {
          resume: this.resolveInterceptionPromise,
          render: this.renderer.renderElement
        };
        const immediateRender = this.delegate.allowsImmediateRender(snapshot, options);
        if (!immediateRender) await renderInterception;
        await this.renderSnapshot(renderer);
        this.delegate.viewRenderedSnapshot(snapshot, isPreview);
        this.delegate.preloadOnLoadLinksForView(this.element);
        this.finishRenderingSnapshot(renderer);
      } finally {
        delete this.renderer;
        this.resolveRenderPromise(undefined);
        delete this.renderPromise;
      }
    } else {
      this.invalidate(renderer.reloadReason);
    }
  }
  invalidate(reason) {
    this.delegate.viewInvalidated(reason);
  }
  async prepareToRenderSnapshot(renderer) {
    this.markAsPreview(renderer.isPreview);
    await renderer.prepareToRender();
  }
  markAsPreview(isPreview) {
    if (isPreview) {
      this.element.setAttribute("data-turbo-preview", "");
    } else {
      this.element.removeAttribute("data-turbo-preview");
    }
  }
  async renderSnapshot(renderer) {
    await renderer.render();
  }
  finishRenderingSnapshot(renderer) {
    renderer.finishRendering();
  }
}
class FrameView extends View {
  invalidate() {
    this.element.innerHTML = "";
  }
  get snapshot() {
    return new Snapshot(this.element);
  }
}
class LinkInterceptor {
  constructor(delegate, element) {
    this.clickBubbled = event => {
      if (this.respondsToEventTarget(event.target)) {
        this.clickEvent = event;
      } else {
        delete this.clickEvent;
      }
    };
    this.linkClicked = event => {
      if (this.clickEvent && this.respondsToEventTarget(event.target) && event.target instanceof Element) {
        if (this.delegate.shouldInterceptLinkClick(event.target, event.detail.url, event.detail.originalEvent)) {
          this.clickEvent.preventDefault();
          event.preventDefault();
          this.delegate.linkClickIntercepted(event.target, event.detail.url, event.detail.originalEvent);
        }
      }
      delete this.clickEvent;
    };
    this.willVisit = _event => {
      delete this.clickEvent;
    };
    this.delegate = delegate;
    this.element = element;
  }
  start() {
    this.element.addEventListener("click", this.clickBubbled);
    document.addEventListener("turbo:click", this.linkClicked);
    document.addEventListener("turbo:before-visit", this.willVisit);
  }
  stop() {
    this.element.removeEventListener("click", this.clickBubbled);
    document.removeEventListener("turbo:click", this.linkClicked);
    document.removeEventListener("turbo:before-visit", this.willVisit);
  }
  respondsToEventTarget(target) {
    const element = target instanceof Element ? target : target instanceof Node ? target.parentElement : null;
    return element && element.closest("turbo-frame, html") == this.element;
  }
}
class LinkClickObserver {
  constructor(delegate, eventTarget) {
    this.started = false;
    this.clickCaptured = () => {
      this.eventTarget.removeEventListener("click", this.clickBubbled, false);
      this.eventTarget.addEventListener("click", this.clickBubbled, false);
    };
    this.clickBubbled = event => {
      if (event instanceof MouseEvent && this.clickEventIsSignificant(event)) {
        const target = event.composedPath && event.composedPath()[0] || event.target;
        const link = this.findLinkFromClickTarget(target);
        if (link && doesNotTargetIFrame(link)) {
          const location = this.getLocationForLink(link);
          if (this.delegate.willFollowLinkToLocation(link, location, event)) {
            event.preventDefault();
            this.delegate.followedLinkToLocation(link, location);
          }
        }
      }
    };
    this.delegate = delegate;
    this.eventTarget = eventTarget;
  }
  start() {
    if (!this.started) {
      this.eventTarget.addEventListener("click", this.clickCaptured, true);
      this.started = true;
    }
  }
  stop() {
    if (this.started) {
      this.eventTarget.removeEventListener("click", this.clickCaptured, true);
      this.started = false;
    }
  }
  clickEventIsSignificant(event) {
    return !(event.target && event.target.isContentEditable || event.defaultPrevented || event.which > 1 || event.altKey || event.ctrlKey || event.metaKey || event.shiftKey);
  }
  findLinkFromClickTarget(target) {
    return findClosestRecursively(target, "a[href]:not([target^=_]):not([download])");
  }
  getLocationForLink(link) {
    return expandURL(link.getAttribute("href") || "");
  }
}
function doesNotTargetIFrame(anchor) {
  if (anchor.hasAttribute("target")) {
    for (const element of document.getElementsByName(anchor.target)) {
      if (element instanceof HTMLIFrameElement) return false;
    }
    return true;
  } else {
    return true;
  }
}
class FormLinkClickObserver {
  constructor(delegate, element) {
    this.delegate = delegate;
    this.linkInterceptor = new LinkClickObserver(this, element);
  }
  start() {
    this.linkInterceptor.start();
  }
  stop() {
    this.linkInterceptor.stop();
  }
  willFollowLinkToLocation(link, location, originalEvent) {
    return this.delegate.willSubmitFormLinkToLocation(link, location, originalEvent) && link.hasAttribute("data-turbo-method");
  }
  followedLinkToLocation(link, location) {
    const form = document.createElement("form");
    const type = "hidden";
    for (const [name, value] of location.searchParams) {
      form.append(Object.assign(document.createElement("input"), {
        type,
        name,
        value
      }));
    }
    const action = Object.assign(location, {
      search: ""
    });
    form.setAttribute("data-turbo", "true");
    form.setAttribute("action", action.href);
    form.setAttribute("hidden", "");
    const method = link.getAttribute("data-turbo-method");
    if (method) form.setAttribute("method", method);
    const turboFrame = link.getAttribute("data-turbo-frame");
    if (turboFrame) form.setAttribute("data-turbo-frame", turboFrame);
    const turboAction = getVisitAction(link);
    if (turboAction) form.setAttribute("data-turbo-action", turboAction);
    const turboConfirm = link.getAttribute("data-turbo-confirm");
    if (turboConfirm) form.setAttribute("data-turbo-confirm", turboConfirm);
    const turboStream = link.hasAttribute("data-turbo-stream");
    if (turboStream) form.setAttribute("data-turbo-stream", "");
    this.delegate.submittedFormLinkToLocation(link, location, form);
    document.body.appendChild(form);
    form.addEventListener("turbo:submit-end", () => form.remove(), {
      once: true
    });
    requestAnimationFrame(() => form.requestSubmit());
  }
}
class Bardo {
  constructor(delegate, permanentElementMap) {
    this.delegate = delegate;
    this.permanentElementMap = permanentElementMap;
  }
  static async preservingPermanentElements(delegate, permanentElementMap, callback) {
    const bardo = new this(delegate, permanentElementMap);
    bardo.enter();
    await callback();
    bardo.leave();
  }
  enter() {
    for (const id in this.permanentElementMap) {
      const [currentPermanentElement, newPermanentElement] = this.permanentElementMap[id];
      this.delegate.enteringBardo(currentPermanentElement, newPermanentElement);
      this.replaceNewPermanentElementWithPlaceholder(newPermanentElement);
    }
  }
  leave() {
    for (const id in this.permanentElementMap) {
      const [currentPermanentElement] = this.permanentElementMap[id];
      this.replaceCurrentPermanentElementWithClone(currentPermanentElement);
      this.replacePlaceholderWithPermanentElement(currentPermanentElement);
      this.delegate.leavingBardo(currentPermanentElement);
    }
  }
  replaceNewPermanentElementWithPlaceholder(permanentElement) {
    const placeholder = createPlaceholderForPermanentElement(permanentElement);
    permanentElement.replaceWith(placeholder);
  }
  replaceCurrentPermanentElementWithClone(permanentElement) {
    const clone = permanentElement.cloneNode(true);
    permanentElement.replaceWith(clone);
  }
  replacePlaceholderWithPermanentElement(permanentElement) {
    const placeholder = this.getPlaceholderById(permanentElement.id);
    placeholder === null || placeholder === void 0 ? void 0 : placeholder.replaceWith(permanentElement);
  }
  getPlaceholderById(id) {
    return this.placeholders.find(element => element.content == id);
  }
  get placeholders() {
    return [...document.querySelectorAll("meta[name=turbo-permanent-placeholder][content]")];
  }
}
function createPlaceholderForPermanentElement(permanentElement) {
  const element = document.createElement("meta");
  element.setAttribute("name", "turbo-permanent-placeholder");
  element.setAttribute("content", permanentElement.id);
  return element;
}
class Renderer {
  constructor(currentSnapshot, newSnapshot, renderElement, isPreview, willRender = true) {
    this.activeElement = null;
    this.currentSnapshot = currentSnapshot;
    this.newSnapshot = newSnapshot;
    this.isPreview = isPreview;
    this.willRender = willRender;
    this.renderElement = renderElement;
    this.promise = new Promise((resolve, reject) => this.resolvingFunctions = {
      resolve,
      reject
    });
  }
  get shouldRender() {
    return true;
  }
  get reloadReason() {
    return;
  }
  prepareToRender() {
    return;
  }
  finishRendering() {
    if (this.resolvingFunctions) {
      this.resolvingFunctions.resolve();
      delete this.resolvingFunctions;
    }
  }
  async preservingPermanentElements(callback) {
    await Bardo.preservingPermanentElements(this, this.permanentElementMap, callback);
  }
  focusFirstAutofocusableElement() {
    const element = this.connectedSnapshot.firstAutofocusableElement;
    if (elementIsFocusable(element)) {
      element.focus();
    }
  }
  enteringBardo(currentPermanentElement) {
    if (this.activeElement) return;
    if (currentPermanentElement.contains(this.currentSnapshot.activeElement)) {
      this.activeElement = this.currentSnapshot.activeElement;
    }
  }
  leavingBardo(currentPermanentElement) {
    if (currentPermanentElement.contains(this.activeElement) && this.activeElement instanceof HTMLElement) {
      this.activeElement.focus();
      this.activeElement = null;
    }
  }
  get connectedSnapshot() {
    return this.newSnapshot.isConnected ? this.newSnapshot : this.currentSnapshot;
  }
  get currentElement() {
    return this.currentSnapshot.element;
  }
  get newElement() {
    return this.newSnapshot.element;
  }
  get permanentElementMap() {
    return this.currentSnapshot.getPermanentElementMapForSnapshot(this.newSnapshot);
  }
}
function elementIsFocusable(element) {
  return element && typeof element.focus == "function";
}
class FrameRenderer extends Renderer {
  constructor(delegate, currentSnapshot, newSnapshot, renderElement, isPreview, willRender = true) {
    super(currentSnapshot, newSnapshot, renderElement, isPreview, willRender);
    this.delegate = delegate;
  }
  static renderElement(currentElement, newElement) {
    var _a;
    const destinationRange = document.createRange();
    destinationRange.selectNodeContents(currentElement);
    destinationRange.deleteContents();
    const frameElement = newElement;
    const sourceRange = (_a = frameElement.ownerDocument) === null || _a === void 0 ? void 0 : _a.createRange();
    if (sourceRange) {
      sourceRange.selectNodeContents(frameElement);
      currentElement.appendChild(sourceRange.extractContents());
    }
  }
  get shouldRender() {
    return true;
  }
  async render() {
    await nextAnimationFrame();
    this.preservingPermanentElements(() => {
      this.loadFrameElement();
    });
    this.scrollFrameIntoView();
    await nextAnimationFrame();
    this.focusFirstAutofocusableElement();
    await nextAnimationFrame();
    this.activateScriptElements();
  }
  loadFrameElement() {
    this.delegate.willRenderFrame(this.currentElement, this.newElement);
    this.renderElement(this.currentElement, this.newElement);
  }
  scrollFrameIntoView() {
    if (this.currentElement.autoscroll || this.newElement.autoscroll) {
      const element = this.currentElement.firstElementChild;
      const block = readScrollLogicalPosition(this.currentElement.getAttribute("data-autoscroll-block"), "end");
      const behavior = readScrollBehavior(this.currentElement.getAttribute("data-autoscroll-behavior"), "auto");
      if (element) {
        element.scrollIntoView({
          block,
          behavior
        });
        return true;
      }
    }
    return false;
  }
  activateScriptElements() {
    for (const inertScriptElement of this.newScriptElements) {
      const activatedScriptElement = activateScriptElement(inertScriptElement);
      inertScriptElement.replaceWith(activatedScriptElement);
    }
  }
  get newScriptElements() {
    return this.currentElement.querySelectorAll("script");
  }
}
function readScrollLogicalPosition(value, defaultValue) {
  if (value == "end" || value == "start" || value == "center" || value == "nearest") {
    return value;
  } else {
    return defaultValue;
  }
}
function readScrollBehavior(value, defaultValue) {
  if (value == "auto" || value == "smooth") {
    return value;
  } else {
    return defaultValue;
  }
}
class ProgressBar {
  constructor() {
    this.hiding = false;
    this.value = 0;
    this.visible = false;
    this.trickle = () => {
      this.setValue(this.value + Math.random() / 100);
    };
    this.stylesheetElement = this.createStylesheetElement();
    this.progressElement = this.createProgressElement();
    this.installStylesheetElement();
    this.setValue(0);
  }
  static get defaultCSS() {
    return unindent`
      .turbo-progress-bar {
        position: fixed;
        display: block;
        top: 0;
        left: 0;
        height: 3px;
        background: #0076ff;
        z-index: 2147483647;
        transition:
          width ${ProgressBar.animationDuration}ms ease-out,
          opacity ${ProgressBar.animationDuration / 2}ms ${ProgressBar.animationDuration / 2}ms ease-in;
        transform: translate3d(0, 0, 0);
      }
    `;
  }
  show() {
    if (!this.visible) {
      this.visible = true;
      this.installProgressElement();
      this.startTrickling();
    }
  }
  hide() {
    if (this.visible && !this.hiding) {
      this.hiding = true;
      this.fadeProgressElement(() => {
        this.uninstallProgressElement();
        this.stopTrickling();
        this.visible = false;
        this.hiding = false;
      });
    }
  }
  setValue(value) {
    this.value = value;
    this.refresh();
  }
  installStylesheetElement() {
    document.head.insertBefore(this.stylesheetElement, document.head.firstChild);
  }
  installProgressElement() {
    this.progressElement.style.width = "0";
    this.progressElement.style.opacity = "1";
    document.documentElement.insertBefore(this.progressElement, document.body);
    this.refresh();
  }
  fadeProgressElement(callback) {
    this.progressElement.style.opacity = "0";
    setTimeout(callback, ProgressBar.animationDuration * 1.5);
  }
  uninstallProgressElement() {
    if (this.progressElement.parentNode) {
      document.documentElement.removeChild(this.progressElement);
    }
  }
  startTrickling() {
    if (!this.trickleInterval) {
      this.trickleInterval = window.setInterval(this.trickle, ProgressBar.animationDuration);
    }
  }
  stopTrickling() {
    window.clearInterval(this.trickleInterval);
    delete this.trickleInterval;
  }
  refresh() {
    requestAnimationFrame(() => {
      this.progressElement.style.width = `${10 + this.value * 90}%`;
    });
  }
  createStylesheetElement() {
    const element = document.createElement("style");
    element.type = "text/css";
    element.textContent = ProgressBar.defaultCSS;
    if (this.cspNonce) {
      element.nonce = this.cspNonce;
    }
    return element;
  }
  createProgressElement() {
    const element = document.createElement("div");
    element.className = "turbo-progress-bar";
    return element;
  }
  get cspNonce() {
    return getMetaContent("csp-nonce");
  }
}
ProgressBar.animationDuration = 300;
class HeadSnapshot extends Snapshot {
  constructor() {
    super(...arguments);
    this.detailsByOuterHTML = this.children.filter(element => !elementIsNoscript(element)).map(element => elementWithoutNonce(element)).reduce((result, element) => {
      const {
        outerHTML
      } = element;
      const details = outerHTML in result ? result[outerHTML] : {
        type: elementType(element),
        tracked: elementIsTracked(element),
        elements: []
      };
      return Object.assign(Object.assign({}, result), {
        [outerHTML]: Object.assign(Object.assign({}, details), {
          elements: [...details.elements, element]
        })
      });
    }, {});
  }
  get trackedElementSignature() {
    return Object.keys(this.detailsByOuterHTML).filter(outerHTML => this.detailsByOuterHTML[outerHTML].tracked).join("");
  }
  getScriptElementsNotInSnapshot(snapshot) {
    return this.getElementsMatchingTypeNotInSnapshot("script", snapshot);
  }
  getStylesheetElementsNotInSnapshot(snapshot) {
    return this.getElementsMatchingTypeNotInSnapshot("stylesheet", snapshot);
  }
  getElementsMatchingTypeNotInSnapshot(matchedType, snapshot) {
    return Object.keys(this.detailsByOuterHTML).filter(outerHTML => !(outerHTML in snapshot.detailsByOuterHTML)).map(outerHTML => this.detailsByOuterHTML[outerHTML]).filter(({
      type
    }) => type == matchedType).map(({
      elements: [element]
    }) => element);
  }
  get provisionalElements() {
    return Object.keys(this.detailsByOuterHTML).reduce((result, outerHTML) => {
      const {
        type,
        tracked,
        elements
      } = this.detailsByOuterHTML[outerHTML];
      if (type == null && !tracked) {
        return [...result, ...elements];
      } else if (elements.length > 1) {
        return [...result, ...elements.slice(1)];
      } else {
        return result;
      }
    }, []);
  }
  getMetaValue(name) {
    const element = this.findMetaElementByName(name);
    return element ? element.getAttribute("content") : null;
  }
  findMetaElementByName(name) {
    return Object.keys(this.detailsByOuterHTML).reduce((result, outerHTML) => {
      const {
        elements: [element]
      } = this.detailsByOuterHTML[outerHTML];
      return elementIsMetaElementWithName(element, name) ? element : result;
    }, undefined);
  }
}
function elementType(element) {
  if (elementIsScript(element)) {
    return "script";
  } else if (elementIsStylesheet(element)) {
    return "stylesheet";
  }
}
function elementIsTracked(element) {
  return element.getAttribute("data-turbo-track") == "reload";
}
function elementIsScript(element) {
  const tagName = element.localName;
  return tagName == "script";
}
function elementIsNoscript(element) {
  const tagName = element.localName;
  return tagName == "noscript";
}
function elementIsStylesheet(element) {
  const tagName = element.localName;
  return tagName == "style" || tagName == "link" && element.getAttribute("rel") == "stylesheet";
}
function elementIsMetaElementWithName(element, name) {
  const tagName = element.localName;
  return tagName == "meta" && element.getAttribute("name") == name;
}
function elementWithoutNonce(element) {
  if (element.hasAttribute("nonce")) {
    element.setAttribute("nonce", "");
  }
  return element;
}
class PageSnapshot extends Snapshot {
  constructor(element, headSnapshot) {
    super(element);
    this.headSnapshot = headSnapshot;
  }
  static fromHTMLString(html = "") {
    return this.fromDocument(parseHTMLDocument(html));
  }
  static fromElement(element) {
    return this.fromDocument(element.ownerDocument);
  }
  static fromDocument({
    head,
    body
  }) {
    return new this(body, new HeadSnapshot(head));
  }
  clone() {
    const clonedElement = this.element.cloneNode(true);
    const selectElements = this.element.querySelectorAll("select");
    const clonedSelectElements = clonedElement.querySelectorAll("select");
    for (const [index, source] of selectElements.entries()) {
      const clone = clonedSelectElements[index];
      for (const option of clone.selectedOptions) option.selected = false;
      for (const option of source.selectedOptions) clone.options[option.index].selected = true;
    }
    for (const clonedPasswordInput of clonedElement.querySelectorAll('input[type="password"]')) {
      clonedPasswordInput.value = "";
    }
    return new PageSnapshot(clonedElement, this.headSnapshot);
  }
  get headElement() {
    return this.headSnapshot.element;
  }
  get rootLocation() {
    var _a;
    const root = (_a = this.getSetting("root")) !== null && _a !== void 0 ? _a : "/";
    return expandURL(root);
  }
  get cacheControlValue() {
    return this.getSetting("cache-control");
  }
  get isPreviewable() {
    return this.cacheControlValue != "no-preview";
  }
  get isCacheable() {
    return this.cacheControlValue != "no-cache";
  }
  get isVisitable() {
    return this.getSetting("visit-control") != "reload";
  }
  getSetting(name) {
    return this.headSnapshot.getMetaValue(`turbo-${name}`);
  }
}
var TimingMetric;
(function (TimingMetric) {
  TimingMetric["visitStart"] = "visitStart";
  TimingMetric["requestStart"] = "requestStart";
  TimingMetric["requestEnd"] = "requestEnd";
  TimingMetric["visitEnd"] = "visitEnd";
})(TimingMetric || (TimingMetric = {}));
var VisitState;
(function (VisitState) {
  VisitState["initialized"] = "initialized";
  VisitState["started"] = "started";
  VisitState["canceled"] = "canceled";
  VisitState["failed"] = "failed";
  VisitState["completed"] = "completed";
})(VisitState || (VisitState = {}));
const defaultOptions = {
  action: "advance",
  historyChanged: false,
  visitCachedSnapshot: () => {},
  willRender: true,
  updateHistory: true,
  shouldCacheSnapshot: true,
  acceptsStreamResponse: false
};
var SystemStatusCode;
(function (SystemStatusCode) {
  SystemStatusCode[SystemStatusCode["networkFailure"] = 0] = "networkFailure";
  SystemStatusCode[SystemStatusCode["timeoutFailure"] = -1] = "timeoutFailure";
  SystemStatusCode[SystemStatusCode["contentTypeMismatch"] = -2] = "contentTypeMismatch";
})(SystemStatusCode || (SystemStatusCode = {}));
class Visit {
  constructor(delegate, location, restorationIdentifier, options = {}) {
    this.identifier = uuid();
    this.timingMetrics = {};
    this.followedRedirect = false;
    this.historyChanged = false;
    this.scrolled = false;
    this.shouldCacheSnapshot = true;
    this.acceptsStreamResponse = false;
    this.snapshotCached = false;
    this.state = VisitState.initialized;
    this.delegate = delegate;
    this.location = location;
    this.restorationIdentifier = restorationIdentifier || uuid();
    const {
      action,
      historyChanged,
      referrer,
      snapshot,
      snapshotHTML,
      response,
      visitCachedSnapshot,
      willRender,
      updateHistory,
      shouldCacheSnapshot,
      acceptsStreamResponse
    } = Object.assign(Object.assign({}, defaultOptions), options);
    this.action = action;
    this.historyChanged = historyChanged;
    this.referrer = referrer;
    this.snapshot = snapshot;
    this.snapshotHTML = snapshotHTML;
    this.response = response;
    this.isSamePage = this.delegate.locationWithActionIsSamePage(this.location, this.action);
    this.visitCachedSnapshot = visitCachedSnapshot;
    this.willRender = willRender;
    this.updateHistory = updateHistory;
    this.scrolled = !willRender;
    this.shouldCacheSnapshot = shouldCacheSnapshot;
    this.acceptsStreamResponse = acceptsStreamResponse;
  }
  get adapter() {
    return this.delegate.adapter;
  }
  get view() {
    return this.delegate.view;
  }
  get history() {
    return this.delegate.history;
  }
  get restorationData() {
    return this.history.getRestorationDataForIdentifier(this.restorationIdentifier);
  }
  get silent() {
    return this.isSamePage;
  }
  start() {
    if (this.state == VisitState.initialized) {
      this.recordTimingMetric(TimingMetric.visitStart);
      this.state = VisitState.started;
      this.adapter.visitStarted(this);
      this.delegate.visitStarted(this);
    }
  }
  cancel() {
    if (this.state == VisitState.started) {
      if (this.request) {
        this.request.cancel();
      }
      this.cancelRender();
      this.state = VisitState.canceled;
    }
  }
  complete() {
    if (this.state == VisitState.started) {
      this.recordTimingMetric(TimingMetric.visitEnd);
      this.state = VisitState.completed;
      this.followRedirect();
      if (!this.followedRedirect) {
        this.adapter.visitCompleted(this);
        this.delegate.visitCompleted(this);
      }
    }
  }
  fail() {
    if (this.state == VisitState.started) {
      this.state = VisitState.failed;
      this.adapter.visitFailed(this);
    }
  }
  changeHistory() {
    var _a;
    if (!this.historyChanged && this.updateHistory) {
      const actionForHistory = this.location.href === ((_a = this.referrer) === null || _a === void 0 ? void 0 : _a.href) ? "replace" : this.action;
      const method = getHistoryMethodForAction(actionForHistory);
      this.history.update(method, this.location, this.restorationIdentifier);
      this.historyChanged = true;
    }
  }
  issueRequest() {
    if (this.hasPreloadedResponse()) {
      this.simulateRequest();
    } else if (this.shouldIssueRequest() && !this.request) {
      this.request = new FetchRequest(this, FetchMethod.get, this.location);
      this.request.perform();
    }
  }
  simulateRequest() {
    if (this.response) {
      this.startRequest();
      this.recordResponse();
      this.finishRequest();
    }
  }
  startRequest() {
    this.recordTimingMetric(TimingMetric.requestStart);
    this.adapter.visitRequestStarted(this);
  }
  recordResponse(response = this.response) {
    this.response = response;
    if (response) {
      const {
        statusCode
      } = response;
      if (isSuccessful(statusCode)) {
        this.adapter.visitRequestCompleted(this);
      } else {
        this.adapter.visitRequestFailedWithStatusCode(this, statusCode);
      }
    }
  }
  finishRequest() {
    this.recordTimingMetric(TimingMetric.requestEnd);
    this.adapter.visitRequestFinished(this);
  }
  loadResponse() {
    if (this.response) {
      const {
        statusCode,
        responseHTML
      } = this.response;
      this.render(async () => {
        if (this.shouldCacheSnapshot) this.cacheSnapshot();
        if (this.view.renderPromise) await this.view.renderPromise;
        if (isSuccessful(statusCode) && responseHTML != null) {
          await this.view.renderPage(PageSnapshot.fromHTMLString(responseHTML), false, this.willRender, this);
          this.performScroll();
          this.adapter.visitRendered(this);
          this.complete();
        } else {
          await this.view.renderError(PageSnapshot.fromHTMLString(responseHTML), this);
          this.adapter.visitRendered(this);
          this.fail();
        }
      });
    }
  }
  getCachedSnapshot() {
    const snapshot = this.view.getCachedSnapshotForLocation(this.location) || this.getPreloadedSnapshot();
    if (snapshot && (!getAnchor(this.location) || snapshot.hasAnchor(getAnchor(this.location)))) {
      if (this.action == "restore" || snapshot.isPreviewable) {
        return snapshot;
      }
    }
  }
  getPreloadedSnapshot() {
    if (this.snapshotHTML) {
      return PageSnapshot.fromHTMLString(this.snapshotHTML);
    }
  }
  hasCachedSnapshot() {
    return this.getCachedSnapshot() != null;
  }
  loadCachedSnapshot() {
    const snapshot = this.getCachedSnapshot();
    if (snapshot) {
      const isPreview = this.shouldIssueRequest();
      this.render(async () => {
        this.cacheSnapshot();
        if (this.isSamePage) {
          this.adapter.visitRendered(this);
        } else {
          if (this.view.renderPromise) await this.view.renderPromise;
          await this.view.renderPage(snapshot, isPreview, this.willRender, this);
          this.performScroll();
          this.adapter.visitRendered(this);
          if (!isPreview) {
            this.complete();
          }
        }
      });
    }
  }
  followRedirect() {
    var _a;
    if (this.redirectedToLocation && !this.followedRedirect && ((_a = this.response) === null || _a === void 0 ? void 0 : _a.redirected)) {
      this.adapter.visitProposedToLocation(this.redirectedToLocation, {
        action: "replace",
        response: this.response,
        shouldCacheSnapshot: false,
        willRender: false
      });
      this.followedRedirect = true;
    }
  }
  goToSamePageAnchor() {
    if (this.isSamePage) {
      this.render(async () => {
        this.cacheSnapshot();
        this.performScroll();
        this.changeHistory();
        this.adapter.visitRendered(this);
      });
    }
  }
  prepareRequest(request) {
    if (this.acceptsStreamResponse) {
      request.acceptResponseType(StreamMessage.contentType);
    }
  }
  requestStarted() {
    this.startRequest();
  }
  requestPreventedHandlingResponse(_request, _response) {}
  async requestSucceededWithResponse(request, response) {
    const responseHTML = await response.responseHTML;
    const {
      redirected,
      statusCode
    } = response;
    if (responseHTML == undefined) {
      this.recordResponse({
        statusCode: SystemStatusCode.contentTypeMismatch,
        redirected
      });
    } else {
      this.redirectedToLocation = response.redirected ? response.location : undefined;
      this.recordResponse({
        statusCode: statusCode,
        responseHTML,
        redirected
      });
    }
  }
  async requestFailedWithResponse(request, response) {
    const responseHTML = await response.responseHTML;
    const {
      redirected,
      statusCode
    } = response;
    if (responseHTML == undefined) {
      this.recordResponse({
        statusCode: SystemStatusCode.contentTypeMismatch,
        redirected
      });
    } else {
      this.recordResponse({
        statusCode: statusCode,
        responseHTML,
        redirected
      });
    }
  }
  requestErrored(_request, _error) {
    this.recordResponse({
      statusCode: SystemStatusCode.networkFailure,
      redirected: false
    });
  }
  requestFinished() {
    this.finishRequest();
  }
  performScroll() {
    if (!this.scrolled && !this.view.forceReloaded) {
      if (this.action == "restore") {
        this.scrollToRestoredPosition() || this.scrollToAnchor() || this.view.scrollToTop();
      } else {
        this.scrollToAnchor() || this.view.scrollToTop();
      }
      if (this.isSamePage) {
        this.delegate.visitScrolledToSamePageLocation(this.view.lastRenderedLocation, this.location);
      }
      this.scrolled = true;
    }
  }
  scrollToRestoredPosition() {
    const {
      scrollPosition
    } = this.restorationData;
    if (scrollPosition) {
      this.view.scrollToPosition(scrollPosition);
      return true;
    }
  }
  scrollToAnchor() {
    const anchor = getAnchor(this.location);
    if (anchor != null) {
      this.view.scrollToAnchor(anchor);
      return true;
    }
  }
  recordTimingMetric(metric) {
    this.timingMetrics[metric] = new Date().getTime();
  }
  getTimingMetrics() {
    return Object.assign({}, this.timingMetrics);
  }
  getHistoryMethodForAction(action) {
    switch (action) {
      case "replace":
        return history.replaceState;
      case "advance":
      case "restore":
        return history.pushState;
    }
  }
  hasPreloadedResponse() {
    return typeof this.response == "object";
  }
  shouldIssueRequest() {
    if (this.isSamePage) {
      return false;
    } else if (this.action == "restore") {
      return !this.hasCachedSnapshot();
    } else {
      return this.willRender;
    }
  }
  cacheSnapshot() {
    if (!this.snapshotCached) {
      this.view.cacheSnapshot(this.snapshot).then(snapshot => snapshot && this.visitCachedSnapshot(snapshot));
      this.snapshotCached = true;
    }
  }
  async render(callback) {
    this.cancelRender();
    await new Promise(resolve => {
      this.frame = requestAnimationFrame(() => resolve());
    });
    await callback();
    delete this.frame;
  }
  cancelRender() {
    if (this.frame) {
      cancelAnimationFrame(this.frame);
      delete this.frame;
    }
  }
}
function isSuccessful(statusCode) {
  return statusCode >= 200 && statusCode < 300;
}
class BrowserAdapter {
  constructor(session) {
    this.progressBar = new ProgressBar();
    this.showProgressBar = () => {
      this.progressBar.show();
    };
    this.session = session;
  }
  visitProposedToLocation(location, options) {
    this.navigator.startVisit(location, (options === null || options === void 0 ? void 0 : options.restorationIdentifier) || uuid(), options);
  }
  visitStarted(visit) {
    this.location = visit.location;
    visit.loadCachedSnapshot();
    visit.issueRequest();
    visit.goToSamePageAnchor();
  }
  visitRequestStarted(visit) {
    this.progressBar.setValue(0);
    if (visit.hasCachedSnapshot() || visit.action != "restore") {
      this.showVisitProgressBarAfterDelay();
    } else {
      this.showProgressBar();
    }
  }
  visitRequestCompleted(visit) {
    visit.loadResponse();
  }
  visitRequestFailedWithStatusCode(visit, statusCode) {
    switch (statusCode) {
      case SystemStatusCode.networkFailure:
      case SystemStatusCode.timeoutFailure:
      case SystemStatusCode.contentTypeMismatch:
        return this.reload({
          reason: "request_failed",
          context: {
            statusCode
          }
        });
      default:
        return visit.loadResponse();
    }
  }
  visitRequestFinished(_visit) {
    this.progressBar.setValue(1);
    this.hideVisitProgressBar();
  }
  visitCompleted(_visit) {}
  pageInvalidated(reason) {
    this.reload(reason);
  }
  visitFailed(_visit) {}
  visitRendered(_visit) {}
  formSubmissionStarted(_formSubmission) {
    this.progressBar.setValue(0);
    this.showFormProgressBarAfterDelay();
  }
  formSubmissionFinished(_formSubmission) {
    this.progressBar.setValue(1);
    this.hideFormProgressBar();
  }
  showVisitProgressBarAfterDelay() {
    this.visitProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay);
  }
  hideVisitProgressBar() {
    this.progressBar.hide();
    if (this.visitProgressBarTimeout != null) {
      window.clearTimeout(this.visitProgressBarTimeout);
      delete this.visitProgressBarTimeout;
    }
  }
  showFormProgressBarAfterDelay() {
    if (this.formProgressBarTimeout == null) {
      this.formProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay);
    }
  }
  hideFormProgressBar() {
    this.progressBar.hide();
    if (this.formProgressBarTimeout != null) {
      window.clearTimeout(this.formProgressBarTimeout);
      delete this.formProgressBarTimeout;
    }
  }
  reload(reason) {
    var _a;
    dispatch("turbo:reload", {
      detail: reason
    });
    window.location.href = ((_a = this.location) === null || _a === void 0 ? void 0 : _a.toString()) || window.location.href;
  }
  get navigator() {
    return this.session.navigator;
  }
}
class CacheObserver {
  constructor() {
    this.started = false;
    this.removeStaleElements = _event => {
      const staleElements = [...document.querySelectorAll('[data-turbo-cache="false"]')];
      for (const element of staleElements) {
        element.remove();
      }
    };
  }
  start() {
    if (!this.started) {
      this.started = true;
      addEventListener("turbo:before-cache", this.removeStaleElements, false);
    }
  }
  stop() {
    if (this.started) {
      this.started = false;
      removeEventListener("turbo:before-cache", this.removeStaleElements, false);
    }
  }
}
class FrameRedirector {
  constructor(session, element) {
    this.session = session;
    this.element = element;
    this.linkInterceptor = new LinkInterceptor(this, element);
    this.formSubmitObserver = new FormSubmitObserver(this, element);
  }
  start() {
    this.linkInterceptor.start();
    this.formSubmitObserver.start();
  }
  stop() {
    this.linkInterceptor.stop();
    this.formSubmitObserver.stop();
  }
  shouldInterceptLinkClick(element, _location, _event) {
    return this.shouldRedirect(element);
  }
  linkClickIntercepted(element, url, event) {
    const frame = this.findFrameElement(element);
    if (frame) {
      frame.delegate.linkClickIntercepted(element, url, event);
    }
  }
  willSubmitForm(element, submitter) {
    return element.closest("turbo-frame") == null && this.shouldSubmit(element, submitter) && this.shouldRedirect(element, submitter);
  }
  formSubmitted(element, submitter) {
    const frame = this.findFrameElement(element, submitter);
    if (frame) {
      frame.delegate.formSubmitted(element, submitter);
    }
  }
  shouldSubmit(form, submitter) {
    var _a;
    const action = getAction(form, submitter);
    const meta = this.element.ownerDocument.querySelector(`meta[name="turbo-root"]`);
    const rootLocation = expandURL((_a = meta === null || meta === void 0 ? void 0 : meta.content) !== null && _a !== void 0 ? _a : "/");
    return this.shouldRedirect(form, submitter) && locationIsVisitable(action, rootLocation);
  }
  shouldRedirect(element, submitter) {
    const isNavigatable = element instanceof HTMLFormElement ? this.session.submissionIsNavigatable(element, submitter) : this.session.elementIsNavigatable(element);
    if (isNavigatable) {
      const frame = this.findFrameElement(element, submitter);
      return frame ? frame != element.closest("turbo-frame") : false;
    } else {
      return false;
    }
  }
  findFrameElement(element, submitter) {
    const id = (submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute("data-turbo-frame")) || element.getAttribute("data-turbo-frame");
    if (id && id != "_top") {
      const frame = this.element.querySelector(`#${id}:not([disabled])`);
      if (frame instanceof FrameElement) {
        return frame;
      }
    }
  }
}
class History {
  constructor(delegate) {
    this.restorationIdentifier = uuid();
    this.restorationData = {};
    this.started = false;
    this.pageLoaded = false;
    this.onPopState = event => {
      if (this.shouldHandlePopState()) {
        const {
          turbo
        } = event.state || {};
        if (turbo) {
          this.location = new URL(window.location.href);
          const {
            restorationIdentifier
          } = turbo;
          this.restorationIdentifier = restorationIdentifier;
          this.delegate.historyPoppedToLocationWithRestorationIdentifier(this.location, restorationIdentifier);
        }
      }
    };
    this.onPageLoad = async _event => {
      await nextMicrotask();
      this.pageLoaded = true;
    };
    this.delegate = delegate;
  }
  start() {
    if (!this.started) {
      addEventListener("popstate", this.onPopState, false);
      addEventListener("load", this.onPageLoad, false);
      this.started = true;
      this.replace(new URL(window.location.href));
    }
  }
  stop() {
    if (this.started) {
      removeEventListener("popstate", this.onPopState, false);
      removeEventListener("load", this.onPageLoad, false);
      this.started = false;
    }
  }
  push(location, restorationIdentifier) {
    this.update(history.pushState, location, restorationIdentifier);
  }
  replace(location, restorationIdentifier) {
    this.update(history.replaceState, location, restorationIdentifier);
  }
  update(method, location, restorationIdentifier = uuid()) {
    const state = {
      turbo: {
        restorationIdentifier
      }
    };
    method.call(history, state, "", location.href);
    this.location = location;
    this.restorationIdentifier = restorationIdentifier;
  }
  getRestorationDataForIdentifier(restorationIdentifier) {
    return this.restorationData[restorationIdentifier] || {};
  }
  updateRestorationData(additionalData) {
    const {
      restorationIdentifier
    } = this;
    const restorationData = this.restorationData[restorationIdentifier];
    this.restorationData[restorationIdentifier] = Object.assign(Object.assign({}, restorationData), additionalData);
  }
  assumeControlOfScrollRestoration() {
    var _a;
    if (!this.previousScrollRestoration) {
      this.previousScrollRestoration = (_a = history.scrollRestoration) !== null && _a !== void 0 ? _a : "auto";
      history.scrollRestoration = "manual";
    }
  }
  relinquishControlOfScrollRestoration() {
    if (this.previousScrollRestoration) {
      history.scrollRestoration = this.previousScrollRestoration;
      delete this.previousScrollRestoration;
    }
  }
  shouldHandlePopState() {
    return this.pageIsLoaded();
  }
  pageIsLoaded() {
    return this.pageLoaded || document.readyState == "complete";
  }
}
class Navigator {
  constructor(delegate) {
    this.delegate = delegate;
  }
  proposeVisit(location, options = {}) {
    if (this.delegate.allowsVisitingLocationWithAction(location, options.action)) {
      if (locationIsVisitable(location, this.view.snapshot.rootLocation)) {
        this.delegate.visitProposedToLocation(location, options);
      } else {
        window.location.href = location.toString();
      }
    }
  }
  startVisit(locatable, restorationIdentifier, options = {}) {
    this.stop();
    this.currentVisit = new Visit(this, expandURL(locatable), restorationIdentifier, Object.assign({
      referrer: this.location
    }, options));
    this.currentVisit.start();
  }
  submitForm(form, submitter) {
    this.stop();
    this.formSubmission = new FormSubmission(this, form, submitter, true);
    this.formSubmission.start();
  }
  stop() {
    if (this.formSubmission) {
      this.formSubmission.stop();
      delete this.formSubmission;
    }
    if (this.currentVisit) {
      this.currentVisit.cancel();
      delete this.currentVisit;
    }
  }
  get adapter() {
    return this.delegate.adapter;
  }
  get view() {
    return this.delegate.view;
  }
  get history() {
    return this.delegate.history;
  }
  formSubmissionStarted(formSubmission) {
    if (typeof this.adapter.formSubmissionStarted === "function") {
      this.adapter.formSubmissionStarted(formSubmission);
    }
  }
  async formSubmissionSucceededWithResponse(formSubmission, fetchResponse) {
    if (formSubmission == this.formSubmission) {
      const responseHTML = await fetchResponse.responseHTML;
      if (responseHTML) {
        const shouldCacheSnapshot = formSubmission.method == FetchMethod.get;
        if (!shouldCacheSnapshot) {
          this.view.clearSnapshotCache();
        }
        const {
          statusCode,
          redirected
        } = fetchResponse;
        const action = this.getActionForFormSubmission(formSubmission);
        const visitOptions = {
          action,
          shouldCacheSnapshot,
          response: {
            statusCode,
            responseHTML,
            redirected
          }
        };
        this.proposeVisit(fetchResponse.location, visitOptions);
      }
    }
  }
  async formSubmissionFailedWithResponse(formSubmission, fetchResponse) {
    const responseHTML = await fetchResponse.responseHTML;
    if (responseHTML) {
      const snapshot = PageSnapshot.fromHTMLString(responseHTML);
      if (fetchResponse.serverError) {
        await this.view.renderError(snapshot, this.currentVisit);
      } else {
        await this.view.renderPage(snapshot, false, true, this.currentVisit);
      }
      this.view.scrollToTop();
      this.view.clearSnapshotCache();
    }
  }
  formSubmissionErrored(formSubmission, error) {
    console.error(error);
  }
  formSubmissionFinished(formSubmission) {
    if (typeof this.adapter.formSubmissionFinished === "function") {
      this.adapter.formSubmissionFinished(formSubmission);
    }
  }
  visitStarted(visit) {
    this.delegate.visitStarted(visit);
  }
  visitCompleted(visit) {
    this.delegate.visitCompleted(visit);
  }
  locationWithActionIsSamePage(location, action) {
    const anchor = getAnchor(location);
    const currentAnchor = getAnchor(this.view.lastRenderedLocation);
    const isRestorationToTop = action === "restore" && typeof anchor === "undefined";
    return action !== "replace" && getRequestURL(location) === getRequestURL(this.view.lastRenderedLocation) && (isRestorationToTop || anchor != null && anchor !== currentAnchor);
  }
  visitScrolledToSamePageLocation(oldURL, newURL) {
    this.delegate.visitScrolledToSamePageLocation(oldURL, newURL);
  }
  get location() {
    return this.history.location;
  }
  get restorationIdentifier() {
    return this.history.restorationIdentifier;
  }
  getActionForFormSubmission({
    submitter,
    formElement
  }) {
    return getVisitAction(submitter, formElement) || "advance";
  }
}
var PageStage;
(function (PageStage) {
  PageStage[PageStage["initial"] = 0] = "initial";
  PageStage[PageStage["loading"] = 1] = "loading";
  PageStage[PageStage["interactive"] = 2] = "interactive";
  PageStage[PageStage["complete"] = 3] = "complete";
})(PageStage || (PageStage = {}));
class PageObserver {
  constructor(delegate) {
    this.stage = PageStage.initial;
    this.started = false;
    this.interpretReadyState = () => {
      const {
        readyState
      } = this;
      if (readyState == "interactive") {
        this.pageIsInteractive();
      } else if (readyState == "complete") {
        this.pageIsComplete();
      }
    };
    this.pageWillUnload = () => {
      this.delegate.pageWillUnload();
    };
    this.delegate = delegate;
  }
  start() {
    if (!this.started) {
      if (this.stage == PageStage.initial) {
        this.stage = PageStage.loading;
      }
      document.addEventListener("readystatechange", this.interpretReadyState, false);
      addEventListener("pagehide", this.pageWillUnload, false);
      this.started = true;
    }
  }
  stop() {
    if (this.started) {
      document.removeEventListener("readystatechange", this.interpretReadyState, false);
      removeEventListener("pagehide", this.pageWillUnload, false);
      this.started = false;
    }
  }
  pageIsInteractive() {
    if (this.stage == PageStage.loading) {
      this.stage = PageStage.interactive;
      this.delegate.pageBecameInteractive();
    }
  }
  pageIsComplete() {
    this.pageIsInteractive();
    if (this.stage == PageStage.interactive) {
      this.stage = PageStage.complete;
      this.delegate.pageLoaded();
    }
  }
  get readyState() {
    return document.readyState;
  }
}
class ScrollObserver {
  constructor(delegate) {
    this.started = false;
    this.onScroll = () => {
      this.updatePosition({
        x: window.pageXOffset,
        y: window.pageYOffset
      });
    };
    this.delegate = delegate;
  }
  start() {
    if (!this.started) {
      addEventListener("scroll", this.onScroll, false);
      this.onScroll();
      this.started = true;
    }
  }
  stop() {
    if (this.started) {
      removeEventListener("scroll", this.onScroll, false);
      this.started = false;
    }
  }
  updatePosition(position) {
    this.delegate.scrollPositionChanged(position);
  }
}
class StreamMessageRenderer {
  render({
    fragment
  }) {
    Bardo.preservingPermanentElements(this, getPermanentElementMapForFragment(fragment), () => document.documentElement.appendChild(fragment));
  }
  enteringBardo(currentPermanentElement, newPermanentElement) {
    newPermanentElement.replaceWith(currentPermanentElement.cloneNode(true));
  }
  leavingBardo() {}
}
function getPermanentElementMapForFragment(fragment) {
  const permanentElementsInDocument = queryPermanentElementsAll(document.documentElement);
  const permanentElementMap = {};
  for (const permanentElementInDocument of permanentElementsInDocument) {
    const {
      id
    } = permanentElementInDocument;
    for (const streamElement of fragment.querySelectorAll("turbo-stream")) {
      const elementInStream = getPermanentElementById(streamElement.templateElement.content, id);
      if (elementInStream) {
        permanentElementMap[id] = [permanentElementInDocument, elementInStream];
      }
    }
  }
  return permanentElementMap;
}
class StreamObserver {
  constructor(delegate) {
    this.sources = new Set();
    this.started = false;
    this.inspectFetchResponse = event => {
      const response = fetchResponseFromEvent(event);
      if (response && fetchResponseIsStream(response)) {
        event.preventDefault();
        this.receiveMessageResponse(response);
      }
    };
    this.receiveMessageEvent = event => {
      if (this.started && typeof event.data == "string") {
        this.receiveMessageHTML(event.data);
      }
    };
    this.delegate = delegate;
  }
  start() {
    if (!this.started) {
      this.started = true;
      addEventListener("turbo:before-fetch-response", this.inspectFetchResponse, false);
    }
  }
  stop() {
    if (this.started) {
      this.started = false;
      removeEventListener("turbo:before-fetch-response", this.inspectFetchResponse, false);
    }
  }
  connectStreamSource(source) {
    if (!this.streamSourceIsConnected(source)) {
      this.sources.add(source);
      source.addEventListener("message", this.receiveMessageEvent, false);
    }
  }
  disconnectStreamSource(source) {
    if (this.streamSourceIsConnected(source)) {
      this.sources.delete(source);
      source.removeEventListener("message", this.receiveMessageEvent, false);
    }
  }
  streamSourceIsConnected(source) {
    return this.sources.has(source);
  }
  async receiveMessageResponse(response) {
    const html = await response.responseHTML;
    if (html) {
      this.receiveMessageHTML(html);
    }
  }
  receiveMessageHTML(html) {
    this.delegate.receivedMessageFromStream(StreamMessage.wrap(html));
  }
}
function fetchResponseFromEvent(event) {
  var _a;
  const fetchResponse = (_a = event.detail) === null || _a === void 0 ? void 0 : _a.fetchResponse;
  if (fetchResponse instanceof FetchResponse) {
    return fetchResponse;
  }
}
function fetchResponseIsStream(response) {
  var _a;
  const contentType = (_a = response.contentType) !== null && _a !== void 0 ? _a : "";
  return contentType.startsWith(StreamMessage.contentType);
}
class ErrorRenderer extends Renderer {
  static renderElement(currentElement, newElement) {
    const {
      documentElement,
      body
    } = document;
    documentElement.replaceChild(newElement, body);
  }
  async render() {
    this.replaceHeadAndBody();
    this.activateScriptElements();
  }
  replaceHeadAndBody() {
    const {
      documentElement,
      head
    } = document;
    documentElement.replaceChild(this.newHead, head);
    this.renderElement(this.currentElement, this.newElement);
  }
  activateScriptElements() {
    for (const replaceableElement of this.scriptElements) {
      const parentNode = replaceableElement.parentNode;
      if (parentNode) {
        const element = activateScriptElement(replaceableElement);
        parentNode.replaceChild(element, replaceableElement);
      }
    }
  }
  get newHead() {
    return this.newSnapshot.headSnapshot.element;
  }
  get scriptElements() {
    return document.documentElement.querySelectorAll("script");
  }
}
class PageRenderer extends Renderer {
  static renderElement(currentElement, newElement) {
    if (document.body && newElement instanceof HTMLBodyElement) {
      document.body.replaceWith(newElement);
    } else {
      document.documentElement.appendChild(newElement);
    }
  }
  get shouldRender() {
    return this.newSnapshot.isVisitable && this.trackedElementsAreIdentical;
  }
  get reloadReason() {
    if (!this.newSnapshot.isVisitable) {
      return {
        reason: "turbo_visit_control_is_reload"
      };
    }
    if (!this.trackedElementsAreIdentical) {
      return {
        reason: "tracked_element_mismatch"
      };
    }
  }
  async prepareToRender() {
    await this.mergeHead();
  }
  async render() {
    if (this.willRender) {
      await this.replaceBody();
    }
  }
  finishRendering() {
    super.finishRendering();
    if (!this.isPreview) {
      this.focusFirstAutofocusableElement();
    }
  }
  get currentHeadSnapshot() {
    return this.currentSnapshot.headSnapshot;
  }
  get newHeadSnapshot() {
    return this.newSnapshot.headSnapshot;
  }
  get newElement() {
    return this.newSnapshot.element;
  }
  async mergeHead() {
    const mergedHeadElements = this.mergeProvisionalElements();
    const newStylesheetElements = this.copyNewHeadStylesheetElements();
    this.copyNewHeadScriptElements();
    await mergedHeadElements;
    await newStylesheetElements;
  }
  async replaceBody() {
    await this.preservingPermanentElements(async () => {
      this.activateNewBody();
      await this.assignNewBody();
    });
  }
  get trackedElementsAreIdentical() {
    return this.currentHeadSnapshot.trackedElementSignature == this.newHeadSnapshot.trackedElementSignature;
  }
  async copyNewHeadStylesheetElements() {
    const loadingElements = [];
    for (const element of this.newHeadStylesheetElements) {
      loadingElements.push(waitForLoad(element));
      document.head.appendChild(element);
    }
    await Promise.all(loadingElements);
  }
  copyNewHeadScriptElements() {
    for (const element of this.newHeadScriptElements) {
      document.head.appendChild(activateScriptElement(element));
    }
  }
  async mergeProvisionalElements() {
    const newHeadElements = [...this.newHeadProvisionalElements];
    for (const element of this.currentHeadProvisionalElements) {
      if (!this.isCurrentElementInElementList(element, newHeadElements)) {
        document.head.removeChild(element);
      }
    }
    for (const element of newHeadElements) {
      document.head.appendChild(element);
    }
  }
  isCurrentElementInElementList(element, elementList) {
    for (const [index, newElement] of elementList.entries()) {
      if (element.tagName == "TITLE") {
        if (newElement.tagName != "TITLE") {
          continue;
        }
        if (element.innerHTML == newElement.innerHTML) {
          elementList.splice(index, 1);
          return true;
        }
      }
      if (newElement.isEqualNode(element)) {
        elementList.splice(index, 1);
        return true;
      }
    }
    return false;
  }
  removeCurrentHeadProvisionalElements() {
    for (const element of this.currentHeadProvisionalElements) {
      document.head.removeChild(element);
    }
  }
  copyNewHeadProvisionalElements() {
    for (const element of this.newHeadProvisionalElements) {
      document.head.appendChild(element);
    }
  }
  activateNewBody() {
    document.adoptNode(this.newElement);
    this.activateNewBodyScriptElements();
  }
  activateNewBodyScriptElements() {
    for (const inertScriptElement of this.newBodyScriptElements) {
      const activatedScriptElement = activateScriptElement(inertScriptElement);
      inertScriptElement.replaceWith(activatedScriptElement);
    }
  }
  async assignNewBody() {
    await this.renderElement(this.currentElement, this.newElement);
  }
  get newHeadStylesheetElements() {
    return this.newHeadSnapshot.getStylesheetElementsNotInSnapshot(this.currentHeadSnapshot);
  }
  get newHeadScriptElements() {
    return this.newHeadSnapshot.getScriptElementsNotInSnapshot(this.currentHeadSnapshot);
  }
  get currentHeadProvisionalElements() {
    return this.currentHeadSnapshot.provisionalElements;
  }
  get newHeadProvisionalElements() {
    return this.newHeadSnapshot.provisionalElements;
  }
  get newBodyScriptElements() {
    return this.newElement.querySelectorAll("script");
  }
}
class SnapshotCache {
  constructor(size) {
    this.keys = [];
    this.snapshots = {};
    this.size = size;
  }
  has(location) {
    return toCacheKey(location) in this.snapshots;
  }
  get(location) {
    if (this.has(location)) {
      const snapshot = this.read(location);
      this.touch(location);
      return snapshot;
    }
  }
  put(location, snapshot) {
    this.write(location, snapshot);
    this.touch(location);
    return snapshot;
  }
  clear() {
    this.snapshots = {};
  }
  read(location) {
    return this.snapshots[toCacheKey(location)];
  }
  write(location, snapshot) {
    this.snapshots[toCacheKey(location)] = snapshot;
  }
  touch(location) {
    const key = toCacheKey(location);
    const index = this.keys.indexOf(key);
    if (index > -1) this.keys.splice(index, 1);
    this.keys.unshift(key);
    this.trim();
  }
  trim() {
    for (const key of this.keys.splice(this.size)) {
      delete this.snapshots[key];
    }
  }
}
class PageView extends View {
  constructor() {
    super(...arguments);
    this.snapshotCache = new SnapshotCache(10);
    this.lastRenderedLocation = new URL(location.href);
    this.forceReloaded = false;
  }
  renderPage(snapshot, isPreview = false, willRender = true, visit) {
    const renderer = new PageRenderer(this.snapshot, snapshot, PageRenderer.renderElement, isPreview, willRender);
    if (!renderer.shouldRender) {
      this.forceReloaded = true;
    } else {
      visit === null || visit === void 0 ? void 0 : visit.changeHistory();
    }
    return this.render(renderer);
  }
  renderError(snapshot, visit) {
    visit === null || visit === void 0 ? void 0 : visit.changeHistory();
    const renderer = new ErrorRenderer(this.snapshot, snapshot, ErrorRenderer.renderElement, false);
    return this.render(renderer);
  }
  clearSnapshotCache() {
    this.snapshotCache.clear();
  }
  async cacheSnapshot(snapshot = this.snapshot) {
    if (snapshot.isCacheable) {
      this.delegate.viewWillCacheSnapshot();
      const {
        lastRenderedLocation: location
      } = this;
      await nextEventLoopTick();
      const cachedSnapshot = snapshot.clone();
      this.snapshotCache.put(location, cachedSnapshot);
      return cachedSnapshot;
    }
  }
  getCachedSnapshotForLocation(location) {
    return this.snapshotCache.get(location);
  }
  get snapshot() {
    return PageSnapshot.fromElement(this.element);
  }
}
class Preloader {
  constructor(delegate) {
    this.selector = "a[data-turbo-preload]";
    this.delegate = delegate;
  }
  get snapshotCache() {
    return this.delegate.navigator.view.snapshotCache;
  }
  start() {
    if (document.readyState === "loading") {
      return document.addEventListener("DOMContentLoaded", () => {
        this.preloadOnLoadLinksForView(document.body);
      });
    } else {
      this.preloadOnLoadLinksForView(document.body);
    }
  }
  preloadOnLoadLinksForView(element) {
    for (const link of element.querySelectorAll(this.selector)) {
      this.preloadURL(link);
    }
  }
  async preloadURL(link) {
    const location = new URL(link.href);
    if (this.snapshotCache.has(location)) {
      return;
    }
    try {
      const response = await fetch(location.toString(), {
        headers: {
          "VND.PREFETCH": "true",
          Accept: "text/html"
        }
      });
      const responseText = await response.text();
      const snapshot = PageSnapshot.fromHTMLString(responseText);
      this.snapshotCache.put(location, snapshot);
    } catch (_) {}
  }
}
class Session {
  constructor() {
    this.navigator = new Navigator(this);
    this.history = new History(this);
    this.preloader = new Preloader(this);
    this.view = new PageView(this, document.documentElement);
    this.adapter = new BrowserAdapter(this);
    this.pageObserver = new PageObserver(this);
    this.cacheObserver = new CacheObserver();
    this.linkClickObserver = new LinkClickObserver(this, window);
    this.formSubmitObserver = new FormSubmitObserver(this, document);
    this.scrollObserver = new ScrollObserver(this);
    this.streamObserver = new StreamObserver(this);
    this.formLinkClickObserver = new FormLinkClickObserver(this, document.documentElement);
    this.frameRedirector = new FrameRedirector(this, document.documentElement);
    this.streamMessageRenderer = new StreamMessageRenderer();
    this.drive = true;
    this.enabled = true;
    this.progressBarDelay = 500;
    this.started = false;
    this.formMode = "on";
  }
  start() {
    if (!this.started) {
      this.pageObserver.start();
      this.cacheObserver.start();
      this.formLinkClickObserver.start();
      this.linkClickObserver.start();
      this.formSubmitObserver.start();
      this.scrollObserver.start();
      this.streamObserver.start();
      this.frameRedirector.start();
      this.history.start();
      this.preloader.start();
      this.started = true;
      this.enabled = true;
    }
  }
  disable() {
    this.enabled = false;
  }
  stop() {
    if (this.started) {
      this.pageObserver.stop();
      this.cacheObserver.stop();
      this.formLinkClickObserver.stop();
      this.linkClickObserver.stop();
      this.formSubmitObserver.stop();
      this.scrollObserver.stop();
      this.streamObserver.stop();
      this.frameRedirector.stop();
      this.history.stop();
      this.started = false;
    }
  }
  registerAdapter(adapter) {
    this.adapter = adapter;
  }
  visit(location, options = {}) {
    const frameElement = options.frame ? document.getElementById(options.frame) : null;
    if (frameElement instanceof FrameElement) {
      frameElement.src = location.toString();
      frameElement.loaded;
    } else {
      this.navigator.proposeVisit(expandURL(location), options);
    }
  }
  connectStreamSource(source) {
    this.streamObserver.connectStreamSource(source);
  }
  disconnectStreamSource(source) {
    this.streamObserver.disconnectStreamSource(source);
  }
  renderStreamMessage(message) {
    this.streamMessageRenderer.render(StreamMessage.wrap(message));
  }
  clearCache() {
    this.view.clearSnapshotCache();
  }
  setProgressBarDelay(delay) {
    this.progressBarDelay = delay;
  }
  setFormMode(mode) {
    this.formMode = mode;
  }
  get location() {
    return this.history.location;
  }
  get restorationIdentifier() {
    return this.history.restorationIdentifier;
  }
  historyPoppedToLocationWithRestorationIdentifier(location, restorationIdentifier) {
    if (this.enabled) {
      this.navigator.startVisit(location, restorationIdentifier, {
        action: "restore",
        historyChanged: true
      });
    } else {
      this.adapter.pageInvalidated({
        reason: "turbo_disabled"
      });
    }
  }
  scrollPositionChanged(position) {
    this.history.updateRestorationData({
      scrollPosition: position
    });
  }
  willSubmitFormLinkToLocation(link, location) {
    return this.elementIsNavigatable(link) && locationIsVisitable(location, this.snapshot.rootLocation);
  }
  submittedFormLinkToLocation() {}
  willFollowLinkToLocation(link, location, event) {
    return this.elementIsNavigatable(link) && locationIsVisitable(location, this.snapshot.rootLocation) && this.applicationAllowsFollowingLinkToLocation(link, location, event);
  }
  followedLinkToLocation(link, location) {
    const action = this.getActionForLink(link);
    const acceptsStreamResponse = link.hasAttribute("data-turbo-stream");
    this.visit(location.href, {
      action,
      acceptsStreamResponse
    });
  }
  allowsVisitingLocationWithAction(location, action) {
    return this.locationWithActionIsSamePage(location, action) || this.applicationAllowsVisitingLocation(location);
  }
  visitProposedToLocation(location, options) {
    extendURLWithDeprecatedProperties(location);
    this.adapter.visitProposedToLocation(location, options);
  }
  visitStarted(visit) {
    if (!visit.acceptsStreamResponse) {
      markAsBusy(document.documentElement);
    }
    extendURLWithDeprecatedProperties(visit.location);
    if (!visit.silent) {
      this.notifyApplicationAfterVisitingLocation(visit.location, visit.action);
    }
  }
  visitCompleted(visit) {
    clearBusyState(document.documentElement);
    this.notifyApplicationAfterPageLoad(visit.getTimingMetrics());
  }
  locationWithActionIsSamePage(location, action) {
    return this.navigator.locationWithActionIsSamePage(location, action);
  }
  visitScrolledToSamePageLocation(oldURL, newURL) {
    this.notifyApplicationAfterVisitingSamePageLocation(oldURL, newURL);
  }
  willSubmitForm(form, submitter) {
    const action = getAction(form, submitter);
    return this.submissionIsNavigatable(form, submitter) && locationIsVisitable(expandURL(action), this.snapshot.rootLocation);
  }
  formSubmitted(form, submitter) {
    this.navigator.submitForm(form, submitter);
  }
  pageBecameInteractive() {
    this.view.lastRenderedLocation = this.location;
    this.notifyApplicationAfterPageLoad();
  }
  pageLoaded() {
    this.history.assumeControlOfScrollRestoration();
  }
  pageWillUnload() {
    this.history.relinquishControlOfScrollRestoration();
  }
  receivedMessageFromStream(message) {
    this.renderStreamMessage(message);
  }
  viewWillCacheSnapshot() {
    var _a;
    if (!((_a = this.navigator.currentVisit) === null || _a === void 0 ? void 0 : _a.silent)) {
      this.notifyApplicationBeforeCachingSnapshot();
    }
  }
  allowsImmediateRender({
    element
  }, options) {
    const event = this.notifyApplicationBeforeRender(element, options);
    const {
      defaultPrevented,
      detail: {
        render
      }
    } = event;
    if (this.view.renderer && render) {
      this.view.renderer.renderElement = render;
    }
    return !defaultPrevented;
  }
  viewRenderedSnapshot(_snapshot, _isPreview) {
    this.view.lastRenderedLocation = this.history.location;
    this.notifyApplicationAfterRender();
  }
  preloadOnLoadLinksForView(element) {
    this.preloader.preloadOnLoadLinksForView(element);
  }
  viewInvalidated(reason) {
    this.adapter.pageInvalidated(reason);
  }
  frameLoaded(frame) {
    this.notifyApplicationAfterFrameLoad(frame);
  }
  frameRendered(fetchResponse, frame) {
    this.notifyApplicationAfterFrameRender(fetchResponse, frame);
  }
  applicationAllowsFollowingLinkToLocation(link, location, ev) {
    const event = this.notifyApplicationAfterClickingLinkToLocation(link, location, ev);
    return !event.defaultPrevented;
  }
  applicationAllowsVisitingLocation(location) {
    const event = this.notifyApplicationBeforeVisitingLocation(location);
    return !event.defaultPrevented;
  }
  notifyApplicationAfterClickingLinkToLocation(link, location, event) {
    return dispatch("turbo:click", {
      target: link,
      detail: {
        url: location.href,
        originalEvent: event
      },
      cancelable: true
    });
  }
  notifyApplicationBeforeVisitingLocation(location) {
    return dispatch("turbo:before-visit", {
      detail: {
        url: location.href
      },
      cancelable: true
    });
  }
  notifyApplicationAfterVisitingLocation(location, action) {
    return dispatch("turbo:visit", {
      detail: {
        url: location.href,
        action
      }
    });
  }
  notifyApplicationBeforeCachingSnapshot() {
    return dispatch("turbo:before-cache");
  }
  notifyApplicationBeforeRender(newBody, options) {
    return dispatch("turbo:before-render", {
      detail: Object.assign({
        newBody
      }, options),
      cancelable: true
    });
  }
  notifyApplicationAfterRender() {
    return dispatch("turbo:render");
  }
  notifyApplicationAfterPageLoad(timing = {}) {
    return dispatch("turbo:load", {
      detail: {
        url: this.location.href,
        timing
      }
    });
  }
  notifyApplicationAfterVisitingSamePageLocation(oldURL, newURL) {
    dispatchEvent(new HashChangeEvent("hashchange", {
      oldURL: oldURL.toString(),
      newURL: newURL.toString()
    }));
  }
  notifyApplicationAfterFrameLoad(frame) {
    return dispatch("turbo:frame-load", {
      target: frame
    });
  }
  notifyApplicationAfterFrameRender(fetchResponse, frame) {
    return dispatch("turbo:frame-render", {
      detail: {
        fetchResponse
      },
      target: frame,
      cancelable: true
    });
  }
  submissionIsNavigatable(form, submitter) {
    if (this.formMode == "off") {
      return false;
    } else {
      const submitterIsNavigatable = submitter ? this.elementIsNavigatable(submitter) : true;
      if (this.formMode == "optin") {
        return submitterIsNavigatable && form.closest('[data-turbo="true"]') != null;
      } else {
        return submitterIsNavigatable && this.elementIsNavigatable(form);
      }
    }
  }
  elementIsNavigatable(element) {
    const container = findClosestRecursively(element, "[data-turbo]");
    const withinFrame = findClosestRecursively(element, "turbo-frame");
    if (this.drive || withinFrame) {
      if (container) {
        return container.getAttribute("data-turbo") != "false";
      } else {
        return true;
      }
    } else {
      if (container) {
        return container.getAttribute("data-turbo") == "true";
      } else {
        return false;
      }
    }
  }
  getActionForLink(link) {
    return getVisitAction(link) || "advance";
  }
  get snapshot() {
    return this.view.snapshot;
  }
}
function extendURLWithDeprecatedProperties(url) {
  Object.defineProperties(url, deprecatedLocationPropertyDescriptors);
}
const deprecatedLocationPropertyDescriptors = {
  absoluteURL: {
    get() {
      return this.toString();
    }
  }
};
class Cache {
  constructor(session) {
    this.session = session;
  }
  clear() {
    this.session.clearCache();
  }
  resetCacheControl() {
    this.setCacheControl("");
  }
  exemptPageFromCache() {
    this.setCacheControl("no-cache");
  }
  exemptPageFromPreview() {
    this.setCacheControl("no-preview");
  }
  setCacheControl(value) {
    setMetaContent("turbo-cache-control", value);
  }
}
const StreamActions = {
  after() {
    this.targetElements.forEach(e => {
      var _a;
      return (_a = e.parentElement) === null || _a === void 0 ? void 0 : _a.insertBefore(this.templateContent, e.nextSibling);
    });
  },
  append() {
    this.removeDuplicateTargetChildren();
    this.targetElements.forEach(e => e.append(this.templateContent));
  },
  before() {
    this.targetElements.forEach(e => {
      var _a;
      return (_a = e.parentElement) === null || _a === void 0 ? void 0 : _a.insertBefore(this.templateContent, e);
    });
  },
  prepend() {
    this.removeDuplicateTargetChildren();
    this.targetElements.forEach(e => e.prepend(this.templateContent));
  },
  remove() {
    this.targetElements.forEach(e => e.remove());
  },
  replace() {
    this.targetElements.forEach(e => e.replaceWith(this.templateContent));
  },
  update() {
    this.targetElements.forEach(targetElement => {
      targetElement.innerHTML = "";
      targetElement.append(this.templateContent);
    });
  }
};
const session = new Session();
const cache = new Cache(session);
const {
  navigator: navigator$1
} = session;
function start() {
  session.start();
}
function registerAdapter(adapter) {
  session.registerAdapter(adapter);
}
function visit(location, options) {
  session.visit(location, options);
}
function connectStreamSource(source) {
  session.connectStreamSource(source);
}
function disconnectStreamSource(source) {
  session.disconnectStreamSource(source);
}
function renderStreamMessage(message) {
  session.renderStreamMessage(message);
}
function clearCache() {
  console.warn("Please replace `Turbo.clearCache()` with `Turbo.cache.clear()`. The top-level function is deprecated and will be removed in a future version of Turbo.`");
  session.clearCache();
}
function setProgressBarDelay(delay) {
  session.setProgressBarDelay(delay);
}
function setConfirmMethod(confirmMethod) {
  FormSubmission.confirmMethod = confirmMethod;
}
function setFormMode(mode) {
  session.setFormMode(mode);
}
var Turbo = /*#__PURE__*/Object.freeze({
  __proto__: null,
  navigator: navigator$1,
  session: session,
  cache: cache,
  PageRenderer: PageRenderer,
  PageSnapshot: PageSnapshot,
  FrameRenderer: FrameRenderer,
  start: start,
  registerAdapter: registerAdapter,
  visit: visit,
  connectStreamSource: connectStreamSource,
  disconnectStreamSource: disconnectStreamSource,
  renderStreamMessage: renderStreamMessage,
  clearCache: clearCache,
  setProgressBarDelay: setProgressBarDelay,
  setConfirmMethod: setConfirmMethod,
  setFormMode: setFormMode,
  StreamActions: StreamActions
});
class FrameController {
  constructor(element) {
    this.fetchResponseLoaded = _fetchResponse => {};
    this.currentFetchRequest = null;
    this.resolveVisitPromise = () => {};
    this.connected = false;
    this.hasBeenLoaded = false;
    this.ignoredAttributes = new Set();
    this.action = null;
    this.visitCachedSnapshot = ({
      element
    }) => {
      const frame = element.querySelector("#" + this.element.id);
      if (frame && this.previousFrameElement) {
        frame.replaceChildren(...this.previousFrameElement.children);
      }
      delete this.previousFrameElement;
    };
    this.element = element;
    this.view = new FrameView(this, this.element);
    this.appearanceObserver = new AppearanceObserver(this, this.element);
    this.formLinkClickObserver = new FormLinkClickObserver(this, this.element);
    this.linkInterceptor = new LinkInterceptor(this, this.element);
    this.restorationIdentifier = uuid();
    this.formSubmitObserver = new FormSubmitObserver(this, this.element);
  }
  connect() {
    if (!this.connected) {
      this.connected = true;
      if (this.loadingStyle == FrameLoadingStyle.lazy) {
        this.appearanceObserver.start();
      } else {
        this.loadSourceURL();
      }
      this.formLinkClickObserver.start();
      this.linkInterceptor.start();
      this.formSubmitObserver.start();
    }
  }
  disconnect() {
    if (this.connected) {
      this.connected = false;
      this.appearanceObserver.stop();
      this.formLinkClickObserver.stop();
      this.linkInterceptor.stop();
      this.formSubmitObserver.stop();
    }
  }
  disabledChanged() {
    if (this.loadingStyle == FrameLoadingStyle.eager) {
      this.loadSourceURL();
    }
  }
  sourceURLChanged() {
    if (this.isIgnoringChangesTo("src")) return;
    if (this.element.isConnected) {
      this.complete = false;
    }
    if (this.loadingStyle == FrameLoadingStyle.eager || this.hasBeenLoaded) {
      this.loadSourceURL();
    }
  }
  sourceURLReloaded() {
    const {
      src
    } = this.element;
    this.ignoringChangesToAttribute("complete", () => {
      this.element.removeAttribute("complete");
    });
    this.element.src = null;
    this.element.src = src;
    return this.element.loaded;
  }
  completeChanged() {
    if (this.isIgnoringChangesTo("complete")) return;
    this.loadSourceURL();
  }
  loadingStyleChanged() {
    if (this.loadingStyle == FrameLoadingStyle.lazy) {
      this.appearanceObserver.start();
    } else {
      this.appearanceObserver.stop();
      this.loadSourceURL();
    }
  }
  async loadSourceURL() {
    if (this.enabled && this.isActive && !this.complete && this.sourceURL) {
      this.element.loaded = this.visit(expandURL(this.sourceURL));
      this.appearanceObserver.stop();
      await this.element.loaded;
      this.hasBeenLoaded = true;
    }
  }
  async loadResponse(fetchResponse) {
    if (fetchResponse.redirected || fetchResponse.succeeded && fetchResponse.isHTML) {
      this.sourceURL = fetchResponse.response.url;
    }
    try {
      const html = await fetchResponse.responseHTML;
      if (html) {
        const {
          body
        } = parseHTMLDocument(html);
        const newFrameElement = await this.extractForeignFrameElement(body);
        if (newFrameElement) {
          const snapshot = new Snapshot(newFrameElement);
          const renderer = new FrameRenderer(this, this.view.snapshot, snapshot, FrameRenderer.renderElement, false, false);
          if (this.view.renderPromise) await this.view.renderPromise;
          this.changeHistory();
          await this.view.render(renderer);
          this.complete = true;
          session.frameRendered(fetchResponse, this.element);
          session.frameLoaded(this.element);
          this.fetchResponseLoaded(fetchResponse);
        } else if (this.willHandleFrameMissingFromResponse(fetchResponse)) {
          console.warn(`A matching frame for #${this.element.id} was missing from the response, transforming into full-page Visit.`);
          this.visitResponse(fetchResponse.response);
        }
      }
    } catch (error) {
      console.error(error);
      this.view.invalidate();
    } finally {
      this.fetchResponseLoaded = () => {};
    }
  }
  elementAppearedInViewport(element) {
    this.proposeVisitIfNavigatedWithAction(element, element);
    this.loadSourceURL();
  }
  willSubmitFormLinkToLocation(link) {
    return this.shouldInterceptNavigation(link);
  }
  submittedFormLinkToLocation(link, _location, form) {
    const frame = this.findFrameElement(link);
    if (frame) form.setAttribute("data-turbo-frame", frame.id);
  }
  shouldInterceptLinkClick(element, _location, _event) {
    return this.shouldInterceptNavigation(element);
  }
  linkClickIntercepted(element, location) {
    this.navigateFrame(element, location);
  }
  willSubmitForm(element, submitter) {
    return element.closest("turbo-frame") == this.element && this.shouldInterceptNavigation(element, submitter);
  }
  formSubmitted(element, submitter) {
    if (this.formSubmission) {
      this.formSubmission.stop();
    }
    this.formSubmission = new FormSubmission(this, element, submitter);
    const {
      fetchRequest
    } = this.formSubmission;
    this.prepareRequest(fetchRequest);
    this.formSubmission.start();
  }
  prepareRequest(request) {
    var _a;
    request.headers["Turbo-Frame"] = this.id;
    if ((_a = this.currentNavigationElement) === null || _a === void 0 ? void 0 : _a.hasAttribute("data-turbo-stream")) {
      request.acceptResponseType(StreamMessage.contentType);
    }
  }
  requestStarted(_request) {
    markAsBusy(this.element);
  }
  requestPreventedHandlingResponse(_request, _response) {
    this.resolveVisitPromise();
  }
  async requestSucceededWithResponse(request, response) {
    await this.loadResponse(response);
    this.resolveVisitPromise();
  }
  async requestFailedWithResponse(request, response) {
    console.error(response);
    await this.loadResponse(response);
    this.resolveVisitPromise();
  }
  requestErrored(request, error) {
    console.error(error);
    this.resolveVisitPromise();
  }
  requestFinished(_request) {
    clearBusyState(this.element);
  }
  formSubmissionStarted({
    formElement
  }) {
    markAsBusy(formElement, this.findFrameElement(formElement));
  }
  formSubmissionSucceededWithResponse(formSubmission, response) {
    const frame = this.findFrameElement(formSubmission.formElement, formSubmission.submitter);
    frame.delegate.proposeVisitIfNavigatedWithAction(frame, formSubmission.formElement, formSubmission.submitter);
    frame.delegate.loadResponse(response);
  }
  formSubmissionFailedWithResponse(formSubmission, fetchResponse) {
    this.element.delegate.loadResponse(fetchResponse);
  }
  formSubmissionErrored(formSubmission, error) {
    console.error(error);
  }
  formSubmissionFinished({
    formElement
  }) {
    clearBusyState(formElement, this.findFrameElement(formElement));
  }
  allowsImmediateRender({
    element: newFrame
  }, options) {
    const event = dispatch("turbo:before-frame-render", {
      target: this.element,
      detail: Object.assign({
        newFrame
      }, options),
      cancelable: true
    });
    const {
      defaultPrevented,
      detail: {
        render
      }
    } = event;
    if (this.view.renderer && render) {
      this.view.renderer.renderElement = render;
    }
    return !defaultPrevented;
  }
  viewRenderedSnapshot(_snapshot, _isPreview) {}
  preloadOnLoadLinksForView(element) {
    session.preloadOnLoadLinksForView(element);
  }
  viewInvalidated() {}
  willRenderFrame(currentElement, _newElement) {
    this.previousFrameElement = currentElement.cloneNode(true);
  }
  async visit(url) {
    var _a;
    const request = new FetchRequest(this, FetchMethod.get, url, new URLSearchParams(), this.element);
    (_a = this.currentFetchRequest) === null || _a === void 0 ? void 0 : _a.cancel();
    this.currentFetchRequest = request;
    return new Promise(resolve => {
      this.resolveVisitPromise = () => {
        this.resolveVisitPromise = () => {};
        this.currentFetchRequest = null;
        resolve();
      };
      request.perform();
    });
  }
  navigateFrame(element, url, submitter) {
    const frame = this.findFrameElement(element, submitter);
    frame.delegate.proposeVisitIfNavigatedWithAction(frame, element, submitter);
    this.withCurrentNavigationElement(element, () => {
      frame.src = url;
    });
  }
  proposeVisitIfNavigatedWithAction(frame, element, submitter) {
    this.action = getVisitAction(submitter, element, frame);
    if (this.action) {
      const pageSnapshot = PageSnapshot.fromElement(frame).clone();
      const {
        visitCachedSnapshot
      } = frame.delegate;
      frame.delegate.fetchResponseLoaded = fetchResponse => {
        if (frame.src) {
          const {
            statusCode,
            redirected
          } = fetchResponse;
          const responseHTML = frame.ownerDocument.documentElement.outerHTML;
          const response = {
            statusCode,
            redirected,
            responseHTML
          };
          const options = {
            response,
            visitCachedSnapshot,
            willRender: false,
            updateHistory: false,
            restorationIdentifier: this.restorationIdentifier,
            snapshot: pageSnapshot
          };
          if (this.action) options.action = this.action;
          session.visit(frame.src, options);
        }
      };
    }
  }
  changeHistory() {
    if (this.action) {
      const method = getHistoryMethodForAction(this.action);
      session.history.update(method, expandURL(this.element.src || ""), this.restorationIdentifier);
    }
  }
  willHandleFrameMissingFromResponse(fetchResponse) {
    this.element.setAttribute("complete", "");
    const response = fetchResponse.response;
    const visit = async (url, options = {}) => {
      if (url instanceof Response) {
        this.visitResponse(url);
      } else {
        session.visit(url, options);
      }
    };
    const event = dispatch("turbo:frame-missing", {
      target: this.element,
      detail: {
        response,
        visit
      },
      cancelable: true
    });
    return !event.defaultPrevented;
  }
  async visitResponse(response) {
    const wrapped = new FetchResponse(response);
    const responseHTML = await wrapped.responseHTML;
    const {
      location,
      redirected,
      statusCode
    } = wrapped;
    return session.visit(location, {
      response: {
        redirected,
        statusCode,
        responseHTML
      }
    });
  }
  findFrameElement(element, submitter) {
    var _a;
    const id = getAttribute("data-turbo-frame", submitter, element) || this.element.getAttribute("target");
    return (_a = getFrameElementById(id)) !== null && _a !== void 0 ? _a : this.element;
  }
  async extractForeignFrameElement(container) {
    let element;
    const id = CSS.escape(this.id);
    try {
      element = activateElement(container.querySelector(`turbo-frame#${id}`), this.sourceURL);
      if (element) {
        return element;
      }
      element = activateElement(container.querySelector(`turbo-frame[src][recurse~=${id}]`), this.sourceURL);
      if (element) {
        await element.loaded;
        return await this.extractForeignFrameElement(element);
      }
    } catch (error) {
      console.error(error);
      return new FrameElement();
    }
    return null;
  }
  formActionIsVisitable(form, submitter) {
    const action = getAction(form, submitter);
    return locationIsVisitable(expandURL(action), this.rootLocation);
  }
  shouldInterceptNavigation(element, submitter) {
    const id = getAttribute("data-turbo-frame", submitter, element) || this.element.getAttribute("target");
    if (element instanceof HTMLFormElement && !this.formActionIsVisitable(element, submitter)) {
      return false;
    }
    if (!this.enabled || id == "_top") {
      return false;
    }
    if (id) {
      const frameElement = getFrameElementById(id);
      if (frameElement) {
        return !frameElement.disabled;
      }
    }
    if (!session.elementIsNavigatable(element)) {
      return false;
    }
    if (submitter && !session.elementIsNavigatable(submitter)) {
      return false;
    }
    return true;
  }
  get id() {
    return this.element.id;
  }
  get enabled() {
    return !this.element.disabled;
  }
  get sourceURL() {
    if (this.element.src) {
      return this.element.src;
    }
  }
  set sourceURL(sourceURL) {
    this.ignoringChangesToAttribute("src", () => {
      this.element.src = sourceURL !== null && sourceURL !== void 0 ? sourceURL : null;
    });
  }
  get loadingStyle() {
    return this.element.loading;
  }
  get isLoading() {
    return this.formSubmission !== undefined || this.resolveVisitPromise() !== undefined;
  }
  get complete() {
    return this.element.hasAttribute("complete");
  }
  set complete(value) {
    this.ignoringChangesToAttribute("complete", () => {
      if (value) {
        this.element.setAttribute("complete", "");
      } else {
        this.element.removeAttribute("complete");
      }
    });
  }
  get isActive() {
    return this.element.isActive && this.connected;
  }
  get rootLocation() {
    var _a;
    const meta = this.element.ownerDocument.querySelector(`meta[name="turbo-root"]`);
    const root = (_a = meta === null || meta === void 0 ? void 0 : meta.content) !== null && _a !== void 0 ? _a : "/";
    return expandURL(root);
  }
  isIgnoringChangesTo(attributeName) {
    return this.ignoredAttributes.has(attributeName);
  }
  ignoringChangesToAttribute(attributeName, callback) {
    this.ignoredAttributes.add(attributeName);
    callback();
    this.ignoredAttributes.delete(attributeName);
  }
  withCurrentNavigationElement(element, callback) {
    this.currentNavigationElement = element;
    callback();
    delete this.currentNavigationElement;
  }
}
function getFrameElementById(id) {
  if (id != null) {
    const element = document.getElementById(id);
    if (element instanceof FrameElement) {
      return element;
    }
  }
}
function activateElement(element, currentURL) {
  if (element) {
    const src = element.getAttribute("src");
    if (src != null && currentURL != null && urlsAreEqual(src, currentURL)) {
      throw new Error(`Matching <turbo-frame id="${element.id}"> element has a source URL which references itself`);
    }
    if (element.ownerDocument !== document) {
      element = document.importNode(element, true);
    }
    if (element instanceof FrameElement) {
      element.connectedCallback();
      element.disconnectedCallback();
      return element;
    }
  }
}
class StreamElement extends HTMLElement {
  static async renderElement(newElement) {
    await newElement.performAction();
  }
  async connectedCallback() {
    try {
      await this.render();
    } catch (error) {
      console.error(error);
    } finally {
      this.disconnect();
    }
  }
  async render() {
    var _a;
    return (_a = this.renderPromise) !== null && _a !== void 0 ? _a : this.renderPromise = (async () => {
      const event = this.beforeRenderEvent;
      if (this.dispatchEvent(event)) {
        await nextAnimationFrame();
        await event.detail.render(this);
      }
    })();
  }
  disconnect() {
    try {
      this.remove();
    } catch (_a) {}
  }
  removeDuplicateTargetChildren() {
    this.duplicateChildren.forEach(c => c.remove());
  }
  get duplicateChildren() {
    var _a;
    const existingChildren = this.targetElements.flatMap(e => [...e.children]).filter(c => !!c.id);
    const newChildrenIds = [...(((_a = this.templateContent) === null || _a === void 0 ? void 0 : _a.children) || [])].filter(c => !!c.id).map(c => c.id);
    return existingChildren.filter(c => newChildrenIds.includes(c.id));
  }
  get performAction() {
    if (this.action) {
      const actionFunction = StreamActions[this.action];
      if (actionFunction) {
        return actionFunction;
      }
      this.raise("unknown action");
    }
    this.raise("action attribute is missing");
  }
  get targetElements() {
    if (this.target) {
      return this.targetElementsById;
    } else if (this.targets) {
      return this.targetElementsByQuery;
    } else {
      this.raise("target or targets attribute is missing");
    }
  }
  get templateContent() {
    return this.templateElement.content.cloneNode(true);
  }
  get templateElement() {
    if (this.firstElementChild === null) {
      const template = this.ownerDocument.createElement("template");
      this.appendChild(template);
      return template;
    } else if (this.firstElementChild instanceof HTMLTemplateElement) {
      return this.firstElementChild;
    }
    this.raise("first child element must be a <template> element");
  }
  get action() {
    return this.getAttribute("action");
  }
  get target() {
    return this.getAttribute("target");
  }
  get targets() {
    return this.getAttribute("targets");
  }
  raise(message) {
    throw new Error(`${this.description}: ${message}`);
  }
  get description() {
    var _a, _b;
    return (_b = ((_a = this.outerHTML.match(/<[^>]+>/)) !== null && _a !== void 0 ? _a : [])[0]) !== null && _b !== void 0 ? _b : "<turbo-stream>";
  }
  get beforeRenderEvent() {
    return new CustomEvent("turbo:before-stream-render", {
      bubbles: true,
      cancelable: true,
      detail: {
        newStream: this,
        render: StreamElement.renderElement
      }
    });
  }
  get targetElementsById() {
    var _a;
    const element = (_a = this.ownerDocument) === null || _a === void 0 ? void 0 : _a.getElementById(this.target);
    if (element !== null) {
      return [element];
    } else {
      return [];
    }
  }
  get targetElementsByQuery() {
    var _a;
    const elements = (_a = this.ownerDocument) === null || _a === void 0 ? void 0 : _a.querySelectorAll(this.targets);
    if (elements.length !== 0) {
      return Array.prototype.slice.call(elements);
    } else {
      return [];
    }
  }
}
class StreamSourceElement extends HTMLElement {
  constructor() {
    super(...arguments);
    this.streamSource = null;
  }
  connectedCallback() {
    this.streamSource = this.src.match(/^ws{1,2}:/) ? new WebSocket(this.src) : new EventSource(this.src);
    connectStreamSource(this.streamSource);
  }
  disconnectedCallback() {
    if (this.streamSource) {
      disconnectStreamSource(this.streamSource);
    }
  }
  get src() {
    return this.getAttribute("src") || "";
  }
}
FrameElement.delegateConstructor = FrameController;
if (customElements.get("turbo-frame") === undefined) {
  customElements.define("turbo-frame", FrameElement);
}
if (customElements.get("turbo-stream") === undefined) {
  customElements.define("turbo-stream", StreamElement);
}
if (customElements.get("turbo-stream-source") === undefined) {
  customElements.define("turbo-stream-source", StreamSourceElement);
}
(() => {
  let element = document.currentScript;
  if (!element) return;
  if (element.hasAttribute("data-turbo-suppress-warning")) return;
  element = element.parentElement;
  while (element) {
    if (element == document.body) {
      return console.warn(unindent`
        You are loading Turbo from a <script> element inside the <body> element. This is probably not what you meant to do!

        Load your application’s JavaScript bundle inside the <head> element instead. <script> elements in <body> are evaluated with each page change.

        For more information, see: https://turbo.hotwired.dev/handbook/building#working-with-script-elements

        ——
        Suppress this warning by adding a "data-turbo-suppress-warning" attribute to: %s
      `, element.outerHTML);
    }
    element = element.parentElement;
  }
})();
window.Turbo = Turbo;
start();

let consumer;
async function getConsumer() {
  return consumer || setConsumer(createConsumer$1().then(setConsumer));
}
function setConsumer(newConsumer) {
  return consumer = newConsumer;
}
async function createConsumer$1() {
  const {
    createConsumer
  } = await Promise.resolve().then(function () { return index; });
  return createConsumer();
}
async function subscribeTo(channel, mixin) {
  const {
    subscriptions
  } = await getConsumer();
  return subscriptions.create(channel, mixin);
}

// Based on https://github.com/nathan7/snakeize
//
// This software is released under the MIT license:
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
// the Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
function walk(obj) {
  if (!obj || typeof obj !== 'object') return obj;
  if (obj instanceof Date || obj instanceof RegExp) return obj;
  if (Array.isArray(obj)) return obj.map(walk);
  return Object.keys(obj).reduce(function (acc, key) {
    var camel = key[0].toLowerCase() + key.slice(1).replace(/([A-Z]+)/g, function (m, x) {
      return '_' + x.toLowerCase();
    });
    acc[camel] = walk(obj[key]);
    return acc;
  }, {});
}

class TurboCableStreamSourceElement extends HTMLElement {
  async connectedCallback() {
    connectStreamSource(this);
    this.subscription = await subscribeTo(this.channel, {
      received: this.dispatchMessageEvent.bind(this)
    });
  }
  disconnectedCallback() {
    disconnectStreamSource(this);
    if (this.subscription) this.subscription.unsubscribe();
  }
  dispatchMessageEvent(data) {
    const event = new MessageEvent("message", {
      data
    });
    return this.dispatchEvent(event);
  }
  get channel() {
    const channel = this.getAttribute("channel");
    const signed_stream_name = this.getAttribute("signed-stream-name");
    return {
      channel,
      signed_stream_name,
      ...walk({
        ...this.dataset
      })
    };
  }
}
if (customElements.get("turbo-cable-stream-source") === undefined) {
  customElements.define("turbo-cable-stream-source", TurboCableStreamSourceElement);
}

function encodeMethodIntoRequestBody(event) {
  if (event.target instanceof HTMLFormElement) {
    const {
      target: form,
      detail: {
        fetchOptions
      }
    } = event;
    form.addEventListener("turbo:submit-start", ({
      detail: {
        formSubmission: {
          submitter
        }
      }
    }) => {
      const body = isBodyInit(fetchOptions.body) ? fetchOptions.body : new URLSearchParams();
      const method = determineFetchMethod(submitter, body, form);
      if (!/get/i.test(method)) {
        if (/post/i.test(method)) {
          body.delete("_method");
        } else {
          body.set("_method", method);
        }
        fetchOptions.method = "post";
      }
    }, {
      once: true
    });
  }
}
function determineFetchMethod(submitter, body, form) {
  const formMethod = determineFormMethod(submitter);
  const overrideMethod = body.get("_method");
  const method = form.getAttribute("method") || "get";
  if (typeof formMethod == "string") {
    return formMethod;
  } else if (typeof overrideMethod == "string") {
    return overrideMethod;
  } else {
    return method;
  }
}
function determineFormMethod(submitter) {
  if (submitter instanceof HTMLButtonElement || submitter instanceof HTMLInputElement) {
    if (submitter.hasAttribute("formmethod")) {
      return submitter.formMethod;
    } else {
      return null;
    }
  } else {
    return null;
  }
}
function isBodyInit(body) {
  return body instanceof FormData || body instanceof URLSearchParams;
}

addEventListener("turbo:before-fetch-request", encodeMethodIntoRequestBody);

//
session.drive = false; // By default disable Turbo on all pages

var adapters = {
  logger: self.console,
  WebSocket: self.WebSocket
};

// The logger is disabled by default. You can enable it with:
//
//   ActionCable.logger.enabled = true
//
//   Example:
//
//   import * as ActionCable from '@rails/actioncable'
//
//   ActionCable.logger.enabled = true
//   ActionCable.logger.log('Connection Established.')
//

var logger = {
  log(...messages) {
    if (this.enabled) {
      messages.push(Date.now());
      adapters.logger.log("[ActionCable]", ...messages);
    }
  }
};

// Responsible for ensuring the cable connection is in good health by validating the heartbeat pings sent from the server, and attempting
// revival reconnections if things go astray. Internal class, not intended for direct user manipulation.

const now = () => new Date().getTime();
const secondsSince = time => (now() - time) / 1000;
class ConnectionMonitor {
  constructor(connection) {
    this.visibilityDidChange = this.visibilityDidChange.bind(this);
    this.connection = connection;
    this.reconnectAttempts = 0;
  }
  start() {
    if (!this.isRunning()) {
      this.startedAt = now();
      delete this.stoppedAt;
      this.startPolling();
      addEventListener("visibilitychange", this.visibilityDidChange);
      logger.log(`ConnectionMonitor started. stale threshold = ${this.constructor.staleThreshold} s`);
    }
  }
  stop() {
    if (this.isRunning()) {
      this.stoppedAt = now();
      this.stopPolling();
      removeEventListener("visibilitychange", this.visibilityDidChange);
      logger.log("ConnectionMonitor stopped");
    }
  }
  isRunning() {
    return this.startedAt && !this.stoppedAt;
  }
  recordPing() {
    this.pingedAt = now();
  }
  recordConnect() {
    this.reconnectAttempts = 0;
    this.recordPing();
    delete this.disconnectedAt;
    logger.log("ConnectionMonitor recorded connect");
  }
  recordDisconnect() {
    this.disconnectedAt = now();
    logger.log("ConnectionMonitor recorded disconnect");
  }

  // Private

  startPolling() {
    this.stopPolling();
    this.poll();
  }
  stopPolling() {
    clearTimeout(this.pollTimeout);
  }
  poll() {
    this.pollTimeout = setTimeout(() => {
      this.reconnectIfStale();
      this.poll();
    }, this.getPollInterval());
  }
  getPollInterval() {
    const {
      staleThreshold,
      reconnectionBackoffRate
    } = this.constructor;
    const backoff = Math.pow(1 + reconnectionBackoffRate, Math.min(this.reconnectAttempts, 10));
    const jitterMax = this.reconnectAttempts === 0 ? 1.0 : reconnectionBackoffRate;
    const jitter = jitterMax * Math.random();
    return staleThreshold * 1000 * backoff * (1 + jitter);
  }
  reconnectIfStale() {
    if (this.connectionIsStale()) {
      logger.log(`ConnectionMonitor detected stale connection. reconnectAttempts = ${this.reconnectAttempts}, time stale = ${secondsSince(this.refreshedAt)} s, stale threshold = ${this.constructor.staleThreshold} s`);
      this.reconnectAttempts++;
      if (this.disconnectedRecently()) {
        logger.log(`ConnectionMonitor skipping reopening recent disconnect. time disconnected = ${secondsSince(this.disconnectedAt)} s`);
      } else {
        logger.log("ConnectionMonitor reopening");
        this.connection.reopen();
      }
    }
  }
  get refreshedAt() {
    return this.pingedAt ? this.pingedAt : this.startedAt;
  }
  connectionIsStale() {
    return secondsSince(this.refreshedAt) > this.constructor.staleThreshold;
  }
  disconnectedRecently() {
    return this.disconnectedAt && secondsSince(this.disconnectedAt) < this.constructor.staleThreshold;
  }
  visibilityDidChange() {
    if (document.visibilityState === "visible") {
      setTimeout(() => {
        if (this.connectionIsStale() || !this.connection.isOpen()) {
          logger.log(`ConnectionMonitor reopening stale connection on visibilitychange. visibilityState = ${document.visibilityState}`);
          this.connection.reopen();
        }
      }, 200);
    }
  }
}
ConnectionMonitor.staleThreshold = 6; // Server::Connections::BEAT_INTERVAL * 2 (missed two pings)
ConnectionMonitor.reconnectionBackoffRate = 0.15;
var ConnectionMonitor$1 = ConnectionMonitor;

var INTERNAL = {
  "message_types": {
    "welcome": "welcome",
    "disconnect": "disconnect",
    "ping": "ping",
    "confirmation": "confirm_subscription",
    "rejection": "reject_subscription"
  },
  "disconnect_reasons": {
    "unauthorized": "unauthorized",
    "invalid_request": "invalid_request",
    "server_restart": "server_restart"
  },
  "default_mount_path": "/cable",
  "protocols": ["actioncable-v1-json", "actioncable-unsupported"]
};

// Encapsulate the cable connection held by the consumer. This is an internal class not intended for direct user manipulation.

const {
  message_types,
  protocols
} = INTERNAL;
const supportedProtocols = protocols.slice(0, protocols.length - 1);
const indexOf = [].indexOf;
class Connection {
  constructor(consumer) {
    this.open = this.open.bind(this);
    this.consumer = consumer;
    this.subscriptions = this.consumer.subscriptions;
    this.monitor = new ConnectionMonitor$1(this);
    this.disconnected = true;
  }
  send(data) {
    if (this.isOpen()) {
      this.webSocket.send(JSON.stringify(data));
      return true;
    } else {
      return false;
    }
  }
  open() {
    if (this.isActive()) {
      logger.log(`Attempted to open WebSocket, but existing socket is ${this.getState()}`);
      return false;
    } else {
      logger.log(`Opening WebSocket, current state is ${this.getState()}, subprotocols: ${protocols}`);
      if (this.webSocket) {
        this.uninstallEventHandlers();
      }
      this.webSocket = new adapters.WebSocket(this.consumer.url, protocols);
      this.installEventHandlers();
      this.monitor.start();
      return true;
    }
  }
  close({
    allowReconnect
  } = {
    allowReconnect: true
  }) {
    if (!allowReconnect) {
      this.monitor.stop();
    }
    // Avoid closing websockets in a "connecting" state due to Safari 15.1+ bug. See: https://github.com/rails/rails/issues/43835#issuecomment-1002288478
    if (this.isOpen()) {
      return this.webSocket.close();
    }
  }
  reopen() {
    logger.log(`Reopening WebSocket, current state is ${this.getState()}`);
    if (this.isActive()) {
      try {
        return this.close();
      } catch (error) {
        logger.log("Failed to reopen WebSocket", error);
      } finally {
        logger.log(`Reopening WebSocket in ${this.constructor.reopenDelay}ms`);
        setTimeout(this.open, this.constructor.reopenDelay);
      }
    } else {
      return this.open();
    }
  }
  getProtocol() {
    if (this.webSocket) {
      return this.webSocket.protocol;
    }
  }
  isOpen() {
    return this.isState("open");
  }
  isActive() {
    return this.isState("open", "connecting");
  }

  // Private

  isProtocolSupported() {
    return indexOf.call(supportedProtocols, this.getProtocol()) >= 0;
  }
  isState(...states) {
    return indexOf.call(states, this.getState()) >= 0;
  }
  getState() {
    if (this.webSocket) {
      for (let state in adapters.WebSocket) {
        if (adapters.WebSocket[state] === this.webSocket.readyState) {
          return state.toLowerCase();
        }
      }
    }
    return null;
  }
  installEventHandlers() {
    for (let eventName in this.events) {
      const handler = this.events[eventName].bind(this);
      this.webSocket[`on${eventName}`] = handler;
    }
  }
  uninstallEventHandlers() {
    for (let eventName in this.events) {
      this.webSocket[`on${eventName}`] = function () {};
    }
  }
}
Connection.reopenDelay = 500;
Connection.prototype.events = {
  message(event) {
    if (!this.isProtocolSupported()) {
      return;
    }
    const {
      identifier,
      message,
      reason,
      reconnect,
      type
    } = JSON.parse(event.data);
    switch (type) {
      case message_types.welcome:
        this.monitor.recordConnect();
        return this.subscriptions.reload();
      case message_types.disconnect:
        logger.log(`Disconnecting. Reason: ${reason}`);
        return this.close({
          allowReconnect: reconnect
        });
      case message_types.ping:
        return this.monitor.recordPing();
      case message_types.confirmation:
        this.subscriptions.confirmSubscription(identifier);
        return this.subscriptions.notify(identifier, "connected");
      case message_types.rejection:
        return this.subscriptions.reject(identifier);
      default:
        return this.subscriptions.notify(identifier, "received", message);
    }
  },
  open() {
    logger.log(`WebSocket onopen event, using '${this.getProtocol()}' subprotocol`);
    this.disconnected = false;
    if (!this.isProtocolSupported()) {
      logger.log("Protocol is unsupported. Stopping monitor and disconnecting.");
      return this.close({
        allowReconnect: false
      });
    }
  },
  close(event) {
    logger.log("WebSocket onclose event");
    if (this.disconnected) {
      return;
    }
    this.disconnected = true;
    this.monitor.recordDisconnect();
    return this.subscriptions.notifyAll("disconnected", {
      willAttemptReconnect: this.monitor.isRunning()
    });
  },
  error() {
    logger.log("WebSocket onerror event");
  }
};
var Connection$1 = Connection;

// A new subscription is created through the ActionCable.Subscriptions instance available on the consumer.
// It provides a number of callbacks and a method for calling remote procedure calls on the corresponding
// Channel instance on the server side.
//
// An example demonstrates the basic functionality:
//
//   App.appearance = App.cable.subscriptions.create("AppearanceChannel", {
//     connected() {
//       // Called once the subscription has been successfully completed
//     },
//
//     disconnected({ willAttemptReconnect: boolean }) {
//       // Called when the client has disconnected with the server.
//       // The object will have an `willAttemptReconnect` property which
//       // says whether the client has the intention of attempting
//       // to reconnect.
//     },
//
//     appear() {
//       this.perform('appear', {appearing_on: this.appearingOn()})
//     },
//
//     away() {
//       this.perform('away')
//     },
//
//     appearingOn() {
//       $('main').data('appearing-on')
//     }
//   })
//
// The methods #appear and #away forward their intent to the remote AppearanceChannel instance on the server
// by calling the `perform` method with the first parameter being the action (which maps to AppearanceChannel#appear/away).
// The second parameter is a hash that'll get JSON encoded and made available on the server in the data parameter.
//
// This is how the server component would look:
//
//   class AppearanceChannel < ApplicationActionCable::Channel
//     def subscribed
//       current_user.appear
//     end
//
//     def unsubscribed
//       current_user.disappear
//     end
//
//     def appear(data)
//       current_user.appear on: data['appearing_on']
//     end
//
//     def away
//       current_user.away
//     end
//   end
//
// The "AppearanceChannel" name is automatically mapped between the client-side subscription creation and the server-side Ruby class name.
// The AppearanceChannel#appear/away public methods are exposed automatically to client-side invocation through the perform method.

const extend = function (object, properties) {
  if (properties != null) {
    for (let key in properties) {
      const value = properties[key];
      object[key] = value;
    }
  }
  return object;
};
class Subscription {
  constructor(consumer, params = {}, mixin) {
    this.consumer = consumer;
    this.identifier = JSON.stringify(params);
    extend(this, mixin);
  }

  // Perform a channel action with the optional data passed as an attribute
  perform(action, data = {}) {
    data.action = action;
    return this.send(data);
  }
  send(data) {
    return this.consumer.send({
      command: "message",
      identifier: this.identifier,
      data: JSON.stringify(data)
    });
  }
  unsubscribe() {
    return this.consumer.subscriptions.remove(this);
  }
}

// Responsible for ensuring channel subscribe command is confirmed, retrying until confirmation is received.
// Internal class, not intended for direct user manipulation.

class SubscriptionGuarantor {
  constructor(subscriptions) {
    this.subscriptions = subscriptions;
    this.pendingSubscriptions = [];
  }
  guarantee(subscription) {
    if (this.pendingSubscriptions.indexOf(subscription) == -1) {
      logger.log(`SubscriptionGuarantor guaranteeing ${subscription.identifier}`);
      this.pendingSubscriptions.push(subscription);
    } else {
      logger.log(`SubscriptionGuarantor already guaranteeing ${subscription.identifier}`);
    }
    this.startGuaranteeing();
  }
  forget(subscription) {
    logger.log(`SubscriptionGuarantor forgetting ${subscription.identifier}`);
    this.pendingSubscriptions = this.pendingSubscriptions.filter(s => s !== subscription);
  }
  startGuaranteeing() {
    this.stopGuaranteeing();
    this.retrySubscribing();
  }
  stopGuaranteeing() {
    clearTimeout(this.retryTimeout);
  }
  retrySubscribing() {
    this.retryTimeout = setTimeout(() => {
      if (this.subscriptions && typeof this.subscriptions.subscribe === "function") {
        this.pendingSubscriptions.map(subscription => {
          logger.log(`SubscriptionGuarantor resubscribing ${subscription.identifier}`);
          this.subscriptions.subscribe(subscription);
        });
      }
    }, 500);
  }
}
var SubscriptionGuarantor$1 = SubscriptionGuarantor;

// Collection class for creating (and internally managing) channel subscriptions.
// The only method intended to be triggered by the user is ActionCable.Subscriptions#create,
// and it should be called through the consumer like so:
//
//   App = {}
//   App.cable = ActionCable.createConsumer("ws://example.com/accounts/1")
//   App.appearance = App.cable.subscriptions.create("AppearanceChannel")
//
// For more details on how you'd configure an actual channel subscription, see ActionCable.Subscription.

class Subscriptions {
  constructor(consumer) {
    this.consumer = consumer;
    this.guarantor = new SubscriptionGuarantor$1(this);
    this.subscriptions = [];
  }
  create(channelName, mixin) {
    const channel = channelName;
    const params = typeof channel === "object" ? channel : {
      channel
    };
    const subscription = new Subscription(this.consumer, params, mixin);
    return this.add(subscription);
  }

  // Private

  add(subscription) {
    this.subscriptions.push(subscription);
    this.consumer.ensureActiveConnection();
    this.notify(subscription, "initialized");
    this.subscribe(subscription);
    return subscription;
  }
  remove(subscription) {
    this.forget(subscription);
    if (!this.findAll(subscription.identifier).length) {
      this.sendCommand(subscription, "unsubscribe");
    }
    return subscription;
  }
  reject(identifier) {
    return this.findAll(identifier).map(subscription => {
      this.forget(subscription);
      this.notify(subscription, "rejected");
      return subscription;
    });
  }
  forget(subscription) {
    this.guarantor.forget(subscription);
    this.subscriptions = this.subscriptions.filter(s => s !== subscription);
    return subscription;
  }
  findAll(identifier) {
    return this.subscriptions.filter(s => s.identifier === identifier);
  }
  reload() {
    return this.subscriptions.map(subscription => this.subscribe(subscription));
  }
  notifyAll(callbackName, ...args) {
    return this.subscriptions.map(subscription => this.notify(subscription, callbackName, ...args));
  }
  notify(subscription, callbackName, ...args) {
    let subscriptions;
    if (typeof subscription === "string") {
      subscriptions = this.findAll(subscription);
    } else {
      subscriptions = [subscription];
    }
    return subscriptions.map(subscription => typeof subscription[callbackName] === "function" ? subscription[callbackName](...args) : undefined);
  }
  subscribe(subscription) {
    if (this.sendCommand(subscription, "subscribe")) {
      this.guarantor.guarantee(subscription);
    }
  }
  confirmSubscription(identifier) {
    logger.log(`Subscription confirmed ${identifier}`);
    this.findAll(identifier).map(subscription => this.guarantor.forget(subscription));
  }
  sendCommand(subscription, command) {
    const {
      identifier
    } = subscription;
    return this.consumer.send({
      command,
      identifier
    });
  }
}

// The ActionCable.Consumer establishes the connection to a server-side Ruby Connection object. Once established,
// the ActionCable.ConnectionMonitor will ensure that its properly maintained through heartbeats and checking for stale updates.
// The Consumer instance is also the gateway to establishing subscriptions to desired channels through the #createSubscription
// method.
//
// The following example shows how this can be set up:
//
//   App = {}
//   App.cable = ActionCable.createConsumer("ws://example.com/accounts/1")
//   App.appearance = App.cable.subscriptions.create("AppearanceChannel")
//
// For more details on how you'd configure an actual channel subscription, see ActionCable.Subscription.
//
// When a consumer is created, it automatically connects with the server.
//
// To disconnect from the server, call
//
//   App.cable.disconnect()
//
// and to restart the connection:
//
//   App.cable.connect()
//
// Any channel subscriptions which existed prior to disconnecting will
// automatically resubscribe.

class Consumer {
  constructor(url) {
    this._url = url;
    this.subscriptions = new Subscriptions(this);
    this.connection = new Connection$1(this);
  }
  get url() {
    return createWebSocketURL(this._url);
  }
  send(data) {
    return this.connection.send(data);
  }
  connect() {
    return this.connection.open();
  }
  disconnect() {
    return this.connection.close({
      allowReconnect: false
    });
  }
  ensureActiveConnection() {
    if (!this.connection.isActive()) {
      return this.connection.open();
    }
  }
}
function createWebSocketURL(url) {
  if (typeof url === "function") {
    url = url();
  }
  if (url && !/^wss?:/i.test(url)) {
    const a = document.createElement("a");
    a.href = url;
    // Fix populating Location properties in IE. Otherwise, protocol will be blank.
    a.href = a.href;
    a.protocol = a.protocol.replace("http", "ws");
    return a.href;
  } else {
    return url;
  }
}

function createConsumer(url = getConfig("url") || INTERNAL.default_mount_path) {
  return new Consumer(url);
}
function getConfig(name) {
  const element = document.head.querySelector(`meta[name='action-cable-${name}']`);
  if (element) {
    return element.getAttribute("content");
  }
}

var index = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Connection: Connection$1,
	ConnectionMonitor: ConnectionMonitor$1,
	Consumer: Consumer,
	INTERNAL: INTERNAL,
	Subscription: Subscription,
	Subscriptions: Subscriptions,
	SubscriptionGuarantor: SubscriptionGuarantor$1,
	adapters: adapters,
	createWebSocketURL: createWebSocketURL,
	logger: logger,
	createConsumer: createConsumer,
	getConfig: getConfig
});
//# sourceMappingURL=built.js.map
