var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var check = function (it) {
  return it && it.Math == Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global$J =
// eslint-disable-next-line es-x/no-global-this -- safe
check(typeof globalThis == 'object' && globalThis) || check(typeof window == 'object' && window) ||
// eslint-disable-next-line no-restricted-globals -- safe
check(typeof self == 'object' && self) || check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||
// eslint-disable-next-line no-new-func -- fallback
function () {
  return this;
}() || Function('return this')();

var objectGetOwnPropertyDescriptor = {};

var fails$j = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};

var fails$i = fails$j;

// Detect IE8's incomplete defineProperty implementation
var descriptors = !fails$i(function () {
  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing
  return Object.defineProperty({}, 1, {
    get: function () {
      return 7;
    }
  })[1] != 7;
});

var fails$h = fails$j;
var functionBindNative = !fails$h(function () {
  // eslint-disable-next-line es-x/no-function-prototype-bind -- safe
  var test = function () {/* empty */}.bind();
  // eslint-disable-next-line no-prototype-builtins -- safe
  return typeof test != 'function' || test.hasOwnProperty('prototype');
});

var NATIVE_BIND$3 = functionBindNative;
var call$h = Function.prototype.call;
var functionCall = NATIVE_BIND$3 ? call$h.bind(call$h) : function () {
  return call$h.apply(call$h, arguments);
};

var objectPropertyIsEnumerable = {};

var $propertyIsEnumerable = {}.propertyIsEnumerable;
// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor$3 = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor$3 && !$propertyIsEnumerable.call({
  1: 2
}, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
objectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor$3(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;

var createPropertyDescriptor$6 = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

var NATIVE_BIND$2 = functionBindNative;
var FunctionPrototype$2 = Function.prototype;
var bind$9 = FunctionPrototype$2.bind;
var call$g = FunctionPrototype$2.call;
var uncurryThis$l = NATIVE_BIND$2 && bind$9.bind(call$g, call$g);
var functionUncurryThis = NATIVE_BIND$2 ? function (fn) {
  return fn && uncurryThis$l(fn);
} : function (fn) {
  return fn && function () {
    return call$g.apply(fn, arguments);
  };
};

var uncurryThis$k = functionUncurryThis;
var toString$7 = uncurryThis$k({}.toString);
var stringSlice$2 = uncurryThis$k(''.slice);
var classofRaw$1 = function (it) {
  return stringSlice$2(toString$7(it), 8, -1);
};

var global$I = global$J;
var uncurryThis$j = functionUncurryThis;
var fails$g = fails$j;
var classof$a = classofRaw$1;
var Object$5 = global$I.Object;
var split = uncurryThis$j(''.split);

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var indexedObject = fails$g(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !Object$5('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof$a(it) == 'String' ? split(it, '') : Object$5(it);
} : Object$5;

var global$H = global$J;
var TypeError$f = global$H.TypeError;

// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
var requireObjectCoercible$4 = function (it) {
  if (it == undefined) throw TypeError$f("Can't call method on " + it);
  return it;
};

// toObject with fallback for non-array-like ES3 strings
var IndexedObject$2 = indexedObject;
var requireObjectCoercible$3 = requireObjectCoercible$4;
var toIndexedObject$6 = function (it) {
  return IndexedObject$2(requireObjectCoercible$3(it));
};

// `IsCallable` abstract operation
// https://tc39.es/ecma262/#sec-iscallable
var isCallable$n = function (argument) {
  return typeof argument == 'function';
};

var isCallable$m = isCallable$n;
var isObject$e = function (it) {
  return typeof it == 'object' ? it !== null : isCallable$m(it);
};

var global$G = global$J;
var isCallable$l = isCallable$n;
var aFunction = function (argument) {
  return isCallable$l(argument) ? argument : undefined;
};
var getBuiltIn$a = function (namespace, method) {
  return arguments.length < 2 ? aFunction(global$G[namespace]) : global$G[namespace] && global$G[namespace][method];
};

var uncurryThis$i = functionUncurryThis;
var objectIsPrototypeOf = uncurryThis$i({}.isPrototypeOf);

var getBuiltIn$9 = getBuiltIn$a;
var engineUserAgent = getBuiltIn$9('navigator', 'userAgent') || '';

var global$F = global$J;
var userAgent$4 = engineUserAgent;
var process$3 = global$F.process;
var Deno$1 = global$F.Deno;
var versions = process$3 && process$3.versions || Deno$1 && Deno$1.version;
var v8 = versions && versions.v8;
var match$1, version$1;
if (v8) {
  match$1 = v8.split('.');
  // in old Chrome, versions of V8 isn't V8 = Chrome / 10
  // but their correct versions are not interesting for us
  version$1 = match$1[0] > 0 && match$1[0] < 4 ? 1 : +(match$1[0] + match$1[1]);
}

// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
// so check `userAgent` even if `.v8` exists, but 0
if (!version$1 && userAgent$4) {
  match$1 = userAgent$4.match(/Edge\/(\d+)/);
  if (!match$1 || match$1[1] >= 74) {
    match$1 = userAgent$4.match(/Chrome\/(\d+)/);
    if (match$1) version$1 = +match$1[1];
  }
}
var engineV8Version = version$1;

/* eslint-disable es-x/no-symbol -- required for testing */

var V8_VERSION$1 = engineV8Version;
var fails$f = fails$j;

// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- required for testing
var nativeSymbol = !!Object.getOwnPropertySymbols && !fails$f(function () {
  var symbol = Symbol();
  // Chrome 38 Symbol has incorrect toString conversion
  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||
  // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
  !Symbol.sham && V8_VERSION$1 && V8_VERSION$1 < 41;
});

/* eslint-disable es-x/no-symbol -- required for testing */

var NATIVE_SYMBOL$1 = nativeSymbol;
var useSymbolAsUid = NATIVE_SYMBOL$1 && !Symbol.sham && typeof Symbol.iterator == 'symbol';

var global$E = global$J;
var getBuiltIn$8 = getBuiltIn$a;
var isCallable$k = isCallable$n;
var isPrototypeOf$3 = objectIsPrototypeOf;
var USE_SYMBOL_AS_UID$1 = useSymbolAsUid;
var Object$4 = global$E.Object;
var isSymbol$2 = USE_SYMBOL_AS_UID$1 ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  var $Symbol = getBuiltIn$8('Symbol');
  return isCallable$k($Symbol) && isPrototypeOf$3($Symbol.prototype, Object$4(it));
};

var global$D = global$J;
var String$5 = global$D.String;
var tryToString$4 = function (argument) {
  try {
    return String$5(argument);
  } catch (error) {
    return 'Object';
  }
};

var global$C = global$J;
var isCallable$j = isCallable$n;
var tryToString$3 = tryToString$4;
var TypeError$e = global$C.TypeError;

// `Assert: IsCallable(argument) is true`
var aCallable$9 = function (argument) {
  if (isCallable$j(argument)) return argument;
  throw TypeError$e(tryToString$3(argument) + ' is not a function');
};

var aCallable$8 = aCallable$9;

// `GetMethod` abstract operation
// https://tc39.es/ecma262/#sec-getmethod
var getMethod$4 = function (V, P) {
  var func = V[P];
  return func == null ? undefined : aCallable$8(func);
};

var global$B = global$J;
var call$f = functionCall;
var isCallable$i = isCallable$n;
var isObject$d = isObject$e;
var TypeError$d = global$B.TypeError;

// `OrdinaryToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-ordinarytoprimitive
var ordinaryToPrimitive$1 = function (input, pref) {
  var fn, val;
  if (pref === 'string' && isCallable$i(fn = input.toString) && !isObject$d(val = call$f(fn, input))) return val;
  if (isCallable$i(fn = input.valueOf) && !isObject$d(val = call$f(fn, input))) return val;
  if (pref !== 'string' && isCallable$i(fn = input.toString) && !isObject$d(val = call$f(fn, input))) return val;
  throw TypeError$d("Can't convert object to primitive value");
};

var shared$3 = {exports: {}};

var global$A = global$J;

// eslint-disable-next-line es-x/no-object-defineproperty -- safe
var defineProperty$7 = Object.defineProperty;
var defineGlobalProperty$3 = function (key, value) {
  try {
    defineProperty$7(global$A, key, {
      value: value,
      configurable: true,
      writable: true
    });
  } catch (error) {
    global$A[key] = value;
  }
  return value;
};

var global$z = global$J;
var defineGlobalProperty$2 = defineGlobalProperty$3;
var SHARED = '__core-js_shared__';
var store$3 = global$z[SHARED] || defineGlobalProperty$2(SHARED, {});
var sharedStore = store$3;

var store$2 = sharedStore;
(shared$3.exports = function (key, value) {
  return store$2[key] || (store$2[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.22.6',
  mode: 'global',
  copyright: 'Â© 2014-2022 Denis Pushkarev (zloirock.ru)',
  license: 'https://github.com/zloirock/core-js/blob/v3.22.6/LICENSE',
  source: 'https://github.com/zloirock/core-js'
});

var sharedExports = shared$3.exports;

var global$y = global$J;
var requireObjectCoercible$2 = requireObjectCoercible$4;
var Object$3 = global$y.Object;

// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
var toObject$5 = function (argument) {
  return Object$3(requireObjectCoercible$2(argument));
};

var uncurryThis$h = functionUncurryThis;
var toObject$4 = toObject$5;
var hasOwnProperty = uncurryThis$h({}.hasOwnProperty);

// `HasOwnProperty` abstract operation
// https://tc39.es/ecma262/#sec-hasownproperty
// eslint-disable-next-line es-x/no-object-hasown -- safe
var hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty(toObject$4(it), key);
};

var uncurryThis$g = functionUncurryThis;
var id$1 = 0;
var postfix = Math.random();
var toString$6 = uncurryThis$g(1.0.toString);
var uid$3 = function (key) {
  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString$6(++id$1 + postfix, 36);
};

var global$x = global$J;
var shared$2 = sharedExports;
var hasOwn$a = hasOwnProperty_1;
var uid$2 = uid$3;
var NATIVE_SYMBOL = nativeSymbol;
var USE_SYMBOL_AS_UID = useSymbolAsUid;
var WellKnownSymbolsStore = shared$2('wks');
var Symbol$1 = global$x.Symbol;
var symbolFor = Symbol$1 && Symbol$1['for'];
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid$2;
var wellKnownSymbol$h = function (name) {
  if (!hasOwn$a(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {
    var description = 'Symbol.' + name;
    if (NATIVE_SYMBOL && hasOwn$a(Symbol$1, name)) {
      WellKnownSymbolsStore[name] = Symbol$1[name];
    } else if (USE_SYMBOL_AS_UID && symbolFor) {
      WellKnownSymbolsStore[name] = symbolFor(description);
    } else {
      WellKnownSymbolsStore[name] = createWellKnownSymbol(description);
    }
  }
  return WellKnownSymbolsStore[name];
};

var global$w = global$J;
var call$e = functionCall;
var isObject$c = isObject$e;
var isSymbol$1 = isSymbol$2;
var getMethod$3 = getMethod$4;
var ordinaryToPrimitive = ordinaryToPrimitive$1;
var wellKnownSymbol$g = wellKnownSymbol$h;
var TypeError$c = global$w.TypeError;
var TO_PRIMITIVE = wellKnownSymbol$g('toPrimitive');

// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
var toPrimitive$1 = function (input, pref) {
  if (!isObject$c(input) || isSymbol$1(input)) return input;
  var exoticToPrim = getMethod$3(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === undefined) pref = 'default';
    result = call$e(exoticToPrim, input, pref);
    if (!isObject$c(result) || isSymbol$1(result)) return result;
    throw TypeError$c("Can't convert object to primitive value");
  }
  if (pref === undefined) pref = 'number';
  return ordinaryToPrimitive(input, pref);
};

var toPrimitive = toPrimitive$1;
var isSymbol = isSymbol$2;

// `ToPropertyKey` abstract operation
// https://tc39.es/ecma262/#sec-topropertykey
var toPropertyKey$3 = function (argument) {
  var key = toPrimitive(argument, 'string');
  return isSymbol(key) ? key : key + '';
};

var global$v = global$J;
var isObject$b = isObject$e;
var document$3 = global$v.document;
// typeof document.createElement is 'object' in old IE
var EXISTS$1 = isObject$b(document$3) && isObject$b(document$3.createElement);
var documentCreateElement$1 = function (it) {
  return EXISTS$1 ? document$3.createElement(it) : {};
};

var DESCRIPTORS$b = descriptors;
var fails$e = fails$j;
var createElement$2 = documentCreateElement$1;

// Thanks to IE8 for its funny defineProperty
var ie8DomDefine = !DESCRIPTORS$b && !fails$e(function () {
  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing
  return Object.defineProperty(createElement$2('div'), 'a', {
    get: function () {
      return 7;
    }
  }).a != 7;
});

var DESCRIPTORS$a = descriptors;
var call$d = functionCall;
var propertyIsEnumerableModule$1 = objectPropertyIsEnumerable;
var createPropertyDescriptor$5 = createPropertyDescriptor$6;
var toIndexedObject$5 = toIndexedObject$6;
var toPropertyKey$2 = toPropertyKey$3;
var hasOwn$9 = hasOwnProperty_1;
var IE8_DOM_DEFINE$1 = ie8DomDefine;

// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
objectGetOwnPropertyDescriptor.f = DESCRIPTORS$a ? $getOwnPropertyDescriptor$1 : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject$5(O);
  P = toPropertyKey$2(P);
  if (IE8_DOM_DEFINE$1) try {
    return $getOwnPropertyDescriptor$1(O, P);
  } catch (error) {/* empty */}
  if (hasOwn$9(O, P)) return createPropertyDescriptor$5(!call$d(propertyIsEnumerableModule$1.f, O, P), O[P]);
};

var objectDefineProperty = {};

var DESCRIPTORS$9 = descriptors;
var fails$d = fails$j;

// V8 ~ Chrome 36-
// https://bugs.chromium.org/p/v8/issues/detail?id=3334
var v8PrototypeDefineBug = DESCRIPTORS$9 && fails$d(function () {
  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing
  return Object.defineProperty(function () {/* empty */}, 'prototype', {
    value: 42,
    writable: false
  }).prototype != 42;
});

var global$u = global$J;
var isObject$a = isObject$e;
var String$4 = global$u.String;
var TypeError$b = global$u.TypeError;

// `Assert: Type(argument) is Object`
var anObject$b = function (argument) {
  if (isObject$a(argument)) return argument;
  throw TypeError$b(String$4(argument) + ' is not an object');
};

var global$t = global$J;
var DESCRIPTORS$8 = descriptors;
var IE8_DOM_DEFINE = ie8DomDefine;
var V8_PROTOTYPE_DEFINE_BUG$1 = v8PrototypeDefineBug;
var anObject$a = anObject$b;
var toPropertyKey$1 = toPropertyKey$3;
var TypeError$a = global$t.TypeError;
// eslint-disable-next-line es-x/no-object-defineproperty -- safe
var $defineProperty = Object.defineProperty;
// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var ENUMERABLE = 'enumerable';
var CONFIGURABLE$1 = 'configurable';
var WRITABLE = 'writable';

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
objectDefineProperty.f = DESCRIPTORS$8 ? V8_PROTOTYPE_DEFINE_BUG$1 ? function defineProperty(O, P, Attributes) {
  anObject$a(O);
  P = toPropertyKey$1(P);
  anObject$a(Attributes);
  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
    var current = $getOwnPropertyDescriptor(O, P);
    if (current && current[WRITABLE]) {
      O[P] = Attributes.value;
      Attributes = {
        configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],
        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  }
  return $defineProperty(O, P, Attributes);
} : $defineProperty : function defineProperty(O, P, Attributes) {
  anObject$a(O);
  P = toPropertyKey$1(P);
  anObject$a(Attributes);
  if (IE8_DOM_DEFINE) try {
    return $defineProperty(O, P, Attributes);
  } catch (error) {/* empty */}
  if ('get' in Attributes || 'set' in Attributes) throw TypeError$a('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

var DESCRIPTORS$7 = descriptors;
var definePropertyModule$4 = objectDefineProperty;
var createPropertyDescriptor$4 = createPropertyDescriptor$6;
var createNonEnumerableProperty$6 = DESCRIPTORS$7 ? function (object, key, value) {
  return definePropertyModule$4.f(object, key, createPropertyDescriptor$4(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

var makeBuiltIn$2 = {exports: {}};

var DESCRIPTORS$6 = descriptors;
var hasOwn$8 = hasOwnProperty_1;
var FunctionPrototype$1 = Function.prototype;
// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
var getDescriptor = DESCRIPTORS$6 && Object.getOwnPropertyDescriptor;
var EXISTS = hasOwn$8(FunctionPrototype$1, 'name');
// additional protection from minified / mangled / dropped function names
var PROPER = EXISTS && function something() {/* empty */}.name === 'something';
var CONFIGURABLE = EXISTS && (!DESCRIPTORS$6 || DESCRIPTORS$6 && getDescriptor(FunctionPrototype$1, 'name').configurable);
var functionName = {
  EXISTS: EXISTS,
  PROPER: PROPER,
  CONFIGURABLE: CONFIGURABLE
};

var uncurryThis$f = functionUncurryThis;
var isCallable$h = isCallable$n;
var store$1 = sharedStore;
var functionToString = uncurryThis$f(Function.toString);

// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
if (!isCallable$h(store$1.inspectSource)) {
  store$1.inspectSource = function (it) {
    return functionToString(it);
  };
}
var inspectSource$4 = store$1.inspectSource;

var global$s = global$J;
var isCallable$g = isCallable$n;
var inspectSource$3 = inspectSource$4;
var WeakMap$2 = global$s.WeakMap;
var nativeWeakMap = isCallable$g(WeakMap$2) && /native code/.test(inspectSource$3(WeakMap$2));

var shared$1 = sharedExports;
var uid$1 = uid$3;
var keys = shared$1('keys');
var sharedKey$3 = function (key) {
  return keys[key] || (keys[key] = uid$1(key));
};

var hiddenKeys$5 = {};

var NATIVE_WEAK_MAP = nativeWeakMap;
var global$r = global$J;
var uncurryThis$e = functionUncurryThis;
var isObject$9 = isObject$e;
var createNonEnumerableProperty$5 = createNonEnumerableProperty$6;
var hasOwn$7 = hasOwnProperty_1;
var shared = sharedStore;
var sharedKey$2 = sharedKey$3;
var hiddenKeys$4 = hiddenKeys$5;
var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
var TypeError$9 = global$r.TypeError;
var WeakMap$1 = global$r.WeakMap;
var set$1, get, has;
var enforce = function (it) {
  return has(it) ? get(it) : set$1(it, {});
};
var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject$9(it) || (state = get(it)).type !== TYPE) {
      throw TypeError$9('Incompatible receiver, ' + TYPE + ' required');
    }
    return state;
  };
};
if (NATIVE_WEAK_MAP || shared.state) {
  var store = shared.state || (shared.state = new WeakMap$1());
  var wmget = uncurryThis$e(store.get);
  var wmhas = uncurryThis$e(store.has);
  var wmset = uncurryThis$e(store.set);
  set$1 = function (it, metadata) {
    if (wmhas(store, it)) throw new TypeError$9(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    wmset(store, it, metadata);
    return metadata;
  };
  get = function (it) {
    return wmget(store, it) || {};
  };
  has = function (it) {
    return wmhas(store, it);
  };
} else {
  var STATE = sharedKey$2('state');
  hiddenKeys$4[STATE] = true;
  set$1 = function (it, metadata) {
    if (hasOwn$7(it, STATE)) throw new TypeError$9(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty$5(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return hasOwn$7(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return hasOwn$7(it, STATE);
  };
}
var internalState = {
  set: set$1,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};

var fails$c = fails$j;
var isCallable$f = isCallable$n;
var hasOwn$6 = hasOwnProperty_1;
var DESCRIPTORS$5 = descriptors;
var CONFIGURABLE_FUNCTION_NAME$1 = functionName.CONFIGURABLE;
var inspectSource$2 = inspectSource$4;
var InternalStateModule$4 = internalState;
var enforceInternalState = InternalStateModule$4.enforce;
var getInternalState$2 = InternalStateModule$4.get;
// eslint-disable-next-line es-x/no-object-defineproperty -- safe
var defineProperty$6 = Object.defineProperty;
var CONFIGURABLE_LENGTH = DESCRIPTORS$5 && !fails$c(function () {
  return defineProperty$6(function () {/* empty */}, 'length', {
    value: 8
  }).length !== 8;
});
var TEMPLATE = String(String).split('String');
var makeBuiltIn$1 = makeBuiltIn$2.exports = function (value, name, options) {
  if (String(name).slice(0, 7) === 'Symbol(') {
    name = '[' + String(name).replace(/^Symbol\(([^)]*)\)/, '$1') + ']';
  }
  if (options && options.getter) name = 'get ' + name;
  if (options && options.setter) name = 'set ' + name;
  if (!hasOwn$6(value, 'name') || CONFIGURABLE_FUNCTION_NAME$1 && value.name !== name) {
    defineProperty$6(value, 'name', {
      value: name,
      configurable: true
    });
  }
  if (CONFIGURABLE_LENGTH && options && hasOwn$6(options, 'arity') && value.length !== options.arity) {
    defineProperty$6(value, 'length', {
      value: options.arity
    });
  }
  if (options && hasOwn$6(options, 'constructor') && options.constructor) {
    if (DESCRIPTORS$5) try {
      defineProperty$6(value, 'prototype', {
        writable: false
      });
    } catch (error) {/* empty */}
  } else value.prototype = undefined;
  var state = enforceInternalState(value);
  if (!hasOwn$6(state, 'source')) {
    state.source = TEMPLATE.join(typeof name == 'string' ? name : '');
  }
  return value;
};

// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
// eslint-disable-next-line no-extend-native -- required
Function.prototype.toString = makeBuiltIn$1(function toString() {
  return isCallable$f(this) && getInternalState$2(this).source || inspectSource$2(this);
}, 'toString');

var makeBuiltInExports = makeBuiltIn$2.exports;

var isCallable$e = isCallable$n;
var createNonEnumerableProperty$4 = createNonEnumerableProperty$6;
var makeBuiltIn = makeBuiltInExports;
var defineGlobalProperty$1 = defineGlobalProperty$3;
var defineBuiltIn$9 = function (O, key, value, options) {
  if (!options) options = {};
  var simple = options.enumerable;
  var name = options.name !== undefined ? options.name : key;
  if (isCallable$e(value)) makeBuiltIn(value, name, options);
  if (options.global) {
    if (simple) O[key] = value;else defineGlobalProperty$1(key, value);
  } else {
    if (!options.unsafe) delete O[key];else if (O[key]) simple = true;
    if (simple) O[key] = value;else createNonEnumerableProperty$4(O, key, value);
  }
  return O;
};

var objectGetOwnPropertyNames = {};

var ceil = Math.ceil;
var floor = Math.floor;

// `Math.trunc` method
// https://tc39.es/ecma262/#sec-math.trunc
// eslint-disable-next-line es-x/no-math-trunc -- safe
var mathTrunc = Math.trunc || function trunc(x) {
  var n = +x;
  return (n > 0 ? floor : ceil)(n);
};

var trunc = mathTrunc;

// `ToIntegerOrInfinity` abstract operation
// https://tc39.es/ecma262/#sec-tointegerorinfinity
var toIntegerOrInfinity$3 = function (argument) {
  var number = +argument;
  // eslint-disable-next-line no-self-compare -- NaN check
  return number !== number || number === 0 ? 0 : trunc(number);
};

var toIntegerOrInfinity$2 = toIntegerOrInfinity$3;
var max$1 = Math.max;
var min$2 = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
var toAbsoluteIndex$2 = function (index, length) {
  var integer = toIntegerOrInfinity$2(index);
  return integer < 0 ? max$1(integer + length, 0) : min$2(integer, length);
};

var toIntegerOrInfinity$1 = toIntegerOrInfinity$3;
var min$1 = Math.min;

// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
var toLength$2 = function (argument) {
  return argument > 0 ? min$1(toIntegerOrInfinity$1(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};

var toLength$1 = toLength$2;

// `LengthOfArrayLike` abstract operation
// https://tc39.es/ecma262/#sec-lengthofarraylike
var lengthOfArrayLike$5 = function (obj) {
  return toLength$1(obj.length);
};

var toIndexedObject$4 = toIndexedObject$6;
var toAbsoluteIndex$1 = toAbsoluteIndex$2;
var lengthOfArrayLike$4 = lengthOfArrayLike$5;

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod$2 = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject$4($this);
    var length = lengthOfArrayLike$4(O);
    var index = toAbsoluteIndex$1(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare -- NaN check
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare -- NaN check
      if (value != value) return true;
      // Array#indexOf ignores holes, Array#includes - not
    } else for (; length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    }
    return !IS_INCLUDES && -1;
  };
};
var arrayIncludes = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod$2(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod$2(false)
};

var uncurryThis$d = functionUncurryThis;
var hasOwn$5 = hasOwnProperty_1;
var toIndexedObject$3 = toIndexedObject$6;
var indexOf$1 = arrayIncludes.indexOf;
var hiddenKeys$3 = hiddenKeys$5;
var push$2 = uncurryThis$d([].push);
var objectKeysInternal = function (object, names) {
  var O = toIndexedObject$3(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !hasOwn$5(hiddenKeys$3, key) && hasOwn$5(O, key) && push$2(result, key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (hasOwn$5(O, key = names[i++])) {
    ~indexOf$1(result, key) || push$2(result, key);
  }
  return result;
};

// IE8- don't enum bug keys
var enumBugKeys$3 = ['constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf'];

var internalObjectKeys$1 = objectKeysInternal;
var enumBugKeys$2 = enumBugKeys$3;
var hiddenKeys$2 = enumBugKeys$2.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es-x/no-object-getownpropertynames -- safe
objectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys$1(O, hiddenKeys$2);
};

var objectGetOwnPropertySymbols = {};

// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- safe
objectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;

var getBuiltIn$7 = getBuiltIn$a;
var uncurryThis$c = functionUncurryThis;
var getOwnPropertyNamesModule$1 = objectGetOwnPropertyNames;
var getOwnPropertySymbolsModule$1 = objectGetOwnPropertySymbols;
var anObject$9 = anObject$b;
var concat$1 = uncurryThis$c([].concat);

// all object keys, includes non-enumerable and symbols
var ownKeys$3 = getBuiltIn$7('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule$1.f(anObject$9(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule$1.f;
  return getOwnPropertySymbols ? concat$1(keys, getOwnPropertySymbols(it)) : keys;
};

var hasOwn$4 = hasOwnProperty_1;
var ownKeys$2 = ownKeys$3;
var getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;
var definePropertyModule$3 = objectDefineProperty;
var copyConstructorProperties$2 = function (target, source, exceptions) {
  var keys = ownKeys$2(source);
  var defineProperty = definePropertyModule$3.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!hasOwn$4(target, key) && !(exceptions && hasOwn$4(exceptions, key))) {
      defineProperty(target, key, getOwnPropertyDescriptor(source, key));
    }
  }
};

var fails$b = fails$j;
var isCallable$d = isCallable$n;
var replacement = /#|\.prototype\./;
var isForced$3 = function (feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true : value == NATIVE ? false : isCallable$d(detection) ? fails$b(detection) : !!detection;
};
var normalize = isForced$3.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};
var data = isForced$3.data = {};
var NATIVE = isForced$3.NATIVE = 'N';
var POLYFILL = isForced$3.POLYFILL = 'P';
var isForced_1 = isForced$3;

var global$q = global$J;
var getOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;
var createNonEnumerableProperty$3 = createNonEnumerableProperty$6;
var defineBuiltIn$8 = defineBuiltIn$9;
var defineGlobalProperty = defineGlobalProperty$3;
var copyConstructorProperties$1 = copyConstructorProperties$2;
var isForced$2 = isForced_1;

/*
  options.target         - name of the target object
  options.global         - target is the global object
  options.stat           - export as static methods of target
  options.proto          - export as prototype methods of target
  options.real           - real prototype method for the `pure` version
  options.forced         - export even if the native feature is available
  options.bind           - bind methods to the target, required for the `pure` version
  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe         - use the simple assignment of property instead of delete + defineProperty
  options.sham           - add a flag to not completely full polyfills
  options.enumerable     - export as enumerable property
  options.dontCallGetSet - prevent calling a getter on target
  options.name           - the .name of the function if it does not match the key
*/
var _export = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global$q;
  } else if (STATIC) {
    target = global$q[TARGET] || defineGlobalProperty(TARGET, {});
  } else {
    target = (global$q[TARGET] || {}).prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.dontCallGetSet) {
      descriptor = getOwnPropertyDescriptor$2(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced$2(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty == typeof targetProperty) continue;
      copyConstructorProperties$1(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || targetProperty && targetProperty.sham) {
      createNonEnumerableProperty$3(sourceProperty, 'sham', true);
    }
    defineBuiltIn$8(target, key, sourceProperty, options);
  }
};

var uncurryThis$b = functionUncurryThis;
var aCallable$7 = aCallable$9;
var NATIVE_BIND$1 = functionBindNative;
var bind$8 = uncurryThis$b(uncurryThis$b.bind);

// optional / simple context binding
var functionBindContext = function (fn, that) {
  aCallable$7(fn);
  return that === undefined ? fn : NATIVE_BIND$1 ? bind$8(fn, that) : function /* ...args */
  () {
    return fn.apply(that, arguments);
  };
};

var classof$9 = classofRaw$1;

// `IsArray` abstract operation
// https://tc39.es/ecma262/#sec-isarray
// eslint-disable-next-line es-x/no-array-isarray -- safe
var isArray$2 = Array.isArray || function isArray(argument) {
  return classof$9(argument) == 'Array';
};

var wellKnownSymbol$f = wellKnownSymbol$h;
var TO_STRING_TAG$3 = wellKnownSymbol$f('toStringTag');
var test = {};
test[TO_STRING_TAG$3] = 'z';
var toStringTagSupport = String(test) === '[object z]';

var global$p = global$J;
var TO_STRING_TAG_SUPPORT$2 = toStringTagSupport;
var isCallable$c = isCallable$n;
var classofRaw = classofRaw$1;
var wellKnownSymbol$e = wellKnownSymbol$h;
var TO_STRING_TAG$2 = wellKnownSymbol$e('toStringTag');
var Object$2 = global$p.Object;

// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () {
  return arguments;
}()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) {/* empty */}
};

// getting tag from ES6+ `Object.prototype.toString`
var classof$8 = TO_STRING_TAG_SUPPORT$2 ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
  // @@toStringTag case
  : typeof (tag = tryGet(O = Object$2(it), TO_STRING_TAG$2)) == 'string' ? tag
  // builtinTag case
  : CORRECT_ARGUMENTS ? classofRaw(O)
  // ES3 arguments fallback
  : (result = classofRaw(O)) == 'Object' && isCallable$c(O.callee) ? 'Arguments' : result;
};

var uncurryThis$a = functionUncurryThis;
var fails$a = fails$j;
var isCallable$b = isCallable$n;
var classof$7 = classof$8;
var getBuiltIn$6 = getBuiltIn$a;
var inspectSource$1 = inspectSource$4;
var noop$2 = function () {/* empty */};
var empty = [];
var construct = getBuiltIn$6('Reflect', 'construct');
var constructorRegExp = /^\s*(?:class|function)\b/;
var exec = uncurryThis$a(constructorRegExp.exec);
var INCORRECT_TO_STRING = !constructorRegExp.exec(noop$2);
var isConstructorModern = function isConstructor(argument) {
  if (!isCallable$b(argument)) return false;
  try {
    construct(noop$2, empty, argument);
    return true;
  } catch (error) {
    return false;
  }
};
var isConstructorLegacy = function isConstructor(argument) {
  if (!isCallable$b(argument)) return false;
  switch (classof$7(argument)) {
    case 'AsyncFunction':
    case 'GeneratorFunction':
    case 'AsyncGeneratorFunction':
      return false;
  }
  try {
    // we can't check .prototype since constructors produced by .bind haven't it
    // `Function#toString` throws on some built-it function in some legacy engines
    // (for example, `DOMQuad` and similar in FF41-)
    return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource$1(argument));
  } catch (error) {
    return true;
  }
};
isConstructorLegacy.sham = true;

// `IsConstructor` abstract operation
// https://tc39.es/ecma262/#sec-isconstructor
var isConstructor$3 = !construct || fails$a(function () {
  var called;
  return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function () {
    called = true;
  }) || called;
}) ? isConstructorLegacy : isConstructorModern;

var global$o = global$J;
var isArray$1 = isArray$2;
var isConstructor$2 = isConstructor$3;
var isObject$8 = isObject$e;
var wellKnownSymbol$d = wellKnownSymbol$h;
var SPECIES$3 = wellKnownSymbol$d('species');
var Array$3 = global$o.Array;

// a part of `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
var arraySpeciesConstructor$1 = function (originalArray) {
  var C;
  if (isArray$1(originalArray)) {
    C = originalArray.constructor;
    // cross-realm fallback
    if (isConstructor$2(C) && (C === Array$3 || isArray$1(C.prototype))) C = undefined;else if (isObject$8(C)) {
      C = C[SPECIES$3];
      if (C === null) C = undefined;
    }
  }
  return C === undefined ? Array$3 : C;
};

var arraySpeciesConstructor = arraySpeciesConstructor$1;

// `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
var arraySpeciesCreate$1 = function (originalArray, length) {
  return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
};

var bind$7 = functionBindContext;
var uncurryThis$9 = functionUncurryThis;
var IndexedObject$1 = indexedObject;
var toObject$3 = toObject$5;
var lengthOfArrayLike$3 = lengthOfArrayLike$5;
var arraySpeciesCreate = arraySpeciesCreate$1;
var push$1 = uncurryThis$9([].push);

// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation
var createMethod$1 = function (TYPE) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var IS_FILTER_REJECT = TYPE == 7;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  return function ($this, callbackfn, that, specificCreate) {
    var O = toObject$3($this);
    var self = IndexedObject$1(O);
    var boundFunction = bind$7(callbackfn, that);
    var length = lengthOfArrayLike$3(self);
    var index = 0;
    var create = specificCreate || arraySpeciesCreate;
    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;
    var value, result;
    for (; length > index; index++) if (NO_HOLES || index in self) {
      value = self[index];
      result = boundFunction(value, index, O);
      if (TYPE) {
        if (IS_MAP) target[index] = result; // map
        else if (result) switch (TYPE) {
          case 3:
            return true;
          // some
          case 5:
            return value;
          // find
          case 6:
            return index;
          // findIndex
          case 2:
            push$1(target, value);
          // filter
        } else switch (TYPE) {
          case 4:
            return false;
          // every
          case 7:
            push$1(target, value);
          // filterReject
        }
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};
var arrayIteration = {
  // `Array.prototype.forEach` method
  // https://tc39.es/ecma262/#sec-array.prototype.foreach
  forEach: createMethod$1(0),
  // `Array.prototype.map` method
  // https://tc39.es/ecma262/#sec-array.prototype.map
  map: createMethod$1(1),
  // `Array.prototype.filter` method
  // https://tc39.es/ecma262/#sec-array.prototype.filter
  filter: createMethod$1(2),
  // `Array.prototype.some` method
  // https://tc39.es/ecma262/#sec-array.prototype.some
  some: createMethod$1(3),
  // `Array.prototype.every` method
  // https://tc39.es/ecma262/#sec-array.prototype.every
  every: createMethod$1(4),
  // `Array.prototype.find` method
  // https://tc39.es/ecma262/#sec-array.prototype.find
  find: createMethod$1(5),
  // `Array.prototype.findIndex` method
  // https://tc39.es/ecma262/#sec-array.prototype.findIndex
  findIndex: createMethod$1(6),
  // `Array.prototype.filterReject` method
  // https://github.com/tc39/proposal-array-filtering
  filterReject: createMethod$1(7)
};

var objectDefineProperties = {};

var internalObjectKeys = objectKeysInternal;
var enumBugKeys$1 = enumBugKeys$3;

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
// eslint-disable-next-line es-x/no-object-keys -- safe
var objectKeys$2 = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys$1);
};

var DESCRIPTORS$4 = descriptors;
var V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;
var definePropertyModule$2 = objectDefineProperty;
var anObject$8 = anObject$b;
var toIndexedObject$2 = toIndexedObject$6;
var objectKeys$1 = objectKeys$2;

// `Object.defineProperties` method
// https://tc39.es/ecma262/#sec-object.defineproperties
// eslint-disable-next-line es-x/no-object-defineproperties -- safe
objectDefineProperties.f = DESCRIPTORS$4 && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject$8(O);
  var props = toIndexedObject$2(Properties);
  var keys = objectKeys$1(Properties);
  var length = keys.length;
  var index = 0;
  var key;
  while (length > index) definePropertyModule$2.f(O, key = keys[index++], props[key]);
  return O;
};

var getBuiltIn$5 = getBuiltIn$a;
var html$2 = getBuiltIn$5('document', 'documentElement');

/* global ActiveXObject -- old IE, WSH */

var anObject$7 = anObject$b;
var definePropertiesModule = objectDefineProperties;
var enumBugKeys = enumBugKeys$3;
var hiddenKeys$1 = hiddenKeys$5;
var html$1 = html$2;
var documentCreateElement = documentCreateElement$1;
var sharedKey$1 = sharedKey$3;
var GT = '>';
var LT = '<';
var PROTOTYPE = 'prototype';
var SCRIPT = 'script';
var IE_PROTO$1 = sharedKey$1('IE_PROTO');
var EmptyConstructor = function () {/* empty */};
var scriptTag = function (content) {
  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
};

// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
var NullProtoObjectViaActiveX = function (activeXDocument) {
  activeXDocument.write(scriptTag(''));
  activeXDocument.close();
  var temp = activeXDocument.parentWindow.Object;
  activeXDocument = null; // avoid memory leak
  return temp;
};

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var NullProtoObjectViaIFrame = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var JS = 'java' + SCRIPT + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html$1.appendChild(iframe);
  // https://github.com/zloirock/core-js/issues/475
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag('document.F=Object'));
  iframeDocument.close();
  return iframeDocument.F;
};

// Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug
var activeXDocument;
var NullProtoObject = function () {
  try {
    activeXDocument = new ActiveXObject('htmlfile');
  } catch (error) {/* ignore */}
  NullProtoObject = typeof document != 'undefined' ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) // old IE
  : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument); // WSH
  var length = enumBugKeys.length;
  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
  return NullProtoObject();
};
hiddenKeys$1[IE_PROTO$1] = true;

// `Object.create` method
// https://tc39.es/ecma262/#sec-object.create
// eslint-disable-next-line es-x/no-object-create -- safe
var objectCreate = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    EmptyConstructor[PROTOTYPE] = anObject$7(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO$1] = O;
  } else result = NullProtoObject();
  return Properties === undefined ? result : definePropertiesModule.f(result, Properties);
};

var wellKnownSymbol$c = wellKnownSymbol$h;
var create$3 = objectCreate;
var defineProperty$5 = objectDefineProperty.f;
var UNSCOPABLES = wellKnownSymbol$c('unscopables');
var ArrayPrototype$1 = Array.prototype;

// Array.prototype[@@unscopables]
// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
if (ArrayPrototype$1[UNSCOPABLES] == undefined) {
  defineProperty$5(ArrayPrototype$1, UNSCOPABLES, {
    configurable: true,
    value: create$3(null)
  });
}

// add a key to Array.prototype[@@unscopables]
var addToUnscopables$3 = function (key) {
  ArrayPrototype$1[UNSCOPABLES][key] = true;
};

var $$p = _export;
var $find = arrayIteration.find;
var addToUnscopables$2 = addToUnscopables$3;
var FIND = 'find';
var SKIPS_HOLES$1 = true;

// Shouldn't skip holes
if (FIND in []) Array(1)[FIND](function () {
  SKIPS_HOLES$1 = false;
});

// `Array.prototype.find` method
// https://tc39.es/ecma262/#sec-array.prototype.find
$$p({
  target: 'Array',
  proto: true,
  forced: SKIPS_HOLES$1
}, {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables$2(FIND);

var global$n = global$J;
var uncurryThis$8 = functionUncurryThis;
var entryUnbind$3 = function (CONSTRUCTOR, METHOD) {
  return uncurryThis$8(global$n[CONSTRUCTOR].prototype[METHOD]);
};

var entryUnbind$2 = entryUnbind$3;
entryUnbind$2('Array', 'find');

var $$o = _export;
var $findIndex = arrayIteration.findIndex;
var addToUnscopables$1 = addToUnscopables$3;
var FIND_INDEX = 'findIndex';
var SKIPS_HOLES = true;

// Shouldn't skip holes
if (FIND_INDEX in []) Array(1)[FIND_INDEX](function () {
  SKIPS_HOLES = false;
});

// `Array.prototype.findIndex` method
// https://tc39.es/ecma262/#sec-array.prototype.findindex
$$o({
  target: 'Array',
  proto: true,
  forced: SKIPS_HOLES
}, {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
    return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables$1(FIND_INDEX);

var entryUnbind$1 = entryUnbind$3;
entryUnbind$1('Array', 'findIndex');

var global$m = global$J;
var classof$6 = classof$8;
var String$3 = global$m.String;
var toString$5 = function (argument) {
  if (classof$6(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');
  return String$3(argument);
};

var uncurryThis$7 = functionUncurryThis;
var toIntegerOrInfinity = toIntegerOrInfinity$3;
var toString$4 = toString$5;
var requireObjectCoercible$1 = requireObjectCoercible$4;
var charAt$1 = uncurryThis$7(''.charAt);
var charCodeAt = uncurryThis$7(''.charCodeAt);
var stringSlice$1 = uncurryThis$7(''.slice);
var createMethod = function (CONVERT_TO_STRING) {
  return function ($this, pos) {
    var S = toString$4(requireObjectCoercible$1($this));
    var position = toIntegerOrInfinity(pos);
    var size = S.length;
    var first, second;
    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
    first = charCodeAt(S, position);
    return first < 0xD800 || first > 0xDBFF || position + 1 === size || (second = charCodeAt(S, position + 1)) < 0xDC00 || second > 0xDFFF ? CONVERT_TO_STRING ? charAt$1(S, position) : first : CONVERT_TO_STRING ? stringSlice$1(S, position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
  };
};
var stringMultibyte = {
  // `String.prototype.codePointAt` method
  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
  codeAt: createMethod(false),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: createMethod(true)
};

var fails$9 = fails$j;
var correctPrototypeGetter = !fails$9(function () {
  function F() {/* empty */}
  F.prototype.constructor = null;
  // eslint-disable-next-line es-x/no-object-getprototypeof -- required for testing
  return Object.getPrototypeOf(new F()) !== F.prototype;
});

var global$l = global$J;
var hasOwn$3 = hasOwnProperty_1;
var isCallable$a = isCallable$n;
var toObject$2 = toObject$5;
var sharedKey = sharedKey$3;
var CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;
var IE_PROTO = sharedKey('IE_PROTO');
var Object$1 = global$l.Object;
var ObjectPrototype = Object$1.prototype;

// `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof
var objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER ? Object$1.getPrototypeOf : function (O) {
  var object = toObject$2(O);
  if (hasOwn$3(object, IE_PROTO)) return object[IE_PROTO];
  var constructor = object.constructor;
  if (isCallable$a(constructor) && object instanceof constructor) {
    return constructor.prototype;
  }
  return object instanceof Object$1 ? ObjectPrototype : null;
};

var fails$8 = fails$j;
var isCallable$9 = isCallable$n;
var getPrototypeOf$2 = objectGetPrototypeOf;
var defineBuiltIn$7 = defineBuiltIn$9;
var wellKnownSymbol$b = wellKnownSymbol$h;
var ITERATOR$4 = wellKnownSymbol$b('iterator');
var BUGGY_SAFARI_ITERATORS$1 = false;

// `%IteratorPrototype%` object
// https://tc39.es/ecma262/#sec-%iteratorprototype%-object
var IteratorPrototype$2, PrototypeOfArrayIteratorPrototype, arrayIterator;

/* eslint-disable es-x/no-array-prototype-keys -- safe */
if ([].keys) {
  arrayIterator = [].keys();
  // Safari 8 has buggy iterators w/o `next`
  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS$1 = true;else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf$2(getPrototypeOf$2(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype$2 = PrototypeOfArrayIteratorPrototype;
  }
}
var NEW_ITERATOR_PROTOTYPE = IteratorPrototype$2 == undefined || fails$8(function () {
  var test = {};
  // FF44- legacy iterators case
  return IteratorPrototype$2[ITERATOR$4].call(test) !== test;
});
if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype$2 = {};

// `%IteratorPrototype%[@@iterator]()` method
// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator
if (!isCallable$9(IteratorPrototype$2[ITERATOR$4])) {
  defineBuiltIn$7(IteratorPrototype$2, ITERATOR$4, function () {
    return this;
  });
}
var iteratorsCore = {
  IteratorPrototype: IteratorPrototype$2,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1
};

var defineProperty$4 = objectDefineProperty.f;
var hasOwn$2 = hasOwnProperty_1;
var wellKnownSymbol$a = wellKnownSymbol$h;
var TO_STRING_TAG$1 = wellKnownSymbol$a('toStringTag');
var setToStringTag$4 = function (target, TAG, STATIC) {
  if (target && !STATIC) target = target.prototype;
  if (target && !hasOwn$2(target, TO_STRING_TAG$1)) {
    defineProperty$4(target, TO_STRING_TAG$1, {
      configurable: true,
      value: TAG
    });
  }
};

var iterators = {};

var IteratorPrototype$1 = iteratorsCore.IteratorPrototype;
var create$2 = objectCreate;
var createPropertyDescriptor$3 = createPropertyDescriptor$6;
var setToStringTag$3 = setToStringTag$4;
var Iterators$4 = iterators;
var returnThis$1 = function () {
  return this;
};
var createIteratorConstructor$1 = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
  var TO_STRING_TAG = NAME + ' Iterator';
  IteratorConstructor.prototype = create$2(IteratorPrototype$1, {
    next: createPropertyDescriptor$3(+!ENUMERABLE_NEXT, next)
  });
  setToStringTag$3(IteratorConstructor, TO_STRING_TAG, false);
  Iterators$4[TO_STRING_TAG] = returnThis$1;
  return IteratorConstructor;
};

var global$k = global$J;
var isCallable$8 = isCallable$n;
var String$2 = global$k.String;
var TypeError$8 = global$k.TypeError;
var aPossiblePrototype$1 = function (argument) {
  if (typeof argument == 'object' || isCallable$8(argument)) return argument;
  throw TypeError$8("Can't set " + String$2(argument) + ' as a prototype');
};

/* eslint-disable no-proto -- safe */

var uncurryThis$6 = functionUncurryThis;
var anObject$6 = anObject$b;
var aPossiblePrototype = aPossiblePrototype$1;

// `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
// eslint-disable-next-line es-x/no-object-setprototypeof -- safe
var objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;
  try {
    // eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
    setter = uncurryThis$6(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set);
    setter(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) {/* empty */}
  return function setPrototypeOf(O, proto) {
    anObject$6(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER) setter(O, proto);else O.__proto__ = proto;
    return O;
  };
}() : undefined);

var $$n = _export;
var call$c = functionCall;
var FunctionName = functionName;
var isCallable$7 = isCallable$n;
var createIteratorConstructor = createIteratorConstructor$1;
var getPrototypeOf$1 = objectGetPrototypeOf;
var setPrototypeOf$3 = objectSetPrototypeOf;
var setToStringTag$2 = setToStringTag$4;
var createNonEnumerableProperty$2 = createNonEnumerableProperty$6;
var defineBuiltIn$6 = defineBuiltIn$9;
var wellKnownSymbol$9 = wellKnownSymbol$h;
var Iterators$3 = iterators;
var IteratorsCore = iteratorsCore;
var PROPER_FUNCTION_NAME = FunctionName.PROPER;
var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
var IteratorPrototype = IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR$3 = wellKnownSymbol$9('iterator');
var KEYS = 'keys';
var VALUES = 'values';
var ENTRIES = 'entries';
var returnThis = function () {
  return this;
};
var defineIterator$3 = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
  createIteratorConstructor(IteratorConstructor, NAME, next);
  var getIterationMethod = function (KIND) {
    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
    switch (KIND) {
      case KEYS:
        return function keys() {
          return new IteratorConstructor(this, KIND);
        };
      case VALUES:
        return function values() {
          return new IteratorConstructor(this, KIND);
        };
      case ENTRIES:
        return function entries() {
          return new IteratorConstructor(this, KIND);
        };
    }
    return function () {
      return new IteratorConstructor(this);
    };
  };
  var TO_STRING_TAG = NAME + ' Iterator';
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR$3] || IterablePrototype['@@iterator'] || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY;

  // fix native
  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf$1(anyNativeIterator.call(new Iterable()));
    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
      if (getPrototypeOf$1(CurrentIteratorPrototype) !== IteratorPrototype) {
        if (setPrototypeOf$3) {
          setPrototypeOf$3(CurrentIteratorPrototype, IteratorPrototype);
        } else if (!isCallable$7(CurrentIteratorPrototype[ITERATOR$3])) {
          defineBuiltIn$6(CurrentIteratorPrototype, ITERATOR$3, returnThis);
        }
      }
      // Set @@toStringTag to native iterators
      setToStringTag$2(CurrentIteratorPrototype, TO_STRING_TAG, true);
    }
  }

  // fix Array.prototype.{ values, @@iterator }.name in V8 / FF
  if (PROPER_FUNCTION_NAME && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    if (CONFIGURABLE_FUNCTION_NAME) {
      createNonEnumerableProperty$2(IterablePrototype, 'name', VALUES);
    } else {
      INCORRECT_VALUES_NAME = true;
      defaultIterator = function values() {
        return call$c(nativeIterator, this);
      };
    }
  }

  // export additional methods
  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED) for (KEY in methods) {
      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
        defineBuiltIn$6(IterablePrototype, KEY, methods[KEY]);
      }
    } else $$n({
      target: NAME,
      proto: true,
      forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME
    }, methods);
  }

  // define iterator
  if (IterablePrototype[ITERATOR$3] !== defaultIterator) {
    defineBuiltIn$6(IterablePrototype, ITERATOR$3, defaultIterator, {
      name: DEFAULT
    });
  }
  Iterators$3[NAME] = defaultIterator;
  return methods;
};

var charAt = stringMultibyte.charAt;
var toString$3 = toString$5;
var InternalStateModule$3 = internalState;
var defineIterator$2 = defineIterator$3;
var STRING_ITERATOR = 'String Iterator';
var setInternalState$3 = InternalStateModule$3.set;
var getInternalState$1 = InternalStateModule$3.getterFor(STRING_ITERATOR);

// `String.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-string.prototype-@@iterator
defineIterator$2(String, 'String', function (iterated) {
  setInternalState$3(this, {
    type: STRING_ITERATOR,
    string: toString$3(iterated),
    index: 0
  });
  // `%StringIteratorPrototype%.next` method
  // https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
}, function next() {
  var state = getInternalState$1(this);
  var string = state.string;
  var index = state.index;
  var point;
  if (index >= string.length) return {
    value: undefined,
    done: true
  };
  point = charAt(string, index);
  state.index += point.length;
  return {
    value: point,
    done: false
  };
});

var call$b = functionCall;
var anObject$5 = anObject$b;
var getMethod$2 = getMethod$4;
var iteratorClose$2 = function (iterator, kind, value) {
  var innerResult, innerError;
  anObject$5(iterator);
  try {
    innerResult = getMethod$2(iterator, 'return');
    if (!innerResult) {
      if (kind === 'throw') throw value;
      return value;
    }
    innerResult = call$b(innerResult, iterator);
  } catch (error) {
    innerError = true;
    innerResult = error;
  }
  if (kind === 'throw') throw value;
  if (innerError) throw innerResult;
  anObject$5(innerResult);
  return value;
};

var anObject$4 = anObject$b;
var iteratorClose$1 = iteratorClose$2;

// call something on iterator step with safe closing on error
var callWithSafeIterationClosing$1 = function (iterator, fn, value, ENTRIES) {
  try {
    return ENTRIES ? fn(anObject$4(value)[0], value[1]) : fn(value);
  } catch (error) {
    iteratorClose$1(iterator, 'throw', error);
  }
};

var wellKnownSymbol$8 = wellKnownSymbol$h;
var Iterators$2 = iterators;
var ITERATOR$2 = wellKnownSymbol$8('iterator');
var ArrayPrototype = Array.prototype;

// check on default Array iterator
var isArrayIteratorMethod$2 = function (it) {
  return it !== undefined && (Iterators$2.Array === it || ArrayPrototype[ITERATOR$2] === it);
};

var toPropertyKey = toPropertyKey$3;
var definePropertyModule$1 = objectDefineProperty;
var createPropertyDescriptor$2 = createPropertyDescriptor$6;
var createProperty$2 = function (object, key, value) {
  var propertyKey = toPropertyKey(key);
  if (propertyKey in object) definePropertyModule$1.f(object, propertyKey, createPropertyDescriptor$2(0, value));else object[propertyKey] = value;
};

var classof$5 = classof$8;
var getMethod$1 = getMethod$4;
var Iterators$1 = iterators;
var wellKnownSymbol$7 = wellKnownSymbol$h;
var ITERATOR$1 = wellKnownSymbol$7('iterator');
var getIteratorMethod$3 = function (it) {
  if (it != undefined) return getMethod$1(it, ITERATOR$1) || getMethod$1(it, '@@iterator') || Iterators$1[classof$5(it)];
};

var global$j = global$J;
var call$a = functionCall;
var aCallable$6 = aCallable$9;
var anObject$3 = anObject$b;
var tryToString$2 = tryToString$4;
var getIteratorMethod$2 = getIteratorMethod$3;
var TypeError$7 = global$j.TypeError;
var getIterator$2 = function (argument, usingIterator) {
  var iteratorMethod = arguments.length < 2 ? getIteratorMethod$2(argument) : usingIterator;
  if (aCallable$6(iteratorMethod)) return anObject$3(call$a(iteratorMethod, argument));
  throw TypeError$7(tryToString$2(argument) + ' is not iterable');
};

var global$i = global$J;
var bind$6 = functionBindContext;
var call$9 = functionCall;
var toObject$1 = toObject$5;
var callWithSafeIterationClosing = callWithSafeIterationClosing$1;
var isArrayIteratorMethod$1 = isArrayIteratorMethod$2;
var isConstructor$1 = isConstructor$3;
var lengthOfArrayLike$2 = lengthOfArrayLike$5;
var createProperty$1 = createProperty$2;
var getIterator$1 = getIterator$2;
var getIteratorMethod$1 = getIteratorMethod$3;
var Array$2 = global$i.Array;

// `Array.from` method implementation
// https://tc39.es/ecma262/#sec-array.from
var arrayFrom = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
  var O = toObject$1(arrayLike);
  var IS_CONSTRUCTOR = isConstructor$1(this);
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
  var mapping = mapfn !== undefined;
  if (mapping) mapfn = bind$6(mapfn, argumentsLength > 2 ? arguments[2] : undefined);
  var iteratorMethod = getIteratorMethod$1(O);
  var index = 0;
  var length, result, step, iterator, next, value;
  // if the target is not iterable or it's an array with the default iterator - use a simple case
  if (iteratorMethod && !(this == Array$2 && isArrayIteratorMethod$1(iteratorMethod))) {
    iterator = getIterator$1(O, iteratorMethod);
    next = iterator.next;
    result = IS_CONSTRUCTOR ? new this() : [];
    for (; !(step = call$9(next, iterator)).done; index++) {
      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
      createProperty$1(result, index, value);
    }
  } else {
    length = lengthOfArrayLike$2(O);
    result = IS_CONSTRUCTOR ? new this(length) : Array$2(length);
    for (; length > index; index++) {
      value = mapping ? mapfn(O[index], index) : O[index];
      createProperty$1(result, index, value);
    }
  }
  result.length = index;
  return result;
};

var wellKnownSymbol$6 = wellKnownSymbol$h;
var ITERATOR = wellKnownSymbol$6('iterator');
var SAFE_CLOSING = false;
try {
  var called = 0;
  var iteratorWithReturn = {
    next: function () {
      return {
        done: !!called++
      };
    },
    'return': function () {
      SAFE_CLOSING = true;
    }
  };
  iteratorWithReturn[ITERATOR] = function () {
    return this;
  };
  // eslint-disable-next-line es-x/no-array-from, no-throw-literal -- required for testing
  Array.from(iteratorWithReturn, function () {
    throw 2;
  });
} catch (error) {/* empty */}
var checkCorrectnessOfIteration$3 = function (exec, SKIP_CLOSING) {
  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
  var ITERATION_SUPPORT = false;
  try {
    var object = {};
    object[ITERATOR] = function () {
      return {
        next: function () {
          return {
            done: ITERATION_SUPPORT = true
          };
        }
      };
    };
    exec(object);
  } catch (error) {/* empty */}
  return ITERATION_SUPPORT;
};

var $$m = _export;
var from = arrayFrom;
var checkCorrectnessOfIteration$2 = checkCorrectnessOfIteration$3;
var INCORRECT_ITERATION = !checkCorrectnessOfIteration$2(function (iterable) {
  // eslint-disable-next-line es-x/no-array-from -- required for testing
  Array.from(iterable);
});

// `Array.from` method
// https://tc39.es/ecma262/#sec-array.from
$$m({
  target: 'Array',
  stat: true,
  forced: INCORRECT_ITERATION
}, {
  from: from
});

var global$h = global$J;
var path$5 = global$h;

var path$4 = path$5;
path$4.Array.from;

var toIndexedObject$1 = toIndexedObject$6;
var addToUnscopables = addToUnscopables$3;
var Iterators = iterators;
var InternalStateModule$2 = internalState;
var defineProperty$3 = objectDefineProperty.f;
var defineIterator$1 = defineIterator$3;
var DESCRIPTORS$3 = descriptors;
var ARRAY_ITERATOR = 'Array Iterator';
var setInternalState$2 = InternalStateModule$2.set;
var getInternalState = InternalStateModule$2.getterFor(ARRAY_ITERATOR);

// `Array.prototype.entries` method
// https://tc39.es/ecma262/#sec-array.prototype.entries
// `Array.prototype.keys` method
// https://tc39.es/ecma262/#sec-array.prototype.keys
// `Array.prototype.values` method
// https://tc39.es/ecma262/#sec-array.prototype.values
// `Array.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-array.prototype-@@iterator
// `CreateArrayIterator` internal method
// https://tc39.es/ecma262/#sec-createarrayiterator
defineIterator$1(Array, 'Array', function (iterated, kind) {
  setInternalState$2(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject$1(iterated),
    // target
    index: 0,
    // next index
    kind: kind // kind
  });
  // `%ArrayIteratorPrototype%.next` method
  // https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
}, function () {
  var state = getInternalState(this);
  var target = state.target;
  var kind = state.kind;
  var index = state.index++;
  if (!target || index >= target.length) {
    state.target = undefined;
    return {
      value: undefined,
      done: true
    };
  }
  if (kind == 'keys') return {
    value: index,
    done: false
  };
  if (kind == 'values') return {
    value: target[index],
    done: false
  };
  return {
    value: [index, target[index]],
    done: false
  };
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values%
// https://tc39.es/ecma262/#sec-createunmappedargumentsobject
// https://tc39.es/ecma262/#sec-createmappedargumentsobject
var values = Iterators.Arguments = Iterators.Array;

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

// V8 ~ Chrome 45- bug
if (DESCRIPTORS$3 && values.name !== 'values') try {
  defineProperty$3(values, 'name', {
    value: 'values'
  });
} catch (error) {/* empty */}

var internalMetadata = {exports: {}};

var objectGetOwnPropertyNamesExternal = {};

var global$g = global$J;
var toAbsoluteIndex = toAbsoluteIndex$2;
var lengthOfArrayLike$1 = lengthOfArrayLike$5;
var createProperty = createProperty$2;
var Array$1 = global$g.Array;
var max = Math.max;
var arraySliceSimple = function (O, start, end) {
  var length = lengthOfArrayLike$1(O);
  var k = toAbsoluteIndex(start, length);
  var fin = toAbsoluteIndex(end === undefined ? length : end, length);
  var result = Array$1(max(fin - k, 0));
  for (var n = 0; k < fin; k++, n++) createProperty(result, n, O[k]);
  result.length = n;
  return result;
};

/* eslint-disable es-x/no-object-getownpropertynames -- safe */

var classof$4 = classofRaw$1;
var toIndexedObject = toIndexedObject$6;
var $getOwnPropertyNames = objectGetOwnPropertyNames.f;
var arraySlice$2 = arraySliceSimple;
var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
var getWindowNames = function (it) {
  try {
    return $getOwnPropertyNames(it);
  } catch (error) {
    return arraySlice$2(windowNames);
  }
};

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
objectGetOwnPropertyNamesExternal.f = function getOwnPropertyNames(it) {
  return windowNames && classof$4(it) == 'Window' ? getWindowNames(it) : $getOwnPropertyNames(toIndexedObject(it));
};

// FF26- bug: ArrayBuffers are non-extensible, but Object.isExtensible does not report it
var fails$7 = fails$j;
var arrayBufferNonExtensible = fails$7(function () {
  if (typeof ArrayBuffer == 'function') {
    var buffer = new ArrayBuffer(8);
    // eslint-disable-next-line es-x/no-object-isextensible, es-x/no-object-defineproperty -- safe
    if (Object.isExtensible(buffer)) Object.defineProperty(buffer, 'a', {
      value: 8
    });
  }
});

var fails$6 = fails$j;
var isObject$7 = isObject$e;
var classof$3 = classofRaw$1;
var ARRAY_BUFFER_NON_EXTENSIBLE = arrayBufferNonExtensible;

// eslint-disable-next-line es-x/no-object-isextensible -- safe
var $isExtensible = Object.isExtensible;
var FAILS_ON_PRIMITIVES = fails$6(function () {
  $isExtensible(1);
});

// `Object.isExtensible` method
// https://tc39.es/ecma262/#sec-object.isextensible
var objectIsExtensible = FAILS_ON_PRIMITIVES || ARRAY_BUFFER_NON_EXTENSIBLE ? function isExtensible(it) {
  if (!isObject$7(it)) return false;
  if (ARRAY_BUFFER_NON_EXTENSIBLE && classof$3(it) == 'ArrayBuffer') return false;
  return $isExtensible ? $isExtensible(it) : true;
} : $isExtensible;

var fails$5 = fails$j;
var freezing = !fails$5(function () {
  // eslint-disable-next-line es-x/no-object-isextensible, es-x/no-object-preventextensions -- required for testing
  return Object.isExtensible(Object.preventExtensions({}));
});

var $$l = _export;
var uncurryThis$5 = functionUncurryThis;
var hiddenKeys = hiddenKeys$5;
var isObject$6 = isObject$e;
var hasOwn$1 = hasOwnProperty_1;
var defineProperty$2 = objectDefineProperty.f;
var getOwnPropertyNamesModule = objectGetOwnPropertyNames;
var getOwnPropertyNamesExternalModule = objectGetOwnPropertyNamesExternal;
var isExtensible = objectIsExtensible;
var uid = uid$3;
var FREEZING = freezing;
var REQUIRED = false;
var METADATA = uid('meta');
var id = 0;
var setMetadata = function (it) {
  defineProperty$2(it, METADATA, {
    value: {
      objectID: 'O' + id++,
      // object ID
      weakData: {} // weak collections IDs
    }
  });
};
var fastKey$1 = function (it, create) {
  // return a primitive with prefix
  if (!isObject$6(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!hasOwn$1(it, METADATA)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMetadata(it);
    // return object ID
  }
  return it[METADATA].objectID;
};
var getWeakData = function (it, create) {
  if (!hasOwn$1(it, METADATA)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMetadata(it);
    // return the store of weak collections IDs
  }
  return it[METADATA].weakData;
};

// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZING && REQUIRED && isExtensible(it) && !hasOwn$1(it, METADATA)) setMetadata(it);
  return it;
};
var enable = function () {
  meta.enable = function () {/* empty */};
  REQUIRED = true;
  var getOwnPropertyNames = getOwnPropertyNamesModule.f;
  var splice = uncurryThis$5([].splice);
  var test = {};
  test[METADATA] = 1;

  // prevent exposing of metadata key
  if (getOwnPropertyNames(test).length) {
    getOwnPropertyNamesModule.f = function (it) {
      var result = getOwnPropertyNames(it);
      for (var i = 0, length = result.length; i < length; i++) {
        if (result[i] === METADATA) {
          splice(result, i, 1);
          break;
        }
      }
      return result;
    };
    $$l({
      target: 'Object',
      stat: true,
      forced: true
    }, {
      getOwnPropertyNames: getOwnPropertyNamesExternalModule.f
    });
  }
};
var meta = internalMetadata.exports = {
  enable: enable,
  fastKey: fastKey$1,
  getWeakData: getWeakData,
  onFreeze: onFreeze
};
hiddenKeys[METADATA] = true;

var internalMetadataExports = internalMetadata.exports;

var global$f = global$J;
var bind$5 = functionBindContext;
var call$8 = functionCall;
var anObject$2 = anObject$b;
var tryToString$1 = tryToString$4;
var isArrayIteratorMethod = isArrayIteratorMethod$2;
var lengthOfArrayLike = lengthOfArrayLike$5;
var isPrototypeOf$2 = objectIsPrototypeOf;
var getIterator = getIterator$2;
var getIteratorMethod = getIteratorMethod$3;
var iteratorClose = iteratorClose$2;
var TypeError$6 = global$f.TypeError;
var Result = function (stopped, result) {
  this.stopped = stopped;
  this.result = result;
};
var ResultPrototype = Result.prototype;
var iterate$7 = function (iterable, unboundFunction, options) {
  var that = options && options.that;
  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
  var INTERRUPTED = !!(options && options.INTERRUPTED);
  var fn = bind$5(unboundFunction, that);
  var iterator, iterFn, index, length, result, next, step;
  var stop = function (condition) {
    if (iterator) iteratorClose(iterator, 'normal', condition);
    return new Result(true, condition);
  };
  var callFn = function (value) {
    if (AS_ENTRIES) {
      anObject$2(value);
      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
    }
    return INTERRUPTED ? fn(value, stop) : fn(value);
  };
  if (IS_ITERATOR) {
    iterator = iterable;
  } else {
    iterFn = getIteratorMethod(iterable);
    if (!iterFn) throw TypeError$6(tryToString$1(iterable) + ' is not iterable');
    // optimisation for array iterators
    if (isArrayIteratorMethod(iterFn)) {
      for (index = 0, length = lengthOfArrayLike(iterable); length > index; index++) {
        result = callFn(iterable[index]);
        if (result && isPrototypeOf$2(ResultPrototype, result)) return result;
      }
      return new Result(false);
    }
    iterator = getIterator(iterable, iterFn);
  }
  next = iterator.next;
  while (!(step = call$8(next, iterator)).done) {
    try {
      result = callFn(step.value);
    } catch (error) {
      iteratorClose(iterator, 'throw', error);
    }
    if (typeof result == 'object' && result && isPrototypeOf$2(ResultPrototype, result)) return result;
  }
  return new Result(false);
};

var global$e = global$J;
var isPrototypeOf$1 = objectIsPrototypeOf;
var TypeError$5 = global$e.TypeError;
var anInstance$3 = function (it, Prototype) {
  if (isPrototypeOf$1(Prototype, it)) return it;
  throw TypeError$5('Incorrect invocation');
};

var isCallable$6 = isCallable$n;
var isObject$5 = isObject$e;
var setPrototypeOf$2 = objectSetPrototypeOf;

// makes subclassing work correct for wrapped built-ins
var inheritIfRequired$1 = function ($this, dummy, Wrapper) {
  var NewTarget, NewTargetPrototype;
  if (
  // it can work only with native `setPrototypeOf`
  setPrototypeOf$2 &&
  // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
  isCallable$6(NewTarget = dummy.constructor) && NewTarget !== Wrapper && isObject$5(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype) setPrototypeOf$2($this, NewTargetPrototype);
  return $this;
};

var $$k = _export;
var global$d = global$J;
var uncurryThis$4 = functionUncurryThis;
var isForced$1 = isForced_1;
var defineBuiltIn$5 = defineBuiltIn$9;
var InternalMetadataModule = internalMetadataExports;
var iterate$6 = iterate$7;
var anInstance$2 = anInstance$3;
var isCallable$5 = isCallable$n;
var isObject$4 = isObject$e;
var fails$4 = fails$j;
var checkCorrectnessOfIteration$1 = checkCorrectnessOfIteration$3;
var setToStringTag$1 = setToStringTag$4;
var inheritIfRequired = inheritIfRequired$1;
var collection$2 = function (CONSTRUCTOR_NAME, wrapper, common) {
  var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;
  var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;
  var ADDER = IS_MAP ? 'set' : 'add';
  var NativeConstructor = global$d[CONSTRUCTOR_NAME];
  var NativePrototype = NativeConstructor && NativeConstructor.prototype;
  var Constructor = NativeConstructor;
  var exported = {};
  var fixMethod = function (KEY) {
    var uncurriedNativeMethod = uncurryThis$4(NativePrototype[KEY]);
    defineBuiltIn$5(NativePrototype, KEY, KEY == 'add' ? function add(value) {
      uncurriedNativeMethod(this, value === 0 ? 0 : value);
      return this;
    } : KEY == 'delete' ? function (key) {
      return IS_WEAK && !isObject$4(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
    } : KEY == 'get' ? function get(key) {
      return IS_WEAK && !isObject$4(key) ? undefined : uncurriedNativeMethod(this, key === 0 ? 0 : key);
    } : KEY == 'has' ? function has(key) {
      return IS_WEAK && !isObject$4(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
    } : function set(key, value) {
      uncurriedNativeMethod(this, key === 0 ? 0 : key, value);
      return this;
    });
  };
  var REPLACE = isForced$1(CONSTRUCTOR_NAME, !isCallable$5(NativeConstructor) || !(IS_WEAK || NativePrototype.forEach && !fails$4(function () {
    new NativeConstructor().entries().next();
  })));
  if (REPLACE) {
    // create collection constructor
    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
    InternalMetadataModule.enable();
  } else if (isForced$1(CONSTRUCTOR_NAME, true)) {
    var instance = new Constructor();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~ Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails$4(function () {
      instance.has(1);
    });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    // eslint-disable-next-line no-new -- required for testing
    var ACCEPT_ITERABLES = checkCorrectnessOfIteration$1(function (iterable) {
      new NativeConstructor(iterable);
    });
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails$4(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new NativeConstructor();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });
    if (!ACCEPT_ITERABLES) {
      Constructor = wrapper(function (dummy, iterable) {
        anInstance$2(dummy, NativePrototype);
        var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
        if (iterable != undefined) iterate$6(iterable, that[ADDER], {
          that: that,
          AS_ENTRIES: IS_MAP
        });
        return that;
      });
      Constructor.prototype = NativePrototype;
      NativePrototype.constructor = Constructor;
    }
    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);

    // weak collections should not contains .clear method
    if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;
  }
  exported[CONSTRUCTOR_NAME] = Constructor;
  $$k({
    global: true,
    constructor: true,
    forced: Constructor != NativeConstructor
  }, exported);
  setToStringTag$1(Constructor, CONSTRUCTOR_NAME);
  if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);
  return Constructor;
};

var defineBuiltIn$4 = defineBuiltIn$9;
var defineBuiltIns$1 = function (target, src, options) {
  for (var key in src) defineBuiltIn$4(target, key, src[key], options);
  return target;
};

var getBuiltIn$4 = getBuiltIn$a;
var definePropertyModule = objectDefineProperty;
var wellKnownSymbol$5 = wellKnownSymbol$h;
var DESCRIPTORS$2 = descriptors;
var SPECIES$2 = wellKnownSymbol$5('species');
var setSpecies$2 = function (CONSTRUCTOR_NAME) {
  var Constructor = getBuiltIn$4(CONSTRUCTOR_NAME);
  var defineProperty = definePropertyModule.f;
  if (DESCRIPTORS$2 && Constructor && !Constructor[SPECIES$2]) {
    defineProperty(Constructor, SPECIES$2, {
      configurable: true,
      get: function () {
        return this;
      }
    });
  }
};

var defineProperty$1 = objectDefineProperty.f;
var create$1 = objectCreate;
var defineBuiltIns = defineBuiltIns$1;
var bind$4 = functionBindContext;
var anInstance$1 = anInstance$3;
var iterate$5 = iterate$7;
var defineIterator = defineIterator$3;
var setSpecies$1 = setSpecies$2;
var DESCRIPTORS$1 = descriptors;
var fastKey = internalMetadataExports.fastKey;
var InternalStateModule$1 = internalState;
var setInternalState$1 = InternalStateModule$1.set;
var internalStateGetterFor = InternalStateModule$1.getterFor;
var collectionStrong$2 = {
  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
    var Constructor = wrapper(function (that, iterable) {
      anInstance$1(that, Prototype);
      setInternalState$1(that, {
        type: CONSTRUCTOR_NAME,
        index: create$1(null),
        first: undefined,
        last: undefined,
        size: 0
      });
      if (!DESCRIPTORS$1) that.size = 0;
      if (iterable != undefined) iterate$5(iterable, that[ADDER], {
        that: that,
        AS_ENTRIES: IS_MAP
      });
    });
    var Prototype = Constructor.prototype;
    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);
    var define = function (that, key, value) {
      var state = getInternalState(that);
      var entry = getEntry(that, key);
      var previous, index;
      // change existing entry
      if (entry) {
        entry.value = value;
        // create new entry
      } else {
        state.last = entry = {
          index: index = fastKey(key, true),
          key: key,
          value: value,
          previous: previous = state.last,
          next: undefined,
          removed: false
        };
        if (!state.first) state.first = entry;
        if (previous) previous.next = entry;
        if (DESCRIPTORS$1) state.size++;else that.size++;
        // add to index
        if (index !== 'F') state.index[index] = entry;
      }
      return that;
    };
    var getEntry = function (that, key) {
      var state = getInternalState(that);
      // fast case
      var index = fastKey(key);
      var entry;
      if (index !== 'F') return state.index[index];
      // frozen object case
      for (entry = state.first; entry; entry = entry.next) {
        if (entry.key == key) return entry;
      }
    };
    defineBuiltIns(Prototype, {
      // `{ Map, Set }.prototype.clear()` methods
      // https://tc39.es/ecma262/#sec-map.prototype.clear
      // https://tc39.es/ecma262/#sec-set.prototype.clear
      clear: function clear() {
        var that = this;
        var state = getInternalState(that);
        var data = state.index;
        var entry = state.first;
        while (entry) {
          entry.removed = true;
          if (entry.previous) entry.previous = entry.previous.next = undefined;
          delete data[entry.index];
          entry = entry.next;
        }
        state.first = state.last = undefined;
        if (DESCRIPTORS$1) state.size = 0;else that.size = 0;
      },
      // `{ Map, Set }.prototype.delete(key)` methods
      // https://tc39.es/ecma262/#sec-map.prototype.delete
      // https://tc39.es/ecma262/#sec-set.prototype.delete
      'delete': function (key) {
        var that = this;
        var state = getInternalState(that);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.next;
          var prev = entry.previous;
          delete state.index[entry.index];
          entry.removed = true;
          if (prev) prev.next = next;
          if (next) next.previous = prev;
          if (state.first == entry) state.first = next;
          if (state.last == entry) state.last = prev;
          if (DESCRIPTORS$1) state.size--;else that.size--;
        }
        return !!entry;
      },
      // `{ Map, Set }.prototype.forEach(callbackfn, thisArg = undefined)` methods
      // https://tc39.es/ecma262/#sec-map.prototype.foreach
      // https://tc39.es/ecma262/#sec-set.prototype.foreach
      forEach: function forEach(callbackfn /* , that = undefined */) {
        var state = getInternalState(this);
        var boundFunction = bind$4(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
        var entry;
        while (entry = entry ? entry.next : state.first) {
          boundFunction(entry.value, entry.key, this);
          // revert to the last existing entry
          while (entry && entry.removed) entry = entry.previous;
        }
      },
      // `{ Map, Set}.prototype.has(key)` methods
      // https://tc39.es/ecma262/#sec-map.prototype.has
      // https://tc39.es/ecma262/#sec-set.prototype.has
      has: function has(key) {
        return !!getEntry(this, key);
      }
    });
    defineBuiltIns(Prototype, IS_MAP ? {
      // `Map.prototype.get(key)` method
      // https://tc39.es/ecma262/#sec-map.prototype.get
      get: function get(key) {
        var entry = getEntry(this, key);
        return entry && entry.value;
      },
      // `Map.prototype.set(key, value)` method
      // https://tc39.es/ecma262/#sec-map.prototype.set
      set: function set(key, value) {
        return define(this, key === 0 ? 0 : key, value);
      }
    } : {
      // `Set.prototype.add(value)` method
      // https://tc39.es/ecma262/#sec-set.prototype.add
      add: function add(value) {
        return define(this, value = value === 0 ? 0 : value, value);
      }
    });
    if (DESCRIPTORS$1) defineProperty$1(Prototype, 'size', {
      get: function () {
        return getInternalState(this).size;
      }
    });
    return Constructor;
  },
  setStrong: function (Constructor, CONSTRUCTOR_NAME, IS_MAP) {
    var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';
    var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
    var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);
    // `{ Map, Set }.prototype.{ keys, values, entries, @@iterator }()` methods
    // https://tc39.es/ecma262/#sec-map.prototype.entries
    // https://tc39.es/ecma262/#sec-map.prototype.keys
    // https://tc39.es/ecma262/#sec-map.prototype.values
    // https://tc39.es/ecma262/#sec-map.prototype-@@iterator
    // https://tc39.es/ecma262/#sec-set.prototype.entries
    // https://tc39.es/ecma262/#sec-set.prototype.keys
    // https://tc39.es/ecma262/#sec-set.prototype.values
    // https://tc39.es/ecma262/#sec-set.prototype-@@iterator
    defineIterator(Constructor, CONSTRUCTOR_NAME, function (iterated, kind) {
      setInternalState$1(this, {
        type: ITERATOR_NAME,
        target: iterated,
        state: getInternalCollectionState(iterated),
        kind: kind,
        last: undefined
      });
    }, function () {
      var state = getInternalIteratorState(this);
      var kind = state.kind;
      var entry = state.last;
      // revert to the last existing entry
      while (entry && entry.removed) entry = entry.previous;
      // get next entry
      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
        // or finish the iteration
        state.target = undefined;
        return {
          value: undefined,
          done: true
        };
      }
      // return step by kind
      if (kind == 'keys') return {
        value: entry.key,
        done: false
      };
      if (kind == 'values') return {
        value: entry.value,
        done: false
      };
      return {
        value: [entry.key, entry.value],
        done: false
      };
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // `{ Map, Set }.prototype[@@species]` accessors
    // https://tc39.es/ecma262/#sec-get-map-@@species
    // https://tc39.es/ecma262/#sec-get-set-@@species
    setSpecies$1(CONSTRUCTOR_NAME);
  }
};

var collection$1 = collection$2;
var collectionStrong$1 = collectionStrong$2;

// `Map` constructor
// https://tc39.es/ecma262/#sec-map-objects
collection$1('Map', function (init) {
  return function Map() {
    return init(this, arguments.length ? arguments[0] : undefined);
  };
}, collectionStrong$1);

var TO_STRING_TAG_SUPPORT$1 = toStringTagSupport;
var classof$2 = classof$8;

// `Object.prototype.toString` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.tostring
var objectToString = TO_STRING_TAG_SUPPORT$1 ? {}.toString : function toString() {
  return '[object ' + classof$2(this) + ']';
};

var TO_STRING_TAG_SUPPORT = toStringTagSupport;
var defineBuiltIn$3 = defineBuiltIn$9;
var toString$2 = objectToString;

// `Object.prototype.toString` method
// https://tc39.es/ecma262/#sec-object.prototype.tostring
if (!TO_STRING_TAG_SUPPORT) {
  defineBuiltIn$3(Object.prototype, 'toString', toString$2, {
    unsafe: true
  });
}

var path$3 = path$5;
path$3.Map;

var DESCRIPTORS = descriptors;
var uncurryThis$3 = functionUncurryThis;
var call$7 = functionCall;
var fails$3 = fails$j;
var objectKeys = objectKeys$2;
var getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;
var propertyIsEnumerableModule = objectPropertyIsEnumerable;
var toObject = toObject$5;
var IndexedObject = indexedObject;

// eslint-disable-next-line es-x/no-object-assign -- safe
var $assign = Object.assign;
// eslint-disable-next-line es-x/no-object-defineproperty -- required for testing
var defineProperty = Object.defineProperty;
var concat = uncurryThis$3([].concat);

// `Object.assign` method
// https://tc39.es/ecma262/#sec-object.assign
var objectAssign = !$assign || fails$3(function () {
  // should have correct order of operations (Edge bug)
  if (DESCRIPTORS && $assign({
    b: 1
  }, $assign(defineProperty({}, 'a', {
    enumerable: true,
    get: function () {
      defineProperty(this, 'b', {
        value: 3,
        enumerable: false
      });
    }
  }), {
    b: 2
  })).b !== 1) return true;
  // should work with symbols and should have deterministic property order (V8 bug)
  var A = {};
  var B = {};
  // eslint-disable-next-line es-x/no-symbol -- safe
  var symbol = Symbol();
  var alphabet = 'abcdefghijklmnopqrst';
  A[symbol] = 7;
  alphabet.split('').forEach(function (chr) {
    B[chr] = chr;
  });
  return $assign({}, A)[symbol] != 7 || objectKeys($assign({}, B)).join('') != alphabet;
}) ? function assign(target, source) {
  // eslint-disable-line no-unused-vars -- required for `.length`
  var T = toObject(target);
  var argumentsLength = arguments.length;
  var index = 1;
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  var propertyIsEnumerable = propertyIsEnumerableModule.f;
  while (argumentsLength > index) {
    var S = IndexedObject(arguments[index++]);
    var keys = getOwnPropertySymbols ? concat(objectKeys(S), getOwnPropertySymbols(S)) : objectKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS || call$7(propertyIsEnumerable, S, key)) T[key] = S[key];
    }
  }
  return T;
} : $assign;

var $$j = _export;
var assign$1 = objectAssign;

// `Object.assign` method
// https://tc39.es/ecma262/#sec-object.assign
// eslint-disable-next-line es-x/no-object-assign -- required for testing
$$j({
  target: 'Object',
  stat: true,
  arity: 2,
  forced: Object.assign !== assign$1
}, {
  assign: assign$1
});

var path$2 = path$5;
path$2.Object.assign;

var uncurryThis$2 = functionUncurryThis;
var $Error = Error;
var replace = uncurryThis$2(''.replace);
var TEST = function (arg) {
  return String($Error(arg).stack);
}('zxcasd');
var V8_OR_CHAKRA_STACK_ENTRY = /\n\s*at [^:]*:[^\n]*/;
var IS_V8_OR_CHAKRA_STACK = V8_OR_CHAKRA_STACK_ENTRY.test(TEST);
var clearErrorStack$1 = function (stack, dropEntries) {
  if (IS_V8_OR_CHAKRA_STACK && typeof stack == 'string' && !$Error.prepareStackTrace) {
    while (dropEntries--) stack = replace(stack, V8_OR_CHAKRA_STACK_ENTRY, '');
  }
  return stack;
};

var isObject$3 = isObject$e;
var createNonEnumerableProperty$1 = createNonEnumerableProperty$6;

// `InstallErrorCause` abstract operation
// https://tc39.es/proposal-error-cause/#sec-errorobjects-install-error-cause
var installErrorCause$1 = function (O, options) {
  if (isObject$3(options) && 'cause' in options) {
    createNonEnumerableProperty$1(O, 'cause', options.cause);
  }
};

var toString$1 = toString$5;
var normalizeStringArgument$1 = function (argument, $default) {
  return argument === undefined ? arguments.length < 2 ? '' : $default : toString$1(argument);
};

var fails$2 = fails$j;
var createPropertyDescriptor$1 = createPropertyDescriptor$6;
var errorStackInstallable = !fails$2(function () {
  var error = Error('a');
  if (!('stack' in error)) return true;
  // eslint-disable-next-line es-x/no-object-defineproperty -- safe
  Object.defineProperty(error, 'stack', createPropertyDescriptor$1(1, 7));
  return error.stack !== 7;
});

var $$i = _export;
var global$c = global$J;
var isPrototypeOf = objectIsPrototypeOf;
var getPrototypeOf = objectGetPrototypeOf;
var setPrototypeOf$1 = objectSetPrototypeOf;
var copyConstructorProperties = copyConstructorProperties$2;
var create = objectCreate;
var createNonEnumerableProperty = createNonEnumerableProperty$6;
var createPropertyDescriptor = createPropertyDescriptor$6;
var clearErrorStack = clearErrorStack$1;
var installErrorCause = installErrorCause$1;
var iterate$4 = iterate$7;
var normalizeStringArgument = normalizeStringArgument$1;
var wellKnownSymbol$4 = wellKnownSymbol$h;
var ERROR_STACK_INSTALLABLE = errorStackInstallable;
var TO_STRING_TAG = wellKnownSymbol$4('toStringTag');
var Error$1 = global$c.Error;
var push = [].push;
var $AggregateError = function AggregateError(errors, message /* , options */) {
  var options = arguments.length > 2 ? arguments[2] : undefined;
  var isInstance = isPrototypeOf(AggregateErrorPrototype, this);
  var that;
  if (setPrototypeOf$1) {
    that = setPrototypeOf$1(new Error$1(), isInstance ? getPrototypeOf(this) : AggregateErrorPrototype);
  } else {
    that = isInstance ? this : create(AggregateErrorPrototype);
    createNonEnumerableProperty(that, TO_STRING_TAG, 'Error');
  }
  if (message !== undefined) createNonEnumerableProperty(that, 'message', normalizeStringArgument(message));
  if (ERROR_STACK_INSTALLABLE) createNonEnumerableProperty(that, 'stack', clearErrorStack(that.stack, 1));
  installErrorCause(that, options);
  var errorsArray = [];
  iterate$4(errors, push, {
    that: errorsArray
  });
  createNonEnumerableProperty(that, 'errors', errorsArray);
  return that;
};
if (setPrototypeOf$1) setPrototypeOf$1($AggregateError, Error$1);else copyConstructorProperties($AggregateError, Error$1, {
  name: true
});
var AggregateErrorPrototype = $AggregateError.prototype = create(Error$1.prototype, {
  constructor: createPropertyDescriptor(1, $AggregateError),
  message: createPropertyDescriptor(1, ''),
  name: createPropertyDescriptor(1, 'AggregateError')
});

// `AggregateError` constructor
// https://tc39.es/ecma262/#sec-aggregate-error-constructor
$$i({
  global: true,
  constructor: true,
  arity: 2
}, {
  AggregateError: $AggregateError
});

var classof$1 = classofRaw$1;
var global$b = global$J;
var engineIsNode = classof$1(global$b.process) == 'process';

var global$a = global$J;
var isConstructor = isConstructor$3;
var tryToString = tryToString$4;
var TypeError$4 = global$a.TypeError;

// `Assert: IsConstructor(argument) is true`
var aConstructor$1 = function (argument) {
  if (isConstructor(argument)) return argument;
  throw TypeError$4(tryToString(argument) + ' is not a constructor');
};

var anObject$1 = anObject$b;
var aConstructor = aConstructor$1;
var wellKnownSymbol$3 = wellKnownSymbol$h;
var SPECIES$1 = wellKnownSymbol$3('species');

// `SpeciesConstructor` abstract operation
// https://tc39.es/ecma262/#sec-speciesconstructor
var speciesConstructor$2 = function (O, defaultConstructor) {
  var C = anObject$1(O).constructor;
  var S;
  return C === undefined || (S = anObject$1(C)[SPECIES$1]) == undefined ? defaultConstructor : aConstructor(S);
};

var NATIVE_BIND = functionBindNative;
var FunctionPrototype = Function.prototype;
var apply$1 = FunctionPrototype.apply;
var call$6 = FunctionPrototype.call;

// eslint-disable-next-line es-x/no-reflect -- safe
var functionApply = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND ? call$6.bind(apply$1) : function () {
  return call$6.apply(apply$1, arguments);
});

var uncurryThis$1 = functionUncurryThis;
var arraySlice$1 = uncurryThis$1([].slice);

var global$9 = global$J;
var TypeError$3 = global$9.TypeError;
var validateArgumentsLength$1 = function (passed, required) {
  if (passed < required) throw TypeError$3('Not enough arguments');
  return passed;
};

var userAgent$3 = engineUserAgent;
var engineIsIos = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent$3);

var global$8 = global$J;
var apply = functionApply;
var bind$3 = functionBindContext;
var isCallable$4 = isCallable$n;
var hasOwn = hasOwnProperty_1;
var fails$1 = fails$j;
var html = html$2;
var arraySlice = arraySlice$1;
var createElement$1 = documentCreateElement$1;
var validateArgumentsLength = validateArgumentsLength$1;
var IS_IOS$1 = engineIsIos;
var IS_NODE$2 = engineIsNode;
var set = global$8.setImmediate;
var clear = global$8.clearImmediate;
var process$2 = global$8.process;
var Dispatch = global$8.Dispatch;
var Function$1 = global$8.Function;
var MessageChannel = global$8.MessageChannel;
var String$1 = global$8.String;
var counter = 0;
var queue$1 = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var location$1, defer, channel, port;
try {
  // Deno throws a ReferenceError on `location` access without `--location` flag
  location$1 = global$8.location;
} catch (error) {/* empty */}
var run = function (id) {
  if (hasOwn(queue$1, id)) {
    var fn = queue$1[id];
    delete queue$1[id];
    fn();
  }
};
var runner = function (id) {
  return function () {
    run(id);
  };
};
var listener = function (event) {
  run(event.data);
};
var post = function (id) {
  // old engines have not location.origin
  global$8.postMessage(String$1(id), location$1.protocol + '//' + location$1.host);
};

// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!set || !clear) {
  set = function setImmediate(handler) {
    validateArgumentsLength(arguments.length, 1);
    var fn = isCallable$4(handler) ? handler : Function$1(handler);
    var args = arraySlice(arguments, 1);
    queue$1[++counter] = function () {
      apply(fn, undefined, args);
    };
    defer(counter);
    return counter;
  };
  clear = function clearImmediate(id) {
    delete queue$1[id];
  };
  // Node.js 0.8-
  if (IS_NODE$2) {
    defer = function (id) {
      process$2.nextTick(runner(id));
    };
    // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(runner(id));
    };
    // Browsers with MessageChannel, includes WebWorkers
    // except iOS - https://github.com/zloirock/core-js/issues/624
  } else if (MessageChannel && !IS_IOS$1) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = bind$3(port.postMessage, port);
    // Browsers with postMessage, skip WebWorkers
    // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global$8.addEventListener && isCallable$4(global$8.postMessage) && !global$8.importScripts && location$1 && location$1.protocol !== 'file:' && !fails$1(post)) {
    defer = post;
    global$8.addEventListener('message', listener, false);
    // IE8-
  } else if (ONREADYSTATECHANGE in createElement$1('script')) {
    defer = function (id) {
      html.appendChild(createElement$1('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run(id);
      };
    };
    // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(runner(id), 0);
    };
  }
}
var task$1 = {
  set: set,
  clear: clear
};

var userAgent$2 = engineUserAgent;
var global$7 = global$J;
var engineIsIosPebble = /ipad|iphone|ipod/i.test(userAgent$2) && global$7.Pebble !== undefined;

var userAgent$1 = engineUserAgent;
var engineIsWebosWebkit = /web0s(?!.*chrome)/i.test(userAgent$1);

var global$6 = global$J;
var bind$2 = functionBindContext;
var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
var macrotask = task$1.set;
var IS_IOS = engineIsIos;
var IS_IOS_PEBBLE = engineIsIosPebble;
var IS_WEBOS_WEBKIT = engineIsWebosWebkit;
var IS_NODE$1 = engineIsNode;
var MutationObserver$1 = global$6.MutationObserver || global$6.WebKitMutationObserver;
var document$2 = global$6.document;
var process$1 = global$6.process;
var Promise$2 = global$6.Promise;
// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`
var queueMicrotaskDescriptor = getOwnPropertyDescriptor$1(global$6, 'queueMicrotask');
var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;
var flush, head, last, notify$1, toggle, node, promise, then;

// modern engines have queueMicrotask method
if (!queueMicrotask) {
  flush = function () {
    var parent, fn;
    if (IS_NODE$1 && (parent = process$1.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (error) {
        if (head) notify$1();else last = undefined;
        throw error;
      }
    }
    last = undefined;
    if (parent) parent.enter();
  };

  // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
  // also except WebOS Webkit https://github.com/zloirock/core-js/issues/898
  if (!IS_IOS && !IS_NODE$1 && !IS_WEBOS_WEBKIT && MutationObserver$1 && document$2) {
    toggle = true;
    node = document$2.createTextNode('');
    new MutationObserver$1(flush).observe(node, {
      characterData: true
    });
    notify$1 = function () {
      node.data = toggle = !toggle;
    };
    // environments with maybe non-completely correct, but existent Promise
  } else if (!IS_IOS_PEBBLE && Promise$2 && Promise$2.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    promise = Promise$2.resolve(undefined);
    // workaround of WebKit ~ iOS Safari 10.1 bug
    promise.constructor = Promise$2;
    then = bind$2(promise.then, promise);
    notify$1 = function () {
      then(flush);
    };
    // Node.js without promises
  } else if (IS_NODE$1) {
    notify$1 = function () {
      process$1.nextTick(flush);
    };
    // for other environments - macrotask based on:
    // - setImmediate
    // - MessageChannel
    // - window.postMessage
    // - onreadystatechange
    // - setTimeout
  } else {
    // strange IE + webpack dev server bug - use .bind(global)
    macrotask = bind$2(macrotask, global$6);
    notify$1 = function () {
      macrotask(flush);
    };
  }
}
var microtask$1 = queueMicrotask || function (fn) {
  var task = {
    fn: fn,
    next: undefined
  };
  if (last) last.next = task;
  if (!head) {
    head = task;
    notify$1();
  }
  last = task;
};

var global$5 = global$J;
var hostReportErrors$1 = function (a, b) {
  var console = global$5.console;
  if (console && console.error) {
    arguments.length == 1 ? console.error(a) : console.error(a, b);
  }
};

var perform$5 = function (exec) {
  try {
    return {
      error: false,
      value: exec()
    };
  } catch (error) {
    return {
      error: true,
      value: error
    };
  }
};

var Queue$1 = function () {
  this.head = null;
  this.tail = null;
};
Queue$1.prototype = {
  add: function (item) {
    var entry = {
      item: item,
      next: null
    };
    if (this.head) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
  },
  get: function () {
    var entry = this.head;
    if (entry) {
      this.head = entry.next;
      if (this.tail === entry) this.tail = null;
      return entry.item;
    }
  }
};
var queue = Queue$1;

var global$4 = global$J;
var promiseNativeConstructor = global$4.Promise;

var engineIsBrowser = typeof window == 'object' && typeof Deno != 'object';

var global$3 = global$J;
var NativePromiseConstructor$4 = promiseNativeConstructor;
var isCallable$3 = isCallable$n;
var isForced = isForced_1;
var inspectSource = inspectSource$4;
var wellKnownSymbol$2 = wellKnownSymbol$h;
var IS_BROWSER = engineIsBrowser;
var V8_VERSION = engineV8Version;
NativePromiseConstructor$4 && NativePromiseConstructor$4.prototype;
var SPECIES = wellKnownSymbol$2('species');
var SUBCLASSING = false;
var NATIVE_PROMISE_REJECTION_EVENT$1 = isCallable$3(global$3.PromiseRejectionEvent);
var FORCED_PROMISE_CONSTRUCTOR$5 = isForced('Promise', function () {
  var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(NativePromiseConstructor$4);
  var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(NativePromiseConstructor$4);
  // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
  // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
  // We can't detect it synchronously, so just check versions
  if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66) return true;
  // We can't use @@species feature detection in V8 since it causes
  // deoptimization and performance degradation
  // https://github.com/zloirock/core-js/issues/679
  if (V8_VERSION >= 51 && /native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) return false;
  // Detect correctness of subclassing with @@species support
  var promise = new NativePromiseConstructor$4(function (resolve) {
    resolve(1);
  });
  var FakePromise = function (exec) {
    exec(function () {/* empty */}, function () {/* empty */});
  };
  var constructor = promise.constructor = {};
  constructor[SPECIES] = FakePromise;
  SUBCLASSING = promise.then(function () {/* empty */}) instanceof FakePromise;
  if (!SUBCLASSING) return true;
  // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test
  return !GLOBAL_CORE_JS_PROMISE && IS_BROWSER && !NATIVE_PROMISE_REJECTION_EVENT$1;
});
var promiseConstructorDetection = {
  CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR$5,
  REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT$1,
  SUBCLASSING: SUBCLASSING
};

var newPromiseCapability$2 = {};

var aCallable$5 = aCallable$9;
var PromiseCapability = function (C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aCallable$5(resolve);
  this.reject = aCallable$5(reject);
};

// `NewPromiseCapability` abstract operation
// https://tc39.es/ecma262/#sec-newpromisecapability
newPromiseCapability$2.f = function (C) {
  return new PromiseCapability(C);
};

var $$h = _export;
var IS_NODE = engineIsNode;
var global$2 = global$J;
var call$5 = functionCall;
var defineBuiltIn$2 = defineBuiltIn$9;
var setPrototypeOf = objectSetPrototypeOf;
var setToStringTag = setToStringTag$4;
var setSpecies = setSpecies$2;
var aCallable$4 = aCallable$9;
var isCallable$2 = isCallable$n;
var isObject$2 = isObject$e;
var anInstance = anInstance$3;
var speciesConstructor$1 = speciesConstructor$2;
var task = task$1.set;
var microtask = microtask$1;
var hostReportErrors = hostReportErrors$1;
var perform$4 = perform$5;
var Queue = queue;
var InternalStateModule = internalState;
var NativePromiseConstructor$3 = promiseNativeConstructor;
var PromiseConstructorDetection = promiseConstructorDetection;
var newPromiseCapabilityModule$5 = newPromiseCapability$2;
var PROMISE = 'Promise';
var FORCED_PROMISE_CONSTRUCTOR$4 = PromiseConstructorDetection.CONSTRUCTOR;
var NATIVE_PROMISE_REJECTION_EVENT = PromiseConstructorDetection.REJECTION_EVENT;
var NATIVE_PROMISE_SUBCLASSING = PromiseConstructorDetection.SUBCLASSING;
var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
var setInternalState = InternalStateModule.set;
var NativePromisePrototype$2 = NativePromiseConstructor$3 && NativePromiseConstructor$3.prototype;
var PromiseConstructor = NativePromiseConstructor$3;
var PromisePrototype = NativePromisePrototype$2;
var TypeError$2 = global$2.TypeError;
var document$1 = global$2.document;
var process = global$2.process;
var newPromiseCapability$1 = newPromiseCapabilityModule$5.f;
var newGenericPromiseCapability = newPromiseCapability$1;
var DISPATCH_EVENT = !!(document$1 && document$1.createEvent && global$2.dispatchEvent);
var UNHANDLED_REJECTION = 'unhandledrejection';
var REJECTION_HANDLED = 'rejectionhandled';
var PENDING = 0;
var FULFILLED = 1;
var REJECTED = 2;
var HANDLED = 1;
var UNHANDLED = 2;
var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;

// helpers
var isThenable = function (it) {
  var then;
  return isObject$2(it) && isCallable$2(then = it.then) ? then : false;
};
var callReaction = function (reaction, state) {
  var value = state.value;
  var ok = state.state == FULFILLED;
  var handler = ok ? reaction.ok : reaction.fail;
  var resolve = reaction.resolve;
  var reject = reaction.reject;
  var domain = reaction.domain;
  var result, then, exited;
  try {
    if (handler) {
      if (!ok) {
        if (state.rejection === UNHANDLED) onHandleUnhandled(state);
        state.rejection = HANDLED;
      }
      if (handler === true) result = value;else {
        if (domain) domain.enter();
        result = handler(value); // can throw
        if (domain) {
          domain.exit();
          exited = true;
        }
      }
      if (result === reaction.promise) {
        reject(TypeError$2('Promise-chain cycle'));
      } else if (then = isThenable(result)) {
        call$5(then, result, resolve, reject);
      } else resolve(result);
    } else reject(value);
  } catch (error) {
    if (domain && !exited) domain.exit();
    reject(error);
  }
};
var notify = function (state, isReject) {
  if (state.notified) return;
  state.notified = true;
  microtask(function () {
    var reactions = state.reactions;
    var reaction;
    while (reaction = reactions.get()) {
      callReaction(reaction, state);
    }
    state.notified = false;
    if (isReject && !state.rejection) onUnhandled(state);
  });
};
var dispatchEvent$2 = function (name, promise, reason) {
  var event, handler;
  if (DISPATCH_EVENT) {
    event = document$1.createEvent('Event');
    event.promise = promise;
    event.reason = reason;
    event.initEvent(name, false, true);
    global$2.dispatchEvent(event);
  } else event = {
    promise: promise,
    reason: reason
  };
  if (!NATIVE_PROMISE_REJECTION_EVENT && (handler = global$2['on' + name])) handler(event);else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
};
var onUnhandled = function (state) {
  call$5(task, global$2, function () {
    var promise = state.facade;
    var value = state.value;
    var IS_UNHANDLED = isUnhandled(state);
    var result;
    if (IS_UNHANDLED) {
      result = perform$4(function () {
        if (IS_NODE) {
          process.emit('unhandledRejection', value, promise);
        } else dispatchEvent$2(UNHANDLED_REJECTION, promise, value);
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
      if (result.error) throw result.value;
    }
  });
};
var isUnhandled = function (state) {
  return state.rejection !== HANDLED && !state.parent;
};
var onHandleUnhandled = function (state) {
  call$5(task, global$2, function () {
    var promise = state.facade;
    if (IS_NODE) {
      process.emit('rejectionHandled', promise);
    } else dispatchEvent$2(REJECTION_HANDLED, promise, state.value);
  });
};
var bind$1 = function (fn, state, unwrap) {
  return function (value) {
    fn(state, value, unwrap);
  };
};
var internalReject = function (state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  state.value = value;
  state.state = REJECTED;
  notify(state, true);
};
var internalResolve = function (state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  try {
    if (state.facade === value) throw TypeError$2("Promise can't be resolved itself");
    var then = isThenable(value);
    if (then) {
      microtask(function () {
        var wrapper = {
          done: false
        };
        try {
          call$5(then, value, bind$1(internalResolve, wrapper, state), bind$1(internalReject, wrapper, state));
        } catch (error) {
          internalReject(wrapper, error, state);
        }
      });
    } else {
      state.value = value;
      state.state = FULFILLED;
      notify(state, false);
    }
  } catch (error) {
    internalReject({
      done: false
    }, error, state);
  }
};

// constructor polyfill
if (FORCED_PROMISE_CONSTRUCTOR$4) {
  // 25.4.3.1 Promise(executor)
  PromiseConstructor = function Promise(executor) {
    anInstance(this, PromisePrototype);
    aCallable$4(executor);
    call$5(Internal, this);
    var state = getInternalPromiseState(this);
    try {
      executor(bind$1(internalResolve, state), bind$1(internalReject, state));
    } catch (error) {
      internalReject(state, error);
    }
  };
  PromisePrototype = PromiseConstructor.prototype;

  // eslint-disable-next-line no-unused-vars -- required for `.length`
  Internal = function Promise(executor) {
    setInternalState(this, {
      type: PROMISE,
      done: false,
      notified: false,
      parent: false,
      reactions: new Queue(),
      rejection: false,
      state: PENDING,
      value: undefined
    });
  };

  // `Promise.prototype.then` method
  // https://tc39.es/ecma262/#sec-promise.prototype.then
  Internal.prototype = defineBuiltIn$2(PromisePrototype, 'then', function then(onFulfilled, onRejected) {
    var state = getInternalPromiseState(this);
    var reaction = newPromiseCapability$1(speciesConstructor$1(this, PromiseConstructor));
    state.parent = true;
    reaction.ok = isCallable$2(onFulfilled) ? onFulfilled : true;
    reaction.fail = isCallable$2(onRejected) && onRejected;
    reaction.domain = IS_NODE ? process.domain : undefined;
    if (state.state == PENDING) state.reactions.add(reaction);else microtask(function () {
      callReaction(reaction, state);
    });
    return reaction.promise;
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    var state = getInternalPromiseState(promise);
    this.promise = promise;
    this.resolve = bind$1(internalResolve, state);
    this.reject = bind$1(internalReject, state);
  };
  newPromiseCapabilityModule$5.f = newPromiseCapability$1 = function (C) {
    return C === PromiseConstructor || C === PromiseWrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
  };
  if (isCallable$2(NativePromiseConstructor$3) && NativePromisePrototype$2 !== Object.prototype) {
    nativeThen = NativePromisePrototype$2.then;
    if (!NATIVE_PROMISE_SUBCLASSING) {
      // make `Promise#then` return a polyfilled `Promise` for native promise-based APIs
      defineBuiltIn$2(NativePromisePrototype$2, 'then', function then(onFulfilled, onRejected) {
        var that = this;
        return new PromiseConstructor(function (resolve, reject) {
          call$5(nativeThen, that, resolve, reject);
        }).then(onFulfilled, onRejected);
        // https://github.com/zloirock/core-js/issues/640
      }, {
        unsafe: true
      });
    }

    // make `.constructor === Promise` work for native promise-based APIs
    try {
      delete NativePromisePrototype$2.constructor;
    } catch (error) {/* empty */}

    // make `instanceof Promise` work for native promise-based APIs
    if (setPrototypeOf) {
      setPrototypeOf(NativePromisePrototype$2, PromisePrototype);
    }
  }
}
$$h({
  global: true,
  constructor: true,
  wrap: true,
  forced: FORCED_PROMISE_CONSTRUCTOR$4
}, {
  Promise: PromiseConstructor
});
setToStringTag(PromiseConstructor, PROMISE, false);
setSpecies(PROMISE);

var NativePromiseConstructor$2 = promiseNativeConstructor;
var checkCorrectnessOfIteration = checkCorrectnessOfIteration$3;
var FORCED_PROMISE_CONSTRUCTOR$3 = promiseConstructorDetection.CONSTRUCTOR;
var promiseStaticsIncorrectIteration = FORCED_PROMISE_CONSTRUCTOR$3 || !checkCorrectnessOfIteration(function (iterable) {
  NativePromiseConstructor$2.all(iterable).then(undefined, function () {/* empty */});
});

var $$g = _export;
var call$4 = functionCall;
var aCallable$3 = aCallable$9;
var newPromiseCapabilityModule$4 = newPromiseCapability$2;
var perform$3 = perform$5;
var iterate$3 = iterate$7;
var PROMISE_STATICS_INCORRECT_ITERATION$1 = promiseStaticsIncorrectIteration;

// `Promise.all` method
// https://tc39.es/ecma262/#sec-promise.all
$$g({
  target: 'Promise',
  stat: true,
  forced: PROMISE_STATICS_INCORRECT_ITERATION$1
}, {
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapabilityModule$4.f(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform$3(function () {
      var $promiseResolve = aCallable$3(C.resolve);
      var values = [];
      var counter = 0;
      var remaining = 1;
      iterate$3(iterable, function (promise) {
        var index = counter++;
        var alreadyCalled = false;
        remaining++;
        call$4($promiseResolve, C, promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.error) reject(result.value);
    return capability.promise;
  }
});

var $$f = _export;
var FORCED_PROMISE_CONSTRUCTOR$2 = promiseConstructorDetection.CONSTRUCTOR;
var NativePromiseConstructor$1 = promiseNativeConstructor;
var getBuiltIn$3 = getBuiltIn$a;
var isCallable$1 = isCallable$n;
var defineBuiltIn$1 = defineBuiltIn$9;
var NativePromisePrototype$1 = NativePromiseConstructor$1 && NativePromiseConstructor$1.prototype;

// `Promise.prototype.catch` method
// https://tc39.es/ecma262/#sec-promise.prototype.catch
$$f({
  target: 'Promise',
  proto: true,
  forced: FORCED_PROMISE_CONSTRUCTOR$2,
  real: true
}, {
  'catch': function (onRejected) {
    return this.then(undefined, onRejected);
  }
});

// makes sure that native promise-based APIs `Promise#catch` properly works with patched `Promise#then`
if (isCallable$1(NativePromiseConstructor$1)) {
  var method$1 = getBuiltIn$3('Promise').prototype['catch'];
  if (NativePromisePrototype$1['catch'] !== method$1) {
    defineBuiltIn$1(NativePromisePrototype$1, 'catch', method$1, {
      unsafe: true
    });
  }
}

var $$e = _export;
var call$3 = functionCall;
var aCallable$2 = aCallable$9;
var newPromiseCapabilityModule$3 = newPromiseCapability$2;
var perform$2 = perform$5;
var iterate$2 = iterate$7;
var PROMISE_STATICS_INCORRECT_ITERATION = promiseStaticsIncorrectIteration;

// `Promise.race` method
// https://tc39.es/ecma262/#sec-promise.race
$$e({
  target: 'Promise',
  stat: true,
  forced: PROMISE_STATICS_INCORRECT_ITERATION
}, {
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapabilityModule$3.f(C);
    var reject = capability.reject;
    var result = perform$2(function () {
      var $promiseResolve = aCallable$2(C.resolve);
      iterate$2(iterable, function (promise) {
        call$3($promiseResolve, C, promise).then(capability.resolve, reject);
      });
    });
    if (result.error) reject(result.value);
    return capability.promise;
  }
});

var $$d = _export;
var call$2 = functionCall;
var newPromiseCapabilityModule$2 = newPromiseCapability$2;
var FORCED_PROMISE_CONSTRUCTOR$1 = promiseConstructorDetection.CONSTRUCTOR;

// `Promise.reject` method
// https://tc39.es/ecma262/#sec-promise.reject
$$d({
  target: 'Promise',
  stat: true,
  forced: FORCED_PROMISE_CONSTRUCTOR$1
}, {
  reject: function reject(r) {
    var capability = newPromiseCapabilityModule$2.f(this);
    call$2(capability.reject, undefined, r);
    return capability.promise;
  }
});

var anObject = anObject$b;
var isObject$1 = isObject$e;
var newPromiseCapability = newPromiseCapability$2;
var promiseResolve$2 = function (C, x) {
  anObject(C);
  if (isObject$1(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};

var $$c = _export;
var getBuiltIn$2 = getBuiltIn$a;
var FORCED_PROMISE_CONSTRUCTOR = promiseConstructorDetection.CONSTRUCTOR;
var promiseResolve$1 = promiseResolve$2;
getBuiltIn$2('Promise');

// `Promise.resolve` method
// https://tc39.es/ecma262/#sec-promise.resolve
$$c({
  target: 'Promise',
  stat: true,
  forced: FORCED_PROMISE_CONSTRUCTOR
}, {
  resolve: function resolve(x) {
    return promiseResolve$1(this, x);
  }
});

var $$b = _export;
var call$1 = functionCall;
var aCallable$1 = aCallable$9;
var newPromiseCapabilityModule$1 = newPromiseCapability$2;
var perform$1 = perform$5;
var iterate$1 = iterate$7;

// `Promise.allSettled` method
// https://tc39.es/ecma262/#sec-promise.allsettled
$$b({
  target: 'Promise',
  stat: true
}, {
  allSettled: function allSettled(iterable) {
    var C = this;
    var capability = newPromiseCapabilityModule$1.f(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform$1(function () {
      var promiseResolve = aCallable$1(C.resolve);
      var values = [];
      var counter = 0;
      var remaining = 1;
      iterate$1(iterable, function (promise) {
        var index = counter++;
        var alreadyCalled = false;
        remaining++;
        call$1(promiseResolve, C, promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[index] = {
            status: 'fulfilled',
            value: value
          };
          --remaining || resolve(values);
        }, function (error) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[index] = {
            status: 'rejected',
            reason: error
          };
          --remaining || resolve(values);
        });
      });
      --remaining || resolve(values);
    });
    if (result.error) reject(result.value);
    return capability.promise;
  }
});

var $$a = _export;
var call = functionCall;
var aCallable = aCallable$9;
var getBuiltIn$1 = getBuiltIn$a;
var newPromiseCapabilityModule = newPromiseCapability$2;
var perform = perform$5;
var iterate = iterate$7;
var PROMISE_ANY_ERROR = 'No one promise resolved';

// `Promise.any` method
// https://tc39.es/ecma262/#sec-promise.any
$$a({
  target: 'Promise',
  stat: true
}, {
  any: function any(iterable) {
    var C = this;
    var AggregateError = getBuiltIn$1('AggregateError');
    var capability = newPromiseCapabilityModule.f(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var promiseResolve = aCallable(C.resolve);
      var errors = [];
      var counter = 0;
      var remaining = 1;
      var alreadyResolved = false;
      iterate(iterable, function (promise) {
        var index = counter++;
        var alreadyRejected = false;
        remaining++;
        call(promiseResolve, C, promise).then(function (value) {
          if (alreadyRejected || alreadyResolved) return;
          alreadyResolved = true;
          resolve(value);
        }, function (error) {
          if (alreadyRejected || alreadyResolved) return;
          alreadyRejected = true;
          errors[index] = error;
          --remaining || reject(new AggregateError(errors, PROMISE_ANY_ERROR));
        });
      });
      --remaining || reject(new AggregateError(errors, PROMISE_ANY_ERROR));
    });
    if (result.error) reject(result.value);
    return capability.promise;
  }
});

var $$9 = _export;
var NativePromiseConstructor = promiseNativeConstructor;
var fails = fails$j;
var getBuiltIn = getBuiltIn$a;
var isCallable = isCallable$n;
var speciesConstructor = speciesConstructor$2;
var promiseResolve = promiseResolve$2;
var defineBuiltIn = defineBuiltIn$9;
var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;

// Safari bug https://bugs.webkit.org/show_bug.cgi?id=200829
var NON_GENERIC = !!NativePromiseConstructor && fails(function () {
  // eslint-disable-next-line unicorn/no-thenable -- required for testing
  NativePromisePrototype['finally'].call({
    then: function () {/* empty */}
  }, function () {/* empty */});
});

// `Promise.prototype.finally` method
// https://tc39.es/ecma262/#sec-promise.prototype.finally
$$9({
  target: 'Promise',
  proto: true,
  real: true,
  forced: NON_GENERIC
}, {
  'finally': function (onFinally) {
    var C = speciesConstructor(this, getBuiltIn('Promise'));
    var isFunction = isCallable(onFinally);
    return this.then(isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () {
        return x;
      });
    } : onFinally, isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () {
        throw e;
      });
    } : onFinally);
  }
});

// makes sure that native promise-based APIs `Promise#finally` properly works with patched `Promise#then`
if (isCallable(NativePromiseConstructor)) {
  var method = getBuiltIn('Promise').prototype['finally'];
  if (NativePromisePrototype['finally'] !== method) {
    defineBuiltIn(NativePromisePrototype, 'finally', method, {
      unsafe: true
    });
  }
}

var path$1 = path$5;
path$1.Promise;

var collection = collection$2;
var collectionStrong = collectionStrong$2;

// `Set` constructor
// https://tc39.es/ecma262/#sec-set-objects
collection('Set', function (init) {
  return function Set() {
    return init(this, arguments.length ? arguments[0] : undefined);
  };
}, collectionStrong);

var path = path$5;
path.Set;

var isObject = isObject$e;
var classof = classofRaw$1;
var wellKnownSymbol$1 = wellKnownSymbol$h;
var MATCH$1 = wellKnownSymbol$1('match');

// `IsRegExp` abstract operation
// https://tc39.es/ecma262/#sec-isregexp
var isRegexp = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH$1]) !== undefined ? !!isRegExp : classof(it) == 'RegExp');
};

var global$1 = global$J;
var isRegExp = isRegexp;
var TypeError$1 = global$1.TypeError;
var notARegexp = function (it) {
  if (isRegExp(it)) {
    throw TypeError$1("The method doesn't accept regular expressions");
  }
  return it;
};

var wellKnownSymbol = wellKnownSymbol$h;
var MATCH = wellKnownSymbol('match');
var correctIsRegexpLogic = function (METHOD_NAME) {
  var regexp = /./;
  try {
    '/./'[METHOD_NAME](regexp);
  } catch (error1) {
    try {
      regexp[MATCH] = false;
      return '/./'[METHOD_NAME](regexp);
    } catch (error2) {/* empty */}
  }
  return false;
};

var $$8 = _export;
var uncurryThis = functionUncurryThis;
var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
var toLength = toLength$2;
var toString = toString$5;
var notARegExp = notARegexp;
var requireObjectCoercible = requireObjectCoercible$4;
var correctIsRegExpLogic = correctIsRegexpLogic;

// eslint-disable-next-line es-x/no-string-prototype-startswith -- safe
var un$StartsWith = uncurryThis(''.startsWith);
var stringSlice = uncurryThis(''.slice);
var min = Math.min;
var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic('startsWith');
// https://github.com/zloirock/core-js/pull/702
var MDN_POLYFILL_BUG = !CORRECT_IS_REGEXP_LOGIC && !!function () {
  var descriptor = getOwnPropertyDescriptor(String.prototype, 'startsWith');
  return descriptor && !descriptor.writable;
}();

// `String.prototype.startsWith` method
// https://tc39.es/ecma262/#sec-string.prototype.startswith
$$8({
  target: 'String',
  proto: true,
  forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC
}, {
  startsWith: function startsWith(searchString /* , position = 0 */) {
    var that = toString(requireObjectCoercible(this));
    notARegExp(searchString);
    var index = toLength(min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = toString(searchString);
    return un$StartsWith ? un$StartsWith(that, search, index) : stringSlice(that, index, index + search.length) === search;
  }
});

var entryUnbind = entryUnbind$3;
entryUnbind('String', 'startsWith');

// element-closest | CC0-1.0 | github.com/jonathantneal/closest

(function (ElementProto) {
  if (typeof ElementProto.matches !== 'function') {
    ElementProto.matches = ElementProto.msMatchesSelector || ElementProto.mozMatchesSelector || ElementProto.webkitMatchesSelector || function matches(selector) {
      var element = this;
      var elements = (element.document || element.ownerDocument).querySelectorAll(selector);
      var index = 0;
      while (elements[index] && elements[index] !== element) {
        ++index;
      }
      return Boolean(elements[index]);
    };
  }
  if (typeof ElementProto.closest !== 'function') {
    ElementProto.closest = function closest(selector) {
      var element = this;
      while (element && element.nodeType === 1) {
        if (element.matches(selector)) {
          return element;
        }
        element = element.parentNode;
      }
      return null;
    };
  }
})(window.Element.prototype);

if (window.MutationObserver) {
  var element = document.createElement("div");
  element.innerHTML = "<div><div></div></div>";
  new MutationObserver(function (mutations, observer) {
    observer.disconnect();
    if (mutations[0] && mutations[0].type == "childList" && mutations[0].removedNodes[0].childNodes.length == 0) {
      var prototype = HTMLElement.prototype;
      var descriptor = Object.getOwnPropertyDescriptor(prototype, "innerHTML");
      if (descriptor && descriptor.set) {
        Object.defineProperty(prototype, "innerHTML", {
          set: function (value) {
            while (this.lastChild) this.removeChild(this.lastChild);
            descriptor.set.call(this, value);
          }
        });
      }
    }
  }).observe(element, {
    childList: true,
    subtree: true
  });
  element.innerHTML = "";
}

var passiveSupported = false;
var onceSupported = false;
function noop$1() {}
try {
  var options = Object.create({}, {
    passive: {
      get: function () {
        passiveSupported = true;
      }
    },
    once: {
      get: function () {
        onceSupported = true;
      }
    }
  });
  window.addEventListener('test', noop$1, options);
  window.removeEventListener('test', noop$1, options);
} catch (e) {/* */}
var enhance = function enhance(proto) {
  var originalAddEventListener = proto.addEventListener;
  var originalRemoveEventListener = proto.removeEventListener;
  var listeners = new WeakMap();
  proto.addEventListener = function (name, originalCallback, optionsOrCapture) {
    if (optionsOrCapture === undefined || optionsOrCapture === true || optionsOrCapture === false || !originalCallback || typeof originalCallback !== 'function' && typeof originalCallback !== 'object') {
      return originalAddEventListener.call(this, name, originalCallback, optionsOrCapture);
    }
    var callback = typeof originalCallback !== 'function' && typeof originalCallback.handleEvent === 'function' ? originalCallback.handleEvent.bind(originalCallback) : originalCallback;
    var options = typeof optionsOrCapture === 'boolean' ? {
      capture: optionsOrCapture
    } : optionsOrCapture || {};
    var passive = Boolean(options.passive);
    var once = Boolean(options.once);
    var capture = Boolean(options.capture);
    var oldCallback = callback;
    if (!onceSupported && once) {
      callback = function (event) {
        this.removeEventListener(name, originalCallback, options);
        oldCallback.call(this, event);
      };
    }
    if (!passiveSupported && passive) {
      callback = function (event) {
        event.preventDefault = noop$1;
        oldCallback.call(this, event);
      };
    }
    if (!listeners.has(this)) listeners.set(this, new WeakMap());
    var elementMap = listeners.get(this);
    if (!elementMap.has(originalCallback)) elementMap.set(originalCallback, []);
    var optionsOctal = passive * 1 + once * 2 + capture * 4;
    elementMap.get(originalCallback)[optionsOctal] = callback;
    originalAddEventListener.call(this, name, callback, capture);
  };
  proto.removeEventListener = function (name, originalCallback, optionsOrCapture) {
    var capture = Boolean(typeof optionsOrCapture === 'object' ? optionsOrCapture.capture : optionsOrCapture);
    var elementMap = listeners.get(this);
    if (!elementMap) return originalRemoveEventListener.call(this, name, originalCallback, optionsOrCapture);
    var callbacks = elementMap.get(originalCallback);
    if (!callbacks) return originalRemoveEventListener.call(this, name, originalCallback, optionsOrCapture);
    for (var optionsOctal in callbacks) {
      var callbackIsCapture = Boolean(optionsOctal & 4);
      if (callbackIsCapture !== capture) continue; // when unbinding, capture is the only option that counts
      originalRemoveEventListener.call(this, name, callbacks[optionsOctal], callbackIsCapture);
    }
  };
};
if (!passiveSupported || !onceSupported) {
  if (typeof EventTarget !== 'undefined') {
    enhance(EventTarget.prototype);
  } else {
    enhance(Text.prototype);
    enhance(HTMLElement.prototype);
    enhance(HTMLDocument.prototype);
    enhance(Window.prototype);
    enhance(XMLHttpRequest.prototype);
  }
}

if (typeof SVGElement.prototype.contains != "function") {
  SVGElement.prototype.contains = function (node) {
    return this === node || this.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY;
  };
}

/**
 * @this {Promise}
 */
function finallyConstructor(callback) {
  var constructor = this.constructor;
  return this.then(function (value) {
    // @ts-ignore
    return constructor.resolve(callback()).then(function () {
      return value;
    });
  }, function (reason) {
    // @ts-ignore
    return constructor.resolve(callback()).then(function () {
      // @ts-ignore
      return constructor.reject(reason);
    });
  });
}

function allSettled(arr) {
  var P = this;
  return new P(function (resolve, reject) {
    if (!(arr && typeof arr.length !== 'undefined')) {
      return reject(new TypeError(typeof arr + ' ' + arr + ' is not iterable(cannot read property Symbol(Symbol.iterator))'));
    }
    var args = Array.prototype.slice.call(arr);
    if (args.length === 0) return resolve([]);
    var remaining = args.length;
    function res(i, val) {
      if (val && (typeof val === 'object' || typeof val === 'function')) {
        var then = val.then;
        if (typeof then === 'function') {
          then.call(val, function (val) {
            res(i, val);
          }, function (e) {
            args[i] = {
              status: 'rejected',
              reason: e
            };
            if (--remaining === 0) {
              resolve(args);
            }
          });
          return;
        }
      }
      args[i] = {
        status: 'fulfilled',
        value: val
      };
      if (--remaining === 0) {
        resolve(args);
      }
    }
    for (var i = 0; i < args.length; i++) {
      res(i, args[i]);
    }
  });
}

/**
 * @constructor
 */
function AggregateError(errors, message) {
  this.name = 'AggregateError', this.errors = errors;
  this.message = message || '';
}
AggregateError.prototype = Error.prototype;
function any(arr) {
  var P = this;
  return new P(function (resolve, reject) {
    if (!(arr && typeof arr.length !== 'undefined')) {
      return reject(new TypeError('Promise.any accepts an array'));
    }
    var args = Array.prototype.slice.call(arr);
    if (args.length === 0) return reject();
    var rejectionReasons = [];
    for (var i = 0; i < args.length; i++) {
      try {
        P.resolve(args[i]).then(resolve).catch(function (error) {
          rejectionReasons.push(error);
          if (rejectionReasons.length === args.length) {
            reject(new AggregateError(rejectionReasons, 'All promises were rejected'));
          }
        });
      } catch (ex) {
        reject(ex);
      }
    }
  });
}

// Store setTimeout reference so promise-polyfill will be unaffected by
// other code modifying setTimeout (like sinon.useFakeTimers())
var setTimeoutFunc = setTimeout;
function isArray(x) {
  return Boolean(x && typeof x.length !== 'undefined');
}
function noop() {}

// Polyfill for Function.prototype.bind
function bind(fn, thisArg) {
  return function () {
    fn.apply(thisArg, arguments);
  };
}

/**
 * @constructor
 * @param {Function} fn
 */
function Promise$1(fn) {
  if (!(this instanceof Promise$1)) throw new TypeError('Promises must be constructed via new');
  if (typeof fn !== 'function') throw new TypeError('not a function');
  /** @type {!number} */
  this._state = 0;
  /** @type {!boolean} */
  this._handled = false;
  /** @type {Promise|undefined} */
  this._value = undefined;
  /** @type {!Array<!Function>} */
  this._deferreds = [];
  doResolve(fn, this);
}
function handle(self, deferred) {
  while (self._state === 3) {
    self = self._value;
  }
  if (self._state === 0) {
    self._deferreds.push(deferred);
    return;
  }
  self._handled = true;
  Promise$1._immediateFn(function () {
    var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
    if (cb === null) {
      (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
      return;
    }
    var ret;
    try {
      ret = cb(self._value);
    } catch (e) {
      reject(deferred.promise, e);
      return;
    }
    resolve(deferred.promise, ret);
  });
}
function resolve(self, newValue) {
  try {
    // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
    if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');
    if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
      var then = newValue.then;
      if (newValue instanceof Promise$1) {
        self._state = 3;
        self._value = newValue;
        finale(self);
        return;
      } else if (typeof then === 'function') {
        doResolve(bind(then, newValue), self);
        return;
      }
    }
    self._state = 1;
    self._value = newValue;
    finale(self);
  } catch (e) {
    reject(self, e);
  }
}
function reject(self, newValue) {
  self._state = 2;
  self._value = newValue;
  finale(self);
}
function finale(self) {
  if (self._state === 2 && self._deferreds.length === 0) {
    Promise$1._immediateFn(function () {
      if (!self._handled) {
        Promise$1._unhandledRejectionFn(self._value);
      }
    });
  }
  for (var i = 0, len = self._deferreds.length; i < len; i++) {
    handle(self, self._deferreds[i]);
  }
  self._deferreds = null;
}

/**
 * @constructor
 */
function Handler(onFulfilled, onRejected, promise) {
  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
  this.onRejected = typeof onRejected === 'function' ? onRejected : null;
  this.promise = promise;
}

/**
 * Take a potentially misbehaving resolver function and make sure
 * onFulfilled and onRejected are only called once.
 *
 * Makes no guarantees about asynchrony.
 */
function doResolve(fn, self) {
  var done = false;
  try {
    fn(function (value) {
      if (done) return;
      done = true;
      resolve(self, value);
    }, function (reason) {
      if (done) return;
      done = true;
      reject(self, reason);
    });
  } catch (ex) {
    if (done) return;
    done = true;
    reject(self, ex);
  }
}
Promise$1.prototype['catch'] = function (onRejected) {
  return this.then(null, onRejected);
};
Promise$1.prototype.then = function (onFulfilled, onRejected) {
  // @ts-ignore
  var prom = new this.constructor(noop);
  handle(this, new Handler(onFulfilled, onRejected, prom));
  return prom;
};
Promise$1.prototype['finally'] = finallyConstructor;
Promise$1.all = function (arr) {
  return new Promise$1(function (resolve, reject) {
    if (!isArray(arr)) {
      return reject(new TypeError('Promise.all accepts an array'));
    }
    var args = Array.prototype.slice.call(arr);
    if (args.length === 0) return resolve([]);
    var remaining = args.length;
    function res(i, val) {
      try {
        if (val && (typeof val === 'object' || typeof val === 'function')) {
          var then = val.then;
          if (typeof then === 'function') {
            then.call(val, function (val) {
              res(i, val);
            }, reject);
            return;
          }
        }
        args[i] = val;
        if (--remaining === 0) {
          resolve(args);
        }
      } catch (ex) {
        reject(ex);
      }
    }
    for (var i = 0; i < args.length; i++) {
      res(i, args[i]);
    }
  });
};
Promise$1.any = any;
Promise$1.allSettled = allSettled;
Promise$1.resolve = function (value) {
  if (value && typeof value === 'object' && value.constructor === Promise$1) {
    return value;
  }
  return new Promise$1(function (resolve) {
    resolve(value);
  });
};
Promise$1.reject = function (value) {
  return new Promise$1(function (resolve, reject) {
    reject(value);
  });
};
Promise$1.race = function (arr) {
  return new Promise$1(function (resolve, reject) {
    if (!isArray(arr)) {
      return reject(new TypeError('Promise.race accepts an array'));
    }
    for (var i = 0, len = arr.length; i < len; i++) {
      Promise$1.resolve(arr[i]).then(resolve, reject);
    }
  });
};

// Use polyfill for setImmediate for performance gains
Promise$1._immediateFn =
// @ts-ignore
typeof setImmediate === 'function' && function (fn) {
  // @ts-ignore
  setImmediate(fn);
} || function (fn) {
  setTimeoutFunc(fn, 0);
};
Promise$1._unhandledRejectionFn = function _unhandledRejectionFn(err) {
  if (typeof console !== 'undefined' && console) {
    console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
  }
};

/** @suppress {undefinedVars} */
var globalNS = function () {
  // the only reliable means to get the global object is
  // `Function('return this')()`
  // However, this causes CSP violations in Chrome apps.
  if (typeof self !== 'undefined') {
    return self;
  }
  if (typeof window !== 'undefined') {
    return window;
  }
  if (typeof global !== 'undefined') {
    return global;
  }
  throw new Error('unable to locate global object');
}();

// Expose the polyfill if Promise is undefined or set to a
// non-function value. The latter can be due to a named HTMLElement
// being exposed by browsers for legacy reasons.
// https://github.com/taylorhakes/promise-polyfill/issues/114
if (typeof globalNS['Promise'] !== 'function') {
  globalNS['Promise'] = Promise$1;
} else {
  if (!globalNS.Promise.prototype['finally']) {
    globalNS.Promise.prototype['finally'] = finallyConstructor;
  }
  if (!globalNS.Promise.allSettled) {
    globalNS.Promise.allSettled = allSettled;
  }
  if (!globalNS.Promise.any) {
    globalNS.Promise.any = any;
  }
}

/* eslint-disable no-prototype-builtins */
var g = typeof globalThis !== 'undefined' && globalThis || typeof self !== 'undefined' && self ||
// eslint-disable-next-line no-undef
typeof global !== 'undefined' && global || {};
var support = {
  searchParams: 'URLSearchParams' in g,
  iterable: 'Symbol' in g && 'iterator' in Symbol,
  blob: 'FileReader' in g && 'Blob' in g && function () {
    try {
      new Blob();
      return true;
    } catch (e) {
      return false;
    }
  }(),
  formData: 'FormData' in g,
  arrayBuffer: 'ArrayBuffer' in g
};
function isDataView(obj) {
  return obj && DataView.prototype.isPrototypeOf(obj);
}
if (support.arrayBuffer) {
  var viewClasses = ['[object Int8Array]', '[object Uint8Array]', '[object Uint8ClampedArray]', '[object Int16Array]', '[object Uint16Array]', '[object Int32Array]', '[object Uint32Array]', '[object Float32Array]', '[object Float64Array]'];
  var isArrayBufferView = ArrayBuffer.isView || function (obj) {
    return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
  };
}
function normalizeName(name) {
  if (typeof name !== 'string') {
    name = String(name);
  }
  if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === '') {
    throw new TypeError('Invalid character in header field name: "' + name + '"');
  }
  return name.toLowerCase();
}
function normalizeValue(value) {
  if (typeof value !== 'string') {
    value = String(value);
  }
  return value;
}

// Build a destructive iterator for the value list
function iteratorFor(items) {
  var iterator = {
    next: function () {
      var value = items.shift();
      return {
        done: value === undefined,
        value: value
      };
    }
  };
  if (support.iterable) {
    iterator[Symbol.iterator] = function () {
      return iterator;
    };
  }
  return iterator;
}
function Headers$1(headers) {
  this.map = {};
  if (headers instanceof Headers$1) {
    headers.forEach(function (value, name) {
      this.append(name, value);
    }, this);
  } else if (Array.isArray(headers)) {
    headers.forEach(function (header) {
      if (header.length != 2) {
        throw new TypeError('Headers constructor: expected name/value pair to be length 2, found' + header.length);
      }
      this.append(header[0], header[1]);
    }, this);
  } else if (headers) {
    Object.getOwnPropertyNames(headers).forEach(function (name) {
      this.append(name, headers[name]);
    }, this);
  }
}
Headers$1.prototype.append = function (name, value) {
  name = normalizeName(name);
  value = normalizeValue(value);
  var oldValue = this.map[name];
  this.map[name] = oldValue ? oldValue + ', ' + value : value;
};
Headers$1.prototype['delete'] = function (name) {
  delete this.map[normalizeName(name)];
};
Headers$1.prototype.get = function (name) {
  name = normalizeName(name);
  return this.has(name) ? this.map[name] : null;
};
Headers$1.prototype.has = function (name) {
  return this.map.hasOwnProperty(normalizeName(name));
};
Headers$1.prototype.set = function (name, value) {
  this.map[normalizeName(name)] = normalizeValue(value);
};
Headers$1.prototype.forEach = function (callback, thisArg) {
  for (var name in this.map) {
    if (this.map.hasOwnProperty(name)) {
      callback.call(thisArg, this.map[name], name, this);
    }
  }
};
Headers$1.prototype.keys = function () {
  var items = [];
  this.forEach(function (value, name) {
    items.push(name);
  });
  return iteratorFor(items);
};
Headers$1.prototype.values = function () {
  var items = [];
  this.forEach(function (value) {
    items.push(value);
  });
  return iteratorFor(items);
};
Headers$1.prototype.entries = function () {
  var items = [];
  this.forEach(function (value, name) {
    items.push([name, value]);
  });
  return iteratorFor(items);
};
if (support.iterable) {
  Headers$1.prototype[Symbol.iterator] = Headers$1.prototype.entries;
}
function consumed(body) {
  if (body._noBody) return;
  if (body.bodyUsed) {
    return Promise.reject(new TypeError('Already read'));
  }
  body.bodyUsed = true;
}
function fileReaderReady(reader) {
  return new Promise(function (resolve, reject) {
    reader.onload = function () {
      resolve(reader.result);
    };
    reader.onerror = function () {
      reject(reader.error);
    };
  });
}
function readBlobAsArrayBuffer(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  reader.readAsArrayBuffer(blob);
  return promise;
}
function readBlobAsText(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);
  var encoding = match ? match[1] : 'utf-8';
  reader.readAsText(blob, encoding);
  return promise;
}
function readArrayBufferAsText(buf) {
  var view = new Uint8Array(buf);
  var chars = new Array(view.length);
  for (var i = 0; i < view.length; i++) {
    chars[i] = String.fromCharCode(view[i]);
  }
  return chars.join('');
}
function bufferClone(buf) {
  if (buf.slice) {
    return buf.slice(0);
  } else {
    var view = new Uint8Array(buf.byteLength);
    view.set(new Uint8Array(buf));
    return view.buffer;
  }
}
function Body() {
  this.bodyUsed = false;
  this._initBody = function (body) {
    /*
      fetch-mock wraps the Response object in an ES6 Proxy to
      provide useful test harness features such as flush. However, on
      ES5 browsers without fetch or Proxy support pollyfills must be used;
      the proxy-pollyfill is unable to proxy an attribute unless it exists
      on the object before the Proxy is created. This change ensures
      Response.bodyUsed exists on the instance, while maintaining the
      semantic of setting Request.bodyUsed in the constructor before
      _initBody is called.
    */
    // eslint-disable-next-line no-self-assign
    this.bodyUsed = this.bodyUsed;
    this._bodyInit = body;
    if (!body) {
      this._noBody = true;
      this._bodyText = '';
    } else if (typeof body === 'string') {
      this._bodyText = body;
    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
      this._bodyBlob = body;
    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
      this._bodyFormData = body;
    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
      this._bodyText = body.toString();
    } else if (support.arrayBuffer && support.blob && isDataView(body)) {
      this._bodyArrayBuffer = bufferClone(body.buffer);
      // IE 10-11 can't handle a DataView body.
      this._bodyInit = new Blob([this._bodyArrayBuffer]);
    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
      this._bodyArrayBuffer = bufferClone(body);
    } else {
      this._bodyText = body = Object.prototype.toString.call(body);
    }
    if (!this.headers.get('content-type')) {
      if (typeof body === 'string') {
        this.headers.set('content-type', 'text/plain;charset=UTF-8');
      } else if (this._bodyBlob && this._bodyBlob.type) {
        this.headers.set('content-type', this._bodyBlob.type);
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
      }
    }
  };
  if (support.blob) {
    this.blob = function () {
      var rejected = consumed(this);
      if (rejected) {
        return rejected;
      }
      if (this._bodyBlob) {
        return Promise.resolve(this._bodyBlob);
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(new Blob([this._bodyArrayBuffer]));
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as blob');
      } else {
        return Promise.resolve(new Blob([this._bodyText]));
      }
    };
  }
  this.arrayBuffer = function () {
    if (this._bodyArrayBuffer) {
      var isConsumed = consumed(this);
      if (isConsumed) {
        return isConsumed;
      } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
        return Promise.resolve(this._bodyArrayBuffer.buffer.slice(this._bodyArrayBuffer.byteOffset, this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength));
      } else {
        return Promise.resolve(this._bodyArrayBuffer);
      }
    } else if (support.blob) {
      return this.blob().then(readBlobAsArrayBuffer);
    } else {
      throw new Error('could not read as ArrayBuffer');
    }
  };
  this.text = function () {
    var rejected = consumed(this);
    if (rejected) {
      return rejected;
    }
    if (this._bodyBlob) {
      return readBlobAsText(this._bodyBlob);
    } else if (this._bodyArrayBuffer) {
      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
    } else if (this._bodyFormData) {
      throw new Error('could not read FormData body as text');
    } else {
      return Promise.resolve(this._bodyText);
    }
  };
  if (support.formData) {
    this.formData = function () {
      return this.text().then(decode);
    };
  }
  this.json = function () {
    return this.text().then(JSON.parse);
  };
  return this;
}

// HTTP methods whose capitalization should be normalized
var methods = ['CONNECT', 'DELETE', 'GET', 'HEAD', 'OPTIONS', 'PATCH', 'POST', 'PUT', 'TRACE'];
function normalizeMethod(method) {
  var upcased = method.toUpperCase();
  return methods.indexOf(upcased) > -1 ? upcased : method;
}
function Request(input, options) {
  if (!(this instanceof Request)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  }
  options = options || {};
  var body = options.body;
  if (input instanceof Request) {
    if (input.bodyUsed) {
      throw new TypeError('Already read');
    }
    this.url = input.url;
    this.credentials = input.credentials;
    if (!options.headers) {
      this.headers = new Headers$1(input.headers);
    }
    this.method = input.method;
    this.mode = input.mode;
    this.signal = input.signal;
    if (!body && input._bodyInit != null) {
      body = input._bodyInit;
      input.bodyUsed = true;
    }
  } else {
    this.url = String(input);
  }
  this.credentials = options.credentials || this.credentials || 'same-origin';
  if (options.headers || !this.headers) {
    this.headers = new Headers$1(options.headers);
  }
  this.method = normalizeMethod(options.method || this.method || 'GET');
  this.mode = options.mode || this.mode || null;
  this.signal = options.signal || this.signal || function () {
    if ('AbortController' in g) {
      var ctrl = new AbortController();
      return ctrl.signal;
    }
  }();
  this.referrer = null;
  if ((this.method === 'GET' || this.method === 'HEAD') && body) {
    throw new TypeError('Body not allowed for GET or HEAD requests');
  }
  this._initBody(body);
  if (this.method === 'GET' || this.method === 'HEAD') {
    if (options.cache === 'no-store' || options.cache === 'no-cache') {
      // Search for a '_' parameter in the query string
      var reParamSearch = /([?&])_=[^&]*/;
      if (reParamSearch.test(this.url)) {
        // If it already exists then set the value with the current time
        this.url = this.url.replace(reParamSearch, '$1_=' + new Date().getTime());
      } else {
        // Otherwise add a new '_' parameter to the end with the current time
        var reQueryString = /\?/;
        this.url += (reQueryString.test(this.url) ? '&' : '?') + '_=' + new Date().getTime();
      }
    }
  }
}
Request.prototype.clone = function () {
  return new Request(this, {
    body: this._bodyInit
  });
};
function decode(body) {
  var form = new FormData();
  body.trim().split('&').forEach(function (bytes) {
    if (bytes) {
      var split = bytes.split('=');
      var name = split.shift().replace(/\+/g, ' ');
      var value = split.join('=').replace(/\+/g, ' ');
      form.append(decodeURIComponent(name), decodeURIComponent(value));
    }
  });
  return form;
}
function parseHeaders(rawHeaders) {
  var headers = new Headers$1();
  // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
  // https://tools.ietf.org/html/rfc7230#section-3.2
  var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
  // Avoiding split via regex to work around a common IE11 bug with the core-js 3.6.0 regex polyfill
  // https://github.com/github/fetch/issues/748
  // https://github.com/zloirock/core-js/issues/751
  preProcessedHeaders.split('\r').map(function (header) {
    return header.indexOf('\n') === 0 ? header.substr(1, header.length) : header;
  }).forEach(function (line) {
    var parts = line.split(':');
    var key = parts.shift().trim();
    if (key) {
      var value = parts.join(':').trim();
      try {
        headers.append(key, value);
      } catch (error) {
        console.warn('Response ' + error.message);
      }
    }
  });
  return headers;
}
Body.call(Request.prototype);
function Response$1(bodyInit, options) {
  if (!(this instanceof Response$1)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  }
  if (!options) {
    options = {};
  }
  this.type = 'default';
  this.status = options.status === undefined ? 200 : options.status;
  if (this.status < 200 || this.status > 599) {
    throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
  }
  this.ok = this.status >= 200 && this.status < 300;
  this.statusText = options.statusText === undefined ? '' : '' + options.statusText;
  this.headers = new Headers$1(options.headers);
  this.url = options.url || '';
  this._initBody(bodyInit);
}
Body.call(Response$1.prototype);
Response$1.prototype.clone = function () {
  return new Response$1(this._bodyInit, {
    status: this.status,
    statusText: this.statusText,
    headers: new Headers$1(this.headers),
    url: this.url
  });
};
Response$1.error = function () {
  var response = new Response$1(null, {
    status: 200,
    statusText: ''
  });
  response.ok = false;
  response.status = 0;
  response.type = 'error';
  return response;
};
var redirectStatuses = [301, 302, 303, 307, 308];
Response$1.redirect = function (url, status) {
  if (redirectStatuses.indexOf(status) === -1) {
    throw new RangeError('Invalid status code');
  }
  return new Response$1(null, {
    status: status,
    headers: {
      location: url
    }
  });
};
var DOMException$1 = g.DOMException;
try {
  new DOMException$1();
} catch (err) {
  DOMException$1 = function (message, name) {
    this.message = message;
    this.name = name;
    var error = Error(message);
    this.stack = error.stack;
  };
  DOMException$1.prototype = Object.create(Error.prototype);
  DOMException$1.prototype.constructor = DOMException$1;
}
function fetch$2(input, init) {
  return new Promise(function (resolve, reject) {
    var request = new Request(input, init);
    if (request.signal && request.signal.aborted) {
      return reject(new DOMException$1('Aborted', 'AbortError'));
    }
    var xhr = new XMLHttpRequest();
    function abortXhr() {
      xhr.abort();
    }
    xhr.onload = function () {
      var options = {
        statusText: xhr.statusText,
        headers: parseHeaders(xhr.getAllResponseHeaders() || '')
      };
      // This check if specifically for when a user fetches a file locally from the file system
      // Only if the status is out of a normal range
      if (request.url.indexOf('file://') === 0 && (xhr.status < 200 || xhr.status > 599)) {
        options.status = 200;
      } else {
        options.status = xhr.status;
      }
      options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
      var body = 'response' in xhr ? xhr.response : xhr.responseText;
      setTimeout(function () {
        resolve(new Response$1(body, options));
      }, 0);
    };
    xhr.onerror = function () {
      setTimeout(function () {
        reject(new TypeError('Network request failed'));
      }, 0);
    };
    xhr.ontimeout = function () {
      setTimeout(function () {
        reject(new TypeError('Network request timed out'));
      }, 0);
    };
    xhr.onabort = function () {
      setTimeout(function () {
        reject(new DOMException$1('Aborted', 'AbortError'));
      }, 0);
    };
    function fixUrl(url) {
      try {
        return url === '' && g.location.href ? g.location.href : url;
      } catch (e) {
        return url;
      }
    }
    xhr.open(request.method, fixUrl(request.url), true);
    if (request.credentials === 'include') {
      xhr.withCredentials = true;
    } else if (request.credentials === 'omit') {
      xhr.withCredentials = false;
    }
    if ('responseType' in xhr) {
      if (support.blob) {
        xhr.responseType = 'blob';
      } else if (support.arrayBuffer) {
        xhr.responseType = 'arraybuffer';
      }
    }
    if (init && typeof init.headers === 'object' && !(init.headers instanceof Headers$1 || g.Headers && init.headers instanceof g.Headers)) {
      var names = [];
      Object.getOwnPropertyNames(init.headers).forEach(function (name) {
        names.push(normalizeName(name));
        xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
      });
      request.headers.forEach(function (value, name) {
        if (names.indexOf(name) === -1) {
          xhr.setRequestHeader(name, value);
        }
      });
    } else {
      request.headers.forEach(function (value, name) {
        xhr.setRequestHeader(name, value);
      });
    }
    if (request.signal) {
      request.signal.addEventListener('abort', abortXhr);
      xhr.onreadystatechange = function () {
        // DONE (success or failure)
        if (xhr.readyState === 4) {
          request.signal.removeEventListener('abort', abortXhr);
        }
      };
    }
    xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
  });
}
fetch$2.polyfill = true;
if (!g.fetch) {
  g.fetch = fetch$2;
  g.Headers = Headers$1;
  g.Request = Request;
  g.Response = Response$1;
}

/*
Stimulus 3.2.1
Copyright Â© 2023 Basecamp, LLC
 */
class EventListener {
  constructor(eventTarget, eventName, eventOptions) {
    this.eventTarget = eventTarget;
    this.eventName = eventName;
    this.eventOptions = eventOptions;
    this.unorderedBindings = new Set();
  }
  connect() {
    this.eventTarget.addEventListener(this.eventName, this, this.eventOptions);
  }
  disconnect() {
    this.eventTarget.removeEventListener(this.eventName, this, this.eventOptions);
  }
  bindingConnected(binding) {
    this.unorderedBindings.add(binding);
  }
  bindingDisconnected(binding) {
    this.unorderedBindings.delete(binding);
  }
  handleEvent(event) {
    const extendedEvent = extendEvent(event);
    for (const binding of this.bindings) {
      if (extendedEvent.immediatePropagationStopped) {
        break;
      } else {
        binding.handleEvent(extendedEvent);
      }
    }
  }
  hasBindings() {
    return this.unorderedBindings.size > 0;
  }
  get bindings() {
    return Array.from(this.unorderedBindings).sort((left, right) => {
      const leftIndex = left.index,
        rightIndex = right.index;
      return leftIndex < rightIndex ? -1 : leftIndex > rightIndex ? 1 : 0;
    });
  }
}
function extendEvent(event) {
  if ("immediatePropagationStopped" in event) {
    return event;
  } else {
    const {
      stopImmediatePropagation
    } = event;
    return Object.assign(event, {
      immediatePropagationStopped: false,
      stopImmediatePropagation() {
        this.immediatePropagationStopped = true;
        stopImmediatePropagation.call(this);
      }
    });
  }
}
class Dispatcher {
  constructor(application) {
    this.application = application;
    this.eventListenerMaps = new Map();
    this.started = false;
  }
  start() {
    if (!this.started) {
      this.started = true;
      this.eventListeners.forEach(eventListener => eventListener.connect());
    }
  }
  stop() {
    if (this.started) {
      this.started = false;
      this.eventListeners.forEach(eventListener => eventListener.disconnect());
    }
  }
  get eventListeners() {
    return Array.from(this.eventListenerMaps.values()).reduce((listeners, map) => listeners.concat(Array.from(map.values())), []);
  }
  bindingConnected(binding) {
    this.fetchEventListenerForBinding(binding).bindingConnected(binding);
  }
  bindingDisconnected(binding, clearEventListeners = false) {
    this.fetchEventListenerForBinding(binding).bindingDisconnected(binding);
    if (clearEventListeners) this.clearEventListenersForBinding(binding);
  }
  handleError(error, message, detail = {}) {
    this.application.handleError(error, `Error ${message}`, detail);
  }
  clearEventListenersForBinding(binding) {
    const eventListener = this.fetchEventListenerForBinding(binding);
    if (!eventListener.hasBindings()) {
      eventListener.disconnect();
      this.removeMappedEventListenerFor(binding);
    }
  }
  removeMappedEventListenerFor(binding) {
    const {
      eventTarget,
      eventName,
      eventOptions
    } = binding;
    const eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget);
    const cacheKey = this.cacheKey(eventName, eventOptions);
    eventListenerMap.delete(cacheKey);
    if (eventListenerMap.size == 0) this.eventListenerMaps.delete(eventTarget);
  }
  fetchEventListenerForBinding(binding) {
    const {
      eventTarget,
      eventName,
      eventOptions
    } = binding;
    return this.fetchEventListener(eventTarget, eventName, eventOptions);
  }
  fetchEventListener(eventTarget, eventName, eventOptions) {
    const eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget);
    const cacheKey = this.cacheKey(eventName, eventOptions);
    let eventListener = eventListenerMap.get(cacheKey);
    if (!eventListener) {
      eventListener = this.createEventListener(eventTarget, eventName, eventOptions);
      eventListenerMap.set(cacheKey, eventListener);
    }
    return eventListener;
  }
  createEventListener(eventTarget, eventName, eventOptions) {
    const eventListener = new EventListener(eventTarget, eventName, eventOptions);
    if (this.started) {
      eventListener.connect();
    }
    return eventListener;
  }
  fetchEventListenerMapForEventTarget(eventTarget) {
    let eventListenerMap = this.eventListenerMaps.get(eventTarget);
    if (!eventListenerMap) {
      eventListenerMap = new Map();
      this.eventListenerMaps.set(eventTarget, eventListenerMap);
    }
    return eventListenerMap;
  }
  cacheKey(eventName, eventOptions) {
    const parts = [eventName];
    Object.keys(eventOptions).sort().forEach(key => {
      parts.push(`${eventOptions[key] ? "" : "!"}${key}`);
    });
    return parts.join(":");
  }
}
const defaultActionDescriptorFilters = {
  stop({
    event,
    value
  }) {
    if (value) event.stopPropagation();
    return true;
  },
  prevent({
    event,
    value
  }) {
    if (value) event.preventDefault();
    return true;
  },
  self({
    event,
    value,
    element
  }) {
    if (value) {
      return element === event.target;
    } else {
      return true;
    }
  }
};
const descriptorPattern = /^(?:(?:([^.]+?)\+)?(.+?)(?:\.(.+?))?(?:@(window|document))?->)?(.+?)(?:#([^:]+?))(?::(.+))?$/;
function parseActionDescriptorString(descriptorString) {
  const source = descriptorString.trim();
  const matches = source.match(descriptorPattern) || [];
  let eventName = matches[2];
  let keyFilter = matches[3];
  if (keyFilter && !["keydown", "keyup", "keypress"].includes(eventName)) {
    eventName += `.${keyFilter}`;
    keyFilter = "";
  }
  return {
    eventTarget: parseEventTarget(matches[4]),
    eventName,
    eventOptions: matches[7] ? parseEventOptions(matches[7]) : {},
    identifier: matches[5],
    methodName: matches[6],
    keyFilter: matches[1] || keyFilter
  };
}
function parseEventTarget(eventTargetName) {
  if (eventTargetName == "window") {
    return window;
  } else if (eventTargetName == "document") {
    return document;
  }
}
function parseEventOptions(eventOptions) {
  return eventOptions.split(":").reduce((options, token) => Object.assign(options, {
    [token.replace(/^!/, "")]: !/^!/.test(token)
  }), {});
}
function stringifyEventTarget(eventTarget) {
  if (eventTarget == window) {
    return "window";
  } else if (eventTarget == document) {
    return "document";
  }
}
function camelize(value) {
  return value.replace(/(?:[_-])([a-z0-9])/g, (_, char) => char.toUpperCase());
}
function namespaceCamelize(value) {
  return camelize(value.replace(/--/g, "-").replace(/__/g, "_"));
}
function capitalize(value) {
  return value.charAt(0).toUpperCase() + value.slice(1);
}
function dasherize(value) {
  return value.replace(/([A-Z])/g, (_, char) => `-${char.toLowerCase()}`);
}
function tokenize(value) {
  return value.match(/[^\s]+/g) || [];
}
function isSomething(object) {
  return object !== null && object !== undefined;
}
function hasProperty(object, property) {
  return Object.prototype.hasOwnProperty.call(object, property);
}
const allModifiers = ["meta", "ctrl", "alt", "shift"];
class Action {
  constructor(element, index, descriptor, schema) {
    this.element = element;
    this.index = index;
    this.eventTarget = descriptor.eventTarget || element;
    this.eventName = descriptor.eventName || getDefaultEventNameForElement(element) || error("missing event name");
    this.eventOptions = descriptor.eventOptions || {};
    this.identifier = descriptor.identifier || error("missing identifier");
    this.methodName = descriptor.methodName || error("missing method name");
    this.keyFilter = descriptor.keyFilter || "";
    this.schema = schema;
  }
  static forToken(token, schema) {
    return new this(token.element, token.index, parseActionDescriptorString(token.content), schema);
  }
  toString() {
    const eventFilter = this.keyFilter ? `.${this.keyFilter}` : "";
    const eventTarget = this.eventTargetName ? `@${this.eventTargetName}` : "";
    return `${this.eventName}${eventFilter}${eventTarget}->${this.identifier}#${this.methodName}`;
  }
  shouldIgnoreKeyboardEvent(event) {
    if (!this.keyFilter) {
      return false;
    }
    const filters = this.keyFilter.split("+");
    if (this.keyFilterDissatisfied(event, filters)) {
      return true;
    }
    const standardFilter = filters.filter(key => !allModifiers.includes(key))[0];
    if (!standardFilter) {
      return false;
    }
    if (!hasProperty(this.keyMappings, standardFilter)) {
      error(`contains unknown key filter: ${this.keyFilter}`);
    }
    return this.keyMappings[standardFilter].toLowerCase() !== event.key.toLowerCase();
  }
  shouldIgnoreMouseEvent(event) {
    if (!this.keyFilter) {
      return false;
    }
    const filters = [this.keyFilter];
    if (this.keyFilterDissatisfied(event, filters)) {
      return true;
    }
    return false;
  }
  get params() {
    const params = {};
    const pattern = new RegExp(`^data-${this.identifier}-(.+)-param$`, "i");
    for (const {
      name,
      value
    } of Array.from(this.element.attributes)) {
      const match = name.match(pattern);
      const key = match && match[1];
      if (key) {
        params[camelize(key)] = typecast(value);
      }
    }
    return params;
  }
  get eventTargetName() {
    return stringifyEventTarget(this.eventTarget);
  }
  get keyMappings() {
    return this.schema.keyMappings;
  }
  keyFilterDissatisfied(event, filters) {
    const [meta, ctrl, alt, shift] = allModifiers.map(modifier => filters.includes(modifier));
    return event.metaKey !== meta || event.ctrlKey !== ctrl || event.altKey !== alt || event.shiftKey !== shift;
  }
}
const defaultEventNames = {
  a: () => "click",
  button: () => "click",
  form: () => "submit",
  details: () => "toggle",
  input: e => e.getAttribute("type") == "submit" ? "click" : "input",
  select: () => "change",
  textarea: () => "input"
};
function getDefaultEventNameForElement(element) {
  const tagName = element.tagName.toLowerCase();
  if (tagName in defaultEventNames) {
    return defaultEventNames[tagName](element);
  }
}
function error(message) {
  throw new Error(message);
}
function typecast(value) {
  try {
    return JSON.parse(value);
  } catch (o_O) {
    return value;
  }
}
class Binding {
  constructor(context, action) {
    this.context = context;
    this.action = action;
  }
  get index() {
    return this.action.index;
  }
  get eventTarget() {
    return this.action.eventTarget;
  }
  get eventOptions() {
    return this.action.eventOptions;
  }
  get identifier() {
    return this.context.identifier;
  }
  handleEvent(event) {
    const actionEvent = this.prepareActionEvent(event);
    if (this.willBeInvokedByEvent(event) && this.applyEventModifiers(actionEvent)) {
      this.invokeWithEvent(actionEvent);
    }
  }
  get eventName() {
    return this.action.eventName;
  }
  get method() {
    const method = this.controller[this.methodName];
    if (typeof method == "function") {
      return method;
    }
    throw new Error(`Action "${this.action}" references undefined method "${this.methodName}"`);
  }
  applyEventModifiers(event) {
    const {
      element
    } = this.action;
    const {
      actionDescriptorFilters
    } = this.context.application;
    const {
      controller
    } = this.context;
    let passes = true;
    for (const [name, value] of Object.entries(this.eventOptions)) {
      if (name in actionDescriptorFilters) {
        const filter = actionDescriptorFilters[name];
        passes = passes && filter({
          name,
          value,
          event,
          element,
          controller
        });
      } else {
        continue;
      }
    }
    return passes;
  }
  prepareActionEvent(event) {
    return Object.assign(event, {
      params: this.action.params
    });
  }
  invokeWithEvent(event) {
    const {
      target,
      currentTarget
    } = event;
    try {
      this.method.call(this.controller, event);
      this.context.logDebugActivity(this.methodName, {
        event,
        target,
        currentTarget,
        action: this.methodName
      });
    } catch (error) {
      const {
        identifier,
        controller,
        element,
        index
      } = this;
      const detail = {
        identifier,
        controller,
        element,
        index,
        event
      };
      this.context.handleError(error, `invoking action "${this.action}"`, detail);
    }
  }
  willBeInvokedByEvent(event) {
    const eventTarget = event.target;
    if (event instanceof KeyboardEvent && this.action.shouldIgnoreKeyboardEvent(event)) {
      return false;
    }
    if (event instanceof MouseEvent && this.action.shouldIgnoreMouseEvent(event)) {
      return false;
    }
    if (this.element === eventTarget) {
      return true;
    } else if (eventTarget instanceof Element && this.element.contains(eventTarget)) {
      return this.scope.containsElement(eventTarget);
    } else {
      return this.scope.containsElement(this.action.element);
    }
  }
  get controller() {
    return this.context.controller;
  }
  get methodName() {
    return this.action.methodName;
  }
  get element() {
    return this.scope.element;
  }
  get scope() {
    return this.context.scope;
  }
}
class ElementObserver {
  constructor(element, delegate) {
    this.mutationObserverInit = {
      attributes: true,
      childList: true,
      subtree: true
    };
    this.element = element;
    this.started = false;
    this.delegate = delegate;
    this.elements = new Set();
    this.mutationObserver = new MutationObserver(mutations => this.processMutations(mutations));
  }
  start() {
    if (!this.started) {
      this.started = true;
      this.mutationObserver.observe(this.element, this.mutationObserverInit);
      this.refresh();
    }
  }
  pause(callback) {
    if (this.started) {
      this.mutationObserver.disconnect();
      this.started = false;
    }
    callback();
    if (!this.started) {
      this.mutationObserver.observe(this.element, this.mutationObserverInit);
      this.started = true;
    }
  }
  stop() {
    if (this.started) {
      this.mutationObserver.takeRecords();
      this.mutationObserver.disconnect();
      this.started = false;
    }
  }
  refresh() {
    if (this.started) {
      const matches = new Set(this.matchElementsInTree());
      for (const element of Array.from(this.elements)) {
        if (!matches.has(element)) {
          this.removeElement(element);
        }
      }
      for (const element of Array.from(matches)) {
        this.addElement(element);
      }
    }
  }
  processMutations(mutations) {
    if (this.started) {
      for (const mutation of mutations) {
        this.processMutation(mutation);
      }
    }
  }
  processMutation(mutation) {
    if (mutation.type == "attributes") {
      this.processAttributeChange(mutation.target, mutation.attributeName);
    } else if (mutation.type == "childList") {
      this.processRemovedNodes(mutation.removedNodes);
      this.processAddedNodes(mutation.addedNodes);
    }
  }
  processAttributeChange(element, attributeName) {
    if (this.elements.has(element)) {
      if (this.delegate.elementAttributeChanged && this.matchElement(element)) {
        this.delegate.elementAttributeChanged(element, attributeName);
      } else {
        this.removeElement(element);
      }
    } else if (this.matchElement(element)) {
      this.addElement(element);
    }
  }
  processRemovedNodes(nodes) {
    for (const node of Array.from(nodes)) {
      const element = this.elementFromNode(node);
      if (element) {
        this.processTree(element, this.removeElement);
      }
    }
  }
  processAddedNodes(nodes) {
    for (const node of Array.from(nodes)) {
      const element = this.elementFromNode(node);
      if (element && this.elementIsActive(element)) {
        this.processTree(element, this.addElement);
      }
    }
  }
  matchElement(element) {
    return this.delegate.matchElement(element);
  }
  matchElementsInTree(tree = this.element) {
    return this.delegate.matchElementsInTree(tree);
  }
  processTree(tree, processor) {
    for (const element of this.matchElementsInTree(tree)) {
      processor.call(this, element);
    }
  }
  elementFromNode(node) {
    if (node.nodeType == Node.ELEMENT_NODE) {
      return node;
    }
  }
  elementIsActive(element) {
    if (element.isConnected != this.element.isConnected) {
      return false;
    } else {
      return this.element.contains(element);
    }
  }
  addElement(element) {
    if (!this.elements.has(element)) {
      if (this.elementIsActive(element)) {
        this.elements.add(element);
        if (this.delegate.elementMatched) {
          this.delegate.elementMatched(element);
        }
      }
    }
  }
  removeElement(element) {
    if (this.elements.has(element)) {
      this.elements.delete(element);
      if (this.delegate.elementUnmatched) {
        this.delegate.elementUnmatched(element);
      }
    }
  }
}
class AttributeObserver {
  constructor(element, attributeName, delegate) {
    this.attributeName = attributeName;
    this.delegate = delegate;
    this.elementObserver = new ElementObserver(element, this);
  }
  get element() {
    return this.elementObserver.element;
  }
  get selector() {
    return `[${this.attributeName}]`;
  }
  start() {
    this.elementObserver.start();
  }
  pause(callback) {
    this.elementObserver.pause(callback);
  }
  stop() {
    this.elementObserver.stop();
  }
  refresh() {
    this.elementObserver.refresh();
  }
  get started() {
    return this.elementObserver.started;
  }
  matchElement(element) {
    return element.hasAttribute(this.attributeName);
  }
  matchElementsInTree(tree) {
    const match = this.matchElement(tree) ? [tree] : [];
    const matches = Array.from(tree.querySelectorAll(this.selector));
    return match.concat(matches);
  }
  elementMatched(element) {
    if (this.delegate.elementMatchedAttribute) {
      this.delegate.elementMatchedAttribute(element, this.attributeName);
    }
  }
  elementUnmatched(element) {
    if (this.delegate.elementUnmatchedAttribute) {
      this.delegate.elementUnmatchedAttribute(element, this.attributeName);
    }
  }
  elementAttributeChanged(element, attributeName) {
    if (this.delegate.elementAttributeValueChanged && this.attributeName == attributeName) {
      this.delegate.elementAttributeValueChanged(element, attributeName);
    }
  }
}
function add(map, key, value) {
  fetch$1(map, key).add(value);
}
function del(map, key, value) {
  fetch$1(map, key).delete(value);
  prune(map, key);
}
function fetch$1(map, key) {
  let values = map.get(key);
  if (!values) {
    values = new Set();
    map.set(key, values);
  }
  return values;
}
function prune(map, key) {
  const values = map.get(key);
  if (values != null && values.size == 0) {
    map.delete(key);
  }
}
class Multimap {
  constructor() {
    this.valuesByKey = new Map();
  }
  get keys() {
    return Array.from(this.valuesByKey.keys());
  }
  get values() {
    const sets = Array.from(this.valuesByKey.values());
    return sets.reduce((values, set) => values.concat(Array.from(set)), []);
  }
  get size() {
    const sets = Array.from(this.valuesByKey.values());
    return sets.reduce((size, set) => size + set.size, 0);
  }
  add(key, value) {
    add(this.valuesByKey, key, value);
  }
  delete(key, value) {
    del(this.valuesByKey, key, value);
  }
  has(key, value) {
    const values = this.valuesByKey.get(key);
    return values != null && values.has(value);
  }
  hasKey(key) {
    return this.valuesByKey.has(key);
  }
  hasValue(value) {
    const sets = Array.from(this.valuesByKey.values());
    return sets.some(set => set.has(value));
  }
  getValuesForKey(key) {
    const values = this.valuesByKey.get(key);
    return values ? Array.from(values) : [];
  }
  getKeysForValue(value) {
    return Array.from(this.valuesByKey).filter(([_key, values]) => values.has(value)).map(([key, _values]) => key);
  }
}
class SelectorObserver {
  constructor(element, selector, delegate, details) {
    this._selector = selector;
    this.details = details;
    this.elementObserver = new ElementObserver(element, this);
    this.delegate = delegate;
    this.matchesByElement = new Multimap();
  }
  get started() {
    return this.elementObserver.started;
  }
  get selector() {
    return this._selector;
  }
  set selector(selector) {
    this._selector = selector;
    this.refresh();
  }
  start() {
    this.elementObserver.start();
  }
  pause(callback) {
    this.elementObserver.pause(callback);
  }
  stop() {
    this.elementObserver.stop();
  }
  refresh() {
    this.elementObserver.refresh();
  }
  get element() {
    return this.elementObserver.element;
  }
  matchElement(element) {
    const {
      selector
    } = this;
    if (selector) {
      const matches = element.matches(selector);
      if (this.delegate.selectorMatchElement) {
        return matches && this.delegate.selectorMatchElement(element, this.details);
      }
      return matches;
    } else {
      return false;
    }
  }
  matchElementsInTree(tree) {
    const {
      selector
    } = this;
    if (selector) {
      const match = this.matchElement(tree) ? [tree] : [];
      const matches = Array.from(tree.querySelectorAll(selector)).filter(match => this.matchElement(match));
      return match.concat(matches);
    } else {
      return [];
    }
  }
  elementMatched(element) {
    const {
      selector
    } = this;
    if (selector) {
      this.selectorMatched(element, selector);
    }
  }
  elementUnmatched(element) {
    const selectors = this.matchesByElement.getKeysForValue(element);
    for (const selector of selectors) {
      this.selectorUnmatched(element, selector);
    }
  }
  elementAttributeChanged(element, _attributeName) {
    const {
      selector
    } = this;
    if (selector) {
      const matches = this.matchElement(element);
      const matchedBefore = this.matchesByElement.has(selector, element);
      if (matches && !matchedBefore) {
        this.selectorMatched(element, selector);
      } else if (!matches && matchedBefore) {
        this.selectorUnmatched(element, selector);
      }
    }
  }
  selectorMatched(element, selector) {
    this.delegate.selectorMatched(element, selector, this.details);
    this.matchesByElement.add(selector, element);
  }
  selectorUnmatched(element, selector) {
    this.delegate.selectorUnmatched(element, selector, this.details);
    this.matchesByElement.delete(selector, element);
  }
}
class StringMapObserver {
  constructor(element, delegate) {
    this.element = element;
    this.delegate = delegate;
    this.started = false;
    this.stringMap = new Map();
    this.mutationObserver = new MutationObserver(mutations => this.processMutations(mutations));
  }
  start() {
    if (!this.started) {
      this.started = true;
      this.mutationObserver.observe(this.element, {
        attributes: true,
        attributeOldValue: true
      });
      this.refresh();
    }
  }
  stop() {
    if (this.started) {
      this.mutationObserver.takeRecords();
      this.mutationObserver.disconnect();
      this.started = false;
    }
  }
  refresh() {
    if (this.started) {
      for (const attributeName of this.knownAttributeNames) {
        this.refreshAttribute(attributeName, null);
      }
    }
  }
  processMutations(mutations) {
    if (this.started) {
      for (const mutation of mutations) {
        this.processMutation(mutation);
      }
    }
  }
  processMutation(mutation) {
    const attributeName = mutation.attributeName;
    if (attributeName) {
      this.refreshAttribute(attributeName, mutation.oldValue);
    }
  }
  refreshAttribute(attributeName, oldValue) {
    const key = this.delegate.getStringMapKeyForAttribute(attributeName);
    if (key != null) {
      if (!this.stringMap.has(attributeName)) {
        this.stringMapKeyAdded(key, attributeName);
      }
      const value = this.element.getAttribute(attributeName);
      if (this.stringMap.get(attributeName) != value) {
        this.stringMapValueChanged(value, key, oldValue);
      }
      if (value == null) {
        const oldValue = this.stringMap.get(attributeName);
        this.stringMap.delete(attributeName);
        if (oldValue) this.stringMapKeyRemoved(key, attributeName, oldValue);
      } else {
        this.stringMap.set(attributeName, value);
      }
    }
  }
  stringMapKeyAdded(key, attributeName) {
    if (this.delegate.stringMapKeyAdded) {
      this.delegate.stringMapKeyAdded(key, attributeName);
    }
  }
  stringMapValueChanged(value, key, oldValue) {
    if (this.delegate.stringMapValueChanged) {
      this.delegate.stringMapValueChanged(value, key, oldValue);
    }
  }
  stringMapKeyRemoved(key, attributeName, oldValue) {
    if (this.delegate.stringMapKeyRemoved) {
      this.delegate.stringMapKeyRemoved(key, attributeName, oldValue);
    }
  }
  get knownAttributeNames() {
    return Array.from(new Set(this.currentAttributeNames.concat(this.recordedAttributeNames)));
  }
  get currentAttributeNames() {
    return Array.from(this.element.attributes).map(attribute => attribute.name);
  }
  get recordedAttributeNames() {
    return Array.from(this.stringMap.keys());
  }
}
class TokenListObserver {
  constructor(element, attributeName, delegate) {
    this.attributeObserver = new AttributeObserver(element, attributeName, this);
    this.delegate = delegate;
    this.tokensByElement = new Multimap();
  }
  get started() {
    return this.attributeObserver.started;
  }
  start() {
    this.attributeObserver.start();
  }
  pause(callback) {
    this.attributeObserver.pause(callback);
  }
  stop() {
    this.attributeObserver.stop();
  }
  refresh() {
    this.attributeObserver.refresh();
  }
  get element() {
    return this.attributeObserver.element;
  }
  get attributeName() {
    return this.attributeObserver.attributeName;
  }
  elementMatchedAttribute(element) {
    this.tokensMatched(this.readTokensForElement(element));
  }
  elementAttributeValueChanged(element) {
    const [unmatchedTokens, matchedTokens] = this.refreshTokensForElement(element);
    this.tokensUnmatched(unmatchedTokens);
    this.tokensMatched(matchedTokens);
  }
  elementUnmatchedAttribute(element) {
    this.tokensUnmatched(this.tokensByElement.getValuesForKey(element));
  }
  tokensMatched(tokens) {
    tokens.forEach(token => this.tokenMatched(token));
  }
  tokensUnmatched(tokens) {
    tokens.forEach(token => this.tokenUnmatched(token));
  }
  tokenMatched(token) {
    this.delegate.tokenMatched(token);
    this.tokensByElement.add(token.element, token);
  }
  tokenUnmatched(token) {
    this.delegate.tokenUnmatched(token);
    this.tokensByElement.delete(token.element, token);
  }
  refreshTokensForElement(element) {
    const previousTokens = this.tokensByElement.getValuesForKey(element);
    const currentTokens = this.readTokensForElement(element);
    const firstDifferingIndex = zip(previousTokens, currentTokens).findIndex(([previousToken, currentToken]) => !tokensAreEqual(previousToken, currentToken));
    if (firstDifferingIndex == -1) {
      return [[], []];
    } else {
      return [previousTokens.slice(firstDifferingIndex), currentTokens.slice(firstDifferingIndex)];
    }
  }
  readTokensForElement(element) {
    const attributeName = this.attributeName;
    const tokenString = element.getAttribute(attributeName) || "";
    return parseTokenString(tokenString, element, attributeName);
  }
}
function parseTokenString(tokenString, element, attributeName) {
  return tokenString.trim().split(/\s+/).filter(content => content.length).map((content, index) => ({
    element,
    attributeName,
    content,
    index
  }));
}
function zip(left, right) {
  const length = Math.max(left.length, right.length);
  return Array.from({
    length
  }, (_, index) => [left[index], right[index]]);
}
function tokensAreEqual(left, right) {
  return left && right && left.index == right.index && left.content == right.content;
}
class ValueListObserver {
  constructor(element, attributeName, delegate) {
    this.tokenListObserver = new TokenListObserver(element, attributeName, this);
    this.delegate = delegate;
    this.parseResultsByToken = new WeakMap();
    this.valuesByTokenByElement = new WeakMap();
  }
  get started() {
    return this.tokenListObserver.started;
  }
  start() {
    this.tokenListObserver.start();
  }
  stop() {
    this.tokenListObserver.stop();
  }
  refresh() {
    this.tokenListObserver.refresh();
  }
  get element() {
    return this.tokenListObserver.element;
  }
  get attributeName() {
    return this.tokenListObserver.attributeName;
  }
  tokenMatched(token) {
    const {
      element
    } = token;
    const {
      value
    } = this.fetchParseResultForToken(token);
    if (value) {
      this.fetchValuesByTokenForElement(element).set(token, value);
      this.delegate.elementMatchedValue(element, value);
    }
  }
  tokenUnmatched(token) {
    const {
      element
    } = token;
    const {
      value
    } = this.fetchParseResultForToken(token);
    if (value) {
      this.fetchValuesByTokenForElement(element).delete(token);
      this.delegate.elementUnmatchedValue(element, value);
    }
  }
  fetchParseResultForToken(token) {
    let parseResult = this.parseResultsByToken.get(token);
    if (!parseResult) {
      parseResult = this.parseToken(token);
      this.parseResultsByToken.set(token, parseResult);
    }
    return parseResult;
  }
  fetchValuesByTokenForElement(element) {
    let valuesByToken = this.valuesByTokenByElement.get(element);
    if (!valuesByToken) {
      valuesByToken = new Map();
      this.valuesByTokenByElement.set(element, valuesByToken);
    }
    return valuesByToken;
  }
  parseToken(token) {
    try {
      const value = this.delegate.parseValueForToken(token);
      return {
        value
      };
    } catch (error) {
      return {
        error
      };
    }
  }
}
class BindingObserver {
  constructor(context, delegate) {
    this.context = context;
    this.delegate = delegate;
    this.bindingsByAction = new Map();
  }
  start() {
    if (!this.valueListObserver) {
      this.valueListObserver = new ValueListObserver(this.element, this.actionAttribute, this);
      this.valueListObserver.start();
    }
  }
  stop() {
    if (this.valueListObserver) {
      this.valueListObserver.stop();
      delete this.valueListObserver;
      this.disconnectAllActions();
    }
  }
  get element() {
    return this.context.element;
  }
  get identifier() {
    return this.context.identifier;
  }
  get actionAttribute() {
    return this.schema.actionAttribute;
  }
  get schema() {
    return this.context.schema;
  }
  get bindings() {
    return Array.from(this.bindingsByAction.values());
  }
  connectAction(action) {
    const binding = new Binding(this.context, action);
    this.bindingsByAction.set(action, binding);
    this.delegate.bindingConnected(binding);
  }
  disconnectAction(action) {
    const binding = this.bindingsByAction.get(action);
    if (binding) {
      this.bindingsByAction.delete(action);
      this.delegate.bindingDisconnected(binding);
    }
  }
  disconnectAllActions() {
    this.bindings.forEach(binding => this.delegate.bindingDisconnected(binding, true));
    this.bindingsByAction.clear();
  }
  parseValueForToken(token) {
    const action = Action.forToken(token, this.schema);
    if (action.identifier == this.identifier) {
      return action;
    }
  }
  elementMatchedValue(element, action) {
    this.connectAction(action);
  }
  elementUnmatchedValue(element, action) {
    this.disconnectAction(action);
  }
}
class ValueObserver {
  constructor(context, receiver) {
    this.context = context;
    this.receiver = receiver;
    this.stringMapObserver = new StringMapObserver(this.element, this);
    this.valueDescriptorMap = this.controller.valueDescriptorMap;
  }
  start() {
    this.stringMapObserver.start();
    this.invokeChangedCallbacksForDefaultValues();
  }
  stop() {
    this.stringMapObserver.stop();
  }
  get element() {
    return this.context.element;
  }
  get controller() {
    return this.context.controller;
  }
  getStringMapKeyForAttribute(attributeName) {
    if (attributeName in this.valueDescriptorMap) {
      return this.valueDescriptorMap[attributeName].name;
    }
  }
  stringMapKeyAdded(key, attributeName) {
    const descriptor = this.valueDescriptorMap[attributeName];
    if (!this.hasValue(key)) {
      this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), descriptor.writer(descriptor.defaultValue));
    }
  }
  stringMapValueChanged(value, name, oldValue) {
    const descriptor = this.valueDescriptorNameMap[name];
    if (value === null) return;
    if (oldValue === null) {
      oldValue = descriptor.writer(descriptor.defaultValue);
    }
    this.invokeChangedCallback(name, value, oldValue);
  }
  stringMapKeyRemoved(key, attributeName, oldValue) {
    const descriptor = this.valueDescriptorNameMap[key];
    if (this.hasValue(key)) {
      this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), oldValue);
    } else {
      this.invokeChangedCallback(key, descriptor.writer(descriptor.defaultValue), oldValue);
    }
  }
  invokeChangedCallbacksForDefaultValues() {
    for (const {
      key,
      name,
      defaultValue,
      writer
    } of this.valueDescriptors) {
      if (defaultValue != undefined && !this.controller.data.has(key)) {
        this.invokeChangedCallback(name, writer(defaultValue), undefined);
      }
    }
  }
  invokeChangedCallback(name, rawValue, rawOldValue) {
    const changedMethodName = `${name}Changed`;
    const changedMethod = this.receiver[changedMethodName];
    if (typeof changedMethod == "function") {
      const descriptor = this.valueDescriptorNameMap[name];
      try {
        const value = descriptor.reader(rawValue);
        let oldValue = rawOldValue;
        if (rawOldValue) {
          oldValue = descriptor.reader(rawOldValue);
        }
        changedMethod.call(this.receiver, value, oldValue);
      } catch (error) {
        if (error instanceof TypeError) {
          error.message = `Stimulus Value "${this.context.identifier}.${descriptor.name}" - ${error.message}`;
        }
        throw error;
      }
    }
  }
  get valueDescriptors() {
    const {
      valueDescriptorMap
    } = this;
    return Object.keys(valueDescriptorMap).map(key => valueDescriptorMap[key]);
  }
  get valueDescriptorNameMap() {
    const descriptors = {};
    Object.keys(this.valueDescriptorMap).forEach(key => {
      const descriptor = this.valueDescriptorMap[key];
      descriptors[descriptor.name] = descriptor;
    });
    return descriptors;
  }
  hasValue(attributeName) {
    const descriptor = this.valueDescriptorNameMap[attributeName];
    const hasMethodName = `has${capitalize(descriptor.name)}`;
    return this.receiver[hasMethodName];
  }
}
class TargetObserver {
  constructor(context, delegate) {
    this.context = context;
    this.delegate = delegate;
    this.targetsByName = new Multimap();
  }
  start() {
    if (!this.tokenListObserver) {
      this.tokenListObserver = new TokenListObserver(this.element, this.attributeName, this);
      this.tokenListObserver.start();
    }
  }
  stop() {
    if (this.tokenListObserver) {
      this.disconnectAllTargets();
      this.tokenListObserver.stop();
      delete this.tokenListObserver;
    }
  }
  tokenMatched({
    element,
    content: name
  }) {
    if (this.scope.containsElement(element)) {
      this.connectTarget(element, name);
    }
  }
  tokenUnmatched({
    element,
    content: name
  }) {
    this.disconnectTarget(element, name);
  }
  connectTarget(element, name) {
    var _a;
    if (!this.targetsByName.has(name, element)) {
      this.targetsByName.add(name, element);
      (_a = this.tokenListObserver) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.targetConnected(element, name));
    }
  }
  disconnectTarget(element, name) {
    var _a;
    if (this.targetsByName.has(name, element)) {
      this.targetsByName.delete(name, element);
      (_a = this.tokenListObserver) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.targetDisconnected(element, name));
    }
  }
  disconnectAllTargets() {
    for (const name of this.targetsByName.keys) {
      for (const element of this.targetsByName.getValuesForKey(name)) {
        this.disconnectTarget(element, name);
      }
    }
  }
  get attributeName() {
    return `data-${this.context.identifier}-target`;
  }
  get element() {
    return this.context.element;
  }
  get scope() {
    return this.context.scope;
  }
}
function readInheritableStaticArrayValues(constructor, propertyName) {
  const ancestors = getAncestorsForConstructor(constructor);
  return Array.from(ancestors.reduce((values, constructor) => {
    getOwnStaticArrayValues(constructor, propertyName).forEach(name => values.add(name));
    return values;
  }, new Set()));
}
function readInheritableStaticObjectPairs(constructor, propertyName) {
  const ancestors = getAncestorsForConstructor(constructor);
  return ancestors.reduce((pairs, constructor) => {
    pairs.push(...getOwnStaticObjectPairs(constructor, propertyName));
    return pairs;
  }, []);
}
function getAncestorsForConstructor(constructor) {
  const ancestors = [];
  while (constructor) {
    ancestors.push(constructor);
    constructor = Object.getPrototypeOf(constructor);
  }
  return ancestors.reverse();
}
function getOwnStaticArrayValues(constructor, propertyName) {
  const definition = constructor[propertyName];
  return Array.isArray(definition) ? definition : [];
}
function getOwnStaticObjectPairs(constructor, propertyName) {
  const definition = constructor[propertyName];
  return definition ? Object.keys(definition).map(key => [key, definition[key]]) : [];
}
class OutletObserver {
  constructor(context, delegate) {
    this.started = false;
    this.context = context;
    this.delegate = delegate;
    this.outletsByName = new Multimap();
    this.outletElementsByName = new Multimap();
    this.selectorObserverMap = new Map();
    this.attributeObserverMap = new Map();
  }
  start() {
    if (!this.started) {
      this.outletDefinitions.forEach(outletName => {
        this.setupSelectorObserverForOutlet(outletName);
        this.setupAttributeObserverForOutlet(outletName);
      });
      this.started = true;
      this.dependentContexts.forEach(context => context.refresh());
    }
  }
  refresh() {
    this.selectorObserverMap.forEach(observer => observer.refresh());
    this.attributeObserverMap.forEach(observer => observer.refresh());
  }
  stop() {
    if (this.started) {
      this.started = false;
      this.disconnectAllOutlets();
      this.stopSelectorObservers();
      this.stopAttributeObservers();
    }
  }
  stopSelectorObservers() {
    if (this.selectorObserverMap.size > 0) {
      this.selectorObserverMap.forEach(observer => observer.stop());
      this.selectorObserverMap.clear();
    }
  }
  stopAttributeObservers() {
    if (this.attributeObserverMap.size > 0) {
      this.attributeObserverMap.forEach(observer => observer.stop());
      this.attributeObserverMap.clear();
    }
  }
  selectorMatched(element, _selector, {
    outletName
  }) {
    const outlet = this.getOutlet(element, outletName);
    if (outlet) {
      this.connectOutlet(outlet, element, outletName);
    }
  }
  selectorUnmatched(element, _selector, {
    outletName
  }) {
    const outlet = this.getOutletFromMap(element, outletName);
    if (outlet) {
      this.disconnectOutlet(outlet, element, outletName);
    }
  }
  selectorMatchElement(element, {
    outletName
  }) {
    const selector = this.selector(outletName);
    const hasOutlet = this.hasOutlet(element, outletName);
    const hasOutletController = element.matches(`[${this.schema.controllerAttribute}~=${outletName}]`);
    if (selector) {
      return hasOutlet && hasOutletController && element.matches(selector);
    } else {
      return false;
    }
  }
  elementMatchedAttribute(_element, attributeName) {
    const outletName = this.getOutletNameFromOutletAttributeName(attributeName);
    if (outletName) {
      this.updateSelectorObserverForOutlet(outletName);
    }
  }
  elementAttributeValueChanged(_element, attributeName) {
    const outletName = this.getOutletNameFromOutletAttributeName(attributeName);
    if (outletName) {
      this.updateSelectorObserverForOutlet(outletName);
    }
  }
  elementUnmatchedAttribute(_element, attributeName) {
    const outletName = this.getOutletNameFromOutletAttributeName(attributeName);
    if (outletName) {
      this.updateSelectorObserverForOutlet(outletName);
    }
  }
  connectOutlet(outlet, element, outletName) {
    var _a;
    if (!this.outletElementsByName.has(outletName, element)) {
      this.outletsByName.add(outletName, outlet);
      this.outletElementsByName.add(outletName, element);
      (_a = this.selectorObserverMap.get(outletName)) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.outletConnected(outlet, element, outletName));
    }
  }
  disconnectOutlet(outlet, element, outletName) {
    var _a;
    if (this.outletElementsByName.has(outletName, element)) {
      this.outletsByName.delete(outletName, outlet);
      this.outletElementsByName.delete(outletName, element);
      (_a = this.selectorObserverMap.get(outletName)) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.outletDisconnected(outlet, element, outletName));
    }
  }
  disconnectAllOutlets() {
    for (const outletName of this.outletElementsByName.keys) {
      for (const element of this.outletElementsByName.getValuesForKey(outletName)) {
        for (const outlet of this.outletsByName.getValuesForKey(outletName)) {
          this.disconnectOutlet(outlet, element, outletName);
        }
      }
    }
  }
  updateSelectorObserverForOutlet(outletName) {
    const observer = this.selectorObserverMap.get(outletName);
    if (observer) {
      observer.selector = this.selector(outletName);
    }
  }
  setupSelectorObserverForOutlet(outletName) {
    const selector = this.selector(outletName);
    const selectorObserver = new SelectorObserver(document.body, selector, this, {
      outletName
    });
    this.selectorObserverMap.set(outletName, selectorObserver);
    selectorObserver.start();
  }
  setupAttributeObserverForOutlet(outletName) {
    const attributeName = this.attributeNameForOutletName(outletName);
    const attributeObserver = new AttributeObserver(this.scope.element, attributeName, this);
    this.attributeObserverMap.set(outletName, attributeObserver);
    attributeObserver.start();
  }
  selector(outletName) {
    return this.scope.outlets.getSelectorForOutletName(outletName);
  }
  attributeNameForOutletName(outletName) {
    return this.scope.schema.outletAttributeForScope(this.identifier, outletName);
  }
  getOutletNameFromOutletAttributeName(attributeName) {
    return this.outletDefinitions.find(outletName => this.attributeNameForOutletName(outletName) === attributeName);
  }
  get outletDependencies() {
    const dependencies = new Multimap();
    this.router.modules.forEach(module => {
      const constructor = module.definition.controllerConstructor;
      const outlets = readInheritableStaticArrayValues(constructor, "outlets");
      outlets.forEach(outlet => dependencies.add(outlet, module.identifier));
    });
    return dependencies;
  }
  get outletDefinitions() {
    return this.outletDependencies.getKeysForValue(this.identifier);
  }
  get dependentControllerIdentifiers() {
    return this.outletDependencies.getValuesForKey(this.identifier);
  }
  get dependentContexts() {
    const identifiers = this.dependentControllerIdentifiers;
    return this.router.contexts.filter(context => identifiers.includes(context.identifier));
  }
  hasOutlet(element, outletName) {
    return !!this.getOutlet(element, outletName) || !!this.getOutletFromMap(element, outletName);
  }
  getOutlet(element, outletName) {
    return this.application.getControllerForElementAndIdentifier(element, outletName);
  }
  getOutletFromMap(element, outletName) {
    return this.outletsByName.getValuesForKey(outletName).find(outlet => outlet.element === element);
  }
  get scope() {
    return this.context.scope;
  }
  get schema() {
    return this.context.schema;
  }
  get identifier() {
    return this.context.identifier;
  }
  get application() {
    return this.context.application;
  }
  get router() {
    return this.application.router;
  }
}
class Context {
  constructor(module, scope) {
    this.logDebugActivity = (functionName, detail = {}) => {
      const {
        identifier,
        controller,
        element
      } = this;
      detail = Object.assign({
        identifier,
        controller,
        element
      }, detail);
      this.application.logDebugActivity(this.identifier, functionName, detail);
    };
    this.module = module;
    this.scope = scope;
    this.controller = new module.controllerConstructor(this);
    this.bindingObserver = new BindingObserver(this, this.dispatcher);
    this.valueObserver = new ValueObserver(this, this.controller);
    this.targetObserver = new TargetObserver(this, this);
    this.outletObserver = new OutletObserver(this, this);
    try {
      this.controller.initialize();
      this.logDebugActivity("initialize");
    } catch (error) {
      this.handleError(error, "initializing controller");
    }
  }
  connect() {
    this.bindingObserver.start();
    this.valueObserver.start();
    this.targetObserver.start();
    this.outletObserver.start();
    try {
      this.controller.connect();
      this.logDebugActivity("connect");
    } catch (error) {
      this.handleError(error, "connecting controller");
    }
  }
  refresh() {
    this.outletObserver.refresh();
  }
  disconnect() {
    try {
      this.controller.disconnect();
      this.logDebugActivity("disconnect");
    } catch (error) {
      this.handleError(error, "disconnecting controller");
    }
    this.outletObserver.stop();
    this.targetObserver.stop();
    this.valueObserver.stop();
    this.bindingObserver.stop();
  }
  get application() {
    return this.module.application;
  }
  get identifier() {
    return this.module.identifier;
  }
  get schema() {
    return this.application.schema;
  }
  get dispatcher() {
    return this.application.dispatcher;
  }
  get element() {
    return this.scope.element;
  }
  get parentElement() {
    return this.element.parentElement;
  }
  handleError(error, message, detail = {}) {
    const {
      identifier,
      controller,
      element
    } = this;
    detail = Object.assign({
      identifier,
      controller,
      element
    }, detail);
    this.application.handleError(error, `Error ${message}`, detail);
  }
  targetConnected(element, name) {
    this.invokeControllerMethod(`${name}TargetConnected`, element);
  }
  targetDisconnected(element, name) {
    this.invokeControllerMethod(`${name}TargetDisconnected`, element);
  }
  outletConnected(outlet, element, name) {
    this.invokeControllerMethod(`${namespaceCamelize(name)}OutletConnected`, outlet, element);
  }
  outletDisconnected(outlet, element, name) {
    this.invokeControllerMethod(`${namespaceCamelize(name)}OutletDisconnected`, outlet, element);
  }
  invokeControllerMethod(methodName, ...args) {
    const controller = this.controller;
    if (typeof controller[methodName] == "function") {
      controller[methodName](...args);
    }
  }
}
function bless(constructor) {
  return shadow(constructor, getBlessedProperties(constructor));
}
function shadow(constructor, properties) {
  const shadowConstructor = extend$2(constructor);
  const shadowProperties = getShadowProperties(constructor.prototype, properties);
  Object.defineProperties(shadowConstructor.prototype, shadowProperties);
  return shadowConstructor;
}
function getBlessedProperties(constructor) {
  const blessings = readInheritableStaticArrayValues(constructor, "blessings");
  return blessings.reduce((blessedProperties, blessing) => {
    const properties = blessing(constructor);
    for (const key in properties) {
      const descriptor = blessedProperties[key] || {};
      blessedProperties[key] = Object.assign(descriptor, properties[key]);
    }
    return blessedProperties;
  }, {});
}
function getShadowProperties(prototype, properties) {
  return getOwnKeys(properties).reduce((shadowProperties, key) => {
    const descriptor = getShadowedDescriptor(prototype, properties, key);
    if (descriptor) {
      Object.assign(shadowProperties, {
        [key]: descriptor
      });
    }
    return shadowProperties;
  }, {});
}
function getShadowedDescriptor(prototype, properties, key) {
  const shadowingDescriptor = Object.getOwnPropertyDescriptor(prototype, key);
  const shadowedByValue = shadowingDescriptor && "value" in shadowingDescriptor;
  if (!shadowedByValue) {
    const descriptor = Object.getOwnPropertyDescriptor(properties, key).value;
    if (shadowingDescriptor) {
      descriptor.get = shadowingDescriptor.get || descriptor.get;
      descriptor.set = shadowingDescriptor.set || descriptor.set;
    }
    return descriptor;
  }
}
const getOwnKeys = (() => {
  if (typeof Object.getOwnPropertySymbols == "function") {
    return object => [...Object.getOwnPropertyNames(object), ...Object.getOwnPropertySymbols(object)];
  } else {
    return Object.getOwnPropertyNames;
  }
})();
const extend$2 = (() => {
  function extendWithReflect(constructor) {
    function extended() {
      return Reflect.construct(constructor, arguments, new.target);
    }
    extended.prototype = Object.create(constructor.prototype, {
      constructor: {
        value: extended
      }
    });
    Reflect.setPrototypeOf(extended, constructor);
    return extended;
  }
  function testReflectExtension() {
    const a = function () {
      this.a.call(this);
    };
    const b = extendWithReflect(a);
    b.prototype.a = function () {};
    return new b();
  }
  try {
    testReflectExtension();
    return extendWithReflect;
  } catch (error) {
    return constructor => class extended extends constructor {};
  }
})();
function blessDefinition(definition) {
  return {
    identifier: definition.identifier,
    controllerConstructor: bless(definition.controllerConstructor)
  };
}
class Module {
  constructor(application, definition) {
    this.application = application;
    this.definition = blessDefinition(definition);
    this.contextsByScope = new WeakMap();
    this.connectedContexts = new Set();
  }
  get identifier() {
    return this.definition.identifier;
  }
  get controllerConstructor() {
    return this.definition.controllerConstructor;
  }
  get contexts() {
    return Array.from(this.connectedContexts);
  }
  connectContextForScope(scope) {
    const context = this.fetchContextForScope(scope);
    this.connectedContexts.add(context);
    context.connect();
  }
  disconnectContextForScope(scope) {
    const context = this.contextsByScope.get(scope);
    if (context) {
      this.connectedContexts.delete(context);
      context.disconnect();
    }
  }
  fetchContextForScope(scope) {
    let context = this.contextsByScope.get(scope);
    if (!context) {
      context = new Context(this, scope);
      this.contextsByScope.set(scope, context);
    }
    return context;
  }
}
class ClassMap {
  constructor(scope) {
    this.scope = scope;
  }
  has(name) {
    return this.data.has(this.getDataKey(name));
  }
  get(name) {
    return this.getAll(name)[0];
  }
  getAll(name) {
    const tokenString = this.data.get(this.getDataKey(name)) || "";
    return tokenize(tokenString);
  }
  getAttributeName(name) {
    return this.data.getAttributeNameForKey(this.getDataKey(name));
  }
  getDataKey(name) {
    return `${name}-class`;
  }
  get data() {
    return this.scope.data;
  }
}
class DataMap {
  constructor(scope) {
    this.scope = scope;
  }
  get element() {
    return this.scope.element;
  }
  get identifier() {
    return this.scope.identifier;
  }
  get(key) {
    const name = this.getAttributeNameForKey(key);
    return this.element.getAttribute(name);
  }
  set(key, value) {
    const name = this.getAttributeNameForKey(key);
    this.element.setAttribute(name, value);
    return this.get(key);
  }
  has(key) {
    const name = this.getAttributeNameForKey(key);
    return this.element.hasAttribute(name);
  }
  delete(key) {
    if (this.has(key)) {
      const name = this.getAttributeNameForKey(key);
      this.element.removeAttribute(name);
      return true;
    } else {
      return false;
    }
  }
  getAttributeNameForKey(key) {
    return `data-${this.identifier}-${dasherize(key)}`;
  }
}
class Guide {
  constructor(logger) {
    this.warnedKeysByObject = new WeakMap();
    this.logger = logger;
  }
  warn(object, key, message) {
    let warnedKeys = this.warnedKeysByObject.get(object);
    if (!warnedKeys) {
      warnedKeys = new Set();
      this.warnedKeysByObject.set(object, warnedKeys);
    }
    if (!warnedKeys.has(key)) {
      warnedKeys.add(key);
      this.logger.warn(message, object);
    }
  }
}
function attributeValueContainsToken(attributeName, token) {
  return `[${attributeName}~="${token}"]`;
}
class TargetSet {
  constructor(scope) {
    this.scope = scope;
  }
  get element() {
    return this.scope.element;
  }
  get identifier() {
    return this.scope.identifier;
  }
  get schema() {
    return this.scope.schema;
  }
  has(targetName) {
    return this.find(targetName) != null;
  }
  find(...targetNames) {
    return targetNames.reduce((target, targetName) => target || this.findTarget(targetName) || this.findLegacyTarget(targetName), undefined);
  }
  findAll(...targetNames) {
    return targetNames.reduce((targets, targetName) => [...targets, ...this.findAllTargets(targetName), ...this.findAllLegacyTargets(targetName)], []);
  }
  findTarget(targetName) {
    const selector = this.getSelectorForTargetName(targetName);
    return this.scope.findElement(selector);
  }
  findAllTargets(targetName) {
    const selector = this.getSelectorForTargetName(targetName);
    return this.scope.findAllElements(selector);
  }
  getSelectorForTargetName(targetName) {
    const attributeName = this.schema.targetAttributeForScope(this.identifier);
    return attributeValueContainsToken(attributeName, targetName);
  }
  findLegacyTarget(targetName) {
    const selector = this.getLegacySelectorForTargetName(targetName);
    return this.deprecate(this.scope.findElement(selector), targetName);
  }
  findAllLegacyTargets(targetName) {
    const selector = this.getLegacySelectorForTargetName(targetName);
    return this.scope.findAllElements(selector).map(element => this.deprecate(element, targetName));
  }
  getLegacySelectorForTargetName(targetName) {
    const targetDescriptor = `${this.identifier}.${targetName}`;
    return attributeValueContainsToken(this.schema.targetAttribute, targetDescriptor);
  }
  deprecate(element, targetName) {
    if (element) {
      const {
        identifier
      } = this;
      const attributeName = this.schema.targetAttribute;
      const revisedAttributeName = this.schema.targetAttributeForScope(identifier);
      this.guide.warn(element, `target:${targetName}`, `Please replace ${attributeName}="${identifier}.${targetName}" with ${revisedAttributeName}="${targetName}". ` + `The ${attributeName} attribute is deprecated and will be removed in a future version of Stimulus.`);
    }
    return element;
  }
  get guide() {
    return this.scope.guide;
  }
}
class OutletSet {
  constructor(scope, controllerElement) {
    this.scope = scope;
    this.controllerElement = controllerElement;
  }
  get element() {
    return this.scope.element;
  }
  get identifier() {
    return this.scope.identifier;
  }
  get schema() {
    return this.scope.schema;
  }
  has(outletName) {
    return this.find(outletName) != null;
  }
  find(...outletNames) {
    return outletNames.reduce((outlet, outletName) => outlet || this.findOutlet(outletName), undefined);
  }
  findAll(...outletNames) {
    return outletNames.reduce((outlets, outletName) => [...outlets, ...this.findAllOutlets(outletName)], []);
  }
  getSelectorForOutletName(outletName) {
    const attributeName = this.schema.outletAttributeForScope(this.identifier, outletName);
    return this.controllerElement.getAttribute(attributeName);
  }
  findOutlet(outletName) {
    const selector = this.getSelectorForOutletName(outletName);
    if (selector) return this.findElement(selector, outletName);
  }
  findAllOutlets(outletName) {
    const selector = this.getSelectorForOutletName(outletName);
    return selector ? this.findAllElements(selector, outletName) : [];
  }
  findElement(selector, outletName) {
    const elements = this.scope.queryElements(selector);
    return elements.filter(element => this.matchesElement(element, selector, outletName))[0];
  }
  findAllElements(selector, outletName) {
    const elements = this.scope.queryElements(selector);
    return elements.filter(element => this.matchesElement(element, selector, outletName));
  }
  matchesElement(element, selector, outletName) {
    const controllerAttribute = element.getAttribute(this.scope.schema.controllerAttribute) || "";
    return element.matches(selector) && controllerAttribute.split(" ").includes(outletName);
  }
}
class Scope {
  constructor(schema, element, identifier, logger) {
    this.targets = new TargetSet(this);
    this.classes = new ClassMap(this);
    this.data = new DataMap(this);
    this.containsElement = element => {
      return element.closest(this.controllerSelector) === this.element;
    };
    this.schema = schema;
    this.element = element;
    this.identifier = identifier;
    this.guide = new Guide(logger);
    this.outlets = new OutletSet(this.documentScope, element);
  }
  findElement(selector) {
    return this.element.matches(selector) ? this.element : this.queryElements(selector).find(this.containsElement);
  }
  findAllElements(selector) {
    return [...(this.element.matches(selector) ? [this.element] : []), ...this.queryElements(selector).filter(this.containsElement)];
  }
  queryElements(selector) {
    return Array.from(this.element.querySelectorAll(selector));
  }
  get controllerSelector() {
    return attributeValueContainsToken(this.schema.controllerAttribute, this.identifier);
  }
  get isDocumentScope() {
    return this.element === document.documentElement;
  }
  get documentScope() {
    return this.isDocumentScope ? this : new Scope(this.schema, document.documentElement, this.identifier, this.guide.logger);
  }
}
class ScopeObserver {
  constructor(element, schema, delegate) {
    this.element = element;
    this.schema = schema;
    this.delegate = delegate;
    this.valueListObserver = new ValueListObserver(this.element, this.controllerAttribute, this);
    this.scopesByIdentifierByElement = new WeakMap();
    this.scopeReferenceCounts = new WeakMap();
  }
  start() {
    this.valueListObserver.start();
  }
  stop() {
    this.valueListObserver.stop();
  }
  get controllerAttribute() {
    return this.schema.controllerAttribute;
  }
  parseValueForToken(token) {
    const {
      element,
      content: identifier
    } = token;
    return this.parseValueForElementAndIdentifier(element, identifier);
  }
  parseValueForElementAndIdentifier(element, identifier) {
    const scopesByIdentifier = this.fetchScopesByIdentifierForElement(element);
    let scope = scopesByIdentifier.get(identifier);
    if (!scope) {
      scope = this.delegate.createScopeForElementAndIdentifier(element, identifier);
      scopesByIdentifier.set(identifier, scope);
    }
    return scope;
  }
  elementMatchedValue(element, value) {
    const referenceCount = (this.scopeReferenceCounts.get(value) || 0) + 1;
    this.scopeReferenceCounts.set(value, referenceCount);
    if (referenceCount == 1) {
      this.delegate.scopeConnected(value);
    }
  }
  elementUnmatchedValue(element, value) {
    const referenceCount = this.scopeReferenceCounts.get(value);
    if (referenceCount) {
      this.scopeReferenceCounts.set(value, referenceCount - 1);
      if (referenceCount == 1) {
        this.delegate.scopeDisconnected(value);
      }
    }
  }
  fetchScopesByIdentifierForElement(element) {
    let scopesByIdentifier = this.scopesByIdentifierByElement.get(element);
    if (!scopesByIdentifier) {
      scopesByIdentifier = new Map();
      this.scopesByIdentifierByElement.set(element, scopesByIdentifier);
    }
    return scopesByIdentifier;
  }
}
class Router {
  constructor(application) {
    this.application = application;
    this.scopeObserver = new ScopeObserver(this.element, this.schema, this);
    this.scopesByIdentifier = new Multimap();
    this.modulesByIdentifier = new Map();
  }
  get element() {
    return this.application.element;
  }
  get schema() {
    return this.application.schema;
  }
  get logger() {
    return this.application.logger;
  }
  get controllerAttribute() {
    return this.schema.controllerAttribute;
  }
  get modules() {
    return Array.from(this.modulesByIdentifier.values());
  }
  get contexts() {
    return this.modules.reduce((contexts, module) => contexts.concat(module.contexts), []);
  }
  start() {
    this.scopeObserver.start();
  }
  stop() {
    this.scopeObserver.stop();
  }
  loadDefinition(definition) {
    this.unloadIdentifier(definition.identifier);
    const module = new Module(this.application, definition);
    this.connectModule(module);
    const afterLoad = definition.controllerConstructor.afterLoad;
    if (afterLoad) {
      afterLoad.call(definition.controllerConstructor, definition.identifier, this.application);
    }
  }
  unloadIdentifier(identifier) {
    const module = this.modulesByIdentifier.get(identifier);
    if (module) {
      this.disconnectModule(module);
    }
  }
  getContextForElementAndIdentifier(element, identifier) {
    const module = this.modulesByIdentifier.get(identifier);
    if (module) {
      return module.contexts.find(context => context.element == element);
    }
  }
  proposeToConnectScopeForElementAndIdentifier(element, identifier) {
    const scope = this.scopeObserver.parseValueForElementAndIdentifier(element, identifier);
    if (scope) {
      this.scopeObserver.elementMatchedValue(scope.element, scope);
    } else {
      console.error(`Couldn't find or create scope for identifier: "${identifier}" and element:`, element);
    }
  }
  handleError(error, message, detail) {
    this.application.handleError(error, message, detail);
  }
  createScopeForElementAndIdentifier(element, identifier) {
    return new Scope(this.schema, element, identifier, this.logger);
  }
  scopeConnected(scope) {
    this.scopesByIdentifier.add(scope.identifier, scope);
    const module = this.modulesByIdentifier.get(scope.identifier);
    if (module) {
      module.connectContextForScope(scope);
    }
  }
  scopeDisconnected(scope) {
    this.scopesByIdentifier.delete(scope.identifier, scope);
    const module = this.modulesByIdentifier.get(scope.identifier);
    if (module) {
      module.disconnectContextForScope(scope);
    }
  }
  connectModule(module) {
    this.modulesByIdentifier.set(module.identifier, module);
    const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);
    scopes.forEach(scope => module.connectContextForScope(scope));
  }
  disconnectModule(module) {
    this.modulesByIdentifier.delete(module.identifier);
    const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);
    scopes.forEach(scope => module.disconnectContextForScope(scope));
  }
}
const defaultSchema = {
  controllerAttribute: "data-controller",
  actionAttribute: "data-action",
  targetAttribute: "data-target",
  targetAttributeForScope: identifier => `data-${identifier}-target`,
  outletAttributeForScope: (identifier, outlet) => `data-${identifier}-${outlet}-outlet`,
  keyMappings: Object.assign(Object.assign({
    enter: "Enter",
    tab: "Tab",
    esc: "Escape",
    space: " ",
    up: "ArrowUp",
    down: "ArrowDown",
    left: "ArrowLeft",
    right: "ArrowRight",
    home: "Home",
    end: "End",
    page_up: "PageUp",
    page_down: "PageDown"
  }, objectFromEntries("abcdefghijklmnopqrstuvwxyz".split("").map(c => [c, c]))), objectFromEntries("0123456789".split("").map(n => [n, n])))
};
function objectFromEntries(array) {
  return array.reduce((memo, [k, v]) => Object.assign(Object.assign({}, memo), {
    [k]: v
  }), {});
}
class Application {
  constructor(element = document.documentElement, schema = defaultSchema) {
    this.logger = console;
    this.debug = false;
    this.logDebugActivity = (identifier, functionName, detail = {}) => {
      if (this.debug) {
        this.logFormattedMessage(identifier, functionName, detail);
      }
    };
    this.element = element;
    this.schema = schema;
    this.dispatcher = new Dispatcher(this);
    this.router = new Router(this);
    this.actionDescriptorFilters = Object.assign({}, defaultActionDescriptorFilters);
  }
  static start(element, schema) {
    const application = new this(element, schema);
    application.start();
    return application;
  }
  async start() {
    await domReady();
    this.logDebugActivity("application", "starting");
    this.dispatcher.start();
    this.router.start();
    this.logDebugActivity("application", "start");
  }
  stop() {
    this.logDebugActivity("application", "stopping");
    this.dispatcher.stop();
    this.router.stop();
    this.logDebugActivity("application", "stop");
  }
  register(identifier, controllerConstructor) {
    this.load({
      identifier,
      controllerConstructor
    });
  }
  registerActionOption(name, filter) {
    this.actionDescriptorFilters[name] = filter;
  }
  load(head, ...rest) {
    const definitions = Array.isArray(head) ? head : [head, ...rest];
    definitions.forEach(definition => {
      if (definition.controllerConstructor.shouldLoad) {
        this.router.loadDefinition(definition);
      }
    });
  }
  unload(head, ...rest) {
    const identifiers = Array.isArray(head) ? head : [head, ...rest];
    identifiers.forEach(identifier => this.router.unloadIdentifier(identifier));
  }
  get controllers() {
    return this.router.contexts.map(context => context.controller);
  }
  getControllerForElementAndIdentifier(element, identifier) {
    const context = this.router.getContextForElementAndIdentifier(element, identifier);
    return context ? context.controller : null;
  }
  handleError(error, message, detail) {
    var _a;
    this.logger.error(`%s\n\n%o\n\n%o`, message, error, detail);
    (_a = window.onerror) === null || _a === void 0 ? void 0 : _a.call(window, message, "", 0, 0, error);
  }
  logFormattedMessage(identifier, functionName, detail = {}) {
    detail = Object.assign({
      application: this
    }, detail);
    this.logger.groupCollapsed(`${identifier} #${functionName}`);
    this.logger.log("details:", Object.assign({}, detail));
    this.logger.groupEnd();
  }
}
function domReady() {
  return new Promise(resolve => {
    if (document.readyState == "loading") {
      document.addEventListener("DOMContentLoaded", () => resolve());
    } else {
      resolve();
    }
  });
}
function ClassPropertiesBlessing(constructor) {
  const classes = readInheritableStaticArrayValues(constructor, "classes");
  return classes.reduce((properties, classDefinition) => {
    return Object.assign(properties, propertiesForClassDefinition(classDefinition));
  }, {});
}
function propertiesForClassDefinition(key) {
  return {
    [`${key}Class`]: {
      get() {
        const {
          classes
        } = this;
        if (classes.has(key)) {
          return classes.get(key);
        } else {
          const attribute = classes.getAttributeName(key);
          throw new Error(`Missing attribute "${attribute}"`);
        }
      }
    },
    [`${key}Classes`]: {
      get() {
        return this.classes.getAll(key);
      }
    },
    [`has${capitalize(key)}Class`]: {
      get() {
        return this.classes.has(key);
      }
    }
  };
}
function OutletPropertiesBlessing(constructor) {
  const outlets = readInheritableStaticArrayValues(constructor, "outlets");
  return outlets.reduce((properties, outletDefinition) => {
    return Object.assign(properties, propertiesForOutletDefinition(outletDefinition));
  }, {});
}
function getOutletController(controller, element, identifier) {
  return controller.application.getControllerForElementAndIdentifier(element, identifier);
}
function getControllerAndEnsureConnectedScope(controller, element, outletName) {
  let outletController = getOutletController(controller, element, outletName);
  if (outletController) return outletController;
  controller.application.router.proposeToConnectScopeForElementAndIdentifier(element, outletName);
  outletController = getOutletController(controller, element, outletName);
  if (outletController) return outletController;
}
function propertiesForOutletDefinition(name) {
  const camelizedName = namespaceCamelize(name);
  return {
    [`${camelizedName}Outlet`]: {
      get() {
        const outletElement = this.outlets.find(name);
        const selector = this.outlets.getSelectorForOutletName(name);
        if (outletElement) {
          const outletController = getControllerAndEnsureConnectedScope(this, outletElement, name);
          if (outletController) return outletController;
          throw new Error(`The provided outlet element is missing an outlet controller "${name}" instance for host controller "${this.identifier}"`);
        }
        throw new Error(`Missing outlet element "${name}" for host controller "${this.identifier}". Stimulus couldn't find a matching outlet element using selector "${selector}".`);
      }
    },
    [`${camelizedName}Outlets`]: {
      get() {
        const outlets = this.outlets.findAll(name);
        if (outlets.length > 0) {
          return outlets.map(outletElement => {
            const outletController = getControllerAndEnsureConnectedScope(this, outletElement, name);
            if (outletController) return outletController;
            console.warn(`The provided outlet element is missing an outlet controller "${name}" instance for host controller "${this.identifier}"`, outletElement);
          }).filter(controller => controller);
        }
        return [];
      }
    },
    [`${camelizedName}OutletElement`]: {
      get() {
        const outletElement = this.outlets.find(name);
        const selector = this.outlets.getSelectorForOutletName(name);
        if (outletElement) {
          return outletElement;
        } else {
          throw new Error(`Missing outlet element "${name}" for host controller "${this.identifier}". Stimulus couldn't find a matching outlet element using selector "${selector}".`);
        }
      }
    },
    [`${camelizedName}OutletElements`]: {
      get() {
        return this.outlets.findAll(name);
      }
    },
    [`has${capitalize(camelizedName)}Outlet`]: {
      get() {
        return this.outlets.has(name);
      }
    }
  };
}
function TargetPropertiesBlessing(constructor) {
  const targets = readInheritableStaticArrayValues(constructor, "targets");
  return targets.reduce((properties, targetDefinition) => {
    return Object.assign(properties, propertiesForTargetDefinition(targetDefinition));
  }, {});
}
function propertiesForTargetDefinition(name) {
  return {
    [`${name}Target`]: {
      get() {
        const target = this.targets.find(name);
        if (target) {
          return target;
        } else {
          throw new Error(`Missing target element "${name}" for "${this.identifier}" controller`);
        }
      }
    },
    [`${name}Targets`]: {
      get() {
        return this.targets.findAll(name);
      }
    },
    [`has${capitalize(name)}Target`]: {
      get() {
        return this.targets.has(name);
      }
    }
  };
}
function ValuePropertiesBlessing(constructor) {
  const valueDefinitionPairs = readInheritableStaticObjectPairs(constructor, "values");
  const propertyDescriptorMap = {
    valueDescriptorMap: {
      get() {
        return valueDefinitionPairs.reduce((result, valueDefinitionPair) => {
          const valueDescriptor = parseValueDefinitionPair(valueDefinitionPair, this.identifier);
          const attributeName = this.data.getAttributeNameForKey(valueDescriptor.key);
          return Object.assign(result, {
            [attributeName]: valueDescriptor
          });
        }, {});
      }
    }
  };
  return valueDefinitionPairs.reduce((properties, valueDefinitionPair) => {
    return Object.assign(properties, propertiesForValueDefinitionPair(valueDefinitionPair));
  }, propertyDescriptorMap);
}
function propertiesForValueDefinitionPair(valueDefinitionPair, controller) {
  const definition = parseValueDefinitionPair(valueDefinitionPair, controller);
  const {
    key,
    name,
    reader: read,
    writer: write
  } = definition;
  return {
    [name]: {
      get() {
        const value = this.data.get(key);
        if (value !== null) {
          return read(value);
        } else {
          return definition.defaultValue;
        }
      },
      set(value) {
        if (value === undefined) {
          this.data.delete(key);
        } else {
          this.data.set(key, write(value));
        }
      }
    },
    [`has${capitalize(name)}`]: {
      get() {
        return this.data.has(key) || definition.hasCustomDefaultValue;
      }
    }
  };
}
function parseValueDefinitionPair([token, typeDefinition], controller) {
  return valueDescriptorForTokenAndTypeDefinition({
    controller,
    token,
    typeDefinition
  });
}
function parseValueTypeConstant(constant) {
  switch (constant) {
    case Array:
      return "array";
    case Boolean:
      return "boolean";
    case Number:
      return "number";
    case Object:
      return "object";
    case String:
      return "string";
  }
}
function parseValueTypeDefault(defaultValue) {
  switch (typeof defaultValue) {
    case "boolean":
      return "boolean";
    case "number":
      return "number";
    case "string":
      return "string";
  }
  if (Array.isArray(defaultValue)) return "array";
  if (Object.prototype.toString.call(defaultValue) === "[object Object]") return "object";
}
function parseValueTypeObject(payload) {
  const {
    controller,
    token,
    typeObject
  } = payload;
  const hasType = isSomething(typeObject.type);
  const hasDefault = isSomething(typeObject.default);
  const fullObject = hasType && hasDefault;
  const onlyType = hasType && !hasDefault;
  const onlyDefault = !hasType && hasDefault;
  const typeFromObject = parseValueTypeConstant(typeObject.type);
  const typeFromDefaultValue = parseValueTypeDefault(payload.typeObject.default);
  if (onlyType) return typeFromObject;
  if (onlyDefault) return typeFromDefaultValue;
  if (typeFromObject !== typeFromDefaultValue) {
    const propertyPath = controller ? `${controller}.${token}` : token;
    throw new Error(`The specified default value for the Stimulus Value "${propertyPath}" must match the defined type "${typeFromObject}". The provided default value of "${typeObject.default}" is of type "${typeFromDefaultValue}".`);
  }
  if (fullObject) return typeFromObject;
}
function parseValueTypeDefinition(payload) {
  const {
    controller,
    token,
    typeDefinition
  } = payload;
  const typeObject = {
    controller,
    token,
    typeObject: typeDefinition
  };
  const typeFromObject = parseValueTypeObject(typeObject);
  const typeFromDefaultValue = parseValueTypeDefault(typeDefinition);
  const typeFromConstant = parseValueTypeConstant(typeDefinition);
  const type = typeFromObject || typeFromDefaultValue || typeFromConstant;
  if (type) return type;
  const propertyPath = controller ? `${controller}.${typeDefinition}` : token;
  throw new Error(`Unknown value type "${propertyPath}" for "${token}" value`);
}
function defaultValueForDefinition(typeDefinition) {
  const constant = parseValueTypeConstant(typeDefinition);
  if (constant) return defaultValuesByType[constant];
  const hasDefault = hasProperty(typeDefinition, "default");
  const hasType = hasProperty(typeDefinition, "type");
  const typeObject = typeDefinition;
  if (hasDefault) return typeObject.default;
  if (hasType) {
    const {
      type
    } = typeObject;
    const constantFromType = parseValueTypeConstant(type);
    if (constantFromType) return defaultValuesByType[constantFromType];
  }
  return typeDefinition;
}
function valueDescriptorForTokenAndTypeDefinition(payload) {
  const {
    token,
    typeDefinition
  } = payload;
  const key = `${dasherize(token)}-value`;
  const type = parseValueTypeDefinition(payload);
  return {
    type,
    key,
    name: camelize(key),
    get defaultValue() {
      return defaultValueForDefinition(typeDefinition);
    },
    get hasCustomDefaultValue() {
      return parseValueTypeDefault(typeDefinition) !== undefined;
    },
    reader: readers[type],
    writer: writers[type] || writers.default
  };
}
const defaultValuesByType = {
  get array() {
    return [];
  },
  boolean: false,
  number: 0,
  get object() {
    return {};
  },
  string: ""
};
const readers = {
  array(value) {
    const array = JSON.parse(value);
    if (!Array.isArray(array)) {
      throw new TypeError(`expected value of type "array" but instead got value "${value}" of type "${parseValueTypeDefault(array)}"`);
    }
    return array;
  },
  boolean(value) {
    return !(value == "0" || String(value).toLowerCase() == "false");
  },
  number(value) {
    return Number(value.replace(/_/g, ""));
  },
  object(value) {
    const object = JSON.parse(value);
    if (object === null || typeof object != "object" || Array.isArray(object)) {
      throw new TypeError(`expected value of type "object" but instead got value "${value}" of type "${parseValueTypeDefault(object)}"`);
    }
    return object;
  },
  string(value) {
    return value;
  }
};
const writers = {
  default: writeString,
  array: writeJSON,
  object: writeJSON
};
function writeJSON(value) {
  return JSON.stringify(value);
}
function writeString(value) {
  return `${value}`;
}
class Controller {
  constructor(context) {
    this.context = context;
  }
  static get shouldLoad() {
    return true;
  }
  static afterLoad(_identifier, _application) {
    return;
  }
  get application() {
    return this.context.application;
  }
  get scope() {
    return this.context.scope;
  }
  get element() {
    return this.scope.element;
  }
  get identifier() {
    return this.scope.identifier;
  }
  get targets() {
    return this.scope.targets;
  }
  get outlets() {
    return this.scope.outlets;
  }
  get classes() {
    return this.scope.classes;
  }
  get data() {
    return this.scope.data;
  }
  initialize() {}
  connect() {}
  disconnect() {}
  dispatch(eventName, {
    target = this.element,
    detail = {},
    prefix = this.identifier,
    bubbles = true,
    cancelable = true
  } = {}) {
    const type = prefix ? `${prefix}:${eventName}` : eventName;
    const event = new CustomEvent(type, {
      detail,
      bubbles,
      cancelable
    });
    target.dispatchEvent(event);
    return event;
  }
}
Controller.blessings = [ClassPropertiesBlessing, TargetPropertiesBlessing, ValuePropertiesBlessing, OutletPropertiesBlessing];
Controller.targets = [];
Controller.outlets = [];
Controller.values = {};

var application = Application.start();

// Configure Stimulus development experience
application.warnings = true;
application.debug = false;
window.Stimulus = application;

/**! 
 * hotkeys-js v3.12.0 
 * A simple micro-library for defining and dispatching keyboard shortcuts. It has no dependencies. 
 * 
 * Copyright (c) 2023 kenny wong <wowohoo@qq.com> 
 * https://jaywcjlove.github.io/hotkeys-js 
 * Licensed under the MIT license 
 */

var isff = typeof navigator !== 'undefined' ? navigator.userAgent.toLowerCase().indexOf('firefox') > 0 : false;

// ç»å®äºä»¶
function addEvent(object, event, method, useCapture) {
  if (object.addEventListener) {
    object.addEventListener(event, method, useCapture);
  } else if (object.attachEvent) {
    object.attachEvent("on".concat(event), function () {
      method(window.event);
    });
  }
}

// ä¿®é¥°é®è½¬æ¢æå¯¹åºçé®ç 
function getMods(modifier, key) {
  var mods = key.slice(0, key.length - 1);
  for (var i = 0; i < mods.length; i++) mods[i] = modifier[mods[i].toLowerCase()];
  return mods;
}

// å¤çä¼ çkeyå­ç¬¦ä¸²è½¬æ¢ææ°ç»
function getKeys(key) {
  if (typeof key !== 'string') key = '';
  key = key.replace(/\s/g, ''); // å¹éä»»ä½ç©ºç½å­ç¬¦,åæ¬ç©ºæ ¼ãå¶è¡¨ç¬¦ãæ¢é¡µç¬¦ç­ç­
  var keys = key.split(','); // åæ¶è®¾ç½®å¤ä¸ªå¿«æ·é®ï¼ä»¥','åå²
  var index = keys.lastIndexOf('');

  // å¿«æ·é®å¯è½åå«','ï¼éç¹æ®å¤ç
  for (; index >= 0;) {
    keys[index - 1] += ',';
    keys.splice(index, 1);
    index = keys.lastIndexOf('');
  }
  return keys;
}

// æ¯è¾ä¿®é¥°é®çæ°ç»
function compareArray(a1, a2) {
  var arr1 = a1.length >= a2.length ? a1 : a2;
  var arr2 = a1.length >= a2.length ? a2 : a1;
  var isIndex = true;
  for (var i = 0; i < arr1.length; i++) {
    if (arr2.indexOf(arr1[i]) === -1) isIndex = false;
  }
  return isIndex;
}

// Special Keys
var _keyMap = {
  backspace: 8,
  'â«': 8,
  tab: 9,
  clear: 12,
  enter: 13,
  'â©': 13,
  return: 13,
  esc: 27,
  escape: 27,
  space: 32,
  left: 37,
  up: 38,
  right: 39,
  down: 40,
  del: 46,
  delete: 46,
  ins: 45,
  insert: 45,
  home: 36,
  end: 35,
  pageup: 33,
  pagedown: 34,
  capslock: 20,
  num_0: 96,
  num_1: 97,
  num_2: 98,
  num_3: 99,
  num_4: 100,
  num_5: 101,
  num_6: 102,
  num_7: 103,
  num_8: 104,
  num_9: 105,
  num_multiply: 106,
  num_add: 107,
  num_enter: 108,
  num_subtract: 109,
  num_decimal: 110,
  num_divide: 111,
  'âª': 20,
  ',': 188,
  '.': 190,
  '/': 191,
  '`': 192,
  '-': isff ? 173 : 189,
  '=': isff ? 61 : 187,
  ';': isff ? 59 : 186,
  '\'': 222,
  '[': 219,
  ']': 221,
  '\\': 220
};

// Modifier Keys
var _modifier = {
  // shiftKey
  'â§': 16,
  shift: 16,
  // altKey
  'â¥': 18,
  alt: 18,
  option: 18,
  // ctrlKey
  'â': 17,
  ctrl: 17,
  control: 17,
  // metaKey
  'â': 91,
  cmd: 91,
  command: 91
};
var modifierMap = {
  16: 'shiftKey',
  18: 'altKey',
  17: 'ctrlKey',
  91: 'metaKey',
  shiftKey: 16,
  ctrlKey: 17,
  altKey: 18,
  metaKey: 91
};
var _mods = {
  16: false,
  18: false,
  17: false,
  91: false
};
var _handlers = {};

// F1~F12 special key
for (var k = 1; k < 20; k++) {
  _keyMap["f".concat(k)] = 111 + k;
}
var _downKeys = []; // è®°å½æä¸çç»å®é®
var winListendFocus = false; // windowæ¯å¦å·²ç»çå¬äºfocusäºä»¶
var _scope = 'all'; // é»è®¤ç­é®èå´
var elementHasBindEvent = []; // å·²ç»å®äºä»¶çèç¹è®°å½

// è¿åé®ç 
var code = function code(x) {
  return _keyMap[x.toLowerCase()] || _modifier[x.toLowerCase()] || x.toUpperCase().charCodeAt(0);
};
var getKey = function getKey(x) {
  return Object.keys(_keyMap).find(function (k) {
    return _keyMap[k] === x;
  });
};
var getModifier = function getModifier(x) {
  return Object.keys(_modifier).find(function (k) {
    return _modifier[k] === x;
  });
};

// è®¾ç½®è·åå½åèå´ï¼é»è®¤ä¸º'ææ'ï¼
function setScope(scope) {
  _scope = scope || 'all';
}
// è·åå½åèå´
function getScope() {
  return _scope || 'all';
}
// è·åæä¸ç»å®é®çé®å¼
function getPressedKeyCodes() {
  return _downKeys.slice(0);
}
function getPressedKeyString() {
  return _downKeys.map(function (c) {
    return getKey(c) || getModifier(c) || String.fromCharCode(c);
  });
}
function getAllKeyCodes() {
  var result = [];
  Object.keys(_handlers).forEach(function (k) {
    _handlers[k].forEach(function (_ref) {
      var key = _ref.key,
        scope = _ref.scope,
        mods = _ref.mods,
        shortcut = _ref.shortcut;
      result.push({
        scope: scope,
        shortcut: shortcut,
        mods: mods,
        keys: key.split('+').map(function (v) {
          return code(v);
        })
      });
    });
  });
  return result;
}

// è¡¨åæ§ä»¶æ§ä»¶å¤æ­ è¿å Boolean
// hotkey is effective only when filter return true
function filter(event) {
  var target = event.target || event.srcElement;
  var tagName = target.tagName;
  var flag = true;
  // ignore: isContentEditable === 'true', <input> and <textarea> when readOnly state is false, <select>
  if (target.isContentEditable || (tagName === 'INPUT' || tagName === 'TEXTAREA' || tagName === 'SELECT') && !target.readOnly) {
    flag = false;
  }
  return flag;
}

// å¤æ­æä¸çé®æ¯å¦ä¸ºæä¸ªé®ï¼è¿åtrueæèfalse
function isPressed(keyCode) {
  if (typeof keyCode === 'string') {
    keyCode = code(keyCode); // è½¬æ¢æé®ç 
  }
  return _downKeys.indexOf(keyCode) !== -1;
}

// å¾ªç¯å é¤handlersä¸­çææ scope(èå´)
function deleteScope(scope, newScope) {
  var handlers;
  var i;

  // æ²¡ææå®scopeï¼è·åscope
  if (!scope) scope = getScope();
  for (var key in _handlers) {
    if (Object.prototype.hasOwnProperty.call(_handlers, key)) {
      handlers = _handlers[key];
      for (i = 0; i < handlers.length;) {
        if (handlers[i].scope === scope) handlers.splice(i, 1);else i++;
      }
    }
  }

  // å¦æscopeè¢«å é¤ï¼å°scopeéç½®ä¸ºall
  if (getScope() === scope) setScope(newScope || 'all');
}

// æ¸é¤ä¿®é¥°é®
function clearModifier(event) {
  var key = event.keyCode || event.which || event.charCode;
  var i = _downKeys.indexOf(key);

  // ä»åè¡¨ä¸­æ¸é¤æåè¿çé®
  if (i >= 0) {
    _downKeys.splice(i, 1);
  }
  // ç¹æ®å¤ç cmmand é®ï¼å¨ cmmand ç»åå¿«æ·é® keyup åªæ§è¡ä¸æ¬¡çé®é¢
  if (event.key && event.key.toLowerCase() === 'meta') {
    _downKeys.splice(0, _downKeys.length);
  }

  // ä¿®é¥°é® shiftKey altKey ctrlKey (command||metaKey) æ¸é¤
  if (key === 93 || key === 224) key = 91;
  if (key in _mods) {
    _mods[key] = false;

    // å°ä¿®é¥°é®éç½®ä¸ºfalse
    for (var k in _modifier) if (_modifier[k] === key) hotkeys[k] = false;
  }
}
function unbind(keysInfo) {
  // unbind(), unbind all keys
  if (typeof keysInfo === 'undefined') {
    Object.keys(_handlers).forEach(function (key) {
      return delete _handlers[key];
    });
  } else if (Array.isArray(keysInfo)) {
    // support like : unbind([{key: 'ctrl+a', scope: 's1'}, {key: 'ctrl-a', scope: 's2', splitKey: '-'}])
    keysInfo.forEach(function (info) {
      if (info.key) eachUnbind(info);
    });
  } else if (typeof keysInfo === 'object') {
    // support like unbind({key: 'ctrl+a, ctrl+b', scope:'abc'})
    if (keysInfo.key) eachUnbind(keysInfo);
  } else if (typeof keysInfo === 'string') {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    // support old method
    // eslint-disable-line
    var scope = args[0],
      method = args[1];
    if (typeof scope === 'function') {
      method = scope;
      scope = '';
    }
    eachUnbind({
      key: keysInfo,
      scope: scope,
      method: method,
      splitKey: '+'
    });
  }
}

// è§£é¤ç»å®æä¸ªèå´çå¿«æ·é®
var eachUnbind = function eachUnbind(_ref2) {
  var key = _ref2.key,
    scope = _ref2.scope,
    method = _ref2.method,
    _ref2$splitKey = _ref2.splitKey,
    splitKey = _ref2$splitKey === void 0 ? '+' : _ref2$splitKey;
  var multipleKeys = getKeys(key);
  multipleKeys.forEach(function (originKey) {
    var unbindKeys = originKey.split(splitKey);
    var len = unbindKeys.length;
    var lastKey = unbindKeys[len - 1];
    var keyCode = lastKey === '*' ? '*' : code(lastKey);
    if (!_handlers[keyCode]) return;
    // å¤æ­æ¯å¦ä¼ å¥èå´ï¼æ²¡æå°±è·åèå´
    if (!scope) scope = getScope();
    var mods = len > 1 ? getMods(_modifier, unbindKeys) : [];
    _handlers[keyCode] = _handlers[keyCode].filter(function (record) {
      // éè¿å½æ°å¤æ­ï¼æ¯å¦è§£é¤ç»å®ï¼å½æ°ç¸ç­ç´æ¥è¿å
      var isMatchingMethod = method ? record.method === method : true;
      return !(isMatchingMethod && record.scope === scope && compareArray(record.mods, mods));
    });
  });
};

// å¯¹çå¬å¯¹åºå¿«æ·é®çåè°å½æ°è¿è¡å¤ç
function eventHandler(event, handler, scope, element) {
  if (handler.element !== element) {
    return;
  }
  var modifiersMatch;

  // çå®æ¯å¦å¨å½åèå´
  if (handler.scope === scope || handler.scope === 'all') {
    // æ£æ¥æ¯å¦å¹éä¿®é¥°ç¬¦ï¼å¦ææè¿åtrueï¼
    modifiersMatch = handler.mods.length > 0;
    for (var y in _mods) {
      if (Object.prototype.hasOwnProperty.call(_mods, y)) {
        if (!_mods[y] && handler.mods.indexOf(+y) > -1 || _mods[y] && handler.mods.indexOf(+y) === -1) {
          modifiersMatch = false;
        }
      }
    }

    // è°ç¨å¤çç¨åºï¼å¦ææ¯ä¿®é¥°é®ä¸åå¤ç
    if (handler.mods.length === 0 && !_mods[16] && !_mods[18] && !_mods[17] && !_mods[91] || modifiersMatch || handler.shortcut === '*') {
      handler.keys = [];
      handler.keys = handler.keys.concat(_downKeys);
      if (handler.method(event, handler) === false) {
        if (event.preventDefault) event.preventDefault();else event.returnValue = false;
        if (event.stopPropagation) event.stopPropagation();
        if (event.cancelBubble) event.cancelBubble = true;
      }
    }
  }
}

// å¤çkeydownäºä»¶
function dispatch$1(event, element) {
  var asterisk = _handlers['*'];
  var key = event.keyCode || event.which || event.charCode;

  // è¡¨åæ§ä»¶è¿æ»¤ é»è®¤è¡¨åæ§ä»¶ä¸è§¦åå¿«æ·é®
  if (!hotkeys.filter.call(this, event)) return;

  // Gecko(Firefox)çcommandé®å¼224ï¼å¨Webkit(Chrome)ä¸­ä¿æä¸è´
  // Webkitå·¦å³ command é®å¼ä¸ä¸æ ·
  if (key === 93 || key === 224) key = 91;

  /**
   * Collect bound keys
   * If an Input Method Editor is processing key input and the event is keydown, return 229.
   * https://stackoverflow.com/questions/25043934/is-it-ok-to-ignore-keydown-events-with-keycode-229
   * http://lists.w3.org/Archives/Public/www-dom/2010JulSep/att-0182/keyCode-spec.html
   */
  if (_downKeys.indexOf(key) === -1 && key !== 229) _downKeys.push(key);
  /**
   * Jest test cases are required.
   * ===============================
   */
  ['ctrlKey', 'altKey', 'shiftKey', 'metaKey'].forEach(function (keyName) {
    var keyNum = modifierMap[keyName];
    if (event[keyName] && _downKeys.indexOf(keyNum) === -1) {
      _downKeys.push(keyNum);
    } else if (!event[keyName] && _downKeys.indexOf(keyNum) > -1) {
      _downKeys.splice(_downKeys.indexOf(keyNum), 1);
    } else if (keyName === 'metaKey' && event[keyName] && _downKeys.length === 3) {
      /**
       * Fix if Command is pressed:
       * ===============================
       */
      if (!(event.ctrlKey || event.shiftKey || event.altKey)) {
        _downKeys = _downKeys.slice(_downKeys.indexOf(keyNum));
      }
    }
  });
  /**
   * -------------------------------
   */

  if (key in _mods) {
    _mods[key] = true;

    // å°ç¹æ®å­ç¬¦çkeyæ³¨åå° hotkeys ä¸
    for (var k in _modifier) {
      if (_modifier[k] === key) hotkeys[k] = true;
    }
    if (!asterisk) return;
  }

  // å° modifierMap éé¢çä¿®é¥°é®ç»å®å° event ä¸­
  for (var e in _mods) {
    if (Object.prototype.hasOwnProperty.call(_mods, e)) {
      _mods[e] = event[modifierMap[e]];
    }
  }
  /**
   * https://github.com/jaywcjlove/hotkeys/pull/129
   * This solves the issue in Firefox on Windows where hotkeys corresponding to special characters would not trigger.
   * An example of this is ctrl+alt+m on a Swedish keyboard which is used to type Î¼.
   * Browser support: https://caniuse.com/#feat=keyboardevent-getmodifierstate
   */
  if (event.getModifierState && !(event.altKey && !event.ctrlKey) && event.getModifierState('AltGraph')) {
    if (_downKeys.indexOf(17) === -1) {
      _downKeys.push(17);
    }
    if (_downKeys.indexOf(18) === -1) {
      _downKeys.push(18);
    }
    _mods[17] = true;
    _mods[18] = true;
  }

  // è·åèå´ é»è®¤ä¸º `all`
  var scope = getScope();
  // å¯¹ä»»ä½å¿«æ·é®é½éè¦åçå¤ç
  if (asterisk) {
    for (var i = 0; i < asterisk.length; i++) {
      if (asterisk[i].scope === scope && (event.type === 'keydown' && asterisk[i].keydown || event.type === 'keyup' && asterisk[i].keyup)) {
        eventHandler(event, asterisk[i], scope, element);
      }
    }
  }
  // key ä¸å¨ _handlers ä¸­è¿å
  if (!(key in _handlers)) return;
  for (var _i = 0; _i < _handlers[key].length; _i++) {
    if (event.type === 'keydown' && _handlers[key][_i].keydown || event.type === 'keyup' && _handlers[key][_i].keyup) {
      if (_handlers[key][_i].key) {
        var record = _handlers[key][_i];
        var splitKey = record.splitKey;
        var keyShortcut = record.key.split(splitKey);
        var _downKeysCurrent = []; // è®°å½å½åæé®é®å¼
        for (var a = 0; a < keyShortcut.length; a++) {
          _downKeysCurrent.push(code(keyShortcut[a]));
        }
        if (_downKeysCurrent.sort().join('') === _downKeys.sort().join('')) {
          // æ¾å°å¤çåå®¹
          eventHandler(event, record, scope, element);
        }
      }
    }
  }
}

// å¤æ­ element æ¯å¦å·²ç»ç»å®äºä»¶
function isElementBind(element) {
  return elementHasBindEvent.indexOf(element) > -1;
}
function hotkeys(key, option, method) {
  _downKeys = [];
  var keys = getKeys(key); // éè¦å¤ççå¿«æ·é®åè¡¨
  var mods = [];
  var scope = 'all'; // scopeé»è®¤ä¸ºallï¼ææèå´é½ææ
  var element = document; // å¿«æ·é®äºä»¶ç»å®èç¹
  var i = 0;
  var keyup = false;
  var keydown = true;
  var splitKey = '+';
  var capture = false;

  // å¯¹ä¸ºè®¾å®èå´çå¤æ­
  if (method === undefined && typeof option === 'function') {
    method = option;
  }
  if (Object.prototype.toString.call(option) === '[object Object]') {
    if (option.scope) scope = option.scope; // eslint-disable-line
    if (option.element) element = option.element; // eslint-disable-line
    if (option.keyup) keyup = option.keyup; // eslint-disable-line
    if (option.keydown !== undefined) keydown = option.keydown; // eslint-disable-line
    if (option.capture !== undefined) capture = option.capture; // eslint-disable-line
    if (typeof option.splitKey === 'string') splitKey = option.splitKey; // eslint-disable-line
  }
  if (typeof option === 'string') scope = option;

  // å¯¹äºæ¯ä¸ªå¿«æ·é®è¿è¡å¤ç
  for (; i < keys.length; i++) {
    key = keys[i].split(splitKey); // æé®åè¡¨
    mods = [];

    // å¦ææ¯ç»åå¿«æ·é®åå¾ç»åå¿«æ·é®
    if (key.length > 1) mods = getMods(_modifier, key);

    // å°éä¿®é¥°é®è½¬åä¸ºé®ç 
    key = key[key.length - 1];
    key = key === '*' ? '*' : code(key); // *è¡¨ç¤ºå¹éææå¿«æ·é®

    // å¤æ­keyæ¯å¦å¨_handlersä¸­ï¼ä¸å¨å°±èµä¸ä¸ªç©ºæ°ç»
    if (!(key in _handlers)) _handlers[key] = [];
    _handlers[key].push({
      keyup: keyup,
      keydown: keydown,
      scope: scope,
      mods: mods,
      shortcut: keys[i],
      method: method,
      key: keys[i],
      splitKey: splitKey,
      element: element
    });
  }
  // å¨å¨å±documentä¸è®¾ç½®å¿«æ·é®
  if (typeof element !== 'undefined' && !isElementBind(element) && window) {
    elementHasBindEvent.push(element);
    addEvent(element, 'keydown', function (e) {
      dispatch$1(e, element);
    }, capture);
    if (!winListendFocus) {
      winListendFocus = true;
      addEvent(window, 'focus', function () {
        _downKeys = [];
      }, capture);
    }
    addEvent(element, 'keyup', function (e) {
      dispatch$1(e, element);
      clearModifier(e);
    }, capture);
  }
}
function trigger(shortcut) {
  var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'all';
  Object.keys(_handlers).forEach(function (key) {
    var dataList = _handlers[key].filter(function (item) {
      return item.scope === scope && item.shortcut === shortcut;
    });
    dataList.forEach(function (data) {
      if (data && data.method) {
        data.method();
      }
    });
  });
}
var _api = {
  getPressedKeyString: getPressedKeyString,
  setScope: setScope,
  getScope: getScope,
  deleteScope: deleteScope,
  getPressedKeyCodes: getPressedKeyCodes,
  getAllKeyCodes: getAllKeyCodes,
  isPressed: isPressed,
  filter: filter,
  trigger: trigger,
  unbind: unbind,
  keyMap: _keyMap,
  modifier: _modifier,
  modifierMap: modifierMap
};
for (var a in _api) {
  if (Object.prototype.hasOwnProperty.call(_api, a)) {
    hotkeys[a] = _api[a];
  }
}
if (typeof window !== 'undefined') {
  var _hotkeys = window.hotkeys;
  hotkeys.noConflict = function (deep) {
    if (deep && window.hotkeys === hotkeys) {
      window.hotkeys = _hotkeys;
    }
    return hotkeys;
  };
  window.hotkeys = hotkeys;
}

/*
Stimulus-Use 0.51.3
*/
class DebounceController extends Controller {}
DebounceController.debounces = [];
class ThrottleController extends Controller {}
ThrottleController.throttles = [];
const alpineNames = {
  enterFromClass: 'enter',
  enterActiveClass: 'enterStart',
  enterToClass: 'enterEnd',
  leaveFromClass: 'leave',
  leaveActiveClass: 'leaveStart',
  leaveToClass: 'leaveEnd'
};
const defaultOptions$1$1 = {
  transitioned: false,
  hiddenClass: 'hidden',
  preserveOriginalClass: true,
  removeToClasses: true
};
const useTransition = (composableController, options = {}) => {
  var _a, _b, _c;
  const controller = composableController;
  const targetName = controller.element.dataset.transitionTarget;
  let targetFromAttribute;
  if (targetName) {
    targetFromAttribute = controller[`${targetName}Target`];
  }
  const targetElement = (options === null || options === void 0 ? void 0 : options.element) || targetFromAttribute || controller.element;
  if (!(targetElement instanceof HTMLElement || targetElement instanceof SVGElement)) return;
  const dataset = targetElement.dataset;
  const leaveAfter = parseInt(dataset.leaveAfter || '') || options.leaveAfter || 0;
  const {
    transitioned,
    hiddenClass,
    preserveOriginalClass,
    removeToClasses
  } = Object.assign({}, defaultOptions$1$1, options);
  const controllerEnter = (_a = controller.enter) === null || _a === void 0 ? void 0 : _a.bind(controller);
  const controllerLeave = (_b = controller.leave) === null || _b === void 0 ? void 0 : _b.bind(controller);
  const controllerToggleTransition = (_c = controller.toggleTransition) === null || _c === void 0 ? void 0 : _c.bind(controller);
  async function enter(event) {
    if (controller.transitioned) return;
    controller.transitioned = true;
    controllerEnter && controllerEnter(event);
    const enterFromClasses = getAttribute$1('enterFrom', options, dataset);
    const enterActiveClasses = getAttribute$1('enterActive', options, dataset);
    const enterToClasses = getAttribute$1('enterTo', options, dataset);
    const leaveToClasses = getAttribute$1('leaveTo', options, dataset);
    if (!!hiddenClass) {
      targetElement.classList.remove(hiddenClass);
    }
    if (!removeToClasses) {
      removeClasses(targetElement, leaveToClasses);
    }
    await transition(targetElement, enterFromClasses, enterActiveClasses, enterToClasses, hiddenClass, preserveOriginalClass, removeToClasses);
    if (leaveAfter > 0) {
      setTimeout(() => {
        leave(event);
      }, leaveAfter);
    }
  }
  async function leave(event) {
    if (!controller.transitioned) return;
    controller.transitioned = false;
    controllerLeave && controllerLeave(event);
    const leaveFromClasses = getAttribute$1('leaveFrom', options, dataset);
    const leaveActiveClasses = getAttribute$1('leaveActive', options, dataset);
    const leaveToClasses = getAttribute$1('leaveTo', options, dataset);
    const enterToClasses = getAttribute$1('enterTo', options, dataset);
    if (!removeToClasses) {
      removeClasses(targetElement, enterToClasses);
    }
    await transition(targetElement, leaveFromClasses, leaveActiveClasses, leaveToClasses, hiddenClass, preserveOriginalClass, removeToClasses);
    if (!!hiddenClass) {
      targetElement.classList.add(hiddenClass);
    }
  }
  function toggleTransition(event) {
    controllerToggleTransition && controllerToggleTransition(event);
    if (controller.transitioned) {
      leave();
    } else {
      enter();
    }
  }
  async function transition(element, initialClasses, activeClasses, endClasses, hiddenClass, preserveOriginalClass, removeEndClasses) {
    const stashedClasses = [];
    if (preserveOriginalClass) {
      initialClasses.forEach(cls => element.classList.contains(cls) && cls !== hiddenClass && stashedClasses.push(cls));
      activeClasses.forEach(cls => element.classList.contains(cls) && cls !== hiddenClass && stashedClasses.push(cls));
      endClasses.forEach(cls => element.classList.contains(cls) && cls !== hiddenClass && stashedClasses.push(cls));
    }
    addClasses(element, initialClasses);
    removeClasses(element, stashedClasses);
    addClasses(element, activeClasses);
    await nextAnimationFrame$1();
    removeClasses(element, initialClasses);
    addClasses(element, endClasses);
    await afterTransition(element);
    removeClasses(element, activeClasses);
    if (removeEndClasses) {
      removeClasses(element, endClasses);
    }
    addClasses(element, stashedClasses);
  }
  function initialState() {
    controller.transitioned = transitioned;
    if (transitioned) {
      if (!!hiddenClass) {
        targetElement.classList.remove(hiddenClass);
      }
      enter();
    } else {
      if (!!hiddenClass) {
        targetElement.classList.add(hiddenClass);
      }
      leave();
    }
  }
  function addClasses(element, classes) {
    if (classes.length > 0) {
      element.classList.add(...classes);
    }
  }
  function removeClasses(element, classes) {
    if (classes.length > 0) {
      element.classList.remove(...classes);
    }
  }
  initialState();
  Object.assign(controller, {
    enter,
    leave,
    toggleTransition
  });
  return [enter, leave, toggleTransition];
};
function getAttribute$1(name, options, dataset) {
  const datasetName = `transition${name[0].toUpperCase()}${name.substr(1)}`;
  const datasetAlpineName = alpineNames[name];
  const classes = options[name] || dataset[datasetName] || dataset[datasetAlpineName] || ' ';
  return isEmpty(classes) ? [] : classes.split(' ');
}
async function afterTransition(element) {
  return new Promise(resolve => {
    const duration = Number(getComputedStyle(element).transitionDuration.split(',')[0].replace('s', '')) * 1000;
    setTimeout(() => {
      resolve(duration);
    }, duration);
  });
}
async function nextAnimationFrame$1() {
  return new Promise(resolve => {
    requestAnimationFrame(() => {
      requestAnimationFrame(resolve);
    });
  });
}
function isEmpty(str) {
  return str.length === 0 || !str.trim();
}

class i extends Controller {
  connect() {
    useTransition(this, {
      element: this.menuTarget
    });
  }
  toggle() {
    this.toggleTransition();
  }
  hide(t) {
    !this.element.contains(t.target) && !this.menuTarget.classList.contains("hidden") && this.leave();
  }
}
i.targets = ["menu"];

function _callSuper(t, o, e) {
  return o = _getPrototypeOf$1(o), _possibleConstructorReturn$1(t, _isNativeReflectConstruct$1() ? Reflect.construct(o, e || [], _getPrototypeOf$1(t).constructor) : o.apply(t, e));
}
function _isNativeReflectConstruct$1() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
  } catch (t) {}
  return (_isNativeReflectConstruct$1 = function () {
    return !!t;
  })();
}
function ownKeys$1(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2$1(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$1(Object(t), !0).forEach(function (r) {
      _defineProperty$2(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
}
function _toPrimitive$1(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _toPropertyKey$1(t) {
  var i = _toPrimitive$1(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _classCallCheck$1(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$1(descriptor.key), descriptor);
  }
}
function _createClass$1(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _defineProperty$2(obj, key, value) {
  key = _toPropertyKey$1(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _inherits$1(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf$1(subClass, superClass);
}
function _getPrototypeOf$1(o) {
  _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$1(o);
}
function _setPrototypeOf$1(o, p) {
  _setPrototypeOf$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf$1(o, p);
}
function _assertThisInitialized$1(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _possibleConstructorReturn$1(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$1(self);
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$1(arr);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _unsupportedIterableToArray$1(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$1(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);
}
function _arrayLikeToArray$1(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var $$7 = window.$;

// Used when a table has toggleable rows (initially hidden rows that can be toggled open
// to see e.g. notes or extended details) and each master row and its toggleable sibling are
// nested in a tbody (this is valid HTML) - ie there are probably two trs per tbody, and the last
// one is toggleable. If you need anything more complex you'll need to clone or adapt this
// controller
var _default$F = /*#__PURE__*/function (_Controller) {
  function _default() {
    _classCallCheck$1(this, _default);
    return _callSuper(this, _default, arguments);
  }
  _inherits$1(_default, _Controller);
  return _createClass$1(_default, [{
    key: "row",
    value:
    // This handler toggles the last tr in the current tbody. We use multiple tbodys in each table
    // to make toggling like this simpler, and to group the related (visible and toggleable) rows
    // together.
    function row(event) {
      event.preventDefault;
      var tbody = event.target.closest("tbody");
      tbody.classList.toggle("toggleable--open");
      // Update masonry - TODO: move to a module
      $$7(".mgrid > .row").masonry("layout");
    }

    // Toggle the last tr in each tbody in the current table.
    // The link that triggers this event will most likely be a double chevron icon
    // sitting in a thead.
  }, {
    key: "table",
    value: function table(event) {
      event.preventDefault;
      var table = event.target.closest("table");
      var thead = event.target.closest("thead");
      // Use an Array rather a NodeList here as IE does not support NodeList.forEach
      var tbodies = Array.prototype.slice.call(table.querySelectorAll("tbody"));
      var hide = thead.classList.contains("toggleable--open");
      thead.classList.toggle("toggleable--open");
      tbodies.forEach(function (tbody) {
        tbody.classList.toggle("toggleable--open", !hide);
      });
      // Update masonry - TODO: move to a module
      $$7(".mgrid > .row").masonry("layout");
    }
  }]);
}(Controller);

/*  Single use controller only for the Dietetic Clinic Visit */
var _default$E = /*#__PURE__*/function (_Controller) {
  function _default() {
    _classCallCheck$1(this, _default);
    return _callSuper(this, _default, arguments);
  }
  _inherits$1(_default, _Controller);
  return _createClass$1(_default, [{
    key: "initialize",
    value: function initialize() {
      this.calculate = this.calculate.bind(this);
    }
  }, {
    key: "connect",
    value: function connect() {
      // As the weight and the height are outside the scope of the controller
      // -> grab them directly
      this.weightElement = document.querySelector(this.weightSelectorValue);
      this.heightElement = document.querySelector(this.heightSelectorValue);
      this.heightElement.addEventListener("input", this.calculate);
      this.weightElement.addEventListener("input", this.calculate);
      this.calculate();
    }
  }, {
    key: "disconnect",
    value: function disconnect() {
      this.heightElement.removeEventListener("input", this.calculate);
      this.weightElement.removeEventListener("input", this.calculate);
    }
  }, {
    key: "calculate",
    value: function calculate() {
      var weight = this.weightElement.value;
      var height = this.heightElement.value;
      var value = weight && height ? (Math.round(weight / height / height * 10) / 10).toFixed(1) : "";
      this.outputTarget.innerText = value;
    }
  }]);
}(Controller);
_defineProperty$2(_default$E, "targets", ["output"]);
_defineProperty$2(_default$E, "values", {
  weightSelector: String,
  heightSelector: String
});

/*  Single use controller only for the Dietetic Clinic Visit */
var _default$D = /*#__PURE__*/function (_Controller) {
  function _default() {
    _classCallCheck$1(this, _default);
    return _callSuper(this, _default, arguments);
  }
  _inherits$1(_default, _Controller);
  return _createClass$1(_default, [{
    key: "initialize",
    value: function initialize() {
      this.calculate = this.calculate.bind(this);
    }
  }, {
    key: "connect",
    value: function connect() {
      // As weight is outside the scope of the controller
      // -> grab directly
      this.weightElement = document.querySelector(this.weightSelectorValue);
      this.weightElement.addEventListener("input", this.calculate);
      this.calculate();
    }
  }, {
    key: "disconnect",
    value: function disconnect() {
      this.weightElement.removeEventListener("input", this.calculate);
    }
  }, {
    key: "calculate",
    value: function calculate() {
      var weight = this.weightElement.value;
      var previousWeight = this.previousWeightTarget.value;
      var value = weight && previousWeight ? Math.round((weight - previousWeight) / previousWeight * 100 * 10) / 10 + "%" : "";
      this.outputTarget.innerText = value;
    }
  }]);
}(Controller);
_defineProperty$2(_default$D, "targets", ["previousWeight", "output"]);
_defineProperty$2(_default$D, "values", {
  weightSelector: String
});

/*  Single use controller only for the Dietetic Clinic Visit */
var _default$C = /*#__PURE__*/function (_Controller) {
  function _default() {
    _classCallCheck$1(this, _default);
    return _callSuper(this, _default, arguments);
  }
  _inherits$1(_default, _Controller);
  return _createClass$1(_default, [{
    key: "initialize",
    value: function initialize() {
      this.calculate = this.calculate.bind(this);
    }
  }, {
    key: "connect",
    value: function connect() {
      // As weight is outside the scope of the controller
      // -> grab directly
      this.idealBodyWeightElement = document.querySelector("#clinic_visit_document_ideal_body_weight");
      this.idealBodyWeightElement.addEventListener("input", this.calculate);
      this.calculate();
    }
  }, {
    key: "disconnect",
    value: function disconnect() {
      this.idealBodyWeightElement.removeEventListener("input", this.calculate);
    }
  }, {
    key: "calculate",
    value: function calculate() {
      var weight = this.idealBodyWeightElement.value;
      var proteinIntake = this.proteinIntakeTarget.value;
      var value = weight && proteinIntake ? Math.round(proteinIntake / weight * 10) / 10 + " g/day/kg" : "";
      this.outputTarget.innerText = value;
    }
  }]);
}(Controller);
_defineProperty$2(_default$C, "targets", ["proteinIntake", "output"]);

var $$6 = window.$;
var _default$B = /*#__PURE__*/function (_Controller) {
  function _default() {
    _classCallCheck$1(this, _default);
    return _callSuper(this, _default, arguments);
  }
  _inherits$1(_default, _Controller);
  return _createClass$1(_default, [{
    key: "toggleAdministered",
    value: function toggleAdministered() {
      var checked = event.target.value == "true";
      this.containerTarget.classList.toggle("administered", checked);
      this.containerTarget.classList.toggle("not-administered", !checked);
      this.containerTarget.classList.remove("undecided");
      // The rest of this actions are using jQuery for now.
      $$6(".authentication", this.containerTarget).toggle(checked);
      $$6(".authentication", this.containerTarget).toggleClass("disabled-with-faded-overlay", !checked);
      $$6(".reason-why-not-administered", this.containerTarget).toggle(!checked);
      $$6("#btn_save_and_witness_later").toggle(checked);
    }
  }]);
}(Controller);
_defineProperty$2(_default$B, "targets", ["container", "radio"]);

var Rails$3 = window.Rails;

// Handles the modal dialog used for presenting Home Delivery print options to
// the user. Used on the prescriptions page.
var _default$A = /*#__PURE__*/function (_Controller) {
  function _default() {
    _classCallCheck$1(this, _default);
    return _callSuper(this, _default, arguments);
  }
  _inherits$1(_default, _Controller);
  return _createClass$1(_default, [{
    key: "refreshForm",
    value:
    // Submit and re-display the form when 'drug type' or 'prescription duration'
    // dropdowns are changed
    function refreshForm() {
      Rails$3.fire(this.formTarget, "submit");
    }

    // When the user has clicked Print (launching the PDF in a new tab), hide
    // the Print button and display content which asks whether printing was
    // successful or not. Click one of these 2 buttons will dismiss the modal.
    // FYI if they say Yes (printing was a success) the home delivery
    // event (the object 'behind' our modal form) is updated with printed=true.
  }, {
    key: "askForPrintFeedback",
    value: function askForPrintFeedback() {
      this.printOptionsTarget.classList.toggle("visuallyhidden");
      this.printFeedbackTarget.classList.toggle("visuallyhidden");
    }
  }]);
}(Controller);
_defineProperty$2(_default$A, "targets", ["form", "printOptions", "printFeedback"]);

var $$5 = window.$;
var _default$z = /*#__PURE__*/function (_Controller) {
  function _default() {
    _classCallCheck$1(this, _default);
    return _callSuper(this, _default, arguments);
  }
  _inherits$1(_default, _Controller);
  return _createClass$1(_default, [{
    key: "insert",
    value: function insert(event) {
      // TODO: set up the trix editor in each page as data-target="snippets.trix"
      var modal = $$5("#snippets-modal");
      var snippetBody = $$5(event.target).parent().closest("tr").find(".body").html();
      var trix = document.querySelector("trix-editor");
      trix.editor.insertHTML(snippetBody);
      $$5(modal).foundation("reveal", "close");
    }
  }]);
}(Controller);

var $$4 = window.$;
var _default$y = /*#__PURE__*/function (_Controller) {
  function _default() {
    _classCallCheck$1(this, _default);
    return _callSuper(this, _default, arguments);
  }
  _inherits$1(_default, _Controller);
  return _createClass$1(_default, [{
    key: "initInsertEventNotesIntoTrixEditor",
    value: function initInsertEventNotesIntoTrixEditor(event) {
      event.preventDefault();
      var notes = $$4(event.target).data("notes");
      if (notes && this.trix) {
        this.trix.insertHTML(notes);
      } else {
        alert("There are no notes to insert");
      }
    }
  }, {
    key: "trix",
    get: function get() {
      return this.trixTarget.editor;
    }
  }]);
}(Controller);
_defineProperty$2(_default$y, "targets", ["trix"]);

// Handles the modal dialog used for presenting Home Delivery print options to
// the user. Used on the prescriptions page.
var _default$x = /*#__PURE__*/function (_Controller) {
  function _default() {
    _classCallCheck$1(this, _default);
    return _callSuper(this, _default, arguments);
  }
  _inherits$1(_default, _Controller);
  return _createClass$1(_default, [{
    key: "connect",
    value: function connect() {
      var radio_value = this.providersTarget.querySelector("input:checked").value;
      this.toggleDeliveryDatesVisibility(radio_value);
    }
  }, {
    key: "toggleDeliveryDates",
    value: function toggleDeliveryDates(event) {
      this.toggleDeliveryDatesVisibility(event.target.value);
    }
  }, {
    key: "toggleDeliveryDatesVisibility",
    value: function toggleDeliveryDatesVisibility(radio_value) {
      if (radio_value == "home_delivery") {
        this.homeDeliveryDatesTarget.style.display = "block";
      } else {
        this.homeDeliveryDatesTarget.style.display = "none";
      }
    }
  }]);
}(Controller);
_defineProperty$2(_default$x, "targets", ["homeDeliveryDates", "providers"]);

/*! (c) Andrea Giammarchi - ISC */
var self$1 = {};
try {
  (function (URLSearchParams, plus) {
    if (new URLSearchParams('q=%2B').get('q') !== plus || new URLSearchParams({
      q: plus
    }).get('q') !== plus || new URLSearchParams([['q', plus]]).get('q') !== plus || new URLSearchParams('q=\n').toString() !== 'q=%0A' || new URLSearchParams({
      q: ' &'
    }).toString() !== 'q=+%26' || new URLSearchParams({
      q: '%zx'
    }).toString() !== 'q=%25zx') throw URLSearchParams;
    self$1.URLSearchParams = URLSearchParams;
  })(URLSearchParams, '+');
} catch (URLSearchParams) {
  (function (Object, String, isArray) {

    var create = Object.create;
    var defineProperty = Object.defineProperty;
    var find = /[!'\(\)~]|%20|%00/g;
    var findPercentSign = /%(?![0-9a-fA-F]{2})/g;
    var plus = /\+/g;
    var replace = {
      '!': '%21',
      "'": '%27',
      '(': '%28',
      ')': '%29',
      '~': '%7E',
      '%20': '+',
      '%00': '\x00'
    };
    var proto = {
      append: function (key, value) {
        appendTo(this._ungap, key, value);
      },
      delete: function (key) {
        delete this._ungap[key];
      },
      get: function (key) {
        return this.has(key) ? this._ungap[key][0] : null;
      },
      getAll: function (key) {
        return this.has(key) ? this._ungap[key].slice(0) : [];
      },
      has: function (key) {
        return key in this._ungap;
      },
      set: function (key, value) {
        this._ungap[key] = [String(value)];
      },
      forEach: function (callback, thisArg) {
        var self = this;
        for (var key in self._ungap) self._ungap[key].forEach(invoke, key);
        function invoke(value) {
          callback.call(thisArg, value, String(key), self);
        }
      },
      toJSON: function () {
        return {};
      },
      toString: function () {
        var query = [];
        for (var key in this._ungap) {
          var encoded = encode(key);
          for (var i = 0, value = this._ungap[key]; i < value.length; i++) {
            query.push(encoded + '=' + encode(value[i]));
          }
        }
        return query.join('&');
      }
    };
    for (var key in proto) defineProperty(URLSearchParams.prototype, key, {
      configurable: true,
      writable: true,
      value: proto[key]
    });
    self$1.URLSearchParams = URLSearchParams;
    function URLSearchParams(query) {
      var dict = create(null);
      defineProperty(this, '_ungap', {
        value: dict
      });
      switch (true) {
        case !query:
          break;
        case typeof query === 'string':
          if (query.charAt(0) === '?') {
            query = query.slice(1);
          }
          for (var pairs = query.split('&'), i = 0, length = pairs.length; i < length; i++) {
            var value = pairs[i];
            var index = value.indexOf('=');
            if (-1 < index) {
              appendTo(dict, decode(value.slice(0, index)), decode(value.slice(index + 1)));
            } else if (value.length) {
              appendTo(dict, decode(value), '');
            }
          }
          break;
        case isArray(query):
          for (var i = 0, length = query.length; i < length; i++) {
            var value = query[i];
            appendTo(dict, value[0], value[1]);
          }
          break;
        case 'forEach' in query:
          query.forEach(addEach, dict);
          break;
        default:
          for (var key in query) appendTo(dict, key, query[key]);
      }
    }
    function addEach(value, key) {
      appendTo(this, key, value);
    }
    function appendTo(dict, key, value) {
      var res = isArray(value) ? value.join(',') : value;
      if (key in dict) dict[key].push(res);else dict[key] = [res];
    }
    function decode(str) {
      return decodeURIComponent(str.replace(findPercentSign, '%25').replace(plus, ' '));
    }
    function encode(str) {
      return encodeURIComponent(str).replace(find, replacer);
    }
    function replacer(match) {
      return replace[match];
    }
  })(Object, String, Array.isArray);
}
(function (URLSearchParamsProto) {
  var iterable = false;
  try {
    iterable = !!Symbol.iterator;
  } catch (o_O) {}

  /* istanbul ignore else */
  if (!('forEach' in URLSearchParamsProto)) {
    URLSearchParamsProto.forEach = function forEach(callback, thisArg) {
      var self = this;
      var names = Object.create(null);
      this.toString().replace(/=[\s\S]*?(?:&|$)/g, '=').split('=').forEach(function (name) {
        if (!name.length || name in names) return;
        (names[name] = self.getAll(name)).forEach(function (value) {
          callback.call(thisArg, value, name, self);
        });
      });
    };
  }

  /* istanbul ignore else */
  if (!('keys' in URLSearchParamsProto)) {
    URLSearchParamsProto.keys = function keys() {
      return iterator(this, function (value, key) {
        this.push(key);
      });
    };
  }

  /* istanbul ignore else */
  if (!('values' in URLSearchParamsProto)) {
    URLSearchParamsProto.values = function values() {
      return iterator(this, function (value, key) {
        this.push(value);
      });
    };
  }

  /* istanbul ignore else */
  if (!('entries' in URLSearchParamsProto)) {
    URLSearchParamsProto.entries = function entries() {
      return iterator(this, function (value, key) {
        this.push([key, value]);
      });
    };
  }

  /* istanbul ignore else */
  if (iterable && !(Symbol.iterator in URLSearchParamsProto)) {
    URLSearchParamsProto[Symbol.iterator] = URLSearchParamsProto.entries;
  }

  /* istanbul ignore else */
  if (!('sort' in URLSearchParamsProto)) {
    URLSearchParamsProto.sort = function sort() {
      var entries = this.entries(),
        entry = entries.next(),
        done = entry.done,
        keys = [],
        values = Object.create(null),
        i,
        key,
        value;
      while (!done) {
        value = entry.value;
        key = value[0];
        keys.push(key);
        if (!(key in values)) {
          values[key] = [];
        }
        values[key].push(value[1]);
        entry = entries.next();
        done = entry.done;
      }
      // not the champion in efficiency
      // but these two bits just do the job
      keys.sort();
      for (i = 0; i < keys.length; i++) {
        this.delete(keys[i]);
      }
      for (i = 0; i < keys.length; i++) {
        key = keys[i];
        this.append(key, values[key].shift());
      }
    };
  }
  function iterator(self, callback) {
    var items = [];
    self.forEach(callback, items);
    /* istanbul ignore next */
    return iterable ? items[Symbol.iterator]() : {
      next: function () {
        var value = items.shift();
        return {
          done: value === void 0,
          value: value
        };
      }
    };
  }

  /* istanbul ignore next */
  (function (Object) {
    var dP = Object.defineProperty,
      gOPD = Object.getOwnPropertyDescriptor,
      createSearchParamsPollute = function (search) {
        function append(name, value) {
          URLSearchParamsProto.append.call(this, name, value);
          name = this.toString();
          search.set.call(this._usp, name ? '?' + name : '');
        }
        function del(name) {
          URLSearchParamsProto.delete.call(this, name);
          name = this.toString();
          search.set.call(this._usp, name ? '?' + name : '');
        }
        function set(name, value) {
          URLSearchParamsProto.set.call(this, name, value);
          name = this.toString();
          search.set.call(this._usp, name ? '?' + name : '');
        }
        return function (sp, value) {
          sp.append = append;
          sp.delete = del;
          sp.set = set;
          return dP(sp, '_usp', {
            configurable: true,
            writable: true,
            value: value
          });
        };
      },
      createSearchParamsCreate = function (polluteSearchParams) {
        return function (obj, sp) {
          dP(obj, '_searchParams', {
            configurable: true,
            writable: true,
            value: polluteSearchParams(sp, obj)
          });
          return sp;
        };
      },
      updateSearchParams = function (sp) {
        var append = sp.append;
        sp.append = URLSearchParamsProto.append;
        URLSearchParams.call(sp, sp._usp.search.slice(1));
        sp.append = append;
      },
      verifySearchParams = function (obj, Class) {
        if (!(obj instanceof Class)) throw new TypeError("'searchParams' accessed on an object that " + "does not implement interface " + Class.name);
      },
      upgradeClass = function (Class) {
        var ClassProto = Class.prototype,
          searchParams = gOPD(ClassProto, 'searchParams'),
          href = gOPD(ClassProto, 'href'),
          search = gOPD(ClassProto, 'search'),
          createSearchParams;
        if (!searchParams && search && search.set) {
          createSearchParams = createSearchParamsCreate(createSearchParamsPollute(search));
          Object.defineProperties(ClassProto, {
            href: {
              get: function () {
                return href.get.call(this);
              },
              set: function (value) {
                var sp = this._searchParams;
                href.set.call(this, value);
                if (sp) updateSearchParams(sp);
              }
            },
            search: {
              get: function () {
                return search.get.call(this);
              },
              set: function (value) {
                var sp = this._searchParams;
                search.set.call(this, value);
                if (sp) updateSearchParams(sp);
              }
            },
            searchParams: {
              get: function () {
                verifySearchParams(this, Class);
                return this._searchParams || createSearchParams(this, new URLSearchParams(this.search.slice(1)));
              },
              set: function (sp) {
                verifySearchParams(this, Class);
                createSearchParams(this, sp);
              }
            }
          });
        }
      };
    try {
      upgradeClass(HTMLAnchorElement);
      if (/^function|object$/.test(typeof URL) && URL.prototype) upgradeClass(URL);
    } catch (meh) {}
  })(Object);
})(self$1.URLSearchParams.prototype);
var URLSearchParams$1 = self$1.URLSearchParams;

var highcharts = {exports: {}};

/**
 * Highcharts JS v11.3.0 (2024-01-10)
 *
 * (c) 2009-2024 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */

(function (module) {
	!function (t, e) {
	  module.exports ? (e.default = e, module.exports = t && t.document ? e(t) : e) : (t.Highcharts && t.Highcharts.error(16, !0), t.Highcharts = e(t));
	}("undefined" != typeof window ? window : commonjsGlobal, function (t) {

	  var e = {};
	  function i(e, i, s, o) {
	    e.hasOwnProperty(i) || (e[i] = o.apply(null, s), "function" == typeof CustomEvent && t.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", {
	      detail: {
	        path: i,
	        module: e[i]
	      }
	    })));
	  }
	  return i(e, "Core/Globals.js", [], function () {
	    var e, i;
	    return (i = e || (e = {})).SVG_NS = "http://www.w3.org/2000/svg", i.product = "Highcharts", i.version = "11.3.0", i.win = void 0 !== t ? t : {}, i.doc = i.win.document, i.svg = i.doc && i.doc.createElementNS && !!i.doc.createElementNS(i.SVG_NS, "svg").createSVGRect, i.userAgent = i.win.navigator && i.win.navigator.userAgent || "", i.isChrome = -1 !== i.userAgent.indexOf("Chrome"), i.isFirefox = -1 !== i.userAgent.indexOf("Firefox"), i.isMS = /(edge|msie|trident)/i.test(i.userAgent) && !i.win.opera, i.isSafari = !i.isChrome && -1 !== i.userAgent.indexOf("Safari"), i.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(i.userAgent), i.isWebKit = -1 !== i.userAgent.indexOf("AppleWebKit"), i.deg2rad = 2 * Math.PI / 360, i.hasBidiBug = i.isFirefox && 4 > parseInt(i.userAgent.split("Firefox/")[1], 10), i.hasTouch = !!i.win.TouchEvent, i.marginNames = ["plotTop", "marginRight", "marginBottom", "plotLeft"], i.noop = function () {}, i.supportsPassiveEvents = function () {
	      let t = !1;
	      if (!i.isMS) {
	        let e = Object.defineProperty({}, "passive", {
	          get: function () {
	            t = !0;
	          }
	        });
	        i.win.addEventListener && i.win.removeEventListener && (i.win.addEventListener("testPassive", i.noop, e), i.win.removeEventListener("testPassive", i.noop, e));
	      }
	      return t;
	    }(), i.charts = [], i.composed = [], i.dateFormats = {}, i.seriesTypes = {}, i.symbolSizes = {}, i.chartCount = 0, e;
	  }), i(e, "Core/Utilities.js", [e["Core/Globals.js"]], function (t) {
	    let e;
	    let {
	      charts: i,
	      doc: s,
	      win: o
	    } = t;
	    function r(e, i, s, n) {
	      let a = i ? "Highcharts error" : "Highcharts warning";
	      32 === e && (e = `${a}: Deprecated member`);
	      let h = p(e),
	        l = h ? `${a} #${e}: www.highcharts.com/errors/${e}/` : e.toString();
	      if (void 0 !== n) {
	        let t = "";
	        h && (l += "?"), k(n, function (e, i) {
	          t += `
 - ${i}: ${e}`, h && (l += encodeURI(i) + "=" + encodeURI(e));
	        }), l += t;
	      }
	      C(t, "displayError", {
	        chart: s,
	        code: e,
	        message: l,
	        params: n
	      }, function () {
	        if (i) throw Error(l);
	        o.console && -1 === r.messages.indexOf(l) && console.warn(l);
	      }), r.messages.push(l);
	    }
	    function n(t, e) {
	      return parseInt(t, e || 10);
	    }
	    function a(t) {
	      return "string" == typeof t;
	    }
	    function h(t) {
	      let e = Object.prototype.toString.call(t);
	      return "[object Array]" === e || "[object Array Iterator]" === e;
	    }
	    function l(t, e) {
	      return !!t && "object" == typeof t && (!e || !h(t));
	    }
	    function d(t) {
	      return l(t) && "number" == typeof t.nodeType;
	    }
	    function c(t) {
	      let e = t && t.constructor;
	      return !!(l(t, !0) && !d(t) && e && e.name && "Object" !== e.name);
	    }
	    function p(t) {
	      return "number" == typeof t && !isNaN(t) && t < 1 / 0 && t > -1 / 0;
	    }
	    function u(t) {
	      return null != t;
	    }
	    function g(t, e, i) {
	      let s;
	      let o = a(e) && !u(i),
	        r = (e, i) => {
	          u(e) ? t.setAttribute(i, e) : o ? (s = t.getAttribute(i)) || "class" !== i || (s = t.getAttribute(i + "Name")) : t.removeAttribute(i);
	        };
	      return a(e) ? r(i, e) : k(e, r), s;
	    }
	    function f(t) {
	      return h(t) ? t : [t];
	    }
	    function m(t, e) {
	      let i;
	      for (i in t || (t = {}), e) t[i] = e[i];
	      return t;
	    }
	    function x() {
	      let t = arguments,
	        e = t.length;
	      for (let i = 0; i < e; i++) {
	        let e = t[i];
	        if (null != e) return e;
	      }
	    }
	    function y(e, i) {
	      t.isMS && !t.svg && i && u(i.opacity) && (i.filter = `alpha(opacity=${100 * i.opacity})`), m(e.style, i);
	    }
	    function b(t) {
	      return Math.pow(10, Math.floor(Math.log(t) / Math.LN10));
	    }
	    function v(t, e) {
	      return t > 1e14 ? t : parseFloat(t.toPrecision(e || 14));
	    }
	    (r || (r = {})).messages = [], Math.easeInOutSine = function (t) {
	      return -.5 * (Math.cos(Math.PI * t) - 1);
	    };
	    let S = Array.prototype.find ? function (t, e) {
	      return t.find(e);
	    } : function (t, e) {
	      let i;
	      let s = t.length;
	      for (i = 0; i < s; i++) if (e(t[i], i)) return t[i];
	    };
	    function k(t, e, i) {
	      for (let s in t) Object.hasOwnProperty.call(t, s) && e.call(i || t[s], t[s], s, t);
	    }
	    function M(t, e, i) {
	      function s(e, i) {
	        let s = t.removeEventListener;
	        s && s.call(t, e, i, !1);
	      }
	      function o(i) {
	        let o, r;
	        t.nodeName && (e ? (o = {})[e] = !0 : o = i, k(o, function (t, e) {
	          if (i[e]) for (r = i[e].length; r--;) s(e, i[e][r].fn);
	        }));
	      }
	      let r = "function" == typeof t && t.prototype || t;
	      if (Object.hasOwnProperty.call(r, "hcEvents")) {
	        let t = r.hcEvents;
	        if (e) {
	          let r = t[e] || [];
	          i ? (t[e] = r.filter(function (t) {
	            return i !== t.fn;
	          }), s(e, i)) : (o(t), t[e] = []);
	        } else o(t), delete r.hcEvents;
	      }
	    }
	    function C(e, i, o, r) {
	      let n;
	      if (o = o || {}, s.createEvent && (e.dispatchEvent || e.fireEvent && e !== t)) (n = s.createEvent("Events")).initEvent(i, !0, !0), o = m(n, o), e.dispatchEvent ? e.dispatchEvent(o) : e.fireEvent(i, o);else if (e.hcEvents) {
	        o.target || m(o, {
	          preventDefault: function () {
	            o.defaultPrevented = !0;
	          },
	          target: e,
	          type: i
	        });
	        let t = [],
	          s = e,
	          r = !1;
	        for (; s.hcEvents;) Object.hasOwnProperty.call(s, "hcEvents") && s.hcEvents[i] && (t.length && (r = !0), t.unshift.apply(t, s.hcEvents[i])), s = Object.getPrototypeOf(s);
	        r && t.sort((t, e) => t.order - e.order), t.forEach(t => {
	          !1 === t.fn.call(e, o) && o.preventDefault();
	        });
	      }
	      r && !o.defaultPrevented && r.call(e, o);
	    }
	    k({
	      map: "map",
	      each: "forEach",
	      grep: "filter",
	      reduce: "reduce",
	      some: "some"
	    }, function (e, i) {
	      t[i] = function (t) {
	        return r(32, !1, void 0, {
	          [`Highcharts.${i}`]: `use Array.${e}`
	        }), Array.prototype[e].apply(t, [].slice.call(arguments, 1));
	      };
	    });
	    let w = function () {
	      let t = Math.random().toString(36).substring(2, 9) + "-",
	        i = 0;
	      return function () {
	        return "highcharts-" + (e ? "" : t) + i++;
	      };
	    }();
	    o.jQuery && (o.jQuery.fn.highcharts = function () {
	      let e = [].slice.call(arguments);
	      if (this[0]) return e[0] ? (new t[a(e[0]) ? e.shift() : "Chart"](this[0], e[0], e[1]), this) : i[g(this[0], "data-highcharts-chart")];
	    });
	    let T = {
	      addEvent: function (e, i, s, o = {}) {
	        let r = "function" == typeof e && e.prototype || e;
	        Object.hasOwnProperty.call(r, "hcEvents") || (r.hcEvents = {});
	        let n = r.hcEvents;
	        t.Point && e instanceof t.Point && e.series && e.series.chart && (e.series.chart.runTrackerClick = !0);
	        let a = e.addEventListener;
	        a && a.call(e, i, s, !!t.supportsPassiveEvents && {
	          passive: void 0 === o.passive ? -1 !== i.indexOf("touch") : o.passive,
	          capture: !1
	        }), n[i] || (n[i] = []);
	        let h = {
	          fn: s,
	          order: "number" == typeof o.order ? o.order : 1 / 0
	        };
	        return n[i].push(h), n[i].sort((t, e) => t.order - e.order), function () {
	          M(e, i, s);
	        };
	      },
	      arrayMax: function (t) {
	        let e = t.length,
	          i = t[0];
	        for (; e--;) t[e] > i && (i = t[e]);
	        return i;
	      },
	      arrayMin: function (t) {
	        let e = t.length,
	          i = t[0];
	        for (; e--;) t[e] < i && (i = t[e]);
	        return i;
	      },
	      attr: g,
	      clamp: function (t, e, i) {
	        return t > e ? t < i ? t : i : e;
	      },
	      clearTimeout: function (t) {
	        u(t) && clearTimeout(t);
	      },
	      correctFloat: v,
	      createElement: function (t, e, i, o, r) {
	        let n = s.createElement(t);
	        return e && m(n, e), r && y(n, {
	          padding: "0",
	          border: "none",
	          margin: "0"
	        }), i && y(n, i), o && o.appendChild(n), n;
	      },
	      css: y,
	      defined: u,
	      destroyObjectProperties: function (t, e) {
	        k(t, function (i, s) {
	          i && i !== e && i.destroy && i.destroy(), delete t[s];
	        });
	      },
	      diffObjects: function (t, e, i, s) {
	        let o = {};
	        return function t(e, o, r, n) {
	          let a = i ? o : e;
	          k(e, function (i, d) {
	            if (!n && s && s.indexOf(d) > -1 && o[d]) {
	              i = f(i), r[d] = [];
	              for (let e = 0; e < Math.max(i.length, o[d].length); e++) o[d][e] && (void 0 === i[e] ? r[d][e] = o[d][e] : (r[d][e] = {}, t(i[e], o[d][e], r[d][e], n + 1)));
	            } else l(i, !0) && !i.nodeType ? (r[d] = h(i) ? [] : {}, t(i, o[d] || {}, r[d], n + 1), 0 !== Object.keys(r[d]).length || "colorAxis" === d && 0 === n || delete r[d]) : (e[d] !== o[d] || d in e && !(d in o)) && (r[d] = a[d]);
	          });
	        }(t, e, o, 0), o;
	      },
	      discardElement: function (t) {
	        t && t.parentElement && t.parentElement.removeChild(t);
	      },
	      erase: function (t, e) {
	        let i = t.length;
	        for (; i--;) if (t[i] === e) {
	          t.splice(i, 1);
	          break;
	        }
	      },
	      error: r,
	      extend: m,
	      extendClass: function (t, e) {
	        let i = function () {};
	        return i.prototype = new t(), m(i.prototype, e), i;
	      },
	      find: S,
	      fireEvent: C,
	      getClosestDistance: function (t, e) {
	        let i, s, o;
	        let r = !e;
	        return t.forEach(t => {
	          if (t.length > 1) for (o = t.length - 1; o > 0; o--) (s = t[o] - t[o - 1]) < 0 && !r ? (e?.(), e = void 0) : s && (void 0 === i || s < i) && (i = s);
	        }), i;
	      },
	      getMagnitude: b,
	      getNestedProperty: function (t, e) {
	        let i = t.split(".");
	        for (; i.length && u(e);) {
	          let t = i.shift();
	          if (void 0 === t || "__proto__" === t) return;
	          if ("this" === t) {
	            let t;
	            return l(e) && (t = e["@this"]), t ?? e;
	          }
	          let s = e[t];
	          if (!u(s) || "function" == typeof s || "number" == typeof s.nodeType || s === o) return;
	          e = s;
	        }
	        return e;
	      },
	      getStyle: function t(e, i, s) {
	        let r;
	        if ("width" === i) {
	          let i = Math.min(e.offsetWidth, e.scrollWidth),
	            s = e.getBoundingClientRect && e.getBoundingClientRect().width;
	          return s < i && s >= i - 1 && (i = Math.floor(s)), Math.max(0, i - (t(e, "padding-left", !0) || 0) - (t(e, "padding-right", !0) || 0));
	        }
	        if ("height" === i) return Math.max(0, Math.min(e.offsetHeight, e.scrollHeight) - (t(e, "padding-top", !0) || 0) - (t(e, "padding-bottom", !0) || 0));
	        let a = o.getComputedStyle(e, void 0);
	        return a && (r = a.getPropertyValue(i), x(s, "opacity" !== i) && (r = n(r))), r;
	      },
	      inArray: function (t, e, i) {
	        return r(32, !1, void 0, {
	          "Highcharts.inArray": "use Array.indexOf"
	        }), e.indexOf(t, i);
	      },
	      insertItem: function (t, e) {
	        let i;
	        let s = t.options.index,
	          o = e.length;
	        for (i = t.options.isInternal ? o : 0; i < o + 1; i++) if (!e[i] || p(s) && s < x(e[i].options.index, e[i]._i) || e[i].options.isInternal) {
	          e.splice(i, 0, t);
	          break;
	        }
	        return i;
	      },
	      isArray: h,
	      isClass: c,
	      isDOMElement: d,
	      isFunction: function (t) {
	        return "function" == typeof t;
	      },
	      isNumber: p,
	      isObject: l,
	      isString: a,
	      keys: function (t) {
	        return r(32, !1, void 0, {
	          "Highcharts.keys": "use Object.keys"
	        }), Object.keys(t);
	      },
	      merge: function () {
	        let t,
	          e = arguments,
	          i = {},
	          s = function (t, e) {
	            return "object" != typeof t && (t = {}), k(e, function (i, o) {
	              "__proto__" !== o && "constructor" !== o && (!l(i, !0) || c(i) || d(i) ? t[o] = e[o] : t[o] = s(t[o] || {}, i));
	            }), t;
	          };
	        !0 === e[0] && (i = e[1], e = Array.prototype.slice.call(e, 2));
	        let o = e.length;
	        for (t = 0; t < o; t++) i = s(i, e[t]);
	        return i;
	      },
	      normalizeTickInterval: function (t, e, i, s, o) {
	        let r,
	          n = t;
	        i = x(i, b(t));
	        let a = t / i;
	        for (!e && (e = o ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], !1 === s && (1 === i ? e = e.filter(function (t) {
	          return t % 1 == 0;
	        }) : i <= .1 && (e = [1 / i]))), r = 0; r < e.length && (n = e[r], (!o || !(n * i >= t)) && (o || !(a <= (e[r] + (e[r + 1] || e[r])) / 2))); r++);
	        return v(n * i, -Math.round(Math.log(.001) / Math.LN10));
	      },
	      objectEach: k,
	      offset: function (t) {
	        let e = s.documentElement,
	          i = t.parentElement || t.parentNode ? t.getBoundingClientRect() : {
	            top: 0,
	            left: 0,
	            width: 0,
	            height: 0
	          };
	        return {
	          top: i.top + (o.pageYOffset || e.scrollTop) - (e.clientTop || 0),
	          left: i.left + (o.pageXOffset || e.scrollLeft) - (e.clientLeft || 0),
	          width: i.width,
	          height: i.height
	        };
	      },
	      pad: function (t, e, i) {
	        return Array((e || 2) + 1 - String(t).replace("-", "").length).join(i || "0") + t;
	      },
	      pick: x,
	      pInt: n,
	      pushUnique: function (t, e) {
	        return 0 > t.indexOf(e) && !!t.push(e);
	      },
	      relativeLength: function (t, e, i) {
	        return /%$/.test(t) ? e * parseFloat(t) / 100 + (i || 0) : parseFloat(t);
	      },
	      removeEvent: M,
	      splat: f,
	      stableSort: function (t, e) {
	        let i, s;
	        let o = t.length;
	        for (s = 0; s < o; s++) t[s].safeI = s;
	        for (t.sort(function (t, s) {
	          return 0 === (i = e(t, s)) ? t.safeI - s.safeI : i;
	        }), s = 0; s < o; s++) delete t[s].safeI;
	      },
	      syncTimeout: function (t, e, i) {
	        return e > 0 ? setTimeout(t, e, i) : (t.call(0, i), -1);
	      },
	      timeUnits: {
	        millisecond: 1,
	        second: 1e3,
	        minute: 6e4,
	        hour: 36e5,
	        day: 864e5,
	        week: 6048e5,
	        month: 24192e5,
	        year: 314496e5
	      },
	      uniqueKey: w,
	      useSerialIds: function (t) {
	        return e = x(t, e);
	      },
	      wrap: function (t, e, i) {
	        let s = t[e];
	        t[e] = function () {
	          let t = arguments,
	            e = this;
	          return i.apply(this, [function () {
	            return s.apply(e, arguments.length ? arguments : t);
	          }].concat([].slice.call(arguments)));
	        };
	      }
	    };
	    return T;
	  }), i(e, "Core/Chart/ChartDefaults.js", [], function () {
	    return {
	      alignThresholds: !1,
	      panning: {
	        enabled: !1,
	        type: "x"
	      },
	      styledMode: !1,
	      borderRadius: 0,
	      colorCount: 10,
	      allowMutatingData: !0,
	      ignoreHiddenSeries: !0,
	      spacing: [10, 10, 15, 10],
	      resetZoomButton: {
	        theme: {},
	        position: {}
	      },
	      reflow: !0,
	      type: "line",
	      zooming: {
	        singleTouch: !1,
	        resetButton: {
	          theme: {
	            zIndex: 6
	          },
	          position: {
	            align: "right",
	            x: -10,
	            y: 10
	          }
	        }
	      },
	      width: null,
	      height: null,
	      borderColor: "#334eff",
	      backgroundColor: "#ffffff",
	      plotBorderColor: "#cccccc"
	    };
	  }), i(e, "Core/Color/Palettes.js", [], function () {
	    return {
	      colors: ["#2caffe", "#544fc5", "#00e272", "#fe6a35", "#6b8abc", "#d568fb", "#2ee0ca", "#fa4b42", "#feb56a", "#91e8e1"]
	    };
	  }), i(e, "Core/Time.js", [e["Core/Globals.js"], e["Core/Utilities.js"]], function (t, e) {
	    let {
	        win: i
	      } = t,
	      {
	        defined: s,
	        error: o,
	        extend: r,
	        isNumber: n,
	        isObject: a,
	        merge: h,
	        objectEach: l,
	        pad: d,
	        pick: c,
	        splat: p,
	        timeUnits: u
	      } = e,
	      g = t.isSafari && i.Intl && i.Intl.DateTimeFormat.prototype.formatRange,
	      f = t.isSafari && i.Intl && !i.Intl.DateTimeFormat.prototype.formatRange;
	    return class {
	      constructor(t) {
	        this.options = {}, this.useUTC = !1, this.variableTimezone = !1, this.Date = i.Date, this.getTimezoneOffset = this.timezoneOffsetFunction(), this.update(t);
	      }
	      get(t, e) {
	        if (this.variableTimezone || this.timezoneOffset) {
	          let i = e.getTime(),
	            s = i - this.getTimezoneOffset(e);
	          e.setTime(s);
	          let o = e["getUTC" + t]();
	          return e.setTime(i), o;
	        }
	        return this.useUTC ? e["getUTC" + t]() : e["get" + t]();
	      }
	      set(t, e, i) {
	        if (this.variableTimezone || this.timezoneOffset) {
	          if ("Milliseconds" === t || "Seconds" === t || "Minutes" === t && this.getTimezoneOffset(e) % 36e5 == 0) return e["setUTC" + t](i);
	          let s = this.getTimezoneOffset(e),
	            o = e.getTime() - s;
	          e.setTime(o), e["setUTC" + t](i);
	          let r = this.getTimezoneOffset(e);
	          return o = e.getTime() + r, e.setTime(o);
	        }
	        return this.useUTC || g && "FullYear" === t ? e["setUTC" + t](i) : e["set" + t](i);
	      }
	      update(t = {}) {
	        let e = c(t.useUTC, !0);
	        this.options = t = h(!0, this.options, t), this.Date = t.Date || i.Date || Date, this.useUTC = e, this.timezoneOffset = e && t.timezoneOffset || void 0, this.getTimezoneOffset = this.timezoneOffsetFunction(), this.variableTimezone = e && !!(t.getTimezoneOffset || t.timezone);
	      }
	      makeTime(t, e, i, s, o, r) {
	        let n, a, h;
	        return this.useUTC ? (n = this.Date.UTC.apply(0, arguments), a = this.getTimezoneOffset(n), n += a, a !== (h = this.getTimezoneOffset(n)) ? n += h - a : a - 36e5 !== this.getTimezoneOffset(n - 36e5) || f || (n -= 36e5)) : n = new this.Date(t, e, c(i, 1), c(s, 0), c(o, 0), c(r, 0)).getTime(), n;
	      }
	      timezoneOffsetFunction() {
	        let t = this,
	          e = this.options,
	          i = e.getTimezoneOffset;
	        return this.useUTC ? e.timezone ? t => {
	          try {
	            let [i, s, o, r, a = 0] = Intl.DateTimeFormat("en", {
	                timeZone: e.timezone,
	                timeZoneName: "shortOffset"
	              }).format(t).split(/(GMT|:)/).map(Number),
	              h = -(36e5 * (o + a / 60));
	            if (n(h)) return h;
	          } catch (t) {
	            o(34);
	          }
	          return 0;
	        } : this.useUTC && i ? t => 6e4 * i(t.valueOf()) : () => 6e4 * (t.timezoneOffset || 0) : t => 6e4 * new Date(t.toString()).getTimezoneOffset();
	      }
	      dateFormat(e, i, o) {
	        if (!s(i) || isNaN(i)) return t.defaultOptions.lang && t.defaultOptions.lang.invalidDate || "";
	        e = c(e, "%Y-%m-%d %H:%M:%S");
	        let n = this,
	          a = new this.Date(i),
	          h = this.get("Hours", a),
	          p = this.get("Day", a),
	          u = this.get("Date", a),
	          g = this.get("Month", a),
	          f = this.get("FullYear", a),
	          m = t.defaultOptions.lang,
	          x = m && m.weekdays,
	          y = m && m.shortWeekdays,
	          b = r({
	            a: y ? y[p] : x[p].substr(0, 3),
	            A: x[p],
	            d: d(u),
	            e: d(u, 2, " "),
	            w: p,
	            b: m.shortMonths[g],
	            B: m.months[g],
	            m: d(g + 1),
	            o: g + 1,
	            y: f.toString().substr(2, 2),
	            Y: f,
	            H: d(h),
	            k: h,
	            I: d(h % 12 || 12),
	            l: h % 12 || 12,
	            M: d(this.get("Minutes", a)),
	            p: h < 12 ? "AM" : "PM",
	            P: h < 12 ? "am" : "pm",
	            S: d(this.get("Seconds", a)),
	            L: d(Math.floor(i % 1e3), 3)
	          }, t.dateFormats);
	        return l(b, function (t, s) {
	          for (; -1 !== e.indexOf("%" + s);) e = e.replace("%" + s, "function" == typeof t ? t.call(n, i) : t);
	        }), o ? e.substr(0, 1).toUpperCase() + e.substr(1) : e;
	      }
	      resolveDTLFormat(t) {
	        return a(t, !0) ? t : {
	          main: (t = p(t))[0],
	          from: t[1],
	          to: t[2]
	        };
	      }
	      getTimeTicks(t, e, i, o) {
	        let n, a, h, l;
	        let d = this,
	          p = d.Date,
	          g = [],
	          f = {},
	          m = new p(e),
	          x = t.unitRange,
	          y = t.count || 1;
	        if (o = c(o, 1), s(e)) {
	          d.set("Milliseconds", m, x >= u.second ? 0 : y * Math.floor(d.get("Milliseconds", m) / y)), x >= u.second && d.set("Seconds", m, x >= u.minute ? 0 : y * Math.floor(d.get("Seconds", m) / y)), x >= u.minute && d.set("Minutes", m, x >= u.hour ? 0 : y * Math.floor(d.get("Minutes", m) / y)), x >= u.hour && d.set("Hours", m, x >= u.day ? 0 : y * Math.floor(d.get("Hours", m) / y)), x >= u.day && d.set("Date", m, x >= u.month ? 1 : Math.max(1, y * Math.floor(d.get("Date", m) / y))), x >= u.month && (d.set("Month", m, x >= u.year ? 0 : y * Math.floor(d.get("Month", m) / y)), a = d.get("FullYear", m)), x >= u.year && (a -= a % y, d.set("FullYear", m, a)), x === u.week && (l = d.get("Day", m), d.set("Date", m, d.get("Date", m) - l + o + (l < o ? -7 : 0))), a = d.get("FullYear", m);
	          let t = d.get("Month", m),
	            r = d.get("Date", m),
	            c = d.get("Hours", m);
	          e = m.getTime(), (d.variableTimezone || !d.useUTC) && s(i) && (h = i - e > 4 * u.month || d.getTimezoneOffset(e) !== d.getTimezoneOffset(i));
	          let p = m.getTime();
	          for (n = 1; p < i;) g.push(p), x === u.year ? p = d.makeTime(a + n * y, 0) : x === u.month ? p = d.makeTime(a, t + n * y) : h && (x === u.day || x === u.week) ? p = d.makeTime(a, t, r + n * y * (x === u.day ? 1 : 7)) : h && x === u.hour && y > 1 ? p = d.makeTime(a, t, r, c + n * y) : p += x * y, n++;
	          g.push(p), x <= u.hour && g.length < 1e4 && g.forEach(function (t) {
	            t % 18e5 == 0 && "000000000" === d.dateFormat("%H%M%S%L", t) && (f[t] = "day");
	          });
	        }
	        return g.info = r(t, {
	          higherRanks: f,
	          totalRange: x * y
	        }), g;
	      }
	      getDateFormat(t, e, i, s) {
	        let o = this.dateFormat("%m-%d %H:%M:%S.%L", e),
	          r = "01-01 00:00:00.000",
	          n = {
	            millisecond: 15,
	            second: 12,
	            minute: 9,
	            hour: 6,
	            day: 3
	          },
	          a = "millisecond",
	          h = a;
	        for (a in u) {
	          if (t === u.week && +this.dateFormat("%w", e) === i && o.substr(6) === r.substr(6)) {
	            a = "week";
	            break;
	          }
	          if (u[a] > t) {
	            a = h;
	            break;
	          }
	          if (n[a] && o.substr(n[a]) !== r.substr(n[a])) break;
	          "week" !== a && (h = a);
	        }
	        return this.resolveDTLFormat(s[a]).main;
	      }
	    };
	  }), i(e, "Core/Defaults.js", [e["Core/Chart/ChartDefaults.js"], e["Core/Globals.js"], e["Core/Color/Palettes.js"], e["Core/Time.js"], e["Core/Utilities.js"]], function (t, e, i, s, o) {
	    let {
	        isTouchDevice: r,
	        svg: n
	      } = e,
	      {
	        merge: a
	      } = o,
	      h = {
	        colors: i.colors,
	        symbols: ["circle", "diamond", "square", "triangle", "triangle-down"],
	        lang: {
	          loading: "Loading...",
	          months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
	          shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
	          weekdays: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
	          decimalPoint: ".",
	          numericSymbols: ["k", "M", "G", "T", "P", "E"],
	          resetZoom: "Reset zoom",
	          resetZoomTitle: "Reset zoom level 1:1",
	          thousandsSep: " "
	        },
	        global: {},
	        time: {
	          Date: void 0,
	          getTimezoneOffset: void 0,
	          timezone: void 0,
	          timezoneOffset: 0,
	          useUTC: !0
	        },
	        chart: t,
	        title: {
	          style: {
	            color: "#333333",
	            fontWeight: "bold"
	          },
	          text: "Chart title",
	          align: "center",
	          margin: 15,
	          widthAdjust: -44
	        },
	        subtitle: {
	          style: {
	            color: "#666666",
	            fontSize: "0.8em"
	          },
	          text: "",
	          align: "center",
	          widthAdjust: -44
	        },
	        caption: {
	          margin: 15,
	          style: {
	            color: "#666666",
	            fontSize: "0.8em"
	          },
	          text: "",
	          align: "left",
	          verticalAlign: "bottom"
	        },
	        plotOptions: {},
	        legend: {
	          enabled: !0,
	          align: "center",
	          alignColumns: !0,
	          className: "highcharts-no-tooltip",
	          layout: "horizontal",
	          itemMarginBottom: 2,
	          itemMarginTop: 2,
	          labelFormatter: function () {
	            return this.name;
	          },
	          borderColor: "#999999",
	          borderRadius: 0,
	          navigation: {
	            style: {
	              fontSize: "0.8em"
	            },
	            activeColor: "#0022ff",
	            inactiveColor: "#cccccc"
	          },
	          itemStyle: {
	            color: "#333333",
	            cursor: "pointer",
	            fontSize: "0.8em",
	            textDecoration: "none",
	            textOverflow: "ellipsis"
	          },
	          itemHoverStyle: {
	            color: "#000000"
	          },
	          itemHiddenStyle: {
	            color: "#666666",
	            textDecoration: "line-through"
	          },
	          shadow: !1,
	          itemCheckboxStyle: {
	            position: "absolute",
	            width: "13px",
	            height: "13px"
	          },
	          squareSymbol: !0,
	          symbolPadding: 5,
	          verticalAlign: "bottom",
	          x: 0,
	          y: 0,
	          title: {
	            style: {
	              fontSize: "0.8em",
	              fontWeight: "bold"
	            }
	          }
	        },
	        loading: {
	          labelStyle: {
	            fontWeight: "bold",
	            position: "relative",
	            top: "45%"
	          },
	          style: {
	            position: "absolute",
	            backgroundColor: "#ffffff",
	            opacity: .5,
	            textAlign: "center"
	          }
	        },
	        tooltip: {
	          enabled: !0,
	          animation: n,
	          borderRadius: 3,
	          dateTimeLabelFormats: {
	            millisecond: "%A, %e %b, %H:%M:%S.%L",
	            second: "%A, %e %b, %H:%M:%S",
	            minute: "%A, %e %b, %H:%M",
	            hour: "%A, %e %b, %H:%M",
	            day: "%A, %e %b %Y",
	            week: "Week from %A, %e %b %Y",
	            month: "%B %Y",
	            year: "%Y"
	          },
	          footerFormat: "",
	          headerShape: "callout",
	          hideDelay: 500,
	          padding: 8,
	          shape: "callout",
	          shared: !1,
	          snap: r ? 25 : 10,
	          headerFormat: '<span style="font-size: 0.8em">{point.key}</span><br/>',
	          pointFormat: '<span style="color:{point.color}">â</span> {series.name}: <b>{point.y}</b><br/>',
	          backgroundColor: "#ffffff",
	          borderWidth: void 0,
	          shadow: !0,
	          stickOnContact: !1,
	          style: {
	            color: "#333333",
	            cursor: "default",
	            fontSize: "0.8em"
	          },
	          useHTML: !1
	        },
	        credits: {
	          enabled: !0,
	          href: "https://www.highcharts.com?credits",
	          position: {
	            align: "right",
	            x: -10,
	            verticalAlign: "bottom",
	            y: -5
	          },
	          style: {
	            cursor: "pointer",
	            color: "#999999",
	            fontSize: "0.6em"
	          },
	          text: "Highcharts.com"
	        }
	      };
	    h.chart.styledMode = !1;
	    let l = new s(h.time);
	    return {
	      defaultOptions: h,
	      defaultTime: l,
	      getOptions: function () {
	        return h;
	      },
	      setOptions: function (t) {
	        return a(!0, h, t), (t.time || t.global) && (e.time ? e.time.update(a(h.global, h.time, t.global, t.time)) : e.time = l), h;
	      }
	    };
	  }), i(e, "Core/Color/Color.js", [e["Core/Globals.js"], e["Core/Utilities.js"]], function (t, e) {
	    let {
	      isNumber: i,
	      merge: s,
	      pInt: o
	    } = e;
	    class r {
	      static parse(t) {
	        return t ? new r(t) : r.None;
	      }
	      constructor(e) {
	        let i, s, o, n;
	        this.rgba = [NaN, NaN, NaN, NaN], this.input = e;
	        let a = t.Color;
	        if (a && a !== r) return new a(e);
	        if ("object" == typeof e && void 0 !== e.stops) this.stops = e.stops.map(t => new r(t[1]));else if ("string" == typeof e) {
	          if (this.input = e = r.names[e.toLowerCase()] || e, "#" === e.charAt(0)) {
	            let t = e.length,
	              i = parseInt(e.substr(1), 16);
	            7 === t ? s = [(16711680 & i) >> 16, (65280 & i) >> 8, 255 & i, 1] : 4 === t && (s = [(3840 & i) >> 4 | (3840 & i) >> 8, (240 & i) >> 4 | 240 & i, (15 & i) << 4 | 15 & i, 1]);
	          }
	          if (!s) for (o = r.parsers.length; o-- && !s;) (i = (n = r.parsers[o]).regex.exec(e)) && (s = n.parse(i));
	        }
	        s && (this.rgba = s);
	      }
	      get(t) {
	        let e = this.input,
	          o = this.rgba;
	        if ("object" == typeof e && void 0 !== this.stops) {
	          let i = s(e);
	          return i.stops = [].slice.call(i.stops), this.stops.forEach((e, s) => {
	            i.stops[s] = [i.stops[s][0], e.get(t)];
	          }), i;
	        }
	        return o && i(o[0]) ? "rgb" !== t && (t || 1 !== o[3]) ? "a" === t ? `${o[3]}` : "rgba(" + o.join(",") + ")" : "rgb(" + o[0] + "," + o[1] + "," + o[2] + ")" : e;
	      }
	      brighten(t) {
	        let e = this.rgba;
	        if (this.stops) this.stops.forEach(function (e) {
	          e.brighten(t);
	        });else if (i(t) && 0 !== t) for (let i = 0; i < 3; i++) e[i] += o(255 * t), e[i] < 0 && (e[i] = 0), e[i] > 255 && (e[i] = 255);
	        return this;
	      }
	      setOpacity(t) {
	        return this.rgba[3] = t, this;
	      }
	      tweenTo(t, e) {
	        let s = this.rgba,
	          o = t.rgba;
	        if (!i(s[0]) || !i(o[0])) return t.input || "none";
	        let r = 1 !== o[3] || 1 !== s[3];
	        return (r ? "rgba(" : "rgb(") + Math.round(o[0] + (s[0] - o[0]) * (1 - e)) + "," + Math.round(o[1] + (s[1] - o[1]) * (1 - e)) + "," + Math.round(o[2] + (s[2] - o[2]) * (1 - e)) + (r ? "," + (o[3] + (s[3] - o[3]) * (1 - e)) : "") + ")";
	      }
	    }
	    return r.names = {
	      white: "#ffffff",
	      black: "#000000"
	    }, r.parsers = [{
	      regex: /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,
	      parse: function (t) {
	        return [o(t[1]), o(t[2]), o(t[3]), parseFloat(t[4], 10)];
	      }
	    }, {
	      regex: /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/,
	      parse: function (t) {
	        return [o(t[1]), o(t[2]), o(t[3]), 1];
	      }
	    }], r.None = new r(""), r;
	  }), i(e, "Core/Animation/Fx.js", [e["Core/Color/Color.js"], e["Core/Globals.js"], e["Core/Utilities.js"]], function (t, e, i) {
	    let {
	        parse: s
	      } = t,
	      {
	        win: o
	      } = e,
	      {
	        isNumber: r,
	        objectEach: n
	      } = i;
	    class a {
	      constructor(t, e, i) {
	        this.pos = NaN, this.options = e, this.elem = t, this.prop = i;
	      }
	      dSetter() {
	        let t = this.paths,
	          e = t && t[0],
	          i = t && t[1],
	          s = this.now || 0,
	          o = [];
	        if (1 !== s && e && i) {
	          if (e.length === i.length && s < 1) for (let t = 0; t < i.length; t++) {
	            let n = e[t],
	              a = i[t],
	              h = [];
	            for (let t = 0; t < a.length; t++) {
	              let e = n[t],
	                i = a[t];
	              r(e) && r(i) && !("A" === a[0] && (4 === t || 5 === t)) ? h[t] = e + s * (i - e) : h[t] = i;
	            }
	            o.push(h);
	          } else o = i;
	        } else o = this.toD || [];
	        this.elem.attr("d", o, void 0, !0);
	      }
	      update() {
	        let t = this.elem,
	          e = this.prop,
	          i = this.now,
	          s = this.options.step;
	        this[e + "Setter"] ? this[e + "Setter"]() : t.attr ? t.element && t.attr(e, i, null, !0) : t.style[e] = i + this.unit, s && s.call(t, i, this);
	      }
	      run(t, e, i) {
	        let s = this,
	          r = s.options,
	          n = function (t) {
	            return !n.stopped && s.step(t);
	          },
	          h = o.requestAnimationFrame || function (t) {
	            setTimeout(t, 13);
	          },
	          l = function () {
	            for (let t = 0; t < a.timers.length; t++) a.timers[t]() || a.timers.splice(t--, 1);
	            a.timers.length && h(l);
	          };
	        t !== e || this.elem["forceAnimate:" + this.prop] ? (this.startTime = +new Date(), this.start = t, this.end = e, this.unit = i, this.now = this.start, this.pos = 0, n.elem = this.elem, n.prop = this.prop, n() && 1 === a.timers.push(n) && h(l)) : (delete r.curAnim[this.prop], r.complete && 0 === Object.keys(r.curAnim).length && r.complete.call(this.elem));
	      }
	      step(t) {
	        let e, i;
	        let s = +new Date(),
	          o = this.options,
	          r = this.elem,
	          a = o.complete,
	          h = o.duration,
	          l = o.curAnim;
	        return r.attr && !r.element ? e = !1 : t || s >= h + this.startTime ? (this.now = this.end, this.pos = 1, this.update(), l[this.prop] = !0, i = !0, n(l, function (t) {
	          !0 !== t && (i = !1);
	        }), i && a && a.call(r), e = !1) : (this.pos = o.easing((s - this.startTime) / h), this.now = this.start + (this.end - this.start) * this.pos, this.update(), e = !0), e;
	      }
	      initPath(t, e, i) {
	        let s = t.startX,
	          o = t.endX,
	          n = i.slice(),
	          a = t.isArea,
	          h = a ? 2 : 1,
	          l,
	          d,
	          c,
	          p,
	          u = e && e.slice();
	        if (!u) return [n, n];
	        function g(t, e) {
	          for (; t.length < d;) {
	            let i = t[0],
	              s = e[d - t.length];
	            if (s && "M" === i[0] && ("C" === s[0] ? t[0] = ["C", i[1], i[2], i[1], i[2], i[1], i[2]] : t[0] = ["L", i[1], i[2]]), t.unshift(i), a) {
	              let e = t.pop();
	              t.push(t[t.length - 1], e);
	            }
	          }
	        }
	        function f(t, e) {
	          for (; t.length < d;) {
	            let e = t[Math.floor(t.length / h) - 1].slice();
	            if ("C" === e[0] && (e[1] = e[5], e[2] = e[6]), a) {
	              let i = t[Math.floor(t.length / h)].slice();
	              t.splice(t.length / 2, 0, e, i);
	            } else t.push(e);
	          }
	        }
	        if (s && o && o.length) {
	          for (c = 0; c < s.length; c++) {
	            if (s[c] === o[0]) {
	              l = c;
	              break;
	            }
	            if (s[0] === o[o.length - s.length + c]) {
	              l = c, p = !0;
	              break;
	            }
	            if (s[s.length - 1] === o[o.length - s.length + c]) {
	              l = s.length - c;
	              break;
	            }
	          }
	          void 0 === l && (u = []);
	        }
	        return u.length && r(l) && (d = n.length + l * h, p ? (g(u, n), f(n)) : (g(n, u), f(u))), [u, n];
	      }
	      fillSetter() {
	        a.prototype.strokeSetter.apply(this, arguments);
	      }
	      strokeSetter() {
	        this.elem.attr(this.prop, s(this.start).tweenTo(s(this.end), this.pos), void 0, !0);
	      }
	    }
	    return a.timers = [], a;
	  }), i(e, "Core/Animation/AnimationUtilities.js", [e["Core/Animation/Fx.js"], e["Core/Utilities.js"]], function (t, e) {
	    let {
	      defined: i,
	      getStyle: s,
	      isArray: o,
	      isNumber: r,
	      isObject: n,
	      merge: a,
	      objectEach: h,
	      pick: l
	    } = e;
	    function d(t) {
	      return n(t) ? a({
	        duration: 500,
	        defer: 0
	      }, t) : {
	        duration: t ? 500 : 0,
	        defer: 0
	      };
	    }
	    function c(e, i) {
	      let s = t.timers.length;
	      for (; s--;) t.timers[s].elem !== e || i && i !== t.timers[s].prop || (t.timers[s].stopped = !0);
	    }
	    return {
	      animate: function (e, i, l) {
	        let d,
	          p = "",
	          u,
	          g,
	          f;
	        n(l) || (f = arguments, l = {
	          duration: f[2],
	          easing: f[3],
	          complete: f[4]
	        }), r(l.duration) || (l.duration = 400), l.easing = "function" == typeof l.easing ? l.easing : Math[l.easing] || Math.easeInOutSine, l.curAnim = a(i), h(i, function (r, n) {
	          c(e, n), g = new t(e, l, n), u = void 0, "d" === n && o(i.d) ? (g.paths = g.initPath(e, e.pathArray, i.d), g.toD = i.d, d = 0, u = 1) : e.attr ? d = e.attr(n) : (d = parseFloat(s(e, n)) || 0, "opacity" !== n && (p = "px")), u || (u = r), "string" == typeof u && u.match("px") && (u = u.replace(/px/g, "")), g.run(d, u, p);
	        });
	      },
	      animObject: d,
	      getDeferredAnimation: function (t, e, s) {
	        let o = d(e),
	          r = s ? [s] : t.series,
	          a = 0,
	          h = 0;
	        r.forEach(t => {
	          let s = d(t.options.animation);
	          a = n(e) && i(e.defer) ? o.defer : Math.max(a, s.duration + s.defer), h = Math.min(o.duration, s.duration);
	        }), t.renderer.forExport && (a = 0);
	        let l = {
	          defer: Math.max(0, a - h),
	          duration: Math.min(a, h)
	        };
	        return l;
	      },
	      setAnimation: function (t, e) {
	        e.renderer.globalAnimation = l(t, e.options.chart.animation, !0);
	      },
	      stop: c
	    };
	  }), i(e, "Core/Renderer/HTML/AST.js", [e["Core/Globals.js"], e["Core/Utilities.js"]], function (t, e) {
	    let {
	        SVG_NS: i,
	        win: s
	      } = t,
	      {
	        attr: o,
	        createElement: r,
	        css: n,
	        error: a,
	        isFunction: h,
	        isString: l,
	        objectEach: d,
	        splat: c
	      } = e,
	      {
	        trustedTypes: p
	      } = s,
	      u = p && h(p.createPolicy) && p.createPolicy("highcharts", {
	        createHTML: t => t
	      }),
	      g = u ? u.createHTML("") : "",
	      f = function () {
	        try {
	          return !!new DOMParser().parseFromString(g, "text/html");
	        } catch (t) {
	          return !1;
	        }
	      }();
	    class m {
	      static filterUserAttributes(t) {
	        return d(t, (e, i) => {
	          let s = !0;
	          -1 === m.allowedAttributes.indexOf(i) && (s = !1), -1 !== ["background", "dynsrc", "href", "lowsrc", "src"].indexOf(i) && (s = l(e) && m.allowedReferences.some(t => 0 === e.indexOf(t))), s || (a(33, !1, void 0, {
	            "Invalid attribute in config": `${i}`
	          }), delete t[i]), l(e) && t[i] && (t[i] = e.replace(/</g, "&lt;"));
	        }), t;
	      }
	      static parseStyle(t) {
	        return t.split(";").reduce((t, e) => {
	          let i = e.split(":").map(t => t.trim()),
	            s = i.shift();
	          return s && i.length && (t[s.replace(/-([a-z])/g, t => t[1].toUpperCase())] = i.join(":")), t;
	        }, {});
	      }
	      static setElementHTML(t, e) {
	        if (t.innerHTML = m.emptyHTML, e) {
	          let i = new m(e);
	          i.addToDOM(t);
	        }
	      }
	      constructor(t) {
	        this.nodes = "string" == typeof t ? this.parseMarkup(t) : t;
	      }
	      addToDOM(e) {
	        return function e(s, r) {
	          let h;
	          return c(s).forEach(function (s) {
	            let l;
	            let c = s.tagName,
	              p = s.textContent ? t.doc.createTextNode(s.textContent) : void 0,
	              u = m.bypassHTMLFiltering;
	            if (c) {
	              if ("#text" === c) l = p;else if (-1 !== m.allowedTags.indexOf(c) || u) {
	                let a = "svg" === c ? i : r.namespaceURI || i,
	                  h = t.doc.createElementNS(a, c),
	                  g = s.attributes || {};
	                d(s, function (t, e) {
	                  "tagName" !== e && "attributes" !== e && "children" !== e && "style" !== e && "textContent" !== e && (g[e] = t);
	                }), o(h, u ? g : m.filterUserAttributes(g)), s.style && n(h, s.style), p && h.appendChild(p), e(s.children || [], h), l = h;
	              } else a(33, !1, void 0, {
	                "Invalid tagName in config": c
	              });
	            }
	            l && r.appendChild(l), h = l;
	          }), h;
	        }(this.nodes, e);
	      }
	      parseMarkup(t) {
	        let e;
	        let i = [];
	        if (t = t.trim().replace(/ style=(["'])/g, " data-style=$1"), f) e = new DOMParser().parseFromString(u ? u.createHTML(t) : t, "text/html");else {
	          let i = r("div");
	          i.innerHTML = t, e = {
	            body: i
	          };
	        }
	        let s = (t, e) => {
	          let i = t.nodeName.toLowerCase(),
	            o = {
	              tagName: i
	            };
	          "#text" === i && (o.textContent = t.textContent || "");
	          let r = t.attributes;
	          if (r) {
	            let t = {};
	            [].forEach.call(r, e => {
	              "data-style" === e.name ? o.style = m.parseStyle(e.value) : t[e.name] = e.value;
	            }), o.attributes = t;
	          }
	          if (t.childNodes.length) {
	            let e = [];
	            [].forEach.call(t.childNodes, t => {
	              s(t, e);
	            }), e.length && (o.children = e);
	          }
	          e.push(o);
	        };
	        return [].forEach.call(e.body.childNodes, t => s(t, i)), i;
	      }
	    }
	    return m.allowedAttributes = ["alt", "aria-controls", "aria-describedby", "aria-expanded", "aria-haspopup", "aria-hidden", "aria-label", "aria-labelledby", "aria-live", "aria-pressed", "aria-readonly", "aria-roledescription", "aria-selected", "class", "clip-path", "color", "colspan", "cx", "cy", "d", "dx", "dy", "disabled", "fill", "filterUnits", "flood-color", "flood-opacity", "height", "href", "id", "in", "markerHeight", "markerWidth", "offset", "opacity", "orient", "padding", "paddingLeft", "paddingRight", "patternUnits", "r", "refX", "refY", "role", "scope", "slope", "src", "startOffset", "stdDeviation", "stroke", "stroke-linecap", "stroke-width", "style", "tableValues", "result", "rowspan", "summary", "target", "tabindex", "text-align", "text-anchor", "textAnchor", "textLength", "title", "type", "valign", "width", "x", "x1", "x2", "xlink:href", "y", "y1", "y2", "zIndex"], m.allowedReferences = ["https://", "http://", "mailto:", "/", "../", "./", "#"], m.allowedTags = ["a", "abbr", "b", "br", "button", "caption", "circle", "clipPath", "code", "dd", "defs", "div", "dl", "dt", "em", "feComponentTransfer", "feDropShadow", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feOffset", "feMerge", "feMergeNode", "filter", "h1", "h2", "h3", "h4", "h5", "h6", "hr", "i", "img", "li", "linearGradient", "marker", "ol", "p", "path", "pattern", "pre", "rect", "small", "span", "stop", "strong", "style", "sub", "sup", "svg", "table", "text", "textPath", "thead", "title", "tbody", "tspan", "td", "th", "tr", "u", "ul", "#text"], m.emptyHTML = g, m.bypassHTMLFiltering = !1, m;
	  }), i(e, "Core/Templating.js", [e["Core/Defaults.js"], e["Core/Utilities.js"]], function (t, e) {
	    let {
	        defaultOptions: i,
	        defaultTime: s
	      } = t,
	      {
	        extend: o,
	        getNestedProperty: r,
	        isArray: n,
	        isNumber: a,
	        isObject: h,
	        isString: l,
	        pick: d,
	        pInt: c
	      } = e,
	      p = {
	        add: (t, e) => t + e,
	        divide: (t, e) => 0 !== e ? t / e : "",
	        eq: (t, e) => t == e,
	        each: function (t) {
	          let e = arguments[arguments.length - 1];
	          return !!n(t) && t.map((i, s) => u(e.body, o(h(i) ? i : {
	            "@this": i
	          }, {
	            "@index": s,
	            "@first": 0 === s,
	            "@last": s === t.length - 1
	          }))).join("");
	        },
	        ge: (t, e) => t >= e,
	        gt: (t, e) => t > e,
	        if: t => !!t,
	        le: (t, e) => t <= e,
	        lt: (t, e) => t < e,
	        multiply: (t, e) => t * e,
	        ne: (t, e) => t != e,
	        subtract: (t, e) => t - e,
	        unless: t => !t
	      };
	    function u(t = "", e, o) {
	      let n = /\{([a-zA-Z0-9\:\.\,;\-\/<>%_@"'= #\(\)]+)\}/g,
	        a = /\(([a-zA-Z0-9\:\.\,;\-\/<>%_@"'= ]+)\)/g,
	        h = [],
	        l = /f$/,
	        c = /\.([0-9])/,
	        f = i.lang,
	        m = o && o.time || s,
	        x = o && o.numberFormatter || g,
	        y = (t = "") => {
	          let i;
	          return "true" === t || "false" !== t && ((i = Number(t)).toString() === t ? i : r(t, e));
	        },
	        b,
	        v,
	        S = 0,
	        k;
	      for (; null !== (b = n.exec(t));) {
	        let i = a.exec(b[1]);
	        i && (b = i, k = !0), v && v.isBlock || (v = {
	          ctx: e,
	          expression: b[1],
	          find: b[0],
	          isBlock: "#" === b[1].charAt(0),
	          start: b.index,
	          startInner: b.index + b[0].length,
	          length: b[0].length
	        });
	        let s = b[1].split(" ")[0].replace("#", "");
	        p[s] && (v.isBlock && s === v.fn && S++, v.fn || (v.fn = s));
	        let o = "else" === b[1];
	        if (v.isBlock && v.fn && (b[1] === `/${v.fn}` || o)) {
	          if (S) !o && S--;else {
	            let e = v.startInner,
	              i = t.substr(e, b.index - e);
	            void 0 === v.body ? (v.body = i, v.startInner = b.index + b[0].length) : v.elseBody = i, v.find += i + b[0], o || (h.push(v), v = void 0);
	          }
	        } else v.isBlock || h.push(v);
	        if (i && !v?.isBlock) break;
	      }
	      return h.forEach(i => {
	        let s, o;
	        let {
	          body: r,
	          elseBody: n,
	          expression: a,
	          fn: h
	        } = i;
	        if (h) {
	          let t = [i],
	            l = a.split(" ");
	          for (o = p[h].length; o--;) t.unshift(y(l[o + 1]));
	          s = p[h].apply(e, t), i.isBlock && "boolean" == typeof s && (s = u(s ? r : n, e));
	        } else {
	          let t = a.split(":");
	          if (s = y(t.shift() || ""), t.length && "number" == typeof s) {
	            let e = t.join(":");
	            if (l.test(e)) {
	              let t = parseInt((e.match(c) || ["", "-1"])[1], 10);
	              null !== s && (s = x(s, t, f.decimalPoint, e.indexOf(",") > -1 ? f.thousandsSep : ""));
	            } else s = m.dateFormat(e, s);
	          }
	        }
	        t = t.replace(i.find, d(s, ""));
	      }), k ? u(t, e, o) : t;
	    }
	    function g(t, e, s, o) {
	      let r, n;
	      t = +t || 0, e = +e;
	      let h = i.lang,
	        l = (t.toString().split(".")[1] || "").split("e")[0].length,
	        p = t.toString().split("e"),
	        u = e;
	      -1 === e ? e = Math.min(l, 20) : a(e) ? e && p[1] && p[1] < 0 && ((n = e + +p[1]) >= 0 ? (p[0] = (+p[0]).toExponential(n).split("e")[0], e = n) : (p[0] = p[0].split(".")[0] || 0, t = e < 20 ? (p[0] * Math.pow(10, p[1])).toFixed(e) : 0, p[1] = 0)) : e = 2;
	      let g = (Math.abs(p[1] ? p[0] : t) + Math.pow(10, -Math.max(e, l) - 1)).toFixed(e),
	        f = String(c(g)),
	        m = f.length > 3 ? f.length % 3 : 0;
	      return s = d(s, h.decimalPoint), o = d(o, h.thousandsSep), r = (t < 0 ? "-" : "") + (m ? f.substr(0, m) + o : ""), 0 > +p[1] && !u ? r = "0" : r += f.substr(m).replace(/(\d{3})(?=\d)/g, "$1" + o), e && (r += s + g.slice(-e)), p[1] && 0 != +r && (r += "e" + p[1]), r;
	    }
	    return {
	      dateFormat: function (t, e, i) {
	        return s.dateFormat(t, e, i);
	      },
	      format: u,
	      helpers: p,
	      numberFormat: g
	    };
	  }), i(e, "Core/Renderer/RendererUtilities.js", [e["Core/Utilities.js"]], function (t) {
	    var e;
	    let {
	      clamp: i,
	      pick: s,
	      pushUnique: o,
	      stableSort: r
	    } = t;
	    return (e || (e = {})).distribute = function t(e, n, a) {
	      let h = e,
	        l = h.reducedLen || n,
	        d = (t, e) => t.target - e.target,
	        c = [],
	        p = e.length,
	        u = [],
	        g = c.push,
	        f,
	        m,
	        x,
	        y = !0,
	        b,
	        v,
	        S = 0,
	        k;
	      for (f = p; f--;) S += e[f].size;
	      if (S > l) {
	        for (r(e, (t, e) => (e.rank || 0) - (t.rank || 0)), x = (k = e[0].rank === e[e.length - 1].rank) ? p / 2 : -1, m = k ? x : p - 1; x && S > l;) b = e[f = Math.floor(m)], o(u, f) && (S -= b.size), m += x, k && m >= e.length && (x /= 2, m = x);
	        u.sort((t, e) => e - t).forEach(t => g.apply(c, e.splice(t, 1)));
	      }
	      for (r(e, d), e = e.map(t => ({
	        size: t.size,
	        targets: [t.target],
	        align: s(t.align, .5)
	      })); y;) {
	        for (f = e.length; f--;) b = e[f], v = (Math.min.apply(0, b.targets) + Math.max.apply(0, b.targets)) / 2, b.pos = i(v - b.size * b.align, 0, n - b.size);
	        for (f = e.length, y = !1; f--;) f > 0 && e[f - 1].pos + e[f - 1].size > e[f].pos && (e[f - 1].size += e[f].size, e[f - 1].targets = e[f - 1].targets.concat(e[f].targets), e[f - 1].align = .5, e[f - 1].pos + e[f - 1].size > n && (e[f - 1].pos = n - e[f - 1].size), e.splice(f, 1), y = !0);
	      }
	      return g.apply(h, c), f = 0, e.some(e => {
	        let i = 0;
	        return (e.targets || []).some(() => (h[f].pos = e.pos + i, void 0 !== a && Math.abs(h[f].pos - h[f].target) > a) ? (h.slice(0, f + 1).forEach(t => delete t.pos), h.reducedLen = (h.reducedLen || n) - .1 * n, h.reducedLen > .1 * n && t(h, n, a), !0) : (i += h[f].size, f++, !1));
	      }), r(h, d), h;
	    }, e;
	  }), i(e, "Core/Renderer/SVG/SVGElement.js", [e["Core/Animation/AnimationUtilities.js"], e["Core/Color/Color.js"], e["Core/Globals.js"], e["Core/Utilities.js"]], function (t, e, i, s) {
	    let {
	        animate: o,
	        animObject: r,
	        stop: n
	      } = t,
	      {
	        deg2rad: a,
	        doc: h,
	        noop: l,
	        svg: d,
	        SVG_NS: c,
	        win: p
	      } = i,
	      {
	        addEvent: u,
	        attr: g,
	        createElement: f,
	        css: m,
	        defined: x,
	        erase: y,
	        extend: b,
	        fireEvent: v,
	        isArray: S,
	        isFunction: k,
	        isObject: M,
	        isString: C,
	        merge: w,
	        objectEach: T,
	        pick: A,
	        pInt: P,
	        syncTimeout: L,
	        uniqueKey: O
	      } = s;
	    class D {
	      _defaultGetter(t) {
	        let e = A(this[t + "Value"], this[t], this.element ? this.element.getAttribute(t) : null, 0);
	        return /^[\-0-9\.]+$/.test(e) && (e = parseFloat(e)), e;
	      }
	      _defaultSetter(t, e, i) {
	        i.setAttribute(e, t);
	      }
	      add(t) {
	        let e;
	        let i = this.renderer,
	          s = this.element;
	        return t && (this.parentGroup = t), void 0 !== this.textStr && "text" === this.element.nodeName && i.buildText(this), this.added = !0, (!t || t.handleZ || this.zIndex) && (e = this.zIndexSetter()), e || (t ? t.element : i.box).appendChild(s), this.onAdd && this.onAdd(), this;
	      }
	      addClass(t, e) {
	        let i = e ? "" : this.attr("class") || "";
	        return (t = (t || "").split(/ /g).reduce(function (t, e) {
	          return -1 === i.indexOf(e) && t.push(e), t;
	        }, i ? [i] : []).join(" ")) !== i && this.attr("class", t), this;
	      }
	      afterSetters() {
	        this.doTransform && (this.updateTransform(), this.doTransform = !1);
	      }
	      align(t, e, i) {
	        let s, o, r, n, a;
	        let h = {},
	          l = this.renderer,
	          d = l.alignedObjects;
	        t ? (this.alignOptions = t, this.alignByTranslate = e, (!i || C(i)) && (this.alignTo = r = i || "renderer", y(d, this), d.push(this), i = void 0)) : (t = this.alignOptions, e = this.alignByTranslate, r = this.alignTo), i = A(i, l[r], "scrollablePlotBox" === r ? l.plotBox : void 0, l);
	        let c = t.align,
	          p = t.verticalAlign;
	        return s = (i.x || 0) + (t.x || 0), o = (i.y || 0) + (t.y || 0), "right" === c ? n = 1 : "center" === c && (n = 2), n && (s += (i.width - (t.width || 0)) / n), h[e ? "translateX" : "x"] = Math.round(s), "bottom" === p ? a = 1 : "middle" === p && (a = 2), a && (o += (i.height - (t.height || 0)) / a), h[e ? "translateY" : "y"] = Math.round(o), this[this.placed ? "animate" : "attr"](h), this.placed = !0, this.alignAttr = h, this;
	      }
	      alignSetter(t) {
	        let e = {
	          left: "start",
	          center: "middle",
	          right: "end"
	        };
	        e[t] && (this.alignValue = t, this.element.setAttribute("text-anchor", e[t]));
	      }
	      animate(t, e, i) {
	        let s = r(A(e, this.renderer.globalAnimation, !0)),
	          n = s.defer;
	        return h.hidden && (s.duration = 0), 0 !== s.duration ? (i && (s.complete = i), L(() => {
	          this.element && o(this, t, s);
	        }, n)) : (this.attr(t, void 0, i || s.complete), T(t, function (t, e) {
	          s.step && s.step.call(this, t, {
	            prop: e,
	            pos: 1,
	            elem: this
	          });
	        }, this)), this;
	      }
	      applyTextOutline(t) {
	        let e = this.element,
	          s = -1 !== t.indexOf("contrast");
	        s && (t = t.replace(/contrast/g, this.renderer.getContrast(e.style.fill)));
	        let o = t.split(" "),
	          r = o[o.length - 1],
	          n = o[0];
	        if (n && "none" !== n && i.svg) {
	          this.fakeTS = !0, n = n.replace(/(^[\d\.]+)(.*?)$/g, function (t, e, i) {
	            return 2 * Number(e) + i;
	          }), this.removeTextOutline();
	          let t = h.createElementNS(c, "tspan");
	          g(t, {
	            class: "highcharts-text-outline",
	            fill: r,
	            stroke: r,
	            "stroke-width": n,
	            "stroke-linejoin": "round"
	          });
	          let i = e.querySelector("textPath") || e;
	          [].forEach.call(i.childNodes, e => {
	            let i = e.cloneNode(!0);
	            i.removeAttribute && ["fill", "stroke", "stroke-width", "stroke"].forEach(t => i.removeAttribute(t)), t.appendChild(i);
	          });
	          let s = 0;
	          [].forEach.call(i.querySelectorAll("text tspan"), t => {
	            s += Number(t.getAttribute("dy"));
	          });
	          let o = h.createElementNS(c, "tspan");
	          o.textContent = "â", g(o, {
	            x: Number(e.getAttribute("x")),
	            dy: -s
	          }), t.appendChild(o), i.insertBefore(t, i.firstChild);
	        }
	      }
	      attr(t, e, i, s) {
	        let o = this.element,
	          r = D.symbolCustomAttribs,
	          a,
	          h,
	          l = this,
	          d;
	        return "string" == typeof t && void 0 !== e && (a = t, (t = {})[a] = e), "string" == typeof t ? l = (this[t + "Getter"] || this._defaultGetter).call(this, t, o) : (T(t, function (e, i) {
	          d = !1, s || n(this, i), this.symbolName && -1 !== r.indexOf(i) && (h || (this.symbolAttr(t), h = !0), d = !0), this.rotation && ("x" === i || "y" === i) && (this.doTransform = !0), d || (this[i + "Setter"] || this._defaultSetter).call(this, e, i, o);
	        }, this), this.afterSetters()), i && i.call(this), l;
	      }
	      clip(t) {
	        if (t && !t.clipPath) {
	          let e = O() + "-",
	            i = this.renderer.createElement("clipPath").attr({
	              id: e
	            }).add(this.renderer.defs);
	          b(t, {
	            clipPath: i,
	            id: e,
	            count: 0
	          }), t.add(i);
	        }
	        return this.attr("clip-path", t ? `url(${this.renderer.url}#${t.id})` : "none");
	      }
	      crisp(t, e) {
	        e = e || t.strokeWidth || 0;
	        let i = Math.round(e) % 2 / 2;
	        return t.x = Math.floor(t.x || this.x || 0) + i, t.y = Math.floor(t.y || this.y || 0) + i, t.width = Math.floor((t.width || this.width || 0) - 2 * i), t.height = Math.floor((t.height || this.height || 0) - 2 * i), x(t.strokeWidth) && (t.strokeWidth = e), t;
	      }
	      complexColor(t, i, s) {
	        let o = this.renderer,
	          r,
	          n,
	          a,
	          h,
	          l,
	          d,
	          c,
	          p,
	          u,
	          g,
	          f = [],
	          m;
	        v(this.renderer, "complexColor", {
	          args: arguments
	        }, function () {
	          if (t.radialGradient ? n = "radialGradient" : t.linearGradient && (n = "linearGradient"), n) {
	            if (a = t[n], l = o.gradients, d = t.stops, u = s.radialReference, S(a) && (t[n] = a = {
	              x1: a[0],
	              y1: a[1],
	              x2: a[2],
	              y2: a[3],
	              gradientUnits: "userSpaceOnUse"
	            }), "radialGradient" === n && u && !x(a.gradientUnits) && (h = a, a = w(a, o.getRadialAttr(u, h), {
	              gradientUnits: "userSpaceOnUse"
	            })), T(a, function (t, e) {
	              "id" !== e && f.push(e, t);
	            }), T(d, function (t) {
	              f.push(t);
	            }), l[f = f.join(",")]) g = l[f].attr("id");else {
	              a.id = g = O();
	              let t = l[f] = o.createElement(n).attr(a).add(o.defs);
	              t.radAttr = h, t.stops = [], d.forEach(function (i) {
	                0 === i[1].indexOf("rgba") ? (c = (r = e.parse(i[1])).get("rgb"), p = r.get("a")) : (c = i[1], p = 1);
	                let s = o.createElement("stop").attr({
	                  offset: i[0],
	                  "stop-color": c,
	                  "stop-opacity": p
	                }).add(t);
	                t.stops.push(s);
	              });
	            }
	            m = "url(" + o.url + "#" + g + ")", s.setAttribute(i, m), s.gradient = f, t.toString = function () {
	              return m;
	            };
	          }
	        });
	      }
	      css(t) {
	        let e = this.styles,
	          i = {},
	          s = this.element,
	          o,
	          r = !e;
	        if (e && T(t, function (t, s) {
	          e && e[s] !== t && (i[s] = t, r = !0);
	        }), r) {
	          e && (t = b(e, i)), null === t.width || "auto" === t.width ? delete this.textWidth : "text" === s.nodeName.toLowerCase() && t.width && (o = this.textWidth = P(t.width)), this.styles = t, o && !d && this.renderer.forExport && delete t.width;
	          let r = w(t);
	          s.namespaceURI === this.SVG_NS && (["textOutline", "textOverflow", "width"].forEach(t => r && delete r[t]), r.color && (r.fill = r.color)), m(s, r);
	        }
	        return this.added && ("text" === this.element.nodeName && this.renderer.buildText(this), t.textOutline && this.applyTextOutline(t.textOutline)), this;
	      }
	      dashstyleSetter(t) {
	        let e,
	          i = this["stroke-width"];
	        if ("inherit" === i && (i = 1), t = t && t.toLowerCase()) {
	          let s = t.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(",");
	          for (e = s.length; e--;) s[e] = "" + P(s[e]) * A(i, NaN);
	          t = s.join(",").replace(/NaN/g, "none"), this.element.setAttribute("stroke-dasharray", t);
	        }
	      }
	      destroy() {
	        let t = this,
	          e = t.element || {},
	          i = t.renderer,
	          s = e.ownerSVGElement,
	          o = "SPAN" === e.nodeName && t.parentGroup || void 0,
	          r,
	          a;
	        if (e.onclick = e.onmouseout = e.onmouseover = e.onmousemove = e.point = null, n(t), t.clipPath && s) {
	          let e = t.clipPath;
	          [].forEach.call(s.querySelectorAll("[clip-path],[CLIP-PATH]"), function (t) {
	            t.getAttribute("clip-path").indexOf(e.element.id) > -1 && t.removeAttribute("clip-path");
	          }), t.clipPath = e.destroy();
	        }
	        if (t.connector = t.connector?.destroy(), t.stops) {
	          for (a = 0; a < t.stops.length; a++) t.stops[a].destroy();
	          t.stops.length = 0, t.stops = void 0;
	        }
	        for (t.safeRemoveChild(e); o && o.div && 0 === o.div.childNodes.length;) r = o.parentGroup, t.safeRemoveChild(o.div), delete o.div, o = r;
	        t.alignTo && y(i.alignedObjects, t), T(t, function (e, i) {
	          t[i] && t[i].parentGroup === t && t[i].destroy && t[i].destroy(), delete t[i];
	        });
	      }
	      dSetter(t, e, i) {
	        S(t) && ("string" == typeof t[0] && (t = this.renderer.pathToSegments(t)), this.pathArray = t, t = t.reduce((t, e, i) => e && e.join ? (i ? t + " " : "") + e.join(" ") : (e || "").toString(), "")), /(NaN| {2}|^$)/.test(t) && (t = "M 0 0"), this[e] !== t && (i.setAttribute(e, t), this[e] = t);
	      }
	      fillSetter(t, e, i) {
	        "string" == typeof t ? i.setAttribute(e, t) : t && this.complexColor(t, e, i);
	      }
	      hrefSetter(t, e, i) {
	        i.setAttributeNS("http://www.w3.org/1999/xlink", e, t);
	      }
	      getBBox(t, e) {
	        let i, s, o, r, n;
	        let {
	            alignValue: h,
	            element: l,
	            renderer: d,
	            styles: c,
	            textStr: p
	          } = this,
	          {
	            cache: u,
	            cacheKeys: g
	          } = d,
	          f = l.namespaceURI === this.SVG_NS,
	          y = A(e, this.rotation, 0),
	          v = d.styledMode ? l && D.prototype.getStyle.call(l, "font-size") : c && c.fontSize;
	        if (x(p) && (-1 === (n = p.toString()).indexOf("<") && (n = n.replace(/[0-9]/g, "0")), n += ["", d.rootFontSize, v, y, this.textWidth, h, c && c.textOverflow, c && c.fontWeight].join(",")), n && !t && (i = u[n]), !i) {
	          if (f || d.forExport) {
	            try {
	              r = this.fakeTS && function (t) {
	                let e = l.querySelector(".highcharts-text-outline");
	                e && m(e, {
	                  display: t
	                });
	              }, k(r) && r("none"), i = l.getBBox ? b({}, l.getBBox()) : {
	                width: l.offsetWidth,
	                height: l.offsetHeight,
	                x: 0,
	                y: 0
	              }, k(r) && r("");
	            } catch (t) {}
	            (!i || i.width < 0) && (i = {
	              x: 0,
	              y: 0,
	              width: 0,
	              height: 0
	            });
	          } else i = this.htmlGetBBox();
	          if (s = i.width, o = i.height, f && (i.height = o = {
	            "11px,17": 14,
	            "13px,20": 16
	          }[`${v || ""},${Math.round(o)}`] || o), y) {
	            let t = Number(l.getAttribute("y") || 0) - i.y,
	              e = {
	                right: 1,
	                center: .5
	              }[h || 0] || 0,
	              r = y * a,
	              n = (y - 90) * a,
	              d = s * Math.cos(r),
	              c = s * Math.sin(r),
	              p = Math.cos(n),
	              u = Math.sin(n),
	              g = i.x + e * (s - d),
	              f = i.y + t - e * c,
	              m = g + t * p,
	              x = m + d,
	              b = x - o * p,
	              v = b - d,
	              S = f + t * u,
	              k = S + c,
	              M = k - o * u,
	              C = M - c;
	            i.x = Math.min(m, x, b, v), i.y = Math.min(S, k, M, C), i.width = Math.max(m, x, b, v) - i.x, i.height = Math.max(S, k, M, C) - i.y;
	          }
	        }
	        if (n && ("" === p || i.height > 0)) {
	          for (; g.length > 250;) delete u[g.shift()];
	          u[n] || g.push(n), u[n] = i;
	        }
	        return i;
	      }
	      getStyle(t) {
	        return p.getComputedStyle(this.element || this, "").getPropertyValue(t);
	      }
	      hasClass(t) {
	        return -1 !== ("" + this.attr("class")).split(" ").indexOf(t);
	      }
	      hide() {
	        return this.attr({
	          visibility: "hidden"
	        });
	      }
	      htmlGetBBox() {
	        return {
	          height: 0,
	          width: 0,
	          x: 0,
	          y: 0
	        };
	      }
	      constructor(t, e) {
	        this.onEvents = {}, this.opacity = 1, this.SVG_NS = c, this.element = "span" === e ? f(e) : h.createElementNS(this.SVG_NS, e), this.renderer = t, v(this, "afterInit");
	      }
	      on(t, e) {
	        let {
	          onEvents: i
	        } = this;
	        return i[t] && i[t](), i[t] = u(this.element, t, e), this;
	      }
	      opacitySetter(t, e, i) {
	        let s = Number(Number(t).toFixed(3));
	        this.opacity = s, i.setAttribute(e, s);
	      }
	      removeClass(t) {
	        return this.attr("class", ("" + this.attr("class")).replace(C(t) ? RegExp(`(^| )${t}( |$)`) : t, " ").replace(/ +/g, " ").trim());
	      }
	      removeTextOutline() {
	        let t = this.element.querySelector("tspan.highcharts-text-outline");
	        t && this.safeRemoveChild(t);
	      }
	      safeRemoveChild(t) {
	        let e = t.parentNode;
	        e && e.removeChild(t);
	      }
	      setRadialReference(t) {
	        let e = this.element.gradient && this.renderer.gradients[this.element.gradient];
	        return this.element.radialReference = t, e && e.radAttr && e.animate(this.renderer.getRadialAttr(t, e.radAttr)), this;
	      }
	      setTextPath(t, e) {
	        e = w(!0, {
	          enabled: !0,
	          attributes: {
	            dy: -5,
	            startOffset: "50%",
	            textAnchor: "middle"
	          }
	        }, e);
	        let i = this.renderer.url,
	          s = this.text || this,
	          o = s.textPath,
	          {
	            attributes: r,
	            enabled: n
	          } = e;
	        if (t = t || o && o.path, o && o.undo(), t && n) {
	          let e = u(s, "afterModifyTree", e => {
	            if (t && n) {
	              let o = t.attr("id");
	              o || t.attr("id", o = O());
	              let n = {
	                x: 0,
	                y: 0
	              };
	              x(r.dx) && (n.dx = r.dx, delete r.dx), x(r.dy) && (n.dy = r.dy, delete r.dy), s.attr(n), this.attr({
	                transform: ""
	              }), this.box && (this.box = this.box.destroy());
	              let a = e.nodes.slice(0);
	              e.nodes.length = 0, e.nodes[0] = {
	                tagName: "textPath",
	                attributes: b(r, {
	                  "text-anchor": r.textAnchor,
	                  href: `${i}#${o}`
	                }),
	                children: a
	              };
	            }
	          });
	          s.textPath = {
	            path: t,
	            undo: e
	          };
	        } else s.attr({
	          dx: 0,
	          dy: 0
	        }), delete s.textPath;
	        return this.added && (s.textCache = "", this.renderer.buildText(s)), this;
	      }
	      shadow(t) {
	        let {
	            renderer: e
	          } = this,
	          i = w(this.parentGroup?.rotation === 90 ? {
	            offsetX: -1,
	            offsetY: -1
	          } : {}, M(t) ? t : {}),
	          s = e.shadowDefinition(i);
	        return this.attr({
	          filter: t ? `url(${e.url}#${s})` : "none"
	        });
	      }
	      show(t = !0) {
	        return this.attr({
	          visibility: t ? "inherit" : "visible"
	        });
	      }
	      "stroke-widthSetter"(t, e, i) {
	        this[e] = t, i.setAttribute(e, t);
	      }
	      strokeWidth() {
	        if (!this.renderer.styledMode) return this["stroke-width"] || 0;
	        let t = this.getStyle("stroke-width"),
	          e = 0,
	          i;
	        return t.indexOf("px") === t.length - 2 ? e = P(t) : "" !== t && (g(i = h.createElementNS(c, "rect"), {
	          width: t,
	          "stroke-width": 0
	        }), this.element.parentNode.appendChild(i), e = i.getBBox().width, i.parentNode.removeChild(i)), e;
	      }
	      symbolAttr(t) {
	        let e = this;
	        D.symbolCustomAttribs.forEach(function (i) {
	          e[i] = A(t[i], e[i]);
	        }), e.attr({
	          d: e.renderer.symbols[e.symbolName](e.x, e.y, e.width, e.height, e)
	        });
	      }
	      textSetter(t) {
	        t !== this.textStr && (delete this.textPxLength, this.textStr = t, this.added && this.renderer.buildText(this));
	      }
	      titleSetter(t) {
	        let e = this.element,
	          i = e.getElementsByTagName("title")[0] || h.createElementNS(this.SVG_NS, "title");
	        e.insertBefore ? e.insertBefore(i, e.firstChild) : e.appendChild(i), i.textContent = String(A(t, "")).replace(/<[^>]*>/g, "").replace(/&lt;/g, "<").replace(/&gt;/g, ">");
	      }
	      toFront() {
	        let t = this.element;
	        return t.parentNode.appendChild(t), this;
	      }
	      translate(t, e) {
	        return this.attr({
	          translateX: t,
	          translateY: e
	        });
	      }
	      updateTransform(t = "transform") {
	        let {
	            element: e,
	            matrix: i,
	            rotation: s = 0,
	            scaleX: o,
	            scaleY: r,
	            translateX: n = 0,
	            translateY: a = 0
	          } = this,
	          h = ["translate(" + n + "," + a + ")"];
	        x(i) && h.push("matrix(" + i.join(",") + ")"), s && h.push("rotate(" + s + " " + A(this.rotationOriginX, e.getAttribute("x"), 0) + " " + A(this.rotationOriginY, e.getAttribute("y") || 0) + ")"), (x(o) || x(r)) && h.push("scale(" + A(o, 1) + " " + A(r, 1) + ")"), h.length && !(this.text || this).textPath && e.setAttribute(t, h.join(" "));
	      }
	      visibilitySetter(t, e, i) {
	        "inherit" === t ? i.removeAttribute(e) : this[e] !== t && i.setAttribute(e, t), this[e] = t;
	      }
	      xGetter(t) {
	        return "circle" === this.element.nodeName && ("x" === t ? t = "cx" : "y" === t && (t = "cy")), this._defaultGetter(t);
	      }
	      zIndexSetter(t, e) {
	        let i = this.renderer,
	          s = this.parentGroup,
	          o = s || i,
	          r = o.element || i.box,
	          n = this.element,
	          a = r === i.box,
	          h,
	          l,
	          d,
	          c = !1,
	          p,
	          u = this.added,
	          g;
	        if (x(t) ? (n.setAttribute("data-z-index", t), t = +t, this[e] === t && (u = !1)) : x(this[e]) && n.removeAttribute("data-z-index"), this[e] = t, u) {
	          for ((t = this.zIndex) && s && (s.handleZ = !0), g = (h = r.childNodes).length - 1; g >= 0 && !c; g--) p = !x(d = (l = h[g]).getAttribute("data-z-index")), l !== n && (t < 0 && p && !a && !g ? (r.insertBefore(n, h[g]), c = !0) : (P(d) <= t || p && (!x(t) || t >= 0)) && (r.insertBefore(n, h[g + 1]), c = !0));
	          c || (r.insertBefore(n, h[a ? 3 : 0]), c = !0);
	        }
	        return c;
	      }
	    }
	    return D.symbolCustomAttribs = ["anchorX", "anchorY", "clockwise", "end", "height", "innerR", "r", "start", "width", "x", "y"], D.prototype.strokeSetter = D.prototype.fillSetter, D.prototype.yGetter = D.prototype.xGetter, D.prototype.matrixSetter = D.prototype.rotationOriginXSetter = D.prototype.rotationOriginYSetter = D.prototype.rotationSetter = D.prototype.scaleXSetter = D.prototype.scaleYSetter = D.prototype.translateXSetter = D.prototype.translateYSetter = D.prototype.verticalAlignSetter = function (t, e) {
	      this[e] = t, this.doTransform = !0;
	    }, D;
	  }), i(e, "Core/Renderer/RendererRegistry.js", [e["Core/Globals.js"]], function (t) {
	    var e, i;
	    let s;
	    return (i = e || (e = {})).rendererTypes = {}, i.getRendererType = function (t = s) {
	      return i.rendererTypes[t] || i.rendererTypes[s];
	    }, i.registerRendererType = function (e, o, r) {
	      i.rendererTypes[e] = o, (!s || r) && (s = e, t.Renderer = o);
	    }, e;
	  }), i(e, "Core/Renderer/SVG/SVGLabel.js", [e["Core/Renderer/SVG/SVGElement.js"], e["Core/Utilities.js"]], function (t, e) {
	    let {
	      defined: i,
	      extend: s,
	      isNumber: o,
	      merge: r,
	      pick: n,
	      removeEvent: a
	    } = e;
	    class h extends t {
	      constructor(t, e, i, s, o, r, n, a, l, d) {
	        let c;
	        super(t, "g"), this.paddingLeftSetter = this.paddingSetter, this.paddingRightSetter = this.paddingSetter, this.textStr = e, this.x = i, this.y = s, this.anchorX = r, this.anchorY = n, this.baseline = l, this.className = d, this.addClass("button" === d ? "highcharts-no-tooltip" : "highcharts-label"), d && this.addClass("highcharts-" + d), this.text = t.text(void 0, 0, 0, a).attr({
	          zIndex: 1
	        }), "string" == typeof o && ((c = /^url\((.*?)\)$/.test(o)) || this.renderer.symbols[o]) && (this.symbolKey = o), this.bBox = h.emptyBBox, this.padding = 3, this.baselineOffset = 0, this.needsBox = t.styledMode || c, this.deferredAttr = {}, this.alignFactor = 0;
	      }
	      alignSetter(t) {
	        let e = {
	          left: 0,
	          center: .5,
	          right: 1
	        }[t];
	        e !== this.alignFactor && (this.alignFactor = e, this.bBox && o(this.xSetting) && this.attr({
	          x: this.xSetting
	        }));
	      }
	      anchorXSetter(t, e) {
	        this.anchorX = t, this.boxAttr(e, Math.round(t) - this.getCrispAdjust() - this.xSetting);
	      }
	      anchorYSetter(t, e) {
	        this.anchorY = t, this.boxAttr(e, t - this.ySetting);
	      }
	      boxAttr(t, e) {
	        this.box ? this.box.attr(t, e) : this.deferredAttr[t] = e;
	      }
	      css(e) {
	        if (e) {
	          let t = {};
	          e = r(e), h.textProps.forEach(i => {
	            void 0 !== e[i] && (t[i] = e[i], delete e[i]);
	          }), this.text.css(t), "fontSize" in t || "fontWeight" in t ? this.updateTextPadding() : ("width" in t || "textOverflow" in t) && this.updateBoxSize();
	        }
	        return t.prototype.css.call(this, e);
	      }
	      destroy() {
	        a(this.element, "mouseenter"), a(this.element, "mouseleave"), this.text && this.text.destroy(), this.box && (this.box = this.box.destroy()), t.prototype.destroy.call(this);
	      }
	      fillSetter(t, e) {
	        t && (this.needsBox = !0), this.fill = t, this.boxAttr(e, t);
	      }
	      getBBox() {
	        this.textStr && 0 === this.bBox.width && 0 === this.bBox.height && this.updateBoxSize();
	        let t = this.padding,
	          e = n(this.paddingLeft, t);
	        return {
	          width: this.width || 0,
	          height: this.height || 0,
	          x: this.bBox.x - e,
	          y: this.bBox.y - t
	        };
	      }
	      getCrispAdjust() {
	        return this.renderer.styledMode && this.box ? this.box.strokeWidth() % 2 / 2 : (this["stroke-width"] ? parseInt(this["stroke-width"], 10) : 0) % 2 / 2;
	      }
	      heightSetter(t) {
	        this.heightSetting = t;
	      }
	      onAdd() {
	        this.text.add(this), this.attr({
	          text: n(this.textStr, ""),
	          x: this.x || 0,
	          y: this.y || 0
	        }), this.box && i(this.anchorX) && this.attr({
	          anchorX: this.anchorX,
	          anchorY: this.anchorY
	        });
	      }
	      paddingSetter(t, e) {
	        o(t) ? t !== this[e] && (this[e] = t, this.updateTextPadding()) : this[e] = void 0;
	      }
	      rSetter(t, e) {
	        this.boxAttr(e, t);
	      }
	      strokeSetter(t, e) {
	        this.stroke = t, this.boxAttr(e, t);
	      }
	      "stroke-widthSetter"(t, e) {
	        t && (this.needsBox = !0), this["stroke-width"] = t, this.boxAttr(e, t);
	      }
	      "text-alignSetter"(t) {
	        this.textAlign = t;
	      }
	      textSetter(t) {
	        void 0 !== t && this.text.attr({
	          text: t
	        }), this.updateTextPadding();
	      }
	      updateBoxSize() {
	        let t;
	        let e = this.text,
	          r = {},
	          n = this.padding,
	          a = this.bBox = (!o(this.widthSetting) || !o(this.heightSetting) || this.textAlign) && i(e.textStr) ? e.getBBox() : h.emptyBBox;
	        this.width = this.getPaddedWidth(), this.height = (this.heightSetting || a.height || 0) + 2 * n;
	        let l = this.renderer.fontMetrics(e);
	        if (this.baselineOffset = n + Math.min((this.text.firstLineMetrics || l).b, a.height || 1 / 0), this.heightSetting && (this.baselineOffset += (this.heightSetting - l.h) / 2), this.needsBox && !e.textPath) {
	          if (!this.box) {
	            let t = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect();
	            t.addClass(("button" === this.className ? "" : "highcharts-label-box") + (this.className ? " highcharts-" + this.className + "-box" : "")), t.add(this);
	          }
	          t = this.getCrispAdjust(), r.x = t, r.y = (this.baseline ? -this.baselineOffset : 0) + t, r.width = Math.round(this.width), r.height = Math.round(this.height), this.box.attr(s(r, this.deferredAttr)), this.deferredAttr = {};
	        }
	      }
	      updateTextPadding() {
	        let t = this.text;
	        if (!t.textPath) {
	          this.updateBoxSize();
	          let e = this.baseline ? 0 : this.baselineOffset,
	            s = n(this.paddingLeft, this.padding);
	          i(this.widthSetting) && this.bBox && ("center" === this.textAlign || "right" === this.textAlign) && (s += {
	            center: .5,
	            right: 1
	          }[this.textAlign] * (this.widthSetting - this.bBox.width)), (s !== t.x || e !== t.y) && (t.attr("x", s), t.hasBoxWidthChanged && (this.bBox = t.getBBox(!0)), void 0 !== e && t.attr("y", e)), t.x = s, t.y = e;
	        }
	      }
	      widthSetter(t) {
	        this.widthSetting = o(t) ? t : void 0;
	      }
	      getPaddedWidth() {
	        let t = this.padding,
	          e = n(this.paddingLeft, t),
	          i = n(this.paddingRight, t);
	        return (this.widthSetting || this.bBox.width || 0) + e + i;
	      }
	      xSetter(t) {
	        this.x = t, this.alignFactor && (t -= this.alignFactor * this.getPaddedWidth(), this["forceAnimate:x"] = !0), this.xSetting = Math.round(t), this.attr("translateX", this.xSetting);
	      }
	      ySetter(t) {
	        this.ySetting = this.y = Math.round(t), this.attr("translateY", this.ySetting);
	      }
	    }
	    return h.emptyBBox = {
	      width: 0,
	      height: 0,
	      x: 0,
	      y: 0
	    }, h.textProps = ["color", "direction", "fontFamily", "fontSize", "fontStyle", "fontWeight", "lineHeight", "textAlign", "textDecoration", "textOutline", "textOverflow", "whiteSpace", "width"], h;
	  }), i(e, "Core/Renderer/SVG/Symbols.js", [e["Core/Utilities.js"]], function (t) {
	    let {
	      defined: e,
	      isNumber: i,
	      pick: s
	    } = t;
	    function o(t, i, o, r, n) {
	      let a = [];
	      if (n) {
	        let h = n.start || 0,
	          l = s(n.r, o),
	          d = s(n.r, r || o),
	          c = .001 > Math.abs((n.end || 0) - h - 2 * Math.PI),
	          p = (n.end || 0) - .001,
	          u = n.innerR,
	          g = s(n.open, c),
	          f = Math.cos(h),
	          m = Math.sin(h),
	          x = Math.cos(p),
	          y = Math.sin(p),
	          b = s(n.longArc, p - h - Math.PI < .001 ? 0 : 1),
	          v = ["A", l, d, 0, b, s(n.clockwise, 1), t + l * x, i + d * y];
	        v.params = {
	          start: h,
	          end: p,
	          cx: t,
	          cy: i
	        }, a.push(["M", t + l * f, i + d * m], v), e(u) && ((v = ["A", u, u, 0, b, e(n.clockwise) ? 1 - n.clockwise : 0, t + u * f, i + u * m]).params = {
	          start: p,
	          end: h,
	          cx: t,
	          cy: i
	        }, a.push(g ? ["M", t + u * x, i + u * y] : ["L", t + u * x, i + u * y], v)), g || a.push(["Z"]);
	      }
	      return a;
	    }
	    function r(t, e, i, s, o) {
	      return o && o.r ? n(t, e, i, s, o) : [["M", t, e], ["L", t + i, e], ["L", t + i, e + s], ["L", t, e + s], ["Z"]];
	    }
	    function n(t, e, i, s, o) {
	      let r = o?.r || 0;
	      return [["M", t + r, e], ["L", t + i - r, e], ["A", r, r, 0, 0, 1, t + i, e + r], ["L", t + i, e + s - r], ["A", r, r, 0, 0, 1, t + i - r, e + s], ["L", t + r, e + s], ["A", r, r, 0, 0, 1, t, e + s - r], ["L", t, e + r], ["A", r, r, 0, 0, 1, t + r, e], ["Z"]];
	    }
	    return {
	      arc: o,
	      callout: function (t, e, s, o, r) {
	        let a = Math.min(r && r.r || 0, s, o),
	          h = a + 6,
	          l = r && r.anchorX,
	          d = r && r.anchorY || 0,
	          c = n(t, e, s, o, {
	            r: a
	          });
	        if (!i(l) || l < s && l > 0 && d < o && d > 0) return c;
	        if (t + l > s - h) {
	          if (d > e + h && d < e + o - h) c.splice(3, 1, ["L", t + s, d - 6], ["L", t + s + 6, d], ["L", t + s, d + 6], ["L", t + s, e + o - a]);else if (l < s) {
	            let i = d < e + h,
	              r = i ? e : e + o;
	            c.splice(i ? 2 : 5, 0, ["L", l, d], ["L", t + s - a, r]);
	          } else c.splice(3, 1, ["L", t + s, o / 2], ["L", l, d], ["L", t + s, o / 2], ["L", t + s, e + o - a]);
	        } else if (t + l < h) {
	          if (d > e + h && d < e + o - h) c.splice(7, 1, ["L", t, d + 6], ["L", t - 6, d], ["L", t, d - 6], ["L", t, e + a]);else if (l > 0) {
	            let i = d < e + h,
	              s = i ? e : e + o;
	            c.splice(i ? 1 : 6, 0, ["L", l, d], ["L", t + a, s]);
	          } else c.splice(7, 1, ["L", t, o / 2], ["L", l, d], ["L", t, o / 2], ["L", t, e + a]);
	        } else d > o && l < s - h ? c.splice(5, 1, ["L", l + 6, e + o], ["L", l, e + o + 6], ["L", l - 6, e + o], ["L", t + a, e + o]) : d < 0 && l > h && c.splice(1, 1, ["L", l - 6, e], ["L", l, e - 6], ["L", l + 6, e], ["L", s - a, e]);
	        return c;
	      },
	      circle: function (t, e, i, s) {
	        return o(t + i / 2, e + s / 2, i / 2, s / 2, {
	          start: .5 * Math.PI,
	          end: 2.5 * Math.PI,
	          open: !1
	        });
	      },
	      diamond: function (t, e, i, s) {
	        return [["M", t + i / 2, e], ["L", t + i, e + s / 2], ["L", t + i / 2, e + s], ["L", t, e + s / 2], ["Z"]];
	      },
	      rect: r,
	      roundedRect: n,
	      square: r,
	      triangle: function (t, e, i, s) {
	        return [["M", t + i / 2, e], ["L", t + i, e + s], ["L", t, e + s], ["Z"]];
	      },
	      "triangle-down": function (t, e, i, s) {
	        return [["M", t, e], ["L", t + i, e], ["L", t + i / 2, e + s], ["Z"]];
	      }
	    };
	  }), i(e, "Core/Renderer/SVG/TextBuilder.js", [e["Core/Renderer/HTML/AST.js"], e["Core/Globals.js"], e["Core/Utilities.js"]], function (t, e, i) {
	    let {
	        doc: s,
	        SVG_NS: o,
	        win: r
	      } = e,
	      {
	        attr: n,
	        extend: a,
	        fireEvent: h,
	        isString: l,
	        objectEach: d,
	        pick: c
	      } = i;
	    return class {
	      constructor(t) {
	        let e = t.styles;
	        this.renderer = t.renderer, this.svgElement = t, this.width = t.textWidth, this.textLineHeight = e && e.lineHeight, this.textOutline = e && e.textOutline, this.ellipsis = !!(e && "ellipsis" === e.textOverflow), this.noWrap = !!(e && "nowrap" === e.whiteSpace);
	      }
	      buildSVG() {
	        let e = this.svgElement,
	          i = e.element,
	          o = e.renderer,
	          r = c(e.textStr, "").toString(),
	          n = -1 !== r.indexOf("<"),
	          a = i.childNodes,
	          h = !e.added && o.box,
	          d = [r, this.ellipsis, this.noWrap, this.textLineHeight, this.textOutline, e.getStyle("font-size"), this.width].join(",");
	        if (d !== e.textCache) {
	          e.textCache = d, delete e.actualWidth;
	          for (let t = a.length; t--;) i.removeChild(a[t]);
	          if (n || this.ellipsis || this.width || e.textPath || -1 !== r.indexOf(" ") && (!this.noWrap || /<br.*?>/g.test(r))) {
	            if ("" !== r) {
	              h && h.appendChild(i);
	              let s = new t(r);
	              this.modifyTree(s.nodes), s.addToDOM(i), this.modifyDOM(), this.ellipsis && -1 !== (i.textContent || "").indexOf("â¦") && e.attr("title", this.unescapeEntities(e.textStr || "", ["&lt;", "&gt;"])), h && h.removeChild(i);
	            }
	          } else i.appendChild(s.createTextNode(this.unescapeEntities(r)));
	          l(this.textOutline) && e.applyTextOutline && e.applyTextOutline(this.textOutline);
	        }
	      }
	      modifyDOM() {
	        let t;
	        let e = this.svgElement,
	          i = n(e.element, "x");
	        for (e.firstLineMetrics = void 0; t = e.element.firstChild;) if (/^[\s\u200B]*$/.test(t.textContent || " ")) e.element.removeChild(t);else break;
	        [].forEach.call(e.element.querySelectorAll("tspan.highcharts-br"), (t, s) => {
	          t.nextSibling && t.previousSibling && (0 === s && 1 === t.previousSibling.nodeType && (e.firstLineMetrics = e.renderer.fontMetrics(t.previousSibling)), n(t, {
	            dy: this.getLineHeight(t.nextSibling),
	            x: i
	          }));
	        });
	        let a = this.width || 0;
	        if (!a) return;
	        let h = (t, r) => {
	            let h = t.textContent || "",
	              l = h.replace(/([^\^])-/g, "$1- ").split(" "),
	              d = !this.noWrap && (l.length > 1 || e.element.childNodes.length > 1),
	              c = this.getLineHeight(r),
	              p = 0,
	              u = e.actualWidth;
	            if (this.ellipsis) h && this.truncate(t, h, void 0, 0, Math.max(0, a - .8 * c), (t, e) => t.substring(0, e) + "â¦");else if (d) {
	              let h = [],
	                d = [];
	              for (; r.firstChild && r.firstChild !== t;) d.push(r.firstChild), r.removeChild(r.firstChild);
	              for (; l.length;) l.length && !this.noWrap && p > 0 && (h.push(t.textContent || ""), t.textContent = l.join(" ").replace(/- /g, "-")), this.truncate(t, void 0, l, 0 === p && u || 0, a, (t, e) => l.slice(0, e).join(" ").replace(/- /g, "-")), u = e.actualWidth, p++;
	              d.forEach(e => {
	                r.insertBefore(e, t);
	              }), h.forEach(e => {
	                r.insertBefore(s.createTextNode(e), t);
	                let a = s.createElementNS(o, "tspan");
	                a.textContent = "â", n(a, {
	                  dy: c,
	                  x: i
	                }), r.insertBefore(a, t);
	              });
	            }
	          },
	          l = t => {
	            let i = [].slice.call(t.childNodes);
	            i.forEach(i => {
	              i.nodeType === r.Node.TEXT_NODE ? h(i, t) : (-1 !== i.className.baseVal.indexOf("highcharts-br") && (e.actualWidth = 0), l(i));
	            });
	          };
	        l(e.element);
	      }
	      getLineHeight(t) {
	        let e = t.nodeType === r.Node.TEXT_NODE ? t.parentElement : t;
	        return this.textLineHeight ? parseInt(this.textLineHeight.toString(), 10) : this.renderer.fontMetrics(e || this.svgElement.element).h;
	      }
	      modifyTree(t) {
	        let e = (i, s) => {
	          let {
	              attributes: o = {},
	              children: r,
	              style: n = {},
	              tagName: h
	            } = i,
	            l = this.renderer.styledMode;
	          if ("b" === h || "strong" === h ? l ? o.class = "highcharts-strong" : n.fontWeight = "bold" : ("i" === h || "em" === h) && (l ? o.class = "highcharts-emphasized" : n.fontStyle = "italic"), n && n.color && (n.fill = n.color), "br" === h) {
	            o.class = "highcharts-br", i.textContent = "â";
	            let e = t[s + 1];
	            e && e.textContent && (e.textContent = e.textContent.replace(/^ +/gm, ""));
	          } else "a" === h && r && r.some(t => "#text" === t.tagName) && (i.children = [{
	            children: r,
	            tagName: "tspan"
	          }]);
	          "#text" !== h && "a" !== h && (i.tagName = "tspan"), a(i, {
	            attributes: o,
	            style: n
	          }), r && r.filter(t => "#text" !== t.tagName).forEach(e);
	        };
	        t.forEach(e), h(this.svgElement, "afterModifyTree", {
	          nodes: t
	        });
	      }
	      truncate(t, e, i, s, o, r) {
	        let n, a;
	        let h = this.svgElement,
	          {
	            renderer: l,
	            rotation: d
	          } = h,
	          c = [],
	          p = i ? 1 : 0,
	          u = (e || i || "").length,
	          g = u,
	          f = function (e, o) {
	            let r = o || e,
	              n = t.parentNode;
	            if (n && void 0 === c[r] && n.getSubStringLength) try {
	              c[r] = s + n.getSubStringLength(0, i ? r + 1 : r);
	            } catch (t) {}
	            return c[r];
	          };
	        if (h.rotation = 0, s + (a = f(t.textContent.length)) > o) {
	          for (; p <= u;) g = Math.ceil((p + u) / 2), i && (n = r(i, g)), a = f(g, n && n.length - 1), p === u ? p = u + 1 : a > o ? u = g - 1 : p = g;
	          0 === u ? t.textContent = "" : e && u === e.length - 1 || (t.textContent = n || r(e || i, g));
	        }
	        i && i.splice(0, g), h.actualWidth = a, h.rotation = d;
	      }
	      unescapeEntities(t, e) {
	        return d(this.renderer.escapes, function (i, s) {
	          e && -1 !== e.indexOf(i) || (t = t.toString().replace(RegExp(i, "g"), s));
	        }), t;
	      }
	    };
	  }), i(e, "Core/Renderer/SVG/SVGRenderer.js", [e["Core/Renderer/HTML/AST.js"], e["Core/Color/Color.js"], e["Core/Globals.js"], e["Core/Renderer/RendererRegistry.js"], e["Core/Renderer/SVG/SVGElement.js"], e["Core/Renderer/SVG/SVGLabel.js"], e["Core/Renderer/SVG/Symbols.js"], e["Core/Renderer/SVG/TextBuilder.js"], e["Core/Utilities.js"]], function (t, e, i, s, o, r, n, a, h) {
	    let l;
	    let {
	        charts: d,
	        deg2rad: c,
	        doc: p,
	        isFirefox: u,
	        isMS: g,
	        isWebKit: f,
	        noop: m,
	        SVG_NS: x,
	        symbolSizes: y,
	        win: b
	      } = i,
	      {
	        addEvent: v,
	        attr: S,
	        createElement: k,
	        css: M,
	        defined: C,
	        destroyObjectProperties: w,
	        extend: T,
	        isArray: A,
	        isNumber: P,
	        isObject: L,
	        isString: O,
	        merge: D,
	        pick: E,
	        pInt: j,
	        uniqueKey: I
	      } = h;
	    class B {
	      constructor(t, e, i, s, o, r, n) {
	        let a, h;
	        let l = this.createElement("svg").attr({
	            version: "1.1",
	            class: "highcharts-root"
	          }),
	          d = l.element;
	        n || l.css(this.getStyle(s || {})), t.appendChild(d), S(t, "dir", "ltr"), -1 === t.innerHTML.indexOf("xmlns") && S(d, "xmlns", this.SVG_NS), this.box = d, this.boxWrapper = l, this.alignedObjects = [], this.url = this.getReferenceURL();
	        let c = this.createElement("desc").add();
	        c.element.appendChild(p.createTextNode("Created with Highcharts 11.3.0")), this.defs = this.createElement("defs").add(), this.allowHTML = r, this.forExport = o, this.styledMode = n, this.gradients = {}, this.cache = {}, this.cacheKeys = [], this.imgCount = 0, this.rootFontSize = l.getStyle("font-size"), this.setSize(e, i, !1), u && t.getBoundingClientRect && ((a = function () {
	          M(t, {
	            left: 0,
	            top: 0
	          }), h = t.getBoundingClientRect(), M(t, {
	            left: Math.ceil(h.left) - h.left + "px",
	            top: Math.ceil(h.top) - h.top + "px"
	          });
	        })(), this.unSubPixelFix = v(b, "resize", a));
	      }
	      definition(e) {
	        let i = new t([e]);
	        return i.addToDOM(this.defs.element);
	      }
	      getReferenceURL() {
	        if ((u || f) && p.getElementsByTagName("base").length) {
	          if (!C(l)) {
	            let e = I(),
	              i = new t([{
	                tagName: "svg",
	                attributes: {
	                  width: 8,
	                  height: 8
	                },
	                children: [{
	                  tagName: "defs",
	                  children: [{
	                    tagName: "clipPath",
	                    attributes: {
	                      id: e
	                    },
	                    children: [{
	                      tagName: "rect",
	                      attributes: {
	                        width: 4,
	                        height: 4
	                      }
	                    }]
	                  }]
	                }, {
	                  tagName: "rect",
	                  attributes: {
	                    id: "hitme",
	                    width: 8,
	                    height: 8,
	                    "clip-path": `url(#${e})`,
	                    fill: "rgba(0,0,0,0.001)"
	                  }
	                }]
	              }]),
	              s = i.addToDOM(p.body);
	            M(s, {
	              position: "fixed",
	              top: 0,
	              left: 0,
	              zIndex: 9e5
	            });
	            let o = p.elementFromPoint(6, 6);
	            l = "hitme" === (o && o.id), p.body.removeChild(s);
	          }
	          if (l) return b.location.href.split("#")[0].replace(/<[^>]*>/g, "").replace(/([\('\)])/g, "\\$1").replace(/ /g, "%20");
	        }
	        return "";
	      }
	      getStyle(t) {
	        return this.style = T({
	          fontFamily: "Helvetica, Arial, sans-serif",
	          fontSize: "1rem"
	        }, t), this.style;
	      }
	      setStyle(t) {
	        this.boxWrapper.css(this.getStyle(t));
	      }
	      isHidden() {
	        return !this.boxWrapper.getBBox().width;
	      }
	      destroy() {
	        let t = this.defs;
	        return this.box = null, this.boxWrapper = this.boxWrapper.destroy(), w(this.gradients || {}), this.gradients = null, this.defs = t.destroy(), this.unSubPixelFix && this.unSubPixelFix(), this.alignedObjects = null, null;
	      }
	      createElement(t) {
	        return new this.Element(this, t);
	      }
	      getRadialAttr(t, e) {
	        return {
	          cx: t[0] - t[2] / 2 + (e.cx || 0) * t[2],
	          cy: t[1] - t[2] / 2 + (e.cy || 0) * t[2],
	          r: (e.r || 0) * t[2]
	        };
	      }
	      shadowDefinition(t) {
	        let e = [`highcharts-drop-shadow-${this.chartIndex}`, ...Object.keys(t).map(e => `${e}-${t[e]}`)].join("-").toLowerCase().replace(/[^a-z0-9\-]/g, ""),
	          i = D({
	            color: "#000000",
	            offsetX: 1,
	            offsetY: 1,
	            opacity: .15,
	            width: 5
	          }, t);
	        return this.defs.element.querySelector(`#${e}`) || this.definition({
	          tagName: "filter",
	          attributes: {
	            id: e,
	            filterUnits: i.filterUnits
	          },
	          children: [{
	            tagName: "feDropShadow",
	            attributes: {
	              dx: i.offsetX,
	              dy: i.offsetY,
	              "flood-color": i.color,
	              "flood-opacity": Math.min(5 * i.opacity, 1),
	              stdDeviation: i.width / 2
	            }
	          }]
	        }), e;
	      }
	      buildText(t) {
	        new a(t).buildSVG();
	      }
	      getContrast(t) {
	        let i = e.parse(t).rgba.map(t => {
	            let e = t / 255;
	            return e <= .03928 ? e / 12.92 : Math.pow((e + .055) / 1.055, 2.4);
	          }),
	          s = .2126 * i[0] + .7152 * i[1] + .0722 * i[2];
	        return 1.05 / (s + .05) > (s + .05) / .05 ? "#FFFFFF" : "#000000";
	      }
	      button(e, i, s, o, r = {}, n, a, h, l, d) {
	        let c, p, u;
	        let f = this.label(e, i, s, l, void 0, void 0, d, void 0, "button"),
	          m = this.styledMode,
	          x = r.states || {},
	          y = 0;
	        r = D(r), delete r.states;
	        let b = D({
	          color: "#333333",
	          cursor: "pointer",
	          fontSize: "0.8em",
	          fontWeight: "normal"
	        }, r.style);
	        delete r.style;
	        let S = t.filterUserAttributes(r);
	        return f.attr(D({
	          padding: 8,
	          r: 2
	        }, S)), m || (S = D({
	          fill: "#f7f7f7",
	          stroke: "#cccccc",
	          "stroke-width": 1
	        }, S), c = (n = D(S, {
	          fill: "#e6e6e6"
	        }, t.filterUserAttributes(n || x.hover || {}))).style, delete n.style, p = (a = D(S, {
	          fill: "#e6e9ff",
	          style: {
	            color: "#000000",
	            fontWeight: "bold"
	          }
	        }, t.filterUserAttributes(a || x.select || {}))).style, delete a.style, u = (h = D(S, {
	          style: {
	            color: "#cccccc"
	          }
	        }, t.filterUserAttributes(h || x.disabled || {}))).style, delete h.style), v(f.element, g ? "mouseover" : "mouseenter", function () {
	          3 !== y && f.setState(1);
	        }), v(f.element, g ? "mouseout" : "mouseleave", function () {
	          3 !== y && f.setState(y);
	        }), f.setState = function (t) {
	          if (1 !== t && (f.state = y = t), f.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-" + ["normal", "hover", "pressed", "disabled"][t || 0]), !m) {
	            f.attr([S, n, a, h][t || 0]);
	            let e = [b, c, p, u][t || 0];
	            L(e) && f.css(e);
	          }
	        }, !m && (f.attr(S).css(T({
	          cursor: "default"
	        }, b)), d && f.text.css({
	          pointerEvents: "none"
	        })), f.on("touchstart", t => t.stopPropagation()).on("click", function (t) {
	          3 !== y && o.call(f, t);
	        });
	      }
	      crispLine(t, e, i = "round") {
	        let s = t[0],
	          o = t[1];
	        return C(s[1]) && s[1] === o[1] && (s[1] = o[1] = Math[i](s[1]) - e % 2 / 2), C(s[2]) && s[2] === o[2] && (s[2] = o[2] = Math[i](s[2]) + e % 2 / 2), t;
	      }
	      path(t) {
	        let e = this.styledMode ? {} : {
	          fill: "none"
	        };
	        return A(t) ? e.d = t : L(t) && T(e, t), this.createElement("path").attr(e);
	      }
	      circle(t, e, i) {
	        let s = L(t) ? t : void 0 === t ? {} : {
	            x: t,
	            y: e,
	            r: i
	          },
	          o = this.createElement("circle");
	        return o.xSetter = o.ySetter = function (t, e, i) {
	          i.setAttribute("c" + e, t);
	        }, o.attr(s);
	      }
	      arc(t, e, i, s, o, r) {
	        let n;
	        L(t) ? (e = (n = t).y, i = n.r, s = n.innerR, o = n.start, r = n.end, t = n.x) : n = {
	          innerR: s,
	          start: o,
	          end: r
	        };
	        let a = this.symbol("arc", t, e, i, i, n);
	        return a.r = i, a;
	      }
	      rect(t, e, i, s, o, r) {
	        let n = L(t) ? t : void 0 === t ? {} : {
	            x: t,
	            y: e,
	            r: o,
	            width: Math.max(i || 0, 0),
	            height: Math.max(s || 0, 0)
	          },
	          a = this.createElement("rect");
	        return this.styledMode || (void 0 !== r && (n["stroke-width"] = r, T(n, a.crisp(n))), n.fill = "none"), a.rSetter = function (t, e, i) {
	          a.r = t, S(i, {
	            rx: t,
	            ry: t
	          });
	        }, a.rGetter = function () {
	          return a.r || 0;
	        }, a.attr(n);
	      }
	      roundedRect(t) {
	        return this.symbol("roundedRect").attr(t);
	      }
	      setSize(t, e, i) {
	        this.width = t, this.height = e, this.boxWrapper.animate({
	          width: t,
	          height: e
	        }, {
	          step: function () {
	            this.attr({
	              viewBox: "0 0 " + this.attr("width") + " " + this.attr("height")
	            });
	          },
	          duration: E(i, !0) ? void 0 : 0
	        }), this.alignElements();
	      }
	      g(t) {
	        let e = this.createElement("g");
	        return t ? e.attr({
	          class: "highcharts-" + t
	        }) : e;
	      }
	      image(t, e, i, s, o, r) {
	        let n = {
	          preserveAspectRatio: "none"
	        };
	        P(e) && (n.x = e), P(i) && (n.y = i), P(s) && (n.width = s), P(o) && (n.height = o);
	        let a = this.createElement("image").attr(n),
	          h = function (e) {
	            a.attr({
	              href: t
	            }), r.call(a, e);
	          };
	        if (r) {
	          a.attr({
	            href: "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="
	          });
	          let e = new b.Image();
	          v(e, "load", h), e.src = t, e.complete && h({});
	        } else a.attr({
	          href: t
	        });
	        return a;
	      }
	      symbol(t, e, i, s, o, r) {
	        let n, a, h, l;
	        let c = this,
	          u = /^url\((.*?)\)$/,
	          g = u.test(t),
	          f = !g && (this.symbols[t] ? t : "circle"),
	          m = f && this.symbols[f];
	        if (m) "number" == typeof e && (a = m.call(this.symbols, Math.round(e || 0), Math.round(i || 0), s || 0, o || 0, r)), n = this.path(a), c.styledMode || n.attr("fill", "none"), T(n, {
	          symbolName: f || void 0,
	          x: e,
	          y: i,
	          width: s,
	          height: o
	        }), r && T(n, r);else if (g) {
	          h = t.match(u)[1];
	          let s = n = this.image(h);
	          s.imgwidth = E(r && r.width, y[h] && y[h].width), s.imgheight = E(r && r.height, y[h] && y[h].height), l = t => t.attr({
	            width: t.width,
	            height: t.height
	          }), ["width", "height"].forEach(t => {
	            s[`${t}Setter`] = function (t, e) {
	              this[e] = t;
	              let {
	                  alignByTranslate: i,
	                  element: s,
	                  width: o,
	                  height: n,
	                  imgwidth: a,
	                  imgheight: h
	                } = this,
	                l = "width" === e ? a : h,
	                d = 1;
	              r && "within" === r.backgroundSize && o && n && a && h ? (d = Math.min(o / a, n / h), S(s, {
	                width: Math.round(a * d),
	                height: Math.round(h * d)
	              })) : s && l && s.setAttribute(e, l), !i && a && h && this.translate(((o || 0) - a * d) / 2, ((n || 0) - h * d) / 2);
	            };
	          }), C(e) && s.attr({
	            x: e,
	            y: i
	          }), s.isImg = !0, C(s.imgwidth) && C(s.imgheight) ? l(s) : (s.attr({
	            width: 0,
	            height: 0
	          }), k("img", {
	            onload: function () {
	              let t = d[c.chartIndex];
	              0 === this.width && (M(this, {
	                position: "absolute",
	                top: "-999em"
	              }), p.body.appendChild(this)), y[h] = {
	                width: this.width,
	                height: this.height
	              }, s.imgwidth = this.width, s.imgheight = this.height, s.element && l(s), this.parentNode && this.parentNode.removeChild(this), c.imgCount--, c.imgCount || !t || t.hasLoaded || t.onload();
	            },
	            src: h
	          }), this.imgCount++);
	        }
	        return n;
	      }
	      clipRect(t, e, i, s) {
	        return this.rect(t, e, i, s, 0);
	      }
	      text(t, e, i, s) {
	        let o = {};
	        if (s && (this.allowHTML || !this.forExport)) return this.html(t, e, i);
	        o.x = Math.round(e || 0), i && (o.y = Math.round(i)), C(t) && (o.text = t);
	        let r = this.createElement("text").attr(o);
	        return s && (!this.forExport || this.allowHTML) || (r.xSetter = function (t, e, i) {
	          let s = i.getElementsByTagName("tspan"),
	            o = i.getAttribute(e);
	          for (let i = 0, r; i < s.length; i++) (r = s[i]).getAttribute(e) === o && r.setAttribute(e, t);
	          i.setAttribute(e, t);
	        }), r;
	      }
	      fontMetrics(t) {
	        let e = j(o.prototype.getStyle.call(t, "font-size") || 0),
	          i = e < 24 ? e + 3 : Math.round(1.2 * e),
	          s = Math.round(.8 * i);
	        return {
	          h: i,
	          b: s,
	          f: e
	        };
	      }
	      rotCorr(t, e, i) {
	        let s = t;
	        return e && i && (s = Math.max(s * Math.cos(e * c), 4)), {
	          x: -t / 3 * Math.sin(e * c),
	          y: s
	        };
	      }
	      pathToSegments(t) {
	        let e = [],
	          i = [],
	          s = {
	            A: 8,
	            C: 7,
	            H: 2,
	            L: 3,
	            M: 3,
	            Q: 5,
	            S: 5,
	            T: 3,
	            V: 2
	          };
	        for (let o = 0; o < t.length; o++) O(i[0]) && P(t[o]) && i.length === s[i[0].toUpperCase()] && t.splice(o, 0, i[0].replace("M", "L").replace("m", "l")), "string" == typeof t[o] && (i.length && e.push(i.slice(0)), i.length = 0), i.push(t[o]);
	        return e.push(i.slice(0)), e;
	      }
	      label(t, e, i, s, o, n, a, h, l) {
	        return new r(this, t, e, i, s, o, n, a, h, l);
	      }
	      alignElements() {
	        this.alignedObjects.forEach(t => t.align());
	      }
	    }
	    return T(B.prototype, {
	      Element: o,
	      SVG_NS: x,
	      escapes: {
	        "&": "&amp;",
	        "<": "&lt;",
	        ">": "&gt;",
	        "'": "&#39;",
	        '"': "&quot;"
	      },
	      symbols: n,
	      draw: m
	    }), s.registerRendererType("svg", B, !0), B;
	  }), i(e, "Core/Renderer/HTML/HTMLElement.js", [e["Core/Globals.js"], e["Core/Renderer/SVG/SVGElement.js"], e["Core/Utilities.js"]], function (t, e, i) {
	    let {
	        composed: s
	      } = t,
	      {
	        css: o,
	        defined: r,
	        extend: n,
	        pushUnique: a,
	        pInt: h
	      } = i;
	    class l extends e {
	      static compose(t) {
	        if (a(s, this.compose)) {
	          let e = l.prototype,
	            i = t.prototype;
	          i.getSpanCorrection = e.getSpanCorrection, i.htmlCss = e.htmlCss, i.htmlGetBBox = e.htmlGetBBox, i.htmlUpdateTransform = e.htmlUpdateTransform, i.setSpanRotation = e.setSpanRotation;
	        }
	        return t;
	      }
	      getSpanCorrection(t, e, i) {
	        this.xCorr = -t * i, this.yCorr = -e;
	      }
	      htmlCss(t) {
	        let e;
	        let {
	            element: i
	          } = this,
	          s = "SPAN" === i.tagName && t && "width" in t,
	          r = s && t.width;
	        return s && (delete t.width, this.textWidth = h(r) || void 0, e = !0), t?.textOverflow === "ellipsis" && (t.whiteSpace = "nowrap", t.overflow = "hidden"), n(this.styles, t), o(i, t), e && this.htmlUpdateTransform(), this;
	      }
	      htmlGetBBox() {
	        let {
	          element: t
	        } = this;
	        return {
	          x: t.offsetLeft,
	          y: t.offsetTop,
	          width: t.offsetWidth,
	          height: t.offsetHeight
	        };
	      }
	      htmlUpdateTransform() {
	        if (!this.added) {
	          this.alignOnAdd = !0;
	          return;
	        }
	        let {
	            element: t,
	            renderer: e,
	            rotation: i,
	            styles: s,
	            textAlign: n = "left",
	            textWidth: a,
	            translateX: h = 0,
	            translateY: l = 0,
	            x: d = 0,
	            y: c = 0
	          } = this,
	          p = {
	            left: 0,
	            center: .5,
	            right: 1
	          }[n],
	          u = s?.whiteSpace;
	        if (o(t, {
	          marginLeft: `${h}px`,
	          marginTop: `${l}px`
	        }), "SPAN" === t.tagName) {
	          let s = [i, n, t.innerHTML, a, this.textAlign].join(","),
	            h,
	            l = !1;
	          if (a !== this.oldTextWidth) {
	            let e = this.textPxLength ? this.textPxLength : (o(t, {
	                width: "",
	                whiteSpace: u || "nowrap"
	              }), t.offsetWidth),
	              s = a || 0;
	            (s > this.oldTextWidth || e > s) && (/[ \-]/.test(t.textContent || t.innerText) || "ellipsis" === t.style.textOverflow) && (o(t, {
	              width: e > s || i ? a + "px" : "auto",
	              display: "block",
	              whiteSpace: u || "normal"
	            }), this.oldTextWidth = a, l = !0);
	          }
	          this.hasBoxWidthChanged = l, s !== this.cTT && (h = e.fontMetrics(t).b, r(i) && (i !== (this.oldRotation || 0) || n !== this.oldAlign) && this.setSpanRotation(i, p, h), this.getSpanCorrection(!r(i) && this.textPxLength || t.offsetWidth, h, p)), o(t, {
	            left: d + (this.xCorr || 0) + "px",
	            top: c + (this.yCorr || 0) + "px"
	          }), this.cTT = s, this.oldRotation = i, this.oldAlign = n;
	        }
	      }
	      setSpanRotation(t, e, i) {
	        o(this.element, {
	          transform: `rotate(${t}deg)`,
	          transformOrigin: `${100 * e}% ${i}px`
	        });
	      }
	    }
	    return l;
	  }), i(e, "Core/Renderer/HTML/HTMLRenderer.js", [e["Core/Renderer/HTML/AST.js"], e["Core/Globals.js"], e["Core/Renderer/SVG/SVGElement.js"], e["Core/Renderer/SVG/SVGRenderer.js"], e["Core/Utilities.js"]], function (t, e, i, s, o) {
	    let {
	        composed: r
	      } = e,
	      {
	        attr: n,
	        createElement: a,
	        extend: h,
	        pick: l,
	        pushUnique: d
	      } = o;
	    class c extends s {
	      static compose(t) {
	        if (d(r, this.compose)) {
	          let e = c.prototype,
	            i = t.prototype;
	          i.html = e.html;
	        }
	        return t;
	      }
	      html(e, s, o) {
	        let r = this.createElement("span"),
	          d = r.element,
	          c = r.renderer,
	          p = function (t, e) {
	            ["opacity", "visibility"].forEach(function (s) {
	              t[s + "Setter"] = function (o, r, n) {
	                let a = t.div ? t.div.style : e;
	                i.prototype[s + "Setter"].call(this, o, r, n), a && (a[r] = o);
	              };
	            }), t.addedSetters = !0;
	          };
	        return r.textSetter = function (e) {
	          e !== this.textStr && (delete this.bBox, delete this.oldTextWidth, t.setElementHTML(this.element, l(e, "")), this.textStr = e, r.doTransform = !0);
	        }, p(r, r.element.style), r.xSetter = r.ySetter = r.alignSetter = r.rotationSetter = function (t, e) {
	          "align" === e ? r.alignValue = r.textAlign = t : r[e] = t, r.doTransform = !0;
	        }, r.afterSetters = function () {
	          this.doTransform && (this.htmlUpdateTransform(), this.doTransform = !1);
	        }, r.attr({
	          text: e,
	          x: Math.round(s),
	          y: Math.round(o)
	        }).css({
	          position: "absolute"
	        }), c.styledMode || r.css({
	          fontFamily: this.style.fontFamily,
	          fontSize: this.style.fontSize
	        }), d.style.whiteSpace = "nowrap", r.css = r.htmlCss, r.add = function (t) {
	          let e, i;
	          let s = c.box.parentNode,
	            o = [];
	          if (this.parentGroup = t, t) {
	            if (!(e = t.div)) {
	              for (i = t; i;) o.push(i), i = i.parentGroup;
	              o.reverse().forEach(function (t) {
	                var i;
	                let l = n(t.element, "class"),
	                  d = t.css;
	                function c(e, i) {
	                  t[i] = e, "translateX" === i ? g.left = e + "px" : g.top = e + "px", t.doTransform = !0;
	                }
	                let u = t.styles || {};
	                e = t.div = t.div || a("div", l ? {
	                  className: l
	                } : void 0, {
	                  position: "absolute",
	                  left: (t.translateX || 0) + "px",
	                  top: (t.translateY || 0) + "px",
	                  display: t.display,
	                  opacity: t.opacity,
	                  visibility: t.visibility
	                }, e || s);
	                let g = e.style;
	                h(t, {
	                  classSetter: (i = e, function (t) {
	                    this.element.setAttribute("class", t), i.className = t;
	                  }),
	                  css: function (e) {
	                    return d.call(t, e), ["cursor", "pointerEvents"].forEach(t => {
	                      e[t] && (g[t] = e[t]);
	                    }), t;
	                  },
	                  on: function () {
	                    return o[0].div && r.on.apply({
	                      element: o[0].div,
	                      onEvents: t.onEvents
	                    }, arguments), t;
	                  },
	                  translateXSetter: c,
	                  translateYSetter: c
	                }), t.addedSetters || p(t), t.css(u);
	              });
	            }
	          } else e = s;
	          return e.appendChild(d), r.added = !0, r.alignOnAdd && r.htmlUpdateTransform(), r;
	        }, r;
	      }
	    }
	    return c;
	  }), i(e, "Core/Axis/AxisDefaults.js", [], function () {
	    var t, e;
	    return (e = t || (t = {})).xAxis = {
	      alignTicks: !0,
	      allowDecimals: void 0,
	      panningEnabled: !0,
	      zIndex: 2,
	      zoomEnabled: !0,
	      dateTimeLabelFormats: {
	        millisecond: {
	          main: "%H:%M:%S.%L",
	          range: !1
	        },
	        second: {
	          main: "%H:%M:%S",
	          range: !1
	        },
	        minute: {
	          main: "%H:%M",
	          range: !1
	        },
	        hour: {
	          main: "%H:%M",
	          range: !1
	        },
	        day: {
	          main: "%e %b"
	        },
	        week: {
	          main: "%e %b"
	        },
	        month: {
	          main: "%b '%y"
	        },
	        year: {
	          main: "%Y"
	        }
	      },
	      endOnTick: !1,
	      gridLineDashStyle: "Solid",
	      gridZIndex: 1,
	      labels: {
	        autoRotationLimit: 80,
	        distance: 15,
	        enabled: !0,
	        indentation: 10,
	        overflow: "justify",
	        padding: 5,
	        reserveSpace: void 0,
	        rotation: void 0,
	        staggerLines: 0,
	        step: 0,
	        useHTML: !1,
	        zIndex: 7,
	        style: {
	          color: "#333333",
	          cursor: "default",
	          fontSize: "0.8em"
	        }
	      },
	      maxPadding: .01,
	      minorGridLineDashStyle: "Solid",
	      minorTickLength: 2,
	      minorTickPosition: "outside",
	      minorTicksPerMajor: 5,
	      minPadding: .01,
	      offset: void 0,
	      reversed: void 0,
	      reversedStacks: !1,
	      showEmpty: !0,
	      showFirstLabel: !0,
	      showLastLabel: !0,
	      startOfWeek: 1,
	      startOnTick: !1,
	      tickLength: 10,
	      tickPixelInterval: 100,
	      tickmarkPlacement: "between",
	      tickPosition: "outside",
	      title: {
	        align: "middle",
	        useHTML: !1,
	        x: 0,
	        y: 0,
	        style: {
	          color: "#666666",
	          fontSize: "0.8em"
	        }
	      },
	      type: "linear",
	      uniqueNames: !0,
	      visible: !0,
	      minorGridLineColor: "#f2f2f2",
	      minorGridLineWidth: 1,
	      minorTickColor: "#999999",
	      lineColor: "#333333",
	      lineWidth: 1,
	      gridLineColor: "#e6e6e6",
	      gridLineWidth: void 0,
	      tickColor: "#333333"
	    }, e.yAxis = {
	      reversedStacks: !0,
	      endOnTick: !0,
	      maxPadding: .05,
	      minPadding: .05,
	      tickPixelInterval: 72,
	      showLastLabel: !0,
	      labels: {
	        x: void 0
	      },
	      startOnTick: !0,
	      title: {
	        text: "Values"
	      },
	      stackLabels: {
	        animation: {},
	        allowOverlap: !1,
	        enabled: !1,
	        crop: !0,
	        overflow: "justify",
	        formatter: function () {
	          let {
	            numberFormatter: t
	          } = this.axis.chart;
	          return t(this.total || 0, -1);
	        },
	        style: {
	          color: "#000000",
	          fontSize: "0.7em",
	          fontWeight: "bold",
	          textOutline: "1px contrast"
	        }
	      },
	      gridLineWidth: 1,
	      lineWidth: 0
	    }, t;
	  }), i(e, "Core/Foundation.js", [e["Core/Utilities.js"]], function (t) {
	    var e;
	    let {
	      addEvent: i,
	      isFunction: s,
	      objectEach: o,
	      removeEvent: r
	    } = t;
	    return (e || (e = {})).registerEventOptions = function (t, e) {
	      t.eventOptions = t.eventOptions || {}, o(e.events, function (e, o) {
	        t.eventOptions[o] !== e && (t.eventOptions[o] && (r(t, o, t.eventOptions[o]), delete t.eventOptions[o]), s(e) && (t.eventOptions[o] = e, i(t, o, e, {
	          order: 0
	        })));
	      });
	    }, e;
	  }), i(e, "Core/Axis/Tick.js", [e["Core/Templating.js"], e["Core/Globals.js"], e["Core/Utilities.js"]], function (t, e, i) {
	    let {
	        deg2rad: s
	      } = e,
	      {
	        clamp: o,
	        correctFloat: r,
	        defined: n,
	        destroyObjectProperties: a,
	        extend: h,
	        fireEvent: l,
	        isNumber: d,
	        merge: c,
	        objectEach: p,
	        pick: u
	      } = i;
	    return class {
	      constructor(t, e, i, s, o) {
	        this.isNew = !0, this.isNewLabel = !0, this.axis = t, this.pos = e, this.type = i || "", this.parameters = o || {}, this.tickmarkOffset = this.parameters.tickmarkOffset, this.options = this.parameters.options, l(this, "init"), i || s || this.addLabel();
	      }
	      addLabel() {
	        let e = this,
	          i = e.axis,
	          s = i.options,
	          o = i.chart,
	          a = i.categories,
	          c = i.logarithmic,
	          p = i.names,
	          g = e.pos,
	          f = u(e.options && e.options.labels, s.labels),
	          m = i.tickPositions,
	          x = g === m[0],
	          y = g === m[m.length - 1],
	          b = (!f.step || 1 === f.step) && 1 === i.tickInterval,
	          v = m.info,
	          S = e.label,
	          k,
	          M,
	          C,
	          w = this.parameters.category || (a ? u(a[g], p[g], g) : g);
	        c && d(w) && (w = r(c.lin2log(w))), i.dateTime && (v ? k = (M = o.time.resolveDTLFormat(s.dateTimeLabelFormats[!s.grid && v.higherRanks[g] || v.unitName])).main : d(w) && (k = i.dateTime.getXDateFormat(w, s.dateTimeLabelFormats || {}))), e.isFirst = x, e.isLast = y;
	        let T = {
	          axis: i,
	          chart: o,
	          dateTimeLabelFormat: k,
	          isFirst: x,
	          isLast: y,
	          pos: g,
	          tick: e,
	          tickPositionInfo: v,
	          value: w
	        };
	        l(this, "labelFormat", T);
	        let A = e => f.formatter ? f.formatter.call(e, e) : f.format ? (e.text = i.defaultLabelFormatter.call(e, e), t.format(f.format, e, o)) : i.defaultLabelFormatter.call(e, e),
	          P = A.call(T, T),
	          L = M && M.list;
	        L ? e.shortenLabel = function () {
	          for (C = 0; C < L.length; C++) if (h(T, {
	            dateTimeLabelFormat: L[C]
	          }), S.attr({
	            text: A.call(T, T)
	          }), S.getBBox().width < i.getSlotWidth(e) - 2 * f.padding) return;
	          S.attr({
	            text: ""
	          });
	        } : e.shortenLabel = void 0, b && i._addedPlotLB && e.moveLabel(P, f), n(S) || e.movedLabel ? S && S.textStr !== P && !b && (!S.textWidth || f.style.width || S.styles.width || S.css({
	          width: null
	        }), S.attr({
	          text: P
	        }), S.textPxLength = S.getBBox().width) : (e.label = S = e.createLabel(P, f), e.rotation = 0);
	      }
	      createLabel(t, e, i) {
	        let s = this.axis,
	          o = s.chart,
	          r = n(t) && e.enabled ? o.renderer.text(t, i?.x, i?.y, e.useHTML).add(s.labelGroup) : void 0;
	        return r && (o.styledMode || r.css(c(e.style)), r.textPxLength = r.getBBox().width), r;
	      }
	      destroy() {
	        a(this, this.axis);
	      }
	      getPosition(t, e, i, s) {
	        let n = this.axis,
	          a = n.chart,
	          h = s && a.oldChartHeight || a.chartHeight,
	          d = {
	            x: t ? r(n.translate(e + i, void 0, void 0, s) + n.transB) : n.left + n.offset + (n.opposite ? (s && a.oldChartWidth || a.chartWidth) - n.right - n.left : 0),
	            y: t ? h - n.bottom + n.offset - (n.opposite ? n.height : 0) : r(h - n.translate(e + i, void 0, void 0, s) - n.transB)
	          };
	        return d.y = o(d.y, -1e5, 1e5), l(this, "afterGetPosition", {
	          pos: d
	        }), d;
	      }
	      getLabelPosition(t, e, i, o, r, a, h, d) {
	        let c, p;
	        let g = this.axis,
	          f = g.transA,
	          m = g.isLinked && g.linkedParent ? g.linkedParent.reversed : g.reversed,
	          x = g.staggerLines,
	          y = g.tickRotCorr || {
	            x: 0,
	            y: 0
	          },
	          b = o || g.reserveSpaceDefault ? 0 : -g.labelOffset * ("center" === g.labelAlign ? .5 : 1),
	          v = r.distance,
	          S = {};
	        return c = 0 === g.side ? i.rotation ? -v : -i.getBBox().height : 2 === g.side ? y.y + v : Math.cos(i.rotation * s) * (y.y - i.getBBox(!1, 0).height / 2), n(r.y) && (c = 0 === g.side && g.horiz ? r.y + c : r.y), t = t + u(r.x, [0, 1, 0, -1][g.side] * v) + b + y.x - (a && o ? a * f * (m ? -1 : 1) : 0), e = e + c - (a && !o ? a * f * (m ? 1 : -1) : 0), x && (p = h / (d || 1) % x, g.opposite && (p = x - p - 1), e += p * (g.labelOffset / x)), S.x = t, S.y = Math.round(e), l(this, "afterGetLabelPosition", {
	          pos: S,
	          tickmarkOffset: a,
	          index: h
	        }), S;
	      }
	      getLabelSize() {
	        return this.label ? this.label.getBBox()[this.axis.horiz ? "height" : "width"] : 0;
	      }
	      getMarkPath(t, e, i, s, o, r) {
	        return r.crispLine([["M", t, e], ["L", t + (o ? 0 : -i), e + (o ? i : 0)]], s);
	      }
	      handleOverflow(t) {
	        let e = this.axis,
	          i = e.options.labels,
	          o = t.x,
	          r = e.chart.chartWidth,
	          n = e.chart.spacing,
	          a = u(e.labelLeft, Math.min(e.pos, n[3])),
	          h = u(e.labelRight, Math.max(e.isRadial ? 0 : e.pos + e.len, r - n[1])),
	          l = this.label,
	          d = this.rotation,
	          c = {
	            left: 0,
	            center: .5,
	            right: 1
	          }[e.labelAlign || l.attr("align")],
	          p = l.getBBox().width,
	          g = e.getSlotWidth(this),
	          f = {},
	          m = g,
	          x = 1,
	          y;
	        d || "justify" !== i.overflow ? d < 0 && o - c * p < a ? y = Math.round(o / Math.cos(d * s) - a) : d > 0 && o + c * p > h && (y = Math.round((r - o) / Math.cos(d * s))) : (o - c * p < a ? m = t.x + m * (1 - c) - a : o + (1 - c) * p > h && (m = h - t.x + m * c, x = -1), (m = Math.min(g, m)) < g && "center" === e.labelAlign && (t.x += x * (g - m - c * (g - Math.min(p, m)))), (p > m || e.autoRotation && (l.styles || {}).width) && (y = m)), y && (this.shortenLabel ? this.shortenLabel() : (f.width = Math.floor(y) + "px", (i.style || {}).textOverflow || (f.textOverflow = "ellipsis"), l.css(f)));
	      }
	      moveLabel(t, e) {
	        let i = this,
	          s = i.label,
	          o = i.axis,
	          r = !1,
	          n;
	        s && s.textStr === t ? (i.movedLabel = s, r = !0, delete i.label) : p(o.ticks, function (e) {
	          r || e.isNew || e === i || !e.label || e.label.textStr !== t || (i.movedLabel = e.label, r = !0, e.labelPos = i.movedLabel.xy, delete e.label);
	        }), !r && (i.labelPos || s) && (n = i.labelPos || s.xy, i.movedLabel = i.createLabel(t, e, n), i.movedLabel && i.movedLabel.attr({
	          opacity: 0
	        }));
	      }
	      render(t, e, i) {
	        let s = this.axis,
	          o = s.horiz,
	          r = this.pos,
	          n = u(this.tickmarkOffset, s.tickmarkOffset),
	          a = this.getPosition(o, r, n, e),
	          h = a.x,
	          d = a.y,
	          c = o && h === s.pos + s.len || !o && d === s.pos ? -1 : 1,
	          p = u(i, this.label && this.label.newOpacity, 1);
	        i = u(i, 1), this.isActive = !0, this.renderGridLine(e, i, c), this.renderMark(a, i, c), this.renderLabel(a, e, p, t), this.isNew = !1, l(this, "afterRender");
	      }
	      renderGridLine(t, e, i) {
	        let s = this.axis,
	          o = s.options,
	          r = {},
	          n = this.pos,
	          a = this.type,
	          h = u(this.tickmarkOffset, s.tickmarkOffset),
	          l = s.chart.renderer,
	          d = this.gridLine,
	          c,
	          p = o.gridLineWidth,
	          g = o.gridLineColor,
	          f = o.gridLineDashStyle;
	        "minor" === this.type && (p = o.minorGridLineWidth, g = o.minorGridLineColor, f = o.minorGridLineDashStyle), d || (s.chart.styledMode || (r.stroke = g, r["stroke-width"] = p || 0, r.dashstyle = f), a || (r.zIndex = 1), t && (e = 0), this.gridLine = d = l.path().attr(r).addClass("highcharts-" + (a ? a + "-" : "") + "grid-line").add(s.gridGroup)), d && (c = s.getPlotLinePath({
	          value: n + h,
	          lineWidth: d.strokeWidth() * i,
	          force: "pass",
	          old: t,
	          acrossPanes: !1
	        })) && d[t || this.isNew ? "attr" : "animate"]({
	          d: c,
	          opacity: e
	        });
	      }
	      renderMark(t, e, i) {
	        let s = this.axis,
	          o = s.options,
	          r = s.chart.renderer,
	          n = this.type,
	          a = s.tickSize(n ? n + "Tick" : "tick"),
	          h = t.x,
	          l = t.y,
	          d = u(o["minor" !== n ? "tickWidth" : "minorTickWidth"], !n && s.isXAxis ? 1 : 0),
	          c = o["minor" !== n ? "tickColor" : "minorTickColor"],
	          p = this.mark,
	          g = !p;
	        a && (s.opposite && (a[0] = -a[0]), p || (this.mark = p = r.path().addClass("highcharts-" + (n ? n + "-" : "") + "tick").add(s.axisGroup), s.chart.styledMode || p.attr({
	          stroke: c,
	          "stroke-width": d
	        })), p[g ? "attr" : "animate"]({
	          d: this.getMarkPath(h, l, a[0], p.strokeWidth() * i, s.horiz, r),
	          opacity: e
	        }));
	      }
	      renderLabel(t, e, i, s) {
	        let o = this.axis,
	          r = o.horiz,
	          n = o.options,
	          a = this.label,
	          h = n.labels,
	          l = h.step,
	          c = u(this.tickmarkOffset, o.tickmarkOffset),
	          p = t.x,
	          g = t.y,
	          f = !0;
	        a && d(p) && (a.xy = t = this.getLabelPosition(p, g, a, r, h, c, s, l), (!this.isFirst || this.isLast || n.showFirstLabel) && (!this.isLast || this.isFirst || n.showLastLabel) ? !r || h.step || h.rotation || e || 0 === i || this.handleOverflow(t) : f = !1, l && s % l && (f = !1), f && d(t.y) ? (t.opacity = i, a[this.isNewLabel ? "attr" : "animate"](t).show(!0), this.isNewLabel = !1) : (a.hide(), this.isNewLabel = !0));
	      }
	      replaceMovedLabel() {
	        let t = this.label,
	          e = this.axis;
	        t && !this.isNew && (t.animate({
	          opacity: 0
	        }, void 0, t.destroy), delete this.label), e.isDirty = !0, this.label = this.movedLabel, delete this.movedLabel;
	      }
	    };
	  }), i(e, "Core/Axis/Axis.js", [e["Core/Animation/AnimationUtilities.js"], e["Core/Axis/AxisDefaults.js"], e["Core/Color/Color.js"], e["Core/Defaults.js"], e["Core/Foundation.js"], e["Core/Globals.js"], e["Core/Axis/Tick.js"], e["Core/Utilities.js"]], function (t, e, i, s, o, r, n, a) {
	    let {
	        animObject: h
	      } = t,
	      {
	        xAxis: l,
	        yAxis: d
	      } = e,
	      {
	        defaultOptions: c
	      } = s,
	      {
	        registerEventOptions: p
	      } = o,
	      {
	        deg2rad: u
	      } = r,
	      {
	        arrayMax: g,
	        arrayMin: f,
	        clamp: m,
	        correctFloat: x,
	        defined: y,
	        destroyObjectProperties: b,
	        erase: v,
	        error: S,
	        extend: k,
	        fireEvent: M,
	        getClosestDistance: C,
	        insertItem: w,
	        isArray: T,
	        isNumber: A,
	        isString: P,
	        merge: L,
	        normalizeTickInterval: O,
	        objectEach: D,
	        pick: E,
	        relativeLength: j,
	        removeEvent: I,
	        splat: B,
	        syncTimeout: R
	      } = a,
	      z = (t, e) => O(e, void 0, void 0, E(t.options.allowDecimals, e < .5 || void 0 !== t.tickAmount), !!t.tickAmount);
	    k(c, {
	      xAxis: l,
	      yAxis: L(l, d)
	    });
	    class N {
	      constructor(t, e, i) {
	        this.init(t, e, i);
	      }
	      init(t, e, i = this.coll) {
	        let s = "xAxis" === i,
	          o = this.isZAxis || (t.inverted ? !s : s);
	        this.chart = t, this.horiz = o, this.isXAxis = s, this.coll = i, M(this, "init", {
	          userOptions: e
	        }), this.opposite = E(e.opposite, this.opposite), this.side = E(e.side, this.side, o ? this.opposite ? 0 : 2 : this.opposite ? 1 : 3), this.setOptions(e);
	        let r = this.options,
	          n = r.labels,
	          a = r.type;
	        this.userOptions = e, this.minPixelPadding = 0, this.reversed = E(r.reversed, this.reversed), this.visible = r.visible, this.zoomEnabled = r.zoomEnabled, this.hasNames = "category" === a || !0 === r.categories, this.categories = T(r.categories) && r.categories || (this.hasNames ? [] : void 0), this.names || (this.names = [], this.names.keys = {}), this.plotLinesAndBandsGroups = {}, this.positiveValuesOnly = !!this.logarithmic, this.isLinked = y(r.linkedTo), this.ticks = {}, this.labelEdge = [], this.minorTicks = {}, this.plotLinesAndBands = [], this.alternateBands = {}, this.len = 0, this.minRange = this.userMinRange = r.minRange || r.maxZoom, this.range = r.range, this.offset = r.offset || 0, this.max = void 0, this.min = void 0;
	        let h = E(r.crosshair, B(t.options.tooltip.crosshairs)[s ? 0 : 1]);
	        this.crosshair = !0 === h ? {} : h, -1 === t.axes.indexOf(this) && (s ? t.axes.splice(t.xAxis.length, 0, this) : t.axes.push(this), w(this, t[this.coll])), t.orderItems(this.coll), this.series = this.series || [], t.inverted && !this.isZAxis && s && !y(this.reversed) && (this.reversed = !0), this.labelRotation = A(n.rotation) ? n.rotation : void 0, p(this, r), M(this, "afterInit");
	      }
	      setOptions(t) {
	        let e = this.horiz ? {
	          labels: {
	            autoRotation: [-45]
	          },
	          margin: 15
	        } : {
	          title: {
	            rotation: 90 * this.side
	          }
	        };
	        this.options = L(e, c[this.coll], t), M(this, "afterSetOptions", {
	          userOptions: t
	        });
	      }
	      defaultLabelFormatter(t) {
	        let e = this.axis,
	          i = this.chart,
	          {
	            numberFormatter: s
	          } = i,
	          o = A(this.value) ? this.value : NaN,
	          r = e.chart.time,
	          n = e.categories,
	          a = this.dateTimeLabelFormat,
	          h = c.lang,
	          l = h.numericSymbols,
	          d = h.numericSymbolMagnitude || 1e3,
	          p = e.logarithmic ? Math.abs(o) : e.tickInterval,
	          u = l && l.length,
	          g,
	          f;
	        if (n) f = `${this.value}`;else if (a) f = r.dateFormat(a, o);else if (u && l && p >= 1e3) for (; u-- && void 0 === f;) p >= (g = Math.pow(d, u + 1)) && 10 * o % g == 0 && null !== l[u] && 0 !== o && (f = s(o / g, -1) + l[u]);
	        return void 0 === f && (f = Math.abs(o) >= 1e4 ? s(o, -1) : s(o, -1, void 0, "")), f;
	      }
	      getSeriesExtremes() {
	        let t;
	        let e = this;
	        M(this, "getSeriesExtremes", null, function () {
	          e.hasVisibleSeries = !1, e.dataMin = e.dataMax = e.threshold = void 0, e.softThreshold = !e.isXAxis, e.series.forEach(i => {
	            if (i.reserveSpace()) {
	              let s = i.options,
	                o,
	                r = s.threshold,
	                n,
	                a;
	              if (e.hasVisibleSeries = !0, e.positiveValuesOnly && 0 >= (r || 0) && (r = void 0), e.isXAxis) (o = i.xData) && o.length && (o = e.logarithmic ? o.filter(t => t > 0) : o, n = (t = i.getXExtremes(o)).min, a = t.max, A(n) || n instanceof Date || (o = o.filter(A), n = (t = i.getXExtremes(o)).min, a = t.max), o.length && (e.dataMin = Math.min(E(e.dataMin, n), n), e.dataMax = Math.max(E(e.dataMax, a), a)));else {
	                let t = i.applyExtremes();
	                A(t.dataMin) && (n = t.dataMin, e.dataMin = Math.min(E(e.dataMin, n), n)), A(t.dataMax) && (a = t.dataMax, e.dataMax = Math.max(E(e.dataMax, a), a)), y(r) && (e.threshold = r), (!s.softThreshold || e.positiveValuesOnly) && (e.softThreshold = !1);
	              }
	            }
	          });
	        }), M(this, "afterGetSeriesExtremes");
	      }
	      translate(t, e, i, s, o, r) {
	        let n = this.linkedParent || this,
	          a = s && n.old ? n.old.min : n.min;
	        if (!A(a)) return NaN;
	        let h = n.minPixelPadding,
	          l = (n.isOrdinal || n.brokenAxis?.hasBreaks || n.logarithmic && o) && n.lin2val,
	          d = 1,
	          c = 0,
	          p = s && n.old ? n.old.transA : n.transA,
	          u = 0;
	        if (p || (p = n.transA), i && (d *= -1, c = n.len), n.reversed && (d *= -1, c -= d * (n.sector || n.len)), e) u = (t = t * d + c - h) / p + a, l && (u = n.lin2val(u));else {
	          l && (t = n.val2lin(t));
	          let e = d * (t - a) * p;
	          u = (n.isRadial ? e : x(e)) + c + d * h + (A(r) ? p * r : 0);
	        }
	        return u;
	      }
	      toPixels(t, e) {
	        return this.translate(t, !1, !this.horiz, void 0, !0) + (e ? 0 : this.pos);
	      }
	      toValue(t, e) {
	        return this.translate(t - (e ? 0 : this.pos), !0, !this.horiz, void 0, !0);
	      }
	      getPlotLinePath(t) {
	        let e = this,
	          i = e.chart,
	          s = e.left,
	          o = e.top,
	          r = t.old,
	          n = t.value,
	          a = t.lineWidth,
	          h = r && i.oldChartHeight || i.chartHeight,
	          l = r && i.oldChartWidth || i.chartWidth,
	          d = e.transB,
	          c = t.translatedValue,
	          p = t.force,
	          u,
	          g,
	          f,
	          x,
	          y;
	        function b(t, e, i) {
	          return "pass" !== p && (t < e || t > i) && (p ? t = m(t, e, i) : y = !0), t;
	        }
	        let v = {
	          value: n,
	          lineWidth: a,
	          old: r,
	          force: p,
	          acrossPanes: t.acrossPanes,
	          translatedValue: c
	        };
	        return M(this, "getPlotLinePath", v, function (t) {
	          u = f = Math.round((c = m(c = E(c, e.translate(n, void 0, void 0, r)), -1e5, 1e5)) + d), g = x = Math.round(h - c - d), A(c) ? e.horiz ? (g = o, x = h - e.bottom, u = f = b(u, s, s + e.width)) : (u = s, f = l - e.right, g = x = b(g, o, o + e.height)) : (y = !0, p = !1), t.path = y && !p ? void 0 : i.renderer.crispLine([["M", u, g], ["L", f, x]], a || 1);
	        }), v.path;
	      }
	      getLinearTickPositions(t, e, i) {
	        let s, o, r;
	        let n = x(Math.floor(e / t) * t),
	          a = x(Math.ceil(i / t) * t),
	          h = [];
	        if (x(n + t) === n && (r = 20), this.single) return [e];
	        for (s = n; s <= a && (h.push(s), (s = x(s + t, r)) !== o);) o = s;
	        return h;
	      }
	      getMinorTickInterval() {
	        let {
	          minorTicks: t,
	          minorTickInterval: e
	        } = this.options;
	        return !0 === t ? E(e, "auto") : !1 !== t ? e : void 0;
	      }
	      getMinorTickPositions() {
	        let t = this.options,
	          e = this.tickPositions,
	          i = this.minorTickInterval,
	          s = this.pointRangePadding || 0,
	          o = (this.min || 0) - s,
	          r = (this.max || 0) + s,
	          n = r - o,
	          a = [],
	          h;
	        if (n && n / i < this.len / 3) {
	          let s = this.logarithmic;
	          if (s) this.paddedTicks.forEach(function (t, e, o) {
	            e && a.push.apply(a, s.getLogTickPositions(i, o[e - 1], o[e], !0));
	          });else if (this.dateTime && "auto" === this.getMinorTickInterval()) a = a.concat(this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(i), o, r, t.startOfWeek));else for (h = o + (e[0] - o) % i; h <= r && h !== a[0]; h += i) a.push(h);
	        }
	        return 0 !== a.length && this.trimTicks(a), a;
	      }
	      adjustForMinRange() {
	        let t = this.options,
	          e = this.logarithmic,
	          {
	            max: i,
	            min: s,
	            minRange: o
	          } = this,
	          r,
	          n,
	          a,
	          h;
	        this.isXAxis && void 0 === o && !e && (o = y(t.min) || y(t.max) || y(t.floor) || y(t.ceiling) ? null : Math.min(5 * (C(this.series.map(t => (t.xIncrement ? t.xData?.slice(0, 2) : t.xData) || [])) || 0), this.dataMax - this.dataMin)), A(i) && A(s) && A(o) && i - s < o && (n = this.dataMax - this.dataMin >= o, r = (o - i + s) / 2, a = [s - r, E(t.min, s - r)], n && (a[2] = e ? e.log2lin(this.dataMin) : this.dataMin), h = [(s = g(a)) + o, E(t.max, s + o)], n && (h[2] = e ? e.log2lin(this.dataMax) : this.dataMax), (i = f(h)) - s < o && (a[0] = i - o, a[1] = E(t.min, i - o), s = g(a))), this.minRange = o, this.min = s, this.max = i;
	      }
	      getClosest() {
	        let t, e;
	        if (this.categories) e = 1;else {
	          let i = [];
	          this.series.forEach(function (t) {
	            let s = t.closestPointRange;
	            t.xData?.length === 1 ? i.push(t.xData[0]) : !t.noSharedTooltip && y(s) && t.reserveSpace() && (e = y(e) ? Math.min(e, s) : s);
	          }), i.length && (i.sort((t, e) => t - e), t = C([i]));
	        }
	        return t && e ? Math.min(t, e) : t || e;
	      }
	      nameToX(t) {
	        let e = T(this.options.categories),
	          i = e ? this.categories : this.names,
	          s = t.options.x,
	          o;
	        return t.series.requireSorting = !1, y(s) || (s = this.options.uniqueNames && i ? e ? i.indexOf(t.name) : E(i.keys[t.name], -1) : t.series.autoIncrement()), -1 === s ? !e && i && (o = i.length) : o = s, void 0 !== o ? (this.names[o] = t.name, this.names.keys[t.name] = o) : t.x && (o = t.x), o;
	      }
	      updateNames() {
	        let t = this,
	          e = this.names,
	          i = e.length;
	        i > 0 && (Object.keys(e.keys).forEach(function (t) {
	          delete e.keys[t];
	        }), e.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach(e => {
	          e.xIncrement = null, (!e.points || e.isDirtyData) && (t.max = Math.max(t.max, e.xData.length - 1), e.processData(), e.generatePoints()), e.data.forEach(function (i, s) {
	            let o;
	            i?.options && void 0 !== i.name && void 0 !== (o = t.nameToX(i)) && o !== i.x && (i.x = o, e.xData[s] = o);
	          });
	        }));
	      }
	      setAxisTranslation() {
	        let t = this,
	          e = t.max - t.min,
	          i = t.linkedParent,
	          s = !!t.categories,
	          o = t.isXAxis,
	          r = t.axisPointRange || 0,
	          n,
	          a = 0,
	          h = 0,
	          l,
	          d = t.transA;
	        (o || s || r) && (n = t.getClosest(), i ? (a = i.minPointOffset, h = i.pointRangePadding) : t.series.forEach(function (e) {
	          let i = s ? 1 : o ? E(e.options.pointRange, n, 0) : t.axisPointRange || 0,
	            l = e.options.pointPlacement;
	          if (r = Math.max(r, i), !t.single || s) {
	            let t = e.is("xrange") ? !o : o;
	            a = Math.max(a, t && P(l) ? 0 : i / 2), h = Math.max(h, t && "on" === l ? 0 : i);
	          }
	        }), l = t.ordinal && t.ordinal.slope && n ? t.ordinal.slope / n : 1, t.minPointOffset = a *= l, t.pointRangePadding = h *= l, t.pointRange = Math.min(r, t.single && s ? 1 : e), o && n && (t.closestPointRange = n)), t.translationSlope = t.transA = d = t.staticScale || t.len / (e + h || 1), t.transB = t.horiz ? t.left : t.bottom, t.minPixelPadding = d * a, M(this, "afterSetAxisTranslation");
	      }
	      minFromRange() {
	        let {
	          max: t,
	          min: e
	        } = this;
	        return A(t) && A(e) && t - e || void 0;
	      }
	      setTickInterval(t) {
	        let {
	            categories: e,
	            chart: i,
	            dataMax: s,
	            dataMin: o,
	            dateTime: r,
	            isXAxis: n,
	            logarithmic: a,
	            options: h,
	            softThreshold: l
	          } = this,
	          d = A(this.threshold) ? this.threshold : void 0,
	          c = this.minRange || 0,
	          {
	            ceiling: p,
	            floor: u,
	            linkedTo: g,
	            softMax: f,
	            softMin: m
	          } = h,
	          b = A(g) && i[this.coll]?.[g],
	          v = h.tickPixelInterval,
	          k = h.maxPadding,
	          C = h.minPadding,
	          w = 0,
	          T,
	          P = A(h.tickInterval) && h.tickInterval >= 0 ? h.tickInterval : void 0,
	          L,
	          O,
	          D,
	          j;
	        if (r || e || b || this.getTickAmount(), D = E(this.userMin, h.min), j = E(this.userMax, h.max), b ? (this.linkedParent = b, T = b.getExtremes(), this.min = E(T.min, T.dataMin), this.max = E(T.max, T.dataMax), h.type !== b.options.type && S(11, !0, i)) : (l && y(d) && A(s) && A(o) && (o >= d ? (L = d, C = 0) : s <= d && (O = d, k = 0)), this.min = E(D, L, o), this.max = E(j, O, s)), A(this.max) && A(this.min) && (a && (this.positiveValuesOnly && !t && 0 >= Math.min(this.min, E(o, this.min)) && S(10, !0, i), this.min = x(a.log2lin(this.min), 16), this.max = x(a.log2lin(this.max), 16)), this.range && A(o) && (this.userMin = this.min = D = Math.max(o, this.minFromRange() || 0), this.userMax = j = this.max, this.range = void 0)), M(this, "foundExtremes"), this.adjustForMinRange(), A(this.min) && A(this.max)) {
	          if (!A(this.userMin) && A(m) && m < this.min && (this.min = D = m), !A(this.userMax) && A(f) && f > this.max && (this.max = j = f), e || this.axisPointRange || this.stacking?.usePercentage || b || !(w = this.max - this.min) || (!y(D) && C && (this.min -= w * C), y(j) || !k || (this.max += w * k)), !A(this.userMin) && A(u) && (this.min = Math.max(this.min, u)), !A(this.userMax) && A(p) && (this.max = Math.min(this.max, p)), l && A(o) && A(s)) {
	            let t = d || 0;
	            !y(D) && this.min < t && o >= t ? this.min = h.minRange ? Math.min(t, this.max - c) : t : !y(j) && this.max > t && s <= t && (this.max = h.minRange ? Math.max(t, this.min + c) : t);
	          }
	          !i.polar && this.min > this.max && (y(h.min) ? this.max = this.min : y(h.max) && (this.min = this.max)), w = this.max - this.min;
	        }
	        if (this.min !== this.max && A(this.min) && A(this.max) ? b && !P && v === b.options.tickPixelInterval ? this.tickInterval = P = b.tickInterval : this.tickInterval = E(P, this.tickAmount ? w / Math.max(this.tickAmount - 1, 1) : void 0, e ? 1 : w * v / Math.max(this.len, v)) : this.tickInterval = 1, n && !t) {
	          let t = this.min !== this.old?.min || this.max !== this.old?.max;
	          this.series.forEach(function (e) {
	            e.forceCrop = e.forceCropping?.(), e.processData(t);
	          }), M(this, "postProcessData", {
	            hasExtremesChanged: t
	          });
	        }
	        this.setAxisTranslation(), M(this, "initialAxisTranslation"), this.pointRange && !P && (this.tickInterval = Math.max(this.pointRange, this.tickInterval));
	        let I = E(h.minTickInterval, r && !this.series.some(t => t.noSharedTooltip) ? this.closestPointRange : 0);
	        !P && this.tickInterval < I && (this.tickInterval = I), r || a || P || (this.tickInterval = z(this, this.tickInterval)), this.tickAmount || (this.tickInterval = this.unsquish()), this.setTickPositions();
	      }
	      setTickPositions() {
	        let t = this.options,
	          e = t.tickPositions,
	          i = t.tickPositioner,
	          s = this.getMinorTickInterval(),
	          o = this.hasVerticalPanning(),
	          r = "colorAxis" === this.coll,
	          n = (r || !o) && t.startOnTick,
	          a = (r || !o) && t.endOnTick,
	          h = [],
	          l;
	        if (this.tickmarkOffset = this.categories && "between" === t.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0, this.minorTickInterval = "auto" === s && this.tickInterval ? this.tickInterval / t.minorTicksPerMajor : s, this.single = this.min === this.max && y(this.min) && !this.tickAmount && (this.min % 1 == 0 || !1 !== t.allowDecimals), e) h = e.slice();else if (A(this.min) && A(this.max)) {
	          if (!this.ordinal?.positions && (this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200)) h = [this.min, this.max], S(19, !1, this.chart);else if (this.dateTime) h = this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(this.tickInterval, t.units), this.min, this.max, t.startOfWeek, this.ordinal?.positions, this.closestPointRange, !0);else if (this.logarithmic) h = this.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max);else {
	            let t = this.tickInterval,
	              e = t;
	            for (; e <= 2 * t;) if (h = this.getLinearTickPositions(this.tickInterval, this.min, this.max), this.tickAmount && h.length > this.tickAmount) this.tickInterval = z(this, e *= 1.1);else break;
	          }
	          h.length > this.len && (h = [h[0], h[h.length - 1]])[0] === h[1] && (h.length = 1), i && (this.tickPositions = h, (l = i.apply(this, [this.min, this.max])) && (h = l));
	        }
	        this.tickPositions = h, this.paddedTicks = h.slice(0), this.trimTicks(h, n, a), !this.isLinked && A(this.min) && A(this.max) && (this.single && h.length < 2 && !this.categories && !this.series.some(t => t.is("heatmap") && "between" === t.options.pointPlacement) && (this.min -= .5, this.max += .5), e || l || this.adjustTickAmount()), M(this, "afterSetTickPositions");
	      }
	      trimTicks(t, e, i) {
	        let s = t[0],
	          o = t[t.length - 1],
	          r = !this.isOrdinal && this.minPointOffset || 0;
	        if (M(this, "trimTicks"), !this.isLinked) {
	          if (e && s !== -1 / 0) this.min = s;else for (; this.min - r > t[0];) t.shift();
	          if (i) this.max = o;else for (; this.max + r < t[t.length - 1];) t.pop();
	          0 === t.length && y(s) && !this.options.tickPositions && t.push((o + s) / 2);
	        }
	      }
	      alignToOthers() {
	        let t;
	        let e = this,
	          i = [this],
	          s = e.options,
	          o = this.chart.options.chart,
	          r = "yAxis" === this.coll && o.alignThresholds,
	          n = [];
	        if (e.thresholdAlignment = void 0, (!1 !== o.alignTicks && s.alignTicks || r) && !1 !== s.startOnTick && !1 !== s.endOnTick && !e.logarithmic) {
	          let s = t => {
	              let {
	                horiz: e,
	                options: i
	              } = t;
	              return [e ? i.left : i.top, i.width, i.height, i.pane].join(",");
	            },
	            o = s(this);
	          this.chart[this.coll].forEach(function (r) {
	            let {
	              series: n
	            } = r;
	            n.length && n.some(t => t.visible) && r !== e && s(r) === o && (t = !0, i.push(r));
	          });
	        }
	        if (t && r) {
	          i.forEach(t => {
	            let i = t.getThresholdAlignment(e);
	            A(i) && n.push(i);
	          });
	          let t = n.length > 1 ? n.reduce((t, e) => t += e, 0) / n.length : void 0;
	          i.forEach(e => {
	            e.thresholdAlignment = t;
	          });
	        }
	        return t;
	      }
	      getThresholdAlignment(t) {
	        if ((!A(this.dataMin) || this !== t && this.series.some(t => t.isDirty || t.isDirtyData)) && this.getSeriesExtremes(), A(this.threshold)) {
	          let t = m((this.threshold - (this.dataMin || 0)) / ((this.dataMax || 0) - (this.dataMin || 0)), 0, 1);
	          return this.options.reversed && (t = 1 - t), t;
	        }
	      }
	      getTickAmount() {
	        let t = this.options,
	          e = t.tickPixelInterval,
	          i = t.tickAmount;
	        y(t.tickInterval) || i || !(this.len < e) || this.isRadial || this.logarithmic || !t.startOnTick || !t.endOnTick || (i = 2), !i && this.alignToOthers() && (i = Math.ceil(this.len / e) + 1), i < 4 && (this.finalTickAmt = i, i = 5), this.tickAmount = i;
	      }
	      adjustTickAmount() {
	        let t = this,
	          {
	            finalTickAmt: e,
	            max: i,
	            min: s,
	            options: o,
	            tickPositions: r,
	            tickAmount: n,
	            thresholdAlignment: a
	          } = t,
	          h = r?.length,
	          l = E(t.threshold, t.softThreshold ? 0 : null),
	          d,
	          c,
	          p = t.tickInterval,
	          u,
	          g = () => r.push(x(r[r.length - 1] + p)),
	          f = () => r.unshift(x(r[0] - p));
	        if (A(a) && (u = a < .5 ? Math.ceil(a * (n - 1)) : Math.floor(a * (n - 1)), o.reversed && (u = n - 1 - u)), t.hasData() && A(s) && A(i)) {
	          let a = () => {
	            t.transA *= (h - 1) / (n - 1), t.min = o.startOnTick ? r[0] : Math.min(s, r[0]), t.max = o.endOnTick ? r[r.length - 1] : Math.max(i, r[r.length - 1]);
	          };
	          if (A(u) && A(t.threshold)) {
	            for (; r[u] !== l || r.length !== n || r[0] > s || r[r.length - 1] < i;) {
	              for (r.length = 0, r.push(t.threshold); r.length < n;) void 0 === r[u] || r[u] > t.threshold ? f() : g();
	              if (p > 8 * t.tickInterval) break;
	              p *= 2;
	            }
	            a();
	          } else if (h < n) {
	            for (; r.length < n;) r.length % 2 || s === l ? g() : f();
	            a();
	          }
	          if (y(e)) {
	            for (c = d = r.length; c--;) (3 === e && c % 2 == 1 || e <= 2 && c > 0 && c < d - 1) && r.splice(c, 1);
	            t.finalTickAmt = void 0;
	          }
	        }
	      }
	      setScale() {
	        let {
	            coll: t,
	            stacking: e
	          } = this,
	          i = !1,
	          s = !1;
	        this.series.forEach(t => {
	          i = i || t.isDirtyData || t.isDirty, s = s || t.xAxis && t.xAxis.isDirty || !1;
	        }), this.setAxisSize();
	        let o = this.len !== (this.old && this.old.len);
	        o || i || s || this.isLinked || this.forceRedraw || this.userMin !== (this.old && this.old.userMin) || this.userMax !== (this.old && this.old.userMax) || this.alignToOthers() ? (e && "yAxis" === t && e.buildStacks(), this.forceRedraw = !1, this.userMinRange || (this.minRange = void 0), this.getSeriesExtremes(), this.setTickInterval(), e && "xAxis" === t && e.buildStacks(), this.isDirty || (this.isDirty = o || this.min !== this.old?.min || this.max !== this.old?.max)) : e && e.cleanStacks(), i && this.panningState && (this.panningState.isDirty = !0), M(this, "afterSetScale");
	      }
	      setExtremes(t, e, i = !0, s, o) {
	        let r = this,
	          n = r.chart;
	        r.series.forEach(t => {
	          delete t.kdTree;
	        }), M(r, "setExtremes", o = k(o, {
	          min: t,
	          max: e
	        }), () => {
	          r.userMin = t, r.userMax = e, r.eventArgs = o, i && n.redraw(s);
	        });
	      }
	      zoom(t, e) {
	        let i = this,
	          s = this.dataMin,
	          o = this.dataMax,
	          r = this.options,
	          n = Math.min(s, E(r.min, s)),
	          a = Math.max(o, E(r.max, o)),
	          h = {
	            newMin: t,
	            newMax: e
	          };
	        return M(this, "zoom", h, function (t) {
	          let e = t.newMin,
	            r = t.newMax;
	          (e !== i.min || r !== i.max) && (!i.allowZoomOutside && (y(s) && (e < n && (e = n), e > a && (e = a)), y(o) && (r < n && (r = n), r > a && (r = a))), i.displayBtn = void 0 !== e || void 0 !== r, i.setExtremes(e, r, !1, void 0, {
	            trigger: "zoom"
	          })), t.zoomed = !0;
	        }), h.zoomed;
	      }
	      setAxisSize() {
	        let t = this.chart,
	          e = this.options,
	          i = e.offsets || [0, 0, 0, 0],
	          s = this.horiz,
	          o = this.width = Math.round(j(E(e.width, t.plotWidth - i[3] + i[1]), t.plotWidth)),
	          r = this.height = Math.round(j(E(e.height, t.plotHeight - i[0] + i[2]), t.plotHeight)),
	          n = this.top = Math.round(j(E(e.top, t.plotTop + i[0]), t.plotHeight, t.plotTop)),
	          a = this.left = Math.round(j(E(e.left, t.plotLeft + i[3]), t.plotWidth, t.plotLeft));
	        this.bottom = t.chartHeight - r - n, this.right = t.chartWidth - o - a, this.len = Math.max(s ? o : r, 0), this.pos = s ? a : n;
	      }
	      getExtremes() {
	        let t = this.logarithmic;
	        return {
	          min: t ? x(t.lin2log(this.min)) : this.min,
	          max: t ? x(t.lin2log(this.max)) : this.max,
	          dataMin: this.dataMin,
	          dataMax: this.dataMax,
	          userMin: this.userMin,
	          userMax: this.userMax
	        };
	      }
	      getThreshold(t) {
	        let e = this.logarithmic,
	          i = e ? e.lin2log(this.min) : this.min,
	          s = e ? e.lin2log(this.max) : this.max;
	        return null === t || t === -1 / 0 ? t = i : t === 1 / 0 ? t = s : i > t ? t = i : s < t && (t = s), this.translate(t, 0, 1, 0, 1);
	      }
	      autoLabelAlign(t) {
	        let e = (E(t, 0) - 90 * this.side + 720) % 360,
	          i = {
	            align: "center"
	          };
	        return M(this, "autoLabelAlign", i, function (t) {
	          e > 15 && e < 165 ? t.align = "right" : e > 195 && e < 345 && (t.align = "left");
	        }), i.align;
	      }
	      tickSize(t) {
	        let e = this.options,
	          i = E(e["tick" === t ? "tickWidth" : "minorTickWidth"], "tick" === t && this.isXAxis && !this.categories ? 1 : 0),
	          s = e["tick" === t ? "tickLength" : "minorTickLength"],
	          o;
	        i && s && ("inside" === e[t + "Position"] && (s = -s), o = [s, i]);
	        let r = {
	          tickSize: o
	        };
	        return M(this, "afterTickSize", r), r.tickSize;
	      }
	      labelMetrics() {
	        let t = this.chart.renderer,
	          e = this.ticks,
	          i = e[Object.keys(e)[0]] || {};
	        return this.chart.renderer.fontMetrics(i.label || i.movedLabel || t.box);
	      }
	      unsquish() {
	        let t = this.options.labels,
	          e = this.horiz,
	          i = this.tickInterval,
	          s = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / i),
	          o = t.rotation,
	          r = this.labelMetrics().h,
	          n = Math.max(this.max - this.min, 0),
	          a = function (t) {
	            let e = t / (s || 1);
	            return (e = e > 1 ? Math.ceil(e) : 1) * i > n && t !== 1 / 0 && s !== 1 / 0 && n && (e = Math.ceil(n / i)), x(e * i);
	          },
	          h = i,
	          l,
	          d = Number.MAX_VALUE,
	          c;
	        if (e) {
	          if (!t.staggerLines && (A(o) ? c = [o] : s < t.autoRotationLimit && (c = t.autoRotation)), c) {
	            let t, e;
	            for (let i of c) (i === o || i && i >= -90 && i <= 90) && (e = (t = a(Math.abs(r / Math.sin(u * i)))) + Math.abs(i / 360)) < d && (d = e, l = i, h = t);
	          }
	        } else h = a(.75 * r);
	        return this.autoRotation = c, this.labelRotation = E(l, A(o) ? o : 0), t.step ? i : h;
	      }
	      getSlotWidth(t) {
	        let e = this.chart,
	          i = this.horiz,
	          s = this.options.labels,
	          o = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),
	          r = e.margin[3];
	        if (t && A(t.slotWidth)) return t.slotWidth;
	        if (i && s.step < 2) return s.rotation ? 0 : (this.staggerLines || 1) * this.len / o;
	        if (!i) {
	          let t = s.style.width;
	          if (void 0 !== t) return parseInt(String(t), 10);
	          if (r) return r - e.spacing[3];
	        }
	        return .33 * e.chartWidth;
	      }
	      renderUnsquish() {
	        let t = this.chart,
	          e = t.renderer,
	          i = this.tickPositions,
	          s = this.ticks,
	          o = this.options.labels,
	          r = o.style,
	          n = this.horiz,
	          a = this.getSlotWidth(),
	          h = Math.max(1, Math.round(a - 2 * o.padding)),
	          l = {},
	          d = this.labelMetrics(),
	          c = r.textOverflow,
	          p,
	          u,
	          g = 0,
	          f,
	          m;
	        if (P(o.rotation) || (l.rotation = o.rotation || 0), i.forEach(function (t) {
	          let e = s[t];
	          e.movedLabel && e.replaceMovedLabel(), e && e.label && e.label.textPxLength > g && (g = e.label.textPxLength);
	        }), this.maxLabelLength = g, this.autoRotation) g > h && g > d.h ? l.rotation = this.labelRotation : this.labelRotation = 0;else if (a && (p = h, !c)) for (u = "clip", m = i.length; !n && m--;) (f = s[i[m]].label) && (f.styles && "ellipsis" === f.styles.textOverflow ? f.css({
	          textOverflow: "clip"
	        }) : f.textPxLength > a && f.css({
	          width: a + "px"
	        }), f.getBBox().height > this.len / i.length - (d.h - d.f) && (f.specificTextOverflow = "ellipsis"));
	        l.rotation && (p = g > .5 * t.chartHeight ? .33 * t.chartHeight : g, c || (u = "ellipsis")), this.labelAlign = o.align || this.autoLabelAlign(this.labelRotation), this.labelAlign && (l.align = this.labelAlign), i.forEach(function (t) {
	          let e = s[t],
	            i = e && e.label,
	            o = r.width,
	            n = {};
	          i && (i.attr(l), e.shortenLabel ? e.shortenLabel() : p && !o && "nowrap" !== r.whiteSpace && (p < i.textPxLength || "SPAN" === i.element.tagName) ? (n.width = p + "px", c || (n.textOverflow = i.specificTextOverflow || u), i.css(n)) : i.styles && i.styles.width && !n.width && !o && i.css({
	            width: null
	          }), delete i.specificTextOverflow, e.rotation = l.rotation);
	        }, this), this.tickRotCorr = e.rotCorr(d.b, this.labelRotation || 0, 0 !== this.side);
	      }
	      hasData() {
	        return this.series.some(function (t) {
	          return t.hasData();
	        }) || this.options.showEmpty && y(this.min) && y(this.max);
	      }
	      addTitle(t) {
	        let e;
	        let i = this.chart.renderer,
	          s = this.horiz,
	          o = this.opposite,
	          r = this.options,
	          n = r.title,
	          a = this.chart.styledMode;
	        this.axisTitle || ((e = n.textAlign) || (e = (s ? {
	          low: "left",
	          middle: "center",
	          high: "right"
	        } : {
	          low: o ? "right" : "left",
	          middle: "center",
	          high: o ? "left" : "right"
	        })[n.align]), this.axisTitle = i.text(n.text || "", 0, 0, n.useHTML).attr({
	          zIndex: 7,
	          rotation: n.rotation || 0,
	          align: e
	        }).addClass("highcharts-axis-title"), a || this.axisTitle.css(L(n.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = !0), a || n.style.width || this.isRadial || this.axisTitle.css({
	          width: this.len + "px"
	        }), this.axisTitle[t ? "show" : "hide"](t);
	      }
	      generateTick(t) {
	        let e = this.ticks;
	        e[t] ? e[t].addLabel() : e[t] = new n(this, t);
	      }
	      createGroups() {
	        let {
	            axisParent: t,
	            chart: e,
	            coll: i,
	            options: s
	          } = this,
	          o = e.renderer,
	          r = (e, r, n) => o.g(e).attr({
	            zIndex: n
	          }).addClass(`highcharts-${i.toLowerCase()}${r} ` + (this.isRadial ? `highcharts-radial-axis${r} ` : "") + (s.className || "")).add(t);
	        this.axisGroup || (this.gridGroup = r("grid", "-grid", s.gridZIndex), this.axisGroup = r("axis", "", s.zIndex), this.labelGroup = r("axis-labels", "-labels", s.labels.zIndex));
	      }
	      getOffset() {
	        let t = this,
	          {
	            chart: e,
	            horiz: i,
	            options: s,
	            side: o,
	            ticks: r,
	            tickPositions: n,
	            coll: a
	          } = t,
	          h = e.inverted && !t.isZAxis ? [1, 0, 3, 2][o] : o,
	          l = t.hasData(),
	          d = s.title,
	          c = s.labels,
	          p = A(s.crossing),
	          u = e.axisOffset,
	          g = e.clipOffset,
	          f = [-1, 1, 1, -1][o],
	          m,
	          x = 0,
	          b,
	          v = 0,
	          S = 0,
	          k,
	          C;
	        if (t.showAxis = m = l || s.showEmpty, t.staggerLines = t.horiz && c.staggerLines || void 0, t.createGroups(), l || t.isLinked ? (n.forEach(function (e) {
	          t.generateTick(e);
	        }), t.renderUnsquish(), t.reserveSpaceDefault = 0 === o || 2 === o || {
	          1: "left",
	          3: "right"
	        }[o] === t.labelAlign, E(c.reserveSpace, !p && null, "center" === t.labelAlign || null, t.reserveSpaceDefault) && n.forEach(function (t) {
	          S = Math.max(r[t].getLabelSize(), S);
	        }), t.staggerLines && (S *= t.staggerLines), t.labelOffset = S * (t.opposite ? -1 : 1)) : D(r, function (t, e) {
	          t.destroy(), delete r[e];
	        }), d?.text && !1 !== d.enabled && (t.addTitle(m), m && !p && !1 !== d.reserveSpace && (t.titleOffset = x = t.axisTitle.getBBox()[i ? "height" : "width"], v = y(b = d.offset) ? 0 : E(d.margin, i ? 5 : 10))), t.renderLine(), t.offset = f * E(s.offset, u[o] ? u[o] + (s.margin || 0) : 0), t.tickRotCorr = t.tickRotCorr || {
	          x: 0,
	          y: 0
	        }, C = 0 === o ? -t.labelMetrics().h : 2 === o ? t.tickRotCorr.y : 0, k = Math.abs(S) + v, S && (k -= C, k += f * (i ? E(c.y, t.tickRotCorr.y + f * c.distance) : E(c.x, f * c.distance))), t.axisTitleMargin = E(b, k), t.getMaxLabelDimensions && (t.maxLabelDimensions = t.getMaxLabelDimensions(r, n)), "colorAxis" !== a) {
	          let e = this.tickSize("tick");
	          u[o] = Math.max(u[o], (t.axisTitleMargin || 0) + x + f * t.offset, k, n && n.length && e ? e[0] + f * t.offset : 0);
	          let i = !t.axisLine || s.offset ? 0 : 2 * Math.floor(t.axisLine.strokeWidth() / 2);
	          g[h] = Math.max(g[h], i);
	        }
	        M(this, "afterGetOffset");
	      }
	      getLinePath(t) {
	        let e = this.chart,
	          i = this.opposite,
	          s = this.offset,
	          o = this.horiz,
	          r = this.left + (i ? this.width : 0) + s,
	          n = e.chartHeight - this.bottom - (i ? this.height : 0) + s;
	        return i && (t *= -1), e.renderer.crispLine([["M", o ? this.left : r, o ? n : this.top], ["L", o ? e.chartWidth - this.right : r, o ? n : e.chartHeight - this.bottom]], t);
	      }
	      renderLine() {
	        this.axisLine || (this.axisLine = this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({
	          stroke: this.options.lineColor,
	          "stroke-width": this.options.lineWidth,
	          zIndex: 7
	        }));
	      }
	      getTitlePosition(t) {
	        let e = this.horiz,
	          i = this.left,
	          s = this.top,
	          o = this.len,
	          r = this.options.title,
	          n = e ? i : s,
	          a = this.opposite,
	          h = this.offset,
	          l = r.x,
	          d = r.y,
	          c = this.chart.renderer.fontMetrics(t),
	          p = t ? Math.max(t.getBBox(!1, 0).height - c.h - 1, 0) : 0,
	          u = {
	            low: n + (e ? 0 : o),
	            middle: n + o / 2,
	            high: n + (e ? o : 0)
	          }[r.align],
	          g = (e ? s + this.height : i) + (e ? 1 : -1) * (a ? -1 : 1) * (this.axisTitleMargin || 0) + [-p, p, c.f, -p][this.side],
	          f = {
	            x: e ? u + l : g + (a ? this.width : 0) + h + l,
	            y: e ? g + d - (a ? this.height : 0) + h : u + d
	          };
	        return M(this, "afterGetTitlePosition", {
	          titlePosition: f
	        }), f;
	      }
	      renderMinorTick(t, e) {
	        let i = this.minorTicks;
	        i[t] || (i[t] = new n(this, t, "minor")), e && i[t].isNew && i[t].render(null, !0), i[t].render(null, !1, 1);
	      }
	      renderTick(t, e, i) {
	        let s = this.isLinked,
	          o = this.ticks;
	        (!s || t >= this.min && t <= this.max || this.grid && this.grid.isColumn) && (o[t] || (o[t] = new n(this, t)), i && o[t].isNew && o[t].render(e, !0, -1), o[t].render(e));
	      }
	      render() {
	        let t, e;
	        let i = this,
	          s = i.chart,
	          o = i.logarithmic,
	          a = s.renderer,
	          l = i.options,
	          d = i.isLinked,
	          c = i.tickPositions,
	          p = i.axisTitle,
	          u = i.ticks,
	          g = i.minorTicks,
	          f = i.alternateBands,
	          m = l.stackLabels,
	          x = l.alternateGridColor,
	          y = l.crossing,
	          b = i.tickmarkOffset,
	          v = i.axisLine,
	          S = i.showAxis,
	          k = h(a.globalAnimation);
	        if (i.labelEdge.length = 0, i.overlap = !1, [u, g, f].forEach(function (t) {
	          D(t, function (t) {
	            t.isActive = !1;
	          });
	        }), A(y)) {
	          let t = this.isXAxis ? s.yAxis[0] : s.xAxis[0],
	            e = [1, -1, -1, 1][this.side];
	          if (t) {
	            let s = t.toPixels(y, !0);
	            i.horiz && (s = t.len - s), i.offset = e * s;
	          }
	        }
	        if (i.hasData() || d) {
	          let a = i.chart.hasRendered && i.old && A(i.old.min);
	          i.minorTickInterval && !i.categories && i.getMinorTickPositions().forEach(function (t) {
	            i.renderMinorTick(t, a);
	          }), c.length && (c.forEach(function (t, e) {
	            i.renderTick(t, e, a);
	          }), b && (0 === i.min || i.single) && (u[-1] || (u[-1] = new n(i, -1, null, !0)), u[-1].render(-1))), x && c.forEach(function (n, a) {
	            e = void 0 !== c[a + 1] ? c[a + 1] + b : i.max - b, a % 2 == 0 && n < i.max && e <= i.max + (s.polar ? -b : b) && (f[n] || (f[n] = new r.PlotLineOrBand(i, {})), t = n + b, f[n].options = {
	              from: o ? o.lin2log(t) : t,
	              to: o ? o.lin2log(e) : e,
	              color: x,
	              className: "highcharts-alternate-grid"
	            }, f[n].render(), f[n].isActive = !0);
	          }), i._addedPlotLB || (i._addedPlotLB = !0, (l.plotLines || []).concat(l.plotBands || []).forEach(function (t) {
	            i.addPlotBandOrLine(t);
	          }));
	        }
	        [u, g, f].forEach(function (t) {
	          let e = [],
	            i = k.duration;
	          D(t, function (t, i) {
	            t.isActive || (t.render(i, !1, 0), t.isActive = !1, e.push(i));
	          }), R(function () {
	            let i = e.length;
	            for (; i--;) t[e[i]] && !t[e[i]].isActive && (t[e[i]].destroy(), delete t[e[i]]);
	          }, t !== f && s.hasRendered && i ? i : 0);
	        }), v && (v[v.isPlaced ? "animate" : "attr"]({
	          d: this.getLinePath(v.strokeWidth())
	        }), v.isPlaced = !0, v[S ? "show" : "hide"](S)), p && S && (p[p.isNew ? "attr" : "animate"](i.getTitlePosition(p)), p.isNew = !1), m && m.enabled && i.stacking && i.stacking.renderStackTotals(), i.old = {
	          len: i.len,
	          max: i.max,
	          min: i.min,
	          transA: i.transA,
	          userMax: i.userMax,
	          userMin: i.userMin
	        }, i.isDirty = !1, M(this, "afterRender");
	      }
	      redraw() {
	        this.visible && (this.render(), this.plotLinesAndBands.forEach(function (t) {
	          t.render();
	        })), this.series.forEach(function (t) {
	          t.isDirty = !0;
	        });
	      }
	      getKeepProps() {
	        return this.keepProps || N.keepProps;
	      }
	      destroy(t) {
	        let e = this,
	          i = e.plotLinesAndBands,
	          s = this.eventOptions;
	        if (M(this, "destroy", {
	          keepEvents: t
	        }), t || I(e), [e.ticks, e.minorTicks, e.alternateBands].forEach(function (t) {
	          b(t);
	        }), i) {
	          let t = i.length;
	          for (; t--;) i[t].destroy();
	        }
	        for (let t in ["axisLine", "axisTitle", "axisGroup", "gridGroup", "labelGroup", "cross", "scrollbar"].forEach(function (t) {
	          e[t] && (e[t] = e[t].destroy());
	        }), e.plotLinesAndBandsGroups) e.plotLinesAndBandsGroups[t] = e.plotLinesAndBandsGroups[t].destroy();
	        D(e, function (t, i) {
	          -1 === e.getKeepProps().indexOf(i) && delete e[i];
	        }), this.eventOptions = s;
	      }
	      drawCrosshair(t, e) {
	        let s = this.crosshair,
	          o = E(s && s.snap, !0),
	          r = this.chart,
	          n,
	          a,
	          h,
	          l = this.cross,
	          d;
	        if (M(this, "drawCrosshair", {
	          e: t,
	          point: e
	        }), t || (t = this.cross && this.cross.e), s && !1 !== (y(e) || !o)) {
	          if (o ? y(e) && (a = E("colorAxis" !== this.coll ? e.crosshairPos : null, this.isXAxis ? e.plotX : this.len - e.plotY)) : a = t && (this.horiz ? t.chartX - this.pos : this.len - t.chartY + this.pos), y(a) && (d = {
	            value: e && (this.isXAxis ? e.x : E(e.stackY, e.y)),
	            translatedValue: a
	          }, r.polar && k(d, {
	            isCrosshair: !0,
	            chartX: t && t.chartX,
	            chartY: t && t.chartY,
	            point: e
	          }), n = this.getPlotLinePath(d) || null), !y(n)) {
	            this.hideCrosshair();
	            return;
	          }
	          h = this.categories && !this.isRadial, l || (this.cross = l = r.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-" + (h ? "category " : "thin ") + (s.className || "")).attr({
	            zIndex: E(s.zIndex, 2)
	          }).add(), !r.styledMode && (l.attr({
	            stroke: s.color || (h ? i.parse("#ccd3ff").setOpacity(.25).get() : "#cccccc"),
	            "stroke-width": E(s.width, 1)
	          }).css({
	            "pointer-events": "none"
	          }), s.dashStyle && l.attr({
	            dashstyle: s.dashStyle
	          }))), l.show().attr({
	            d: n
	          }), h && !s.width && l.attr({
	            "stroke-width": this.transA
	          }), this.cross.e = t;
	        } else this.hideCrosshair();
	        M(this, "afterDrawCrosshair", {
	          e: t,
	          point: e
	        });
	      }
	      hideCrosshair() {
	        this.cross && this.cross.hide(), M(this, "afterHideCrosshair");
	      }
	      hasVerticalPanning() {
	        let t = this.chart.options.chart.panning;
	        return !!(t && t.enabled && /y/.test(t.type));
	      }
	      update(t, e) {
	        let i = this.chart;
	        t = L(this.userOptions, t), this.destroy(!0), this.init(i, t), i.isDirtyBox = !0, E(e, !0) && i.redraw();
	      }
	      remove(t) {
	        let e = this.chart,
	          i = this.coll,
	          s = this.series,
	          o = s.length;
	        for (; o--;) s[o] && s[o].remove(!1);
	        v(e.axes, this), v(e[i] || [], this), e.orderItems(i), this.destroy(), e.isDirtyBox = !0, E(t, !0) && e.redraw();
	      }
	      setTitle(t, e) {
	        this.update({
	          title: t
	        }, e);
	      }
	      setCategories(t, e) {
	        this.update({
	          categories: t
	        }, e);
	      }
	    }
	    return N.keepProps = ["coll", "extKey", "hcEvents", "names", "series", "userMax", "userMin"], N;
	  }), i(e, "Core/Axis/DateTimeAxis.js", [e["Core/Globals.js"], e["Core/Utilities.js"]], function (t, e) {
	    var i;
	    let {
	        composed: s
	      } = t,
	      {
	        addEvent: o,
	        getMagnitude: r,
	        normalizeTickInterval: n,
	        pushUnique: a,
	        timeUnits: h
	      } = e;
	    return function (t) {
	      function e() {
	        return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);
	      }
	      function i() {
	        if ("datetime" !== this.options.type) {
	          this.dateTime = void 0;
	          return;
	        }
	        this.dateTime || (this.dateTime = new l(this));
	      }
	      t.compose = function t(r) {
	        if (a(s, t)) {
	          r.keepProps.push("dateTime");
	          let t = r.prototype;
	          t.getTimeTicks = e, o(r, "afterSetOptions", i);
	        }
	        return r;
	      };
	      class l {
	        constructor(t) {
	          this.axis = t;
	        }
	        normalizeTimeTickInterval(t, e) {
	          let i = e || [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2]], ["week", [1, 2]], ["month", [1, 2, 3, 4, 6]], ["year", null]],
	            s = i[i.length - 1],
	            o = h[s[0]],
	            a = s[1],
	            l;
	          for (l = 0; l < i.length; l++) if (o = h[(s = i[l])[0]], a = s[1], i[l + 1]) {
	            let e = (o * a[a.length - 1] + h[i[l + 1][0]]) / 2;
	            if (t <= e) break;
	          }
	          o === h.year && t < 5 * o && (a = [1, 2, 5]);
	          let d = n(t / o, a, "year" === s[0] ? Math.max(r(t / o), 1) : 1);
	          return {
	            unitRange: o,
	            count: d,
	            unitName: s[0]
	          };
	        }
	        getXDateFormat(t, e) {
	          let {
	              axis: i
	            } = this,
	            s = i.chart.time;
	          return i.closestPointRange ? s.getDateFormat(i.closestPointRange, t, i.options.startOfWeek, e) || s.resolveDTLFormat(e.year).main : s.resolveDTLFormat(e.day).main;
	        }
	      }
	      t.Additions = l;
	    }(i || (i = {})), i;
	  }), i(e, "Core/Axis/LogarithmicAxis.js", [e["Core/Globals.js"], e["Core/Utilities.js"]], function (t, e) {
	    var i;
	    let {
	        composed: s
	      } = t,
	      {
	        addEvent: o,
	        normalizeTickInterval: r,
	        pick: n,
	        pushUnique: a
	      } = e;
	    return function (t) {
	      function e(t) {
	        let e = t.userOptions,
	          i = this.logarithmic;
	        "logarithmic" !== e.type ? this.logarithmic = void 0 : i || (i = this.logarithmic = new h(this));
	      }
	      function i() {
	        let t = this.logarithmic;
	        t && (this.lin2val = function (e) {
	          return t.lin2log(e);
	        }, this.val2lin = function (e) {
	          return t.log2lin(e);
	        });
	      }
	      t.compose = function t(r) {
	        return a(s, t) && (r.keepProps.push("logarithmic"), o(r, "init", e), o(r, "afterInit", i)), r;
	      };
	      class h {
	        constructor(t) {
	          this.axis = t;
	        }
	        getLogTickPositions(t, e, i, s) {
	          let o = this.axis,
	            a = o.len,
	            h = o.options,
	            l = [];
	          if (s || (this.minorAutoInterval = void 0), t >= .5) t = Math.round(t), l = o.getLinearTickPositions(t, e, i);else if (t >= .08) {
	            let o, r, n, a, h, d, c;
	            let p = Math.floor(e);
	            for (o = t > .3 ? [1, 2, 4] : t > .15 ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9], r = p; r < i + 1 && !c; r++) for (n = 0, a = o.length; n < a && !c; n++) (h = this.log2lin(this.lin2log(r) * o[n])) > e && (!s || d <= i) && void 0 !== d && l.push(d), d > i && (c = !0), d = h;
	          } else {
	            let d = this.lin2log(e),
	              c = this.lin2log(i),
	              p = s ? o.getMinorTickInterval() : h.tickInterval,
	              u = "auto" === p ? null : p,
	              g = h.tickPixelInterval / (s ? 5 : 1),
	              f = s ? a / o.tickPositions.length : a;
	            t = r(t = n(u, this.minorAutoInterval, (c - d) * g / (f || 1))), l = o.getLinearTickPositions(t, d, c).map(this.log2lin), s || (this.minorAutoInterval = t / 5);
	          }
	          return s || (o.tickInterval = t), l;
	        }
	        lin2log(t) {
	          return Math.pow(10, t);
	        }
	        log2lin(t) {
	          return Math.log(t) / Math.LN10;
	        }
	      }
	      t.Additions = h;
	    }(i || (i = {})), i;
	  }), i(e, "Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js", [e["Core/Globals.js"], e["Core/Utilities.js"]], function (t, e) {
	    var i;
	    let {
	        composed: s
	      } = t,
	      {
	        erase: o,
	        extend: r,
	        isNumber: n,
	        pushUnique: a
	      } = e;
	    return function (t) {
	      let e;
	      function i(t) {
	        return this.addPlotBandOrLine(t, "plotBands");
	      }
	      function h(t, i) {
	        let s = this.userOptions,
	          o = new e(this, t);
	        if (this.visible && (o = o.render()), o) {
	          if (this._addedPlotLB || (this._addedPlotLB = !0, (s.plotLines || []).concat(s.plotBands || []).forEach(t => {
	            this.addPlotBandOrLine(t);
	          })), i) {
	            let e = s[i] || [];
	            e.push(t), s[i] = e;
	          }
	          this.plotLinesAndBands.push(o);
	        }
	        return o;
	      }
	      function l(t) {
	        return this.addPlotBandOrLine(t, "plotLines");
	      }
	      function d(t, e, i) {
	        i = i || this.options;
	        let s = this.getPlotLinePath({
	            value: e,
	            force: !0,
	            acrossPanes: i.acrossPanes
	          }),
	          o = [],
	          r = this.horiz,
	          a = !n(this.min) || !n(this.max) || t < this.min && e < this.min || t > this.max && e > this.max,
	          h = this.getPlotLinePath({
	            value: t,
	            force: !0,
	            acrossPanes: i.acrossPanes
	          }),
	          l,
	          d = 1,
	          c;
	        if (h && s) for (a && (c = h.toString() === s.toString(), d = 0), l = 0; l < h.length; l += 2) {
	          let t = h[l],
	            e = h[l + 1],
	            i = s[l],
	            n = s[l + 1];
	          ("M" === t[0] || "L" === t[0]) && ("M" === e[0] || "L" === e[0]) && ("M" === i[0] || "L" === i[0]) && ("M" === n[0] || "L" === n[0]) && (r && i[1] === t[1] ? (i[1] += d, n[1] += d) : r || i[2] !== t[2] || (i[2] += d, n[2] += d), o.push(["M", t[1], t[2]], ["L", e[1], e[2]], ["L", n[1], n[2]], ["L", i[1], i[2]], ["Z"])), o.isFlat = c;
	        }
	        return o;
	      }
	      function c(t) {
	        this.removePlotBandOrLine(t);
	      }
	      function p(t) {
	        let e = this.plotLinesAndBands,
	          i = this.options,
	          s = this.userOptions;
	        if (e) {
	          let r = e.length;
	          for (; r--;) e[r].id === t && e[r].destroy();
	          [i.plotLines || [], s.plotLines || [], i.plotBands || [], s.plotBands || []].forEach(function (e) {
	            for (r = e.length; r--;) (e[r] || {}).id === t && o(e, e[r]);
	          });
	        }
	      }
	      function u(t) {
	        this.removePlotBandOrLine(t);
	      }
	      t.compose = function t(o, n) {
	        return a(s, t) && (e = o, r(n.prototype, {
	          addPlotBand: i,
	          addPlotLine: l,
	          addPlotBandOrLine: h,
	          getPlotBandPath: d,
	          removePlotBand: c,
	          removePlotLine: u,
	          removePlotBandOrLine: p
	        })), n;
	      };
	    }(i || (i = {})), i;
	  }), i(e, "Core/Axis/PlotLineOrBand/PlotLineOrBand.js", [e["Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js"], e["Core/Utilities.js"]], function (t, e) {
	    let {
	      arrayMax: i,
	      arrayMin: s,
	      defined: o,
	      destroyObjectProperties: r,
	      erase: n,
	      fireEvent: a,
	      merge: h,
	      objectEach: l,
	      pick: d
	    } = e;
	    class c {
	      static compose(e) {
	        return t.compose(c, e);
	      }
	      constructor(t, e) {
	        this.axis = t, this.options = e, this.id = e.id;
	      }
	      render() {
	        a(this, "render");
	        let {
	            axis: t,
	            options: e
	          } = this,
	          {
	            horiz: i,
	            logarithmic: s
	          } = t,
	          {
	            color: r,
	            events: n,
	            zIndex: c = 0
	          } = e,
	          p = {},
	          u = t.chart.renderer,
	          g = e.to,
	          f = e.from,
	          m = e.value,
	          x = e.borderWidth,
	          y = e.label,
	          {
	            label: b,
	            svgElem: v
	          } = this,
	          S = [],
	          k,
	          M = o(f) && o(g),
	          C = o(m),
	          w = !v,
	          T = {
	            class: "highcharts-plot-" + (M ? "band " : "line ") + (e.className || "")
	          },
	          A = M ? "bands" : "lines";
	        if (!t.chart.styledMode && (C ? (T.stroke = r || "#999999", T["stroke-width"] = d(e.width, 1), e.dashStyle && (T.dashstyle = e.dashStyle)) : M && (T.fill = r || "#e6e9ff", x && (T.stroke = e.borderColor, T["stroke-width"] = x))), p.zIndex = c, A += "-" + c, (k = t.plotLinesAndBandsGroups[A]) || (t.plotLinesAndBandsGroups[A] = k = u.g("plot-" + A).attr(p).add()), v || (this.svgElem = v = u.path().attr(T).add(k)), o(m)) S = t.getPlotLinePath({
	          value: s?.log2lin(m) ?? m,
	          lineWidth: v.strokeWidth(),
	          acrossPanes: e.acrossPanes
	        });else {
	          if (!(o(f) && o(g))) return;
	          S = t.getPlotBandPath(s?.log2lin(f) ?? f, s?.log2lin(g) ?? g, e);
	        }
	        return !this.eventsAdded && n && (l(n, (t, e) => {
	          v?.on(e, function (t) {
	            n[e].apply(this, [t]);
	          });
	        }), this.eventsAdded = !0), (w || !v.d) && S?.length ? v.attr({
	          d: S
	        }) : v && (S ? (v.show(), v.animate({
	          d: S
	        })) : v.d && (v.hide(), b && (this.label = b = b.destroy()))), y && (o(y.text) || o(y.formatter)) && S?.length && t.width > 0 && t.height > 0 && !S.isFlat ? (y = h({
	          align: i && M && "center",
	          x: i ? !M && 4 : 10,
	          verticalAlign: !i && M && "middle",
	          y: i ? M ? 16 : 10 : M ? 6 : -4,
	          rotation: i && !M && 90
	        }, y), this.renderLabel(y, S, M, c)) : b && b.hide(), this;
	      }
	      renderLabel(t, e, o, r) {
	        let n = this.axis,
	          a = n.chart.renderer,
	          l = this.label;
	        l || (this.label = l = a.text(this.getLabelText(t), 0, 0, t.useHTML).attr({
	          align: t.textAlign || t.align,
	          rotation: t.rotation,
	          class: "highcharts-plot-" + (o ? "band" : "line") + "-label" + (t.className || ""),
	          zIndex: r
	        }), n.chart.styledMode || l.css(h({
	          fontSize: "0.8em",
	          textOverflow: "ellipsis"
	        }, t.style)), l.add());
	        let d = e.xBounds || [e[0][1], e[1][1], o ? e[2][1] : e[0][1]],
	          c = e.yBounds || [e[0][2], e[1][2], o ? e[2][2] : e[0][2]],
	          p = s(d),
	          u = s(c);
	        if (l.align(t, !1, {
	          x: p,
	          y: u,
	          width: i(d) - p,
	          height: i(c) - u
	        }), !l.alignValue || "left" === l.alignValue) {
	          let e = t.clip ? n.width : n.chart.chartWidth;
	          l.css({
	            width: (90 === l.rotation ? n.height - (l.alignAttr.y - n.top) : e - (l.alignAttr.x - n.left)) + "px"
	          });
	        }
	        l.show(!0);
	      }
	      getLabelText(t) {
	        return o(t.formatter) ? t.formatter.call(this) : t.text;
	      }
	      destroy() {
	        n(this.axis.plotLinesAndBands, this), delete this.axis, r(this);
	      }
	    }
	    return c;
	  }), i(e, "Core/Tooltip.js", [e["Core/Templating.js"], e["Core/Globals.js"], e["Core/Renderer/RendererUtilities.js"], e["Core/Renderer/RendererRegistry.js"], e["Core/Utilities.js"]], function (t, e, i, s, o) {
	    var r;
	    let {
	        format: n
	      } = t,
	      {
	        composed: a,
	        doc: h,
	        isSafari: l
	      } = e,
	      {
	        distribute: d
	      } = i,
	      {
	        addEvent: c,
	        clamp: p,
	        css: u,
	        discardElement: g,
	        extend: f,
	        fireEvent: m,
	        isArray: x,
	        isNumber: y,
	        isString: b,
	        merge: v,
	        pick: S,
	        pushUnique: k,
	        splat: M,
	        syncTimeout: C
	      } = o;
	    class w {
	      constructor(t, e) {
	        this.allowShared = !0, this.crosshairs = [], this.distance = 0, this.isHidden = !0, this.isSticky = !1, this.now = {}, this.options = {}, this.outside = !1, this.chart = t, this.init(t, e);
	      }
	      bodyFormatter(t) {
	        return t.map(function (t) {
	          let e = t.series.tooltipOptions;
	          return (e[(t.point.formatPrefix || "point") + "Formatter"] || t.point.tooltipFormatter).call(t.point, e[(t.point.formatPrefix || "point") + "Format"] || "");
	        });
	      }
	      cleanSplit(t) {
	        this.chart.series.forEach(function (e) {
	          let i = e && e.tt;
	          i && (!i.isActive || t ? e.tt = i.destroy() : i.isActive = !1);
	        });
	      }
	      defaultFormatter(t) {
	        let e;
	        let i = this.points || M(this);
	        return (e = (e = [t.tooltipFooterHeaderFormatter(i[0])]).concat(t.bodyFormatter(i))).push(t.tooltipFooterHeaderFormatter(i[0], !0)), e;
	      }
	      destroy() {
	        this.label && (this.label = this.label.destroy()), this.split && (this.cleanSplit(!0), this.tt && (this.tt = this.tt.destroy())), this.renderer && (this.renderer = this.renderer.destroy(), g(this.container)), o.clearTimeout(this.hideTimer), o.clearTimeout(this.tooltipTimeout);
	      }
	      getAnchor(t, e) {
	        let i;
	        let s = this.chart,
	          o = s.pointer,
	          r = s.inverted,
	          n = s.plotTop,
	          a = s.plotLeft;
	        if ((t = M(t))[0].series && t[0].series.yAxis && !t[0].series.yAxis.options.reversedStacks && (t = t.slice().reverse()), this.followPointer && e) void 0 === e.chartX && (e = o.normalize(e)), i = [e.chartX - a, e.chartY - n];else if (t[0].tooltipPos) i = t[0].tooltipPos;else {
	          let s = 0,
	            o = 0;
	          t.forEach(function (t) {
	            let e = t.pos(!0);
	            e && (s += e[0], o += e[1]);
	          }), s /= t.length, o /= t.length, this.shared && t.length > 1 && e && (r ? s = e.chartX : o = e.chartY), i = [s - a, o - n];
	        }
	        return i.map(Math.round);
	      }
	      getClassName(t, e, i) {
	        let s = this.options,
	          o = t.series,
	          r = o.options;
	        return [s.className, "highcharts-label", i && "highcharts-tooltip-header", e ? "highcharts-tooltip-box" : "highcharts-tooltip", !i && "highcharts-color-" + S(t.colorIndex, o.colorIndex), r && r.className].filter(b).join(" ");
	      }
	      getLabel() {
	        let t = this,
	          i = this.chart.styledMode,
	          o = this.options,
	          r = this.split && this.allowShared,
	          n = this.container,
	          a = this.chart.renderer;
	        if (this.label) {
	          let t = !this.label.hasClass("highcharts-label");
	          (!r && t || r && !t) && this.destroy();
	        }
	        if (!this.label) {
	          if (this.outside) {
	            let t = this.chart.options.chart.style,
	              i = s.getRendererType();
	            this.container = n = e.doc.createElement("div"), n.className = "highcharts-tooltip-container", u(n, {
	              position: "absolute",
	              top: "1px",
	              pointerEvents: "none",
	              zIndex: Math.max(this.options.style.zIndex || 0, (t && t.zIndex || 0) + 3)
	            }), this.renderer = a = new i(n, 0, 0, t, void 0, void 0, a.styledMode);
	          }
	          if (r ? this.label = a.g("tooltip") : (this.label = a.label("", 0, 0, o.shape, void 0, void 0, o.useHTML, void 0, "tooltip").attr({
	            padding: o.padding,
	            r: o.borderRadius
	          }), i || this.label.attr({
	            fill: o.backgroundColor,
	            "stroke-width": o.borderWidth || 0
	          }).css(o.style).css({
	            pointerEvents: o.style.pointerEvents || (this.shouldStickOnContact() ? "auto" : "none")
	          })), t.outside) {
	            let e = this.label,
	              {
	                xSetter: i,
	                ySetter: s
	              } = e;
	            e.xSetter = function (s) {
	              i.call(e, t.distance), n && (n.style.left = s + "px");
	            }, e.ySetter = function (i) {
	              s.call(e, t.distance), n && (n.style.top = i + "px");
	            };
	          }
	          this.label.attr({
	            zIndex: 8
	          }).shadow(o.shadow).add();
	        }
	        return n && !n.parentElement && e.doc.body.appendChild(n), this.label;
	      }
	      getPlayingField() {
	        let {
	            body: t,
	            documentElement: e
	          } = h,
	          {
	            chart: i,
	            distance: s,
	            outside: o
	          } = this;
	        return {
	          width: o ? Math.max(t.scrollWidth, e.scrollWidth, t.offsetWidth, e.offsetWidth, e.clientWidth) - 2 * s : i.chartWidth,
	          height: o ? Math.max(t.scrollHeight, e.scrollHeight, t.offsetHeight, e.offsetHeight, e.clientHeight) : i.chartHeight
	        };
	      }
	      getPosition(t, e, i) {
	        let {
	            distance: s,
	            chart: o,
	            outside: r
	          } = this,
	          {
	            inverted: n,
	            plotLeft: a,
	            plotTop: h,
	            polar: l
	          } = o,
	          {
	            plotX: d = 0,
	            plotY: c = 0
	          } = i,
	          p = {},
	          u = n && i.h || 0,
	          {
	            height: g,
	            width: f
	          } = this.getPlayingField(),
	          m = o.pointer.getChartPosition(),
	          x = t => t * m.scaleX,
	          y = t => t * m.scaleY,
	          b = i => {
	            let n = "x" === i;
	            return [i, n ? f : g, n ? t : e].concat(r ? [n ? x(t) : y(e), n ? m.left - s + x(d + a) : m.top - s + y(c + h), 0, n ? f : g] : [n ? t : e, n ? d + a : c + h, n ? a : h, n ? a + o.plotWidth : h + o.plotHeight]);
	          },
	          v = b("y"),
	          k = b("x"),
	          M,
	          C = !!i.negative;
	        !l && o.hoverSeries?.yAxis?.reversed && (C = !C);
	        let w = !this.followPointer && S(i.ttBelow, !l && !n === C),
	          T = function (t, e, i, o, n, a, h) {
	            let l = r ? "y" === t ? y(s) : x(s) : s,
	              d = (i - o) / 2,
	              c = o < n - s,
	              g = n + s + o < e,
	              f = n - l - i + d,
	              m = n + l - d;
	            if (w && g) p[t] = m;else if (!w && c) p[t] = f;else if (c) p[t] = Math.min(h - o, f - u < 0 ? f : f - u);else {
	              if (!g) return !1;
	              p[t] = Math.max(a, m + u + i > e ? m : m + u);
	            }
	          },
	          A = function (t, e, i, o, r) {
	            if (r < s || r > e - s) return !1;
	            r < i / 2 ? p[t] = 1 : r > e - o / 2 ? p[t] = e - o - 2 : p[t] = r - i / 2;
	          },
	          P = function (t) {
	            [v, k] = [k, v], M = t;
	          },
	          L = () => {
	            !1 !== T.apply(0, v) ? !1 !== A.apply(0, k) || M || (P(!0), L()) : M ? p.x = p.y = 0 : (P(!0), L());
	          };
	        return (n && !l || this.len > 1) && P(), L(), p;
	      }
	      hide(t) {
	        let e = this;
	        o.clearTimeout(this.hideTimer), t = S(t, this.options.hideDelay), this.isHidden || (this.hideTimer = C(function () {
	          let i = e.getLabel();
	          e.getLabel().animate({
	            opacity: 0
	          }, {
	            duration: t ? 150 : t,
	            complete: () => {
	              i.hide(), e.container && e.container.remove();
	            }
	          }), e.isHidden = !0;
	        }, t));
	      }
	      init(t, e) {
	        this.chart = t, this.options = e, this.crosshairs = [], this.now = {
	          x: 0,
	          y: 0
	        }, this.isHidden = !0, this.split = e.split && !t.inverted && !t.polar, this.shared = e.shared || this.split, this.outside = S(e.outside, !!(t.scrollablePixelsX || t.scrollablePixelsY));
	      }
	      shouldStickOnContact(t) {
	        return !!(!this.followPointer && this.options.stickOnContact && (!t || this.chart.pointer.inClass(t.target, "highcharts-tooltip")));
	      }
	      move(t, e, i, s) {
	        let r = this,
	          n = r.now,
	          a = !1 !== r.options.animation && !r.isHidden && (Math.abs(t - n.x) > 1 || Math.abs(e - n.y) > 1),
	          h = r.followPointer || r.len > 1;
	        f(n, {
	          x: a ? (2 * n.x + t) / 3 : t,
	          y: a ? (n.y + e) / 2 : e,
	          anchorX: h ? void 0 : a ? (2 * n.anchorX + i) / 3 : i,
	          anchorY: h ? void 0 : a ? (n.anchorY + s) / 2 : s
	        }), r.getLabel().attr(n), r.drawTracker(), a && (o.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function () {
	          r && r.move(t, e, i, s);
	        }, 32));
	      }
	      refresh(t, e) {
	        let i = this.chart,
	          s = this.options,
	          r = i.pointer,
	          a = M(t),
	          h = a[0],
	          l = [],
	          d = s.format,
	          c = s.formatter || this.defaultFormatter,
	          p = this.shared,
	          u = i.styledMode,
	          g = {};
	        if (!s.enabled || !h.series) return;
	        o.clearTimeout(this.hideTimer), this.allowShared = !(!x(t) && t.series && t.series.noSharedTooltip), this.followPointer = !this.split && h.series.tooltipOptions.followPointer;
	        let f = this.getAnchor(t, e),
	          y = f[0],
	          v = f[1];
	        p && this.allowShared ? (r.applyInactiveState(a), a.forEach(function (t) {
	          t.setState("hover"), l.push(t.getLabelConfig());
	        }), (g = h.getLabelConfig()).points = l) : g = h.getLabelConfig(), this.len = l.length;
	        let k = b(d) ? n(d, g, i) : c.call(g, this),
	          C = h.series;
	        if (this.distance = S(C.tooltipOptions.distance, 16), !1 === k) this.hide();else {
	          if (this.split && this.allowShared) this.renderSplit(k, a);else {
	            let t = y,
	              o = v;
	            if (e && r.isDirectTouch && (t = e.chartX - i.plotLeft, o = e.chartY - i.plotTop), i.polar || !1 === C.options.clip || a.some(e => r.isDirectTouch || e.series.shouldShowTooltip(t, o))) {
	              let t = this.getLabel();
	              (!s.style.width || u) && t.css({
	                width: (this.outside ? this.getPlayingField() : i.spacingBox).width + "px"
	              }), t.attr({
	                text: k && k.join ? k.join("") : k
	              }), t.addClass(this.getClassName(h), !0), u || t.attr({
	                stroke: s.borderColor || h.color || C.color || "#666666"
	              }), this.updatePosition({
	                plotX: y,
	                plotY: v,
	                negative: h.negative,
	                ttBelow: h.ttBelow,
	                h: f[2] || 0
	              });
	            } else {
	              this.hide();
	              return;
	            }
	          }
	          this.isHidden && this.label && this.label.attr({
	            opacity: 1
	          }).show(), this.isHidden = !1;
	        }
	        m(this, "refresh");
	      }
	      renderSplit(t, e) {
	        let i = this,
	          {
	            chart: s,
	            chart: {
	              chartWidth: o,
	              chartHeight: r,
	              plotHeight: n,
	              plotLeft: a,
	              plotTop: c,
	              pointer: u,
	              scrollablePixelsY: g = 0,
	              scrollablePixelsX: m,
	              scrollingContainer: {
	                scrollLeft: x,
	                scrollTop: y
	              } = {
	                scrollLeft: 0,
	                scrollTop: 0
	              },
	              styledMode: v
	            },
	            distance: k,
	            options: M,
	            options: {
	              positioner: C
	            }
	          } = i,
	          w = i.outside && "number" != typeof m ? h.documentElement.getBoundingClientRect() : {
	            left: x,
	            right: x + o,
	            top: y,
	            bottom: y + r
	          },
	          T = i.getLabel(),
	          A = this.renderer || s.renderer,
	          P = !!(s.xAxis[0] && s.xAxis[0].opposite),
	          {
	            left: L,
	            top: O
	          } = u.getChartPosition(),
	          D = c + y,
	          E = 0,
	          j = n - g;
	        function I(t, e, s, o, r = !0) {
	          let n, a;
	          return s ? (n = P ? 0 : j, a = p(t - o / 2, w.left, w.right - o - (i.outside ? L : 0))) : (n = e - D, a = p(a = r ? t - o - k : t + k, r ? a : w.left, w.right)), {
	            x: a,
	            y: n
	          };
	        }
	        b(t) && (t = [!1, t]);
	        let B = t.slice(0, e.length + 1).reduce(function (t, s, o) {
	          if (!1 !== s && "" !== s) {
	            let r = e[o - 1] || {
	                isHeader: !0,
	                plotX: e[0].plotX,
	                plotY: n,
	                series: {}
	              },
	              h = r.isHeader,
	              l = h ? i : r.series,
	              d = l.tt = function (t, e, s) {
	                let o = t,
	                  {
	                    isHeader: r,
	                    series: n
	                  } = e;
	                if (!o) {
	                  let t = {
	                    padding: M.padding,
	                    r: M.borderRadius
	                  };
	                  v || (t.fill = M.backgroundColor, t["stroke-width"] = M.borderWidth ?? 1), o = A.label("", 0, 0, M[r ? "headerShape" : "shape"], void 0, void 0, M.useHTML).addClass(i.getClassName(e, !0, r)).attr(t).add(T);
	                }
	                return o.isActive = !0, o.attr({
	                  text: s
	                }), v || o.css(M.style).attr({
	                  stroke: M.borderColor || e.color || n.color || "#333333"
	                }), o;
	              }(l.tt, r, s.toString()),
	              u = d.getBBox(),
	              g = u.width + d.strokeWidth();
	            h && (E = u.height, j += E, P && (D -= E));
	            let {
	              anchorX: f,
	              anchorY: m
	            } = function (t) {
	              let e, i;
	              let {
	                isHeader: s,
	                plotX: o = 0,
	                plotY: r = 0,
	                series: h
	              } = t;
	              if (s) e = Math.max(a + o, a), i = c + n / 2;else {
	                let {
	                  xAxis: t,
	                  yAxis: s
	                } = h;
	                e = t.pos + p(o, -k, t.len + k), h.shouldShowTooltip(0, s.pos - c + r, {
	                  ignoreX: !0
	                }) && (i = s.pos + r);
	              }
	              return {
	                anchorX: e = p(e, w.left - k, w.right + k),
	                anchorY: i
	              };
	            }(r);
	            if ("number" == typeof m) {
	              let e = u.height + 1,
	                s = C ? C.call(i, g, e, r) : I(f, m, h, g);
	              t.push({
	                align: C ? 0 : void 0,
	                anchorX: f,
	                anchorY: m,
	                boxWidth: g,
	                point: r,
	                rank: S(s.rank, h ? 1 : 0),
	                size: e,
	                target: s.y,
	                tt: d,
	                x: s.x
	              });
	            } else d.isActive = !1;
	          }
	          return t;
	        }, []);
	        !C && B.some(t => {
	          let {
	              outside: e
	            } = i,
	            s = (e ? L : 0) + t.anchorX;
	          return s < w.left && s + t.boxWidth < w.right || s < L - w.left + t.boxWidth && w.right - s > s;
	        }) && (B = B.map(t => {
	          let {
	            x: e,
	            y: i
	          } = I(t.anchorX, t.anchorY, t.point.isHeader, t.boxWidth, !1);
	          return f(t, {
	            target: i,
	            x: e
	          });
	        })), i.cleanSplit(), d(B, j);
	        let R = {
	          left: L,
	          right: L
	        };
	        B.forEach(function (t) {
	          let {
	            x: e,
	            boxWidth: s,
	            isHeader: o
	          } = t;
	          !o && (i.outside && L + e < R.left && (R.left = L + e), !o && i.outside && R.left + s > R.right && (R.right = L + e));
	        }), B.forEach(function (t) {
	          let {
	              x: e,
	              anchorX: s,
	              anchorY: o,
	              pos: r,
	              point: {
	                isHeader: n
	              }
	            } = t,
	            a = {
	              visibility: void 0 === r ? "hidden" : "inherit",
	              x: e,
	              y: (r || 0) + D,
	              anchorX: s,
	              anchorY: o
	            };
	          if (i.outside && e < s) {
	            let t = L - R.left;
	            t > 0 && (n || (a.x = e + t, a.anchorX = s + t), n && (a.x = (R.right - R.left) / 2, a.anchorX = s + t));
	          }
	          t.tt.attr(a);
	        });
	        let {
	          container: z,
	          outside: N,
	          renderer: W
	        } = i;
	        if (N && z && W) {
	          let {
	            width: t,
	            height: e,
	            x: i,
	            y: s
	          } = T.getBBox();
	          W.setSize(t + i, e + s, !1), z.style.left = R.left + "px", z.style.top = O + "px";
	        }
	        l && T.attr({
	          opacity: 1 === T.opacity ? .999 : 1
	        });
	      }
	      drawTracker() {
	        if (!this.shouldStickOnContact()) {
	          this.tracker && (this.tracker = this.tracker.destroy());
	          return;
	        }
	        let t = this.chart,
	          e = this.label,
	          i = this.shared ? t.hoverPoints : t.hoverPoint;
	        if (!e || !i) return;
	        let s = {
	            x: 0,
	            y: 0,
	            width: 0,
	            height: 0
	          },
	          o = this.getAnchor(i),
	          r = e.getBBox();
	        o[0] += t.plotLeft - (e.translateX || 0), o[1] += t.plotTop - (e.translateY || 0), s.x = Math.min(0, o[0]), s.y = Math.min(0, o[1]), s.width = o[0] < 0 ? Math.max(Math.abs(o[0]), r.width - o[0]) : Math.max(Math.abs(o[0]), r.width), s.height = o[1] < 0 ? Math.max(Math.abs(o[1]), r.height - Math.abs(o[1])) : Math.max(Math.abs(o[1]), r.height), this.tracker ? this.tracker.attr(s) : (this.tracker = e.renderer.rect(s).addClass("highcharts-tracker").add(e), t.styledMode || this.tracker.attr({
	          fill: "rgba(0,0,0,0)"
	        }));
	      }
	      styledModeFormat(t) {
	        return t.replace('style="font-size: 0.8em"', 'class="highcharts-header"').replace(/style="color:{(point|series)\.color}"/g, 'class="highcharts-color-{$1.colorIndex} {series.options.className} {point.options.className}"');
	      }
	      tooltipFooterHeaderFormatter(t, e) {
	        let i = t.series,
	          s = i.tooltipOptions,
	          o = i.xAxis,
	          r = o && o.dateTime,
	          a = {
	            isFooter: e,
	            labelConfig: t
	          },
	          h = s.xDateFormat,
	          l = s[e ? "footerFormat" : "headerFormat"];
	        return m(this, "headerFormatter", a, function (e) {
	          r && !h && y(t.key) && (h = r.getXDateFormat(t.key, s.dateTimeLabelFormats)), r && h && (t.point && t.point.tooltipDateKeys || ["key"]).forEach(function (t) {
	            l = l.replace("{point." + t + "}", "{point." + t + ":" + h + "}");
	          }), i.chart.styledMode && (l = this.styledModeFormat(l)), e.text = n(l, {
	            point: t,
	            series: i
	          }, this.chart);
	        }), a.text;
	      }
	      update(t) {
	        this.destroy(), this.init(this.chart, v(!0, this.options, t));
	      }
	      updatePosition(t) {
	        let {
	            chart: e,
	            container: i,
	            distance: s,
	            options: o,
	            renderer: r
	          } = this,
	          {
	            height: n = 0,
	            width: a = 0
	          } = this.getLabel(),
	          h = e.pointer,
	          {
	            left: l,
	            top: d,
	            scaleX: c,
	            scaleY: p
	          } = h.getChartPosition(),
	          g = (o.positioner || this.getPosition).call(this, a, n, t),
	          f = (t.plotX || 0) + e.plotLeft,
	          m = (t.plotY || 0) + e.plotTop,
	          x;
	        r && i && (o.positioner && (g.x += l - s, g.y += d - s), x = (o.borderWidth || 0) + 2 * s + 2, r.setSize(a + x, n + x, !1), (1 !== c || 1 !== p) && (u(i, {
	          transform: `scale(${c}, ${p})`
	        }), f *= c, m *= p), f += l - g.x, m += d - g.y), this.move(Math.round(g.x), Math.round(g.y || 0), f, m);
	      }
	    }
	    return (r = w || (w = {})).compose = function t(e) {
	      k(a, t) && c(e, "afterInit", function () {
	        let t = this.chart;
	        t.options.tooltip && (t.tooltip = new r(t, t.options.tooltip));
	      });
	    }, w;
	  }), i(e, "Core/Series/Point.js", [e["Core/Renderer/HTML/AST.js"], e["Core/Animation/AnimationUtilities.js"], e["Core/Defaults.js"], e["Core/Templating.js"], e["Core/Utilities.js"]], function (t, e, i, s, o) {
	    let {
	        animObject: r
	      } = e,
	      {
	        defaultOptions: n
	      } = i,
	      {
	        format: a
	      } = s,
	      {
	        addEvent: h,
	        defined: l,
	        erase: d,
	        extend: c,
	        fireEvent: p,
	        getNestedProperty: u,
	        isArray: g,
	        isFunction: f,
	        isNumber: m,
	        isObject: x,
	        merge: y,
	        objectEach: b,
	        pick: v,
	        syncTimeout: S,
	        removeEvent: k,
	        uniqueKey: M
	      } = o;
	    class C {
	      animateBeforeDestroy() {
	        let t = this,
	          e = {
	            x: t.startXPos,
	            opacity: 0
	          },
	          i = t.getGraphicalProps();
	        i.singular.forEach(function (i) {
	          t[i] = t[i].animate("dataLabel" === i ? {
	            x: t[i].startXPos,
	            y: t[i].startYPos,
	            opacity: 0
	          } : e);
	        }), i.plural.forEach(function (e) {
	          t[e].forEach(function (e) {
	            e.element && e.animate(c({
	              x: t.startXPos
	            }, e.startYPos ? {
	              x: e.startXPos,
	              y: e.startYPos
	            } : {}));
	          });
	        });
	      }
	      applyOptions(t, e) {
	        let i = this.series,
	          s = i.options.pointValKey || i.pointValKey;
	        return c(this, t = C.prototype.optionsToObject.call(this, t)), this.options = this.options ? c(this.options, t) : t, t.group && delete this.group, t.dataLabels && delete this.dataLabels, s && (this.y = C.prototype.getNestedProperty.call(this, s)), this.selected && (this.state = "select"), "name" in this && void 0 === e && i.xAxis && i.xAxis.hasNames && (this.x = i.xAxis.nameToX(this)), void 0 === this.x && i ? void 0 === e ? this.x = i.autoIncrement() : this.x = e : m(t.x) && i.options.relativeXValue && (this.x = i.autoIncrement(t.x)), this.isNull = this.isValid && !this.isValid(), this.formatPrefix = this.isNull ? "null" : "point", this;
	      }
	      destroy() {
	        if (!this.destroyed) {
	          let t = this,
	            e = t.series,
	            i = e.chart,
	            s = e.options.dataSorting,
	            o = i.hoverPoints,
	            n = t.series.chart.renderer.globalAnimation,
	            a = r(n),
	            h = () => {
	              for (let e in (t.graphic || t.graphics || t.dataLabel || t.dataLabels) && (k(t), t.destroyElements()), t) delete t[e];
	            };
	          t.legendItem && i.legend.destroyItem(t), o && (t.setState(), d(o, t), o.length || (i.hoverPoints = null)), t === i.hoverPoint && t.onMouseOut(), s && s.enabled ? (this.animateBeforeDestroy(), S(h, a.duration)) : h(), i.pointCount--;
	        }
	        this.destroyed = !0;
	      }
	      destroyElements(t) {
	        let e = this,
	          i = e.getGraphicalProps(t);
	        i.singular.forEach(function (t) {
	          e[t] = e[t].destroy();
	        }), i.plural.forEach(function (t) {
	          e[t].forEach(function (t) {
	            t && t.element && t.destroy();
	          }), delete e[t];
	        });
	      }
	      firePointEvent(t, e, i) {
	        let s = this,
	          o = this.series,
	          r = o.options;
	        (r.point.events[t] || s.options && s.options.events && s.options.events[t]) && s.importEvents(), "click" === t && r.allowPointSelect && (i = function (t) {
	          !s.destroyed && s.select && s.select(null, t.ctrlKey || t.metaKey || t.shiftKey);
	        }), p(s, t, e, i);
	      }
	      getClassName() {
	        return "highcharts-point" + (this.selected ? " highcharts-point-select" : "") + (this.negative ? " highcharts-negative" : "") + (this.isNull ? " highcharts-null-point" : "") + (void 0 !== this.colorIndex ? " highcharts-color-" + this.colorIndex : "") + (this.options.className ? " " + this.options.className : "") + (this.zone && this.zone.className ? " " + this.zone.className.replace("highcharts-negative", "") : "");
	      }
	      getGraphicalProps(t) {
	        let e, i;
	        let s = this,
	          o = [],
	          r = {
	            singular: [],
	            plural: []
	          };
	        for ((t = t || {
	          graphic: 1,
	          dataLabel: 1
	        }).graphic && o.push("graphic", "connector"), t.dataLabel && o.push("dataLabel", "dataLabelPath", "dataLabelUpper"), i = o.length; i--;) s[e = o[i]] && r.singular.push(e);
	        return ["graphic", "dataLabel"].forEach(function (e) {
	          let i = e + "s";
	          t[e] && s[i] && r.plural.push(i);
	        }), r;
	      }
	      getLabelConfig() {
	        return {
	          x: this.category,
	          y: this.y,
	          color: this.color,
	          colorIndex: this.colorIndex,
	          key: this.name || this.category,
	          series: this.series,
	          point: this,
	          percentage: this.percentage,
	          total: this.total || this.stackTotal
	        };
	      }
	      getNestedProperty(t) {
	        return t ? 0 === t.indexOf("custom.") ? u(t, this.options) : this[t] : void 0;
	      }
	      getZone() {
	        let t = this.series,
	          e = t.zones,
	          i = t.zoneAxis || "y",
	          s,
	          o = 0;
	        for (s = e[0]; this[i] >= s.value;) s = e[++o];
	        return this.nonZonedColor || (this.nonZonedColor = this.color), s && s.color && !this.options.color ? this.color = s.color : this.color = this.nonZonedColor, s;
	      }
	      hasNewShapeType() {
	        let t = this.graphic && (this.graphic.symbolName || this.graphic.element.nodeName);
	        return t !== this.shapeType;
	      }
	      constructor(t, e, i) {
	        this.formatPrefix = "point", this.visible = !0, this.series = t, this.applyOptions(e, i), this.id ?? (this.id = M()), this.resolveColor(), t.chart.pointCount++, p(this, "afterInit");
	      }
	      isValid() {
	        return (m(this.x) || this.x instanceof Date) && m(this.y);
	      }
	      optionsToObject(t) {
	        let e = this.series,
	          i = e.options.keys,
	          s = i || e.pointArrayMap || ["y"],
	          o = s.length,
	          r = {},
	          n,
	          a = 0,
	          h = 0;
	        if (m(t) || null === t) r[s[0]] = t;else if (g(t)) for (!i && t.length > o && ("string" == (n = typeof t[0]) ? r.name = t[0] : "number" === n && (r.x = t[0]), a++); h < o;) i && void 0 === t[a] || (s[h].indexOf(".") > 0 ? C.prototype.setNestedProperty(r, t[a], s[h]) : r[s[h]] = t[a]), a++, h++;else "object" == typeof t && (r = t, t.dataLabels && (e.hasDataLabels = () => !0), t.marker && (e._hasPointMarkers = !0));
	        return r;
	      }
	      pos(t, e = this.plotY) {
	        if (!this.destroyed) {
	          let {
	              plotX: i,
	              series: s
	            } = this,
	            {
	              chart: o,
	              xAxis: r,
	              yAxis: n
	            } = s,
	            a = 0,
	            h = 0;
	          if (m(i) && m(e)) return t && (a = r ? r.pos : o.plotLeft, h = n ? n.pos : o.plotTop), o.inverted && r && n ? [n.len - e + h, r.len - i + a] : [i + a, e + h];
	        }
	      }
	      resolveColor() {
	        let t = this.series,
	          e = t.chart.options.chart,
	          i = t.chart.styledMode,
	          s,
	          o,
	          r = e.colorCount,
	          n;
	        delete this.nonZonedColor, t.options.colorByPoint ? (i || (s = (o = t.options.colors || t.chart.options.colors)[t.colorCounter], r = o.length), n = t.colorCounter, t.colorCounter++, t.colorCounter === r && (t.colorCounter = 0)) : (i || (s = t.color), n = t.colorIndex), this.colorIndex = v(this.options.colorIndex, n), this.color = v(this.options.color, s);
	      }
	      setNestedProperty(t, e, i) {
	        let s = i.split(".");
	        return s.reduce(function (t, i, s, o) {
	          let r = o.length - 1 === s;
	          return t[i] = r ? e : x(t[i], !0) ? t[i] : {}, t[i];
	        }, t), t;
	      }
	      shouldDraw() {
	        return !this.isNull;
	      }
	      tooltipFormatter(t) {
	        let e = this.series,
	          i = e.tooltipOptions,
	          s = v(i.valueDecimals, ""),
	          o = i.valuePrefix || "",
	          r = i.valueSuffix || "";
	        return e.chart.styledMode && (t = e.chart.tooltip.styledModeFormat(t)), (e.pointArrayMap || ["y"]).forEach(function (e) {
	          e = "{point." + e, (o || r) && (t = t.replace(RegExp(e + "}", "g"), o + e + "}" + r)), t = t.replace(RegExp(e + "}", "g"), e + ":,." + s + "f}");
	        }), a(t, {
	          point: this,
	          series: this.series
	        }, e.chart);
	      }
	      update(t, e, i, s) {
	        let o;
	        let r = this,
	          n = r.series,
	          a = r.graphic,
	          h = n.chart,
	          l = n.options;
	        function d() {
	          r.applyOptions(t);
	          let s = a && r.hasMockGraphic,
	            d = null === r.y ? !s : s;
	          a && d && (r.graphic = a.destroy(), delete r.hasMockGraphic), x(t, !0) && (a && a.element && t && t.marker && void 0 !== t.marker.symbol && (r.graphic = a.destroy()), t?.dataLabels && r.dataLabel && (r.dataLabel = r.dataLabel.destroy())), o = r.index, n.updateParallelArrays(r, o), l.data[o] = x(l.data[o], !0) || x(t, !0) ? r.options : v(t, l.data[o]), n.isDirty = n.isDirtyData = !0, !n.fixedBox && n.hasCartesianSeries && (h.isDirtyBox = !0), "point" === l.legendType && (h.isDirtyLegend = !0), e && h.redraw(i);
	        }
	        e = v(e, !0), !1 === s ? d() : r.firePointEvent("update", {
	          options: t
	        }, d);
	      }
	      remove(t, e) {
	        this.series.removePoint(this.series.data.indexOf(this), t, e);
	      }
	      select(t, e) {
	        let i = this,
	          s = i.series,
	          o = s.chart;
	        t = v(t, !i.selected), this.selectedStaging = t, i.firePointEvent(t ? "select" : "unselect", {
	          accumulate: e
	        }, function () {
	          i.selected = i.options.selected = t, s.options.data[s.data.indexOf(i)] = i.options, i.setState(t && "select"), e || o.getSelectedPoints().forEach(function (t) {
	            let e = t.series;
	            t.selected && t !== i && (t.selected = t.options.selected = !1, e.options.data[e.data.indexOf(t)] = t.options, t.setState(o.hoverPoints && e.options.inactiveOtherPoints ? "inactive" : ""), t.firePointEvent("unselect"));
	          });
	        }), delete this.selectedStaging;
	      }
	      onMouseOver(t) {
	        let e = this.series,
	          i = e.chart,
	          s = i.pointer;
	        t = t ? s.normalize(t) : s.getChartCoordinatesFromPoint(this, i.inverted), s.runPointActions(t, this);
	      }
	      onMouseOut() {
	        let t = this.series.chart;
	        this.firePointEvent("mouseOut"), this.series.options.inactiveOtherPoints || (t.hoverPoints || []).forEach(function (t) {
	          t.setState();
	        }), t.hoverPoints = t.hoverPoint = null;
	      }
	      importEvents() {
	        if (!this.hasImportedEvents) {
	          let t = this,
	            e = y(t.series.options.point, t.options),
	            i = e.events;
	          t.events = i, b(i, function (e, i) {
	            f(e) && h(t, i, e);
	          }), this.hasImportedEvents = !0;
	        }
	      }
	      setState(e, i) {
	        let s = this.series,
	          o = this.state,
	          r = s.options.states[e || "normal"] || {},
	          a = n.plotOptions[s.type].marker && s.options.marker,
	          h = a && !1 === a.enabled,
	          l = a && a.states && a.states[e || "normal"] || {},
	          d = !1 === l.enabled,
	          u = this.marker || {},
	          g = s.chart,
	          f = a && s.markerAttribs,
	          x = s.halo,
	          y,
	          b,
	          S,
	          k = s.stateMarkerGraphic,
	          M;
	        if ((e = e || "") === this.state && !i || this.selected && "select" !== e || !1 === r.enabled || e && (d || h && !1 === l.enabled) || e && u.states && u.states[e] && !1 === u.states[e].enabled) return;
	        if (this.state = e, f && (y = s.markerAttribs(this, e)), this.graphic && !this.hasMockGraphic) {
	          if (o && this.graphic.removeClass("highcharts-point-" + o), e && this.graphic.addClass("highcharts-point-" + e), !g.styledMode) {
	            b = s.pointAttribs(this, e), S = v(g.options.chart.animation, r.animation);
	            let t = b.opacity;
	            s.options.inactiveOtherPoints && m(t) && (this.dataLabels || []).forEach(function (e) {
	              e && !e.hasClass("highcharts-data-label-hidden") && (e.animate({
	                opacity: t
	              }, S), e.connector && e.connector.animate({
	                opacity: t
	              }, S));
	            }), this.graphic.animate(b, S);
	          }
	          y && this.graphic.animate(y, v(g.options.chart.animation, l.animation, a.animation)), k && k.hide();
	        } else e && l && (M = u.symbol || s.symbol, k && k.currentSymbol !== M && (k = k.destroy()), y && (k ? k[i ? "animate" : "attr"]({
	          x: y.x,
	          y: y.y
	        }) : M && (s.stateMarkerGraphic = k = g.renderer.symbol(M, y.x, y.y, y.width, y.height).add(s.markerGroup), k.currentSymbol = M)), !g.styledMode && k && "inactive" !== this.state && k.attr(s.pointAttribs(this, e))), k && (k[e && this.isInside ? "show" : "hide"](), k.element.point = this, k.addClass(this.getClassName(), !0));
	        let C = r.halo,
	          w = this.graphic || k,
	          T = w && w.visibility || "inherit";
	        C && C.size && w && "hidden" !== T && !this.isCluster ? (x || (s.halo = x = g.renderer.path().add(w.parentGroup)), x.show()[i ? "animate" : "attr"]({
	          d: this.haloPath(C.size)
	        }), x.attr({
	          class: "highcharts-halo highcharts-color-" + v(this.colorIndex, s.colorIndex) + (this.className ? " " + this.className : ""),
	          visibility: T,
	          zIndex: -1
	        }), x.point = this, g.styledMode || x.attr(c({
	          fill: this.color || s.color,
	          "fill-opacity": C.opacity
	        }, t.filterUserAttributes(C.attributes || {})))) : x && x.point && x.point.haloPath && x.animate({
	          d: x.point.haloPath(0)
	        }, null, x.hide), p(this, "afterSetState", {
	          state: e
	        });
	      }
	      haloPath(t) {
	        let e = this.pos();
	        return e ? this.series.chart.renderer.symbols.circle(Math.floor(e[0]) - t, e[1] - t, 2 * t, 2 * t) : [];
	      }
	    }
	    return C;
	  }), i(e, "Core/Pointer.js", [e["Core/Color/Color.js"], e["Core/Globals.js"], e["Core/Utilities.js"]], function (t, e, i) {
	    var s;
	    let {
	        parse: o
	      } = t,
	      {
	        charts: r,
	        composed: n,
	        noop: a
	      } = e,
	      {
	        addEvent: h,
	        attr: l,
	        css: d,
	        defined: c,
	        extend: p,
	        find: u,
	        fireEvent: g,
	        isNumber: f,
	        isObject: m,
	        objectEach: x,
	        offset: y,
	        pick: b,
	        pushUnique: v,
	        splat: S
	      } = i;
	    class k {
	      applyInactiveState(t) {
	        let e = [],
	          i;
	        (t || []).forEach(function (t) {
	          i = t.series, e.push(i), i.linkedParent && e.push(i.linkedParent), i.linkedSeries && (e = e.concat(i.linkedSeries)), i.navigatorSeries && e.push(i.navigatorSeries);
	        }), this.chart.series.forEach(function (t) {
	          -1 === e.indexOf(t) ? t.setState("inactive", !0) : t.options.inactiveOtherPoints && t.setAllPointsToState("inactive");
	        });
	      }
	      destroy() {
	        let t = this;
	        this.eventsToUnbind.forEach(t => t()), this.eventsToUnbind = [], !e.chartCount && (k.unbindDocumentMouseUp && (k.unbindDocumentMouseUp = k.unbindDocumentMouseUp()), k.unbindDocumentTouchEnd && (k.unbindDocumentTouchEnd = k.unbindDocumentTouchEnd())), clearInterval(t.tooltipTimeout), x(t, function (e, i) {
	          t[i] = void 0;
	        });
	      }
	      getSelectionMarkerAttrs(t, e) {
	        let i = {
	          args: {
	            chartX: t,
	            chartY: e
	          },
	          attrs: {},
	          shapeType: "rect"
	        };
	        return g(this, "getSelectionMarkerAttrs", i, i => {
	          let s;
	          let {
	              chart: o,
	              mouseDownX: r = 0,
	              mouseDownY: n = 0,
	              zoomHor: a,
	              zoomVert: h
	            } = this,
	            l = i.attrs;
	          l.x = o.plotLeft, l.y = o.plotTop, l.width = a ? 1 : o.plotWidth, l.height = h ? 1 : o.plotHeight, a && (s = t - r, l.width = Math.abs(s), l.x = (s > 0 ? 0 : s) + r), h && (s = e - n, l.height = Math.abs(s), l.y = (s > 0 ? 0 : s) + n);
	        }), i;
	      }
	      drag(t) {
	        let e = this.chart,
	          i = e.options.chart,
	          s = e.plotLeft,
	          r = e.plotTop,
	          n = e.plotWidth,
	          a = e.plotHeight,
	          h = this.mouseDownX || 0,
	          l = this.mouseDownY || 0,
	          d = m(i.panning) ? i.panning && i.panning.enabled : i.panning,
	          c = i.panKey && t[i.panKey + "Key"],
	          p = t.chartX,
	          u = t.chartY,
	          g,
	          f = this.selectionMarker;
	        if ((!f || !f.touch) && (p < s ? p = s : p > s + n && (p = s + n), u < r ? u = r : u > r + a && (u = r + a), this.hasDragged = Math.sqrt(Math.pow(h - p, 2) + Math.pow(l - u, 2)), this.hasDragged > 10)) {
	          g = e.isInsidePlot(h - s, l - r, {
	            visiblePlotOnly: !0
	          });
	          let {
	            shapeType: n,
	            attrs: a
	          } = this.getSelectionMarkerAttrs(p, u);
	          (e.hasCartesianSeries || e.mapView) && (this.zoomX || this.zoomY) && g && !c && !f && (this.selectionMarker = f = e.renderer[n](), f.attr({
	            class: "highcharts-selection-marker",
	            zIndex: 7
	          }).add(), e.styledMode || f.attr({
	            fill: i.selectionMarkerFill || o("#334eff").setOpacity(.25).get()
	          })), f && f.attr(a), g && !f && d && e.pan(t, i.panning);
	        }
	      }
	      dragStart(t) {
	        let e = this.chart;
	        e.mouseIsDown = t.type, e.cancelClick = !1, e.mouseDownX = this.mouseDownX = t.chartX, e.mouseDownY = this.mouseDownY = t.chartY;
	      }
	      getSelectionBox(t) {
	        let e = {
	          args: {
	            marker: t
	          },
	          result: {}
	        };
	        return g(this, "getSelectionBox", e, e => {
	          e.result = {
	            x: t.attr ? +t.attr("x") : t.x,
	            y: t.attr ? +t.attr("y") : t.y,
	            width: t.attr ? t.attr("width") : t.width,
	            height: t.attr ? t.attr("height") : t.height
	          };
	        }), e.result;
	      }
	      drop(t) {
	        let e = this,
	          i = this.chart,
	          s = this.hasPinched;
	        if (this.selectionMarker) {
	          let {
	              x: o,
	              y: r,
	              width: n,
	              height: a
	            } = this.getSelectionBox(this.selectionMarker),
	            h = {
	              originalEvent: t,
	              xAxis: [],
	              yAxis: [],
	              x: o,
	              y: r,
	              width: n,
	              height: a
	            },
	            l = !!i.mapView;
	          (this.hasDragged || s) && (i.axes.forEach(function (i) {
	            if (i.zoomEnabled && c(i.min) && (s || e[{
	              xAxis: "zoomX",
	              yAxis: "zoomY"
	            }[i.coll]]) && f(o) && f(r) && f(n) && f(a)) {
	              let e = i.horiz,
	                s = "touchend" === t.type ? i.minPixelPadding : 0,
	                d = i.toValue((e ? o : r) + s),
	                c = i.toValue((e ? o + n : r + a) - s);
	              h[i.coll].push({
	                axis: i,
	                min: Math.min(d, c),
	                max: Math.max(d, c)
	              }), l = !0;
	            }
	          }), l && g(i, "selection", h, function (t) {
	            i.zoom(p(t, s ? {
	              animation: !1
	            } : null));
	          })), f(i.index) && (this.selectionMarker = this.selectionMarker.destroy()), s && this.scaleGroups();
	        }
	        i && f(i.index) && (d(i.container, {
	          cursor: i._cursor
	        }), i.cancelClick = +this.hasDragged > 10, i.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = []);
	      }
	      findNearestKDPoint(t, e, i) {
	        let s;
	        return t.forEach(function (t) {
	          let o = t.noSharedTooltip && e,
	            r = !o && 0 > t.options.findNearestPointBy.indexOf("y"),
	            n = t.searchPoint(i, r);
	          m(n, !0) && n.series && (!m(s, !0) || function (t, i) {
	            let s = t.distX - i.distX,
	              o = t.dist - i.dist,
	              r = (i.series.group && i.series.group.zIndex) - (t.series.group && t.series.group.zIndex);
	            return 0 !== s && e ? s : 0 !== o ? o : 0 !== r ? r : t.series.index > i.series.index ? -1 : 1;
	          }(s, n) > 0) && (s = n);
	        }), s;
	      }
	      getChartCoordinatesFromPoint(t, e) {
	        let i = t.series,
	          s = i.xAxis,
	          o = i.yAxis,
	          r = t.shapeArgs;
	        if (s && o) {
	          let i = b(t.clientX, t.plotX),
	            n = t.plotY || 0;
	          return t.isNode && r && f(r.x) && f(r.y) && (i = r.x, n = r.y), e ? {
	            chartX: o.len + o.pos - n,
	            chartY: s.len + s.pos - i
	          } : {
	            chartX: i + s.pos,
	            chartY: n + o.pos
	          };
	        }
	        if (r && r.x && r.y) return {
	          chartX: r.x,
	          chartY: r.y
	        };
	      }
	      getChartPosition() {
	        if (this.chartPosition) return this.chartPosition;
	        let {
	            container: t
	          } = this.chart,
	          e = y(t);
	        this.chartPosition = {
	          left: e.left,
	          top: e.top,
	          scaleX: 1,
	          scaleY: 1
	        };
	        let i = t.offsetWidth,
	          s = t.offsetHeight;
	        return i > 2 && s > 2 && (this.chartPosition.scaleX = e.width / i, this.chartPosition.scaleY = e.height / s), this.chartPosition;
	      }
	      getCoordinates(t) {
	        let e = {
	          xAxis: [],
	          yAxis: []
	        };
	        return this.chart.axes.forEach(function (i) {
	          e[i.isXAxis ? "xAxis" : "yAxis"].push({
	            axis: i,
	            value: i.toValue(t[i.horiz ? "chartX" : "chartY"])
	          });
	        }), e;
	      }
	      getHoverData(t, e, i, s, o, r) {
	        let n = [],
	          a = function (t) {
	            return t.visible && !(!o && t.directTouch) && b(t.options.enableMouseTracking, !0);
	          },
	          h = e,
	          l,
	          d = {
	            chartX: r ? r.chartX : void 0,
	            chartY: r ? r.chartY : void 0,
	            shared: o
	          };
	        g(this, "beforeGetHoverData", d);
	        let c = h && !h.stickyTracking;
	        l = c ? [h] : i.filter(t => t.stickyTracking && (d.filter || a)(t));
	        let p = s && t || !r ? t : this.findNearestKDPoint(l, o, r);
	        return h = p && p.series, p && (o && !h.noSharedTooltip ? (l = i.filter(function (t) {
	          return d.filter ? d.filter(t) : a(t) && !t.noSharedTooltip;
	        })).forEach(function (t) {
	          let e = u(t.points, function (t) {
	            return t.x === p.x && !t.isNull;
	          });
	          m(e) && (t.boosted && t.boost && (e = t.boost.getPoint(e)), n.push(e));
	        }) : n.push(p)), g(this, "afterGetHoverData", d = {
	          hoverPoint: p
	        }), {
	          hoverPoint: d.hoverPoint,
	          hoverSeries: h,
	          hoverPoints: n
	        };
	      }
	      getPointFromEvent(t) {
	        let e = t.target,
	          i;
	        for (; e && !i;) i = e.point, e = e.parentNode;
	        return i;
	      }
	      onTrackerMouseOut(t) {
	        let e = this.chart,
	          i = t.relatedTarget,
	          s = e.hoverSeries;
	        this.isDirectTouch = !1, !s || !i || s.stickyTracking || this.inClass(i, "highcharts-tooltip") || this.inClass(i, "highcharts-series-" + s.index) && this.inClass(i, "highcharts-tracker") || s.onMouseOut();
	      }
	      inClass(t, e) {
	        let i = t,
	          s;
	        for (; i;) {
	          if (s = l(i, "class")) {
	            if (-1 !== s.indexOf(e)) return !0;
	            if (-1 !== s.indexOf("highcharts-container")) return !1;
	          }
	          i = i.parentElement;
	        }
	      }
	      constructor(t, e) {
	        this.hasDragged = !1, this.lastValidTouch = {}, this.pinchDown = [], this.eventsToUnbind = [], this.options = e, this.chart = t, this.runChartClick = !!e.chart.events?.click, this.pinchDown = [], this.lastValidTouch = {}, this.setDOMEvents(), g(this, "afterInit");
	      }
	      normalize(t, e) {
	        let i = t.touches,
	          s = i ? i.length ? i.item(0) : b(i.changedTouches, t.changedTouches)[0] : t;
	        e || (e = this.getChartPosition());
	        let o = s.pageX - e.left,
	          r = s.pageY - e.top;
	        return p(t, {
	          chartX: Math.round(o /= e.scaleX),
	          chartY: Math.round(r /= e.scaleY)
	        });
	      }
	      onContainerClick(t) {
	        let e = this.chart,
	          i = e.hoverPoint,
	          s = this.normalize(t),
	          o = e.plotLeft,
	          r = e.plotTop;
	        !e.cancelClick && (i && this.inClass(s.target, "highcharts-tracker") ? (g(i.series, "click", p(s, {
	          point: i
	        })), e.hoverPoint && i.firePointEvent("click", s)) : (p(s, this.getCoordinates(s)), e.isInsidePlot(s.chartX - o, s.chartY - r, {
	          visiblePlotOnly: !0
	        }) && g(e, "click", s)));
	      }
	      onContainerMouseDown(t) {
	        let i = (1 & (t.buttons || t.button)) == 1;
	        t = this.normalize(t), e.isFirefox && 0 !== t.button && this.onContainerMouseMove(t), (void 0 === t.button || i) && (this.zoomOption(t), i && t.preventDefault && t.preventDefault(), this.dragStart(t));
	      }
	      onContainerMouseLeave(t) {
	        let e = r[b(k.hoverChartIndex, -1)];
	        t = this.normalize(t), this.onContainerMouseMove(t), e && t.relatedTarget && !this.inClass(t.relatedTarget, "highcharts-tooltip") && (e.pointer.reset(), e.pointer.chartPosition = void 0);
	      }
	      onContainerMouseEnter(t) {
	        delete this.chartPosition;
	      }
	      onContainerMouseMove(t) {
	        let e = this.chart,
	          i = e.tooltip,
	          s = this.normalize(t);
	        this.setHoverChartIndex(t), ("mousedown" === e.mouseIsDown || this.touchSelect(s)) && this.drag(s), !e.openMenu && (this.inClass(s.target, "highcharts-tracker") || e.isInsidePlot(s.chartX - e.plotLeft, s.chartY - e.plotTop, {
	          visiblePlotOnly: !0
	        })) && !(i && i.shouldStickOnContact(s)) && (this.inClass(s.target, "highcharts-no-tooltip") ? this.reset(!1, 0) : this.runPointActions(s));
	      }
	      onDocumentTouchEnd(t) {
	        let e = r[b(k.hoverChartIndex, -1)];
	        e && e.pointer.drop(t);
	      }
	      onContainerTouchMove(t) {
	        this.touchSelect(t) ? this.onContainerMouseMove(t) : this.touch(t);
	      }
	      onContainerTouchStart(t) {
	        this.touchSelect(t) ? this.onContainerMouseDown(t) : (this.zoomOption(t), this.touch(t, !0));
	      }
	      onDocumentMouseMove(t) {
	        let e = this.chart,
	          i = e.tooltip,
	          s = this.chartPosition,
	          o = this.normalize(t, s);
	        !s || e.isInsidePlot(o.chartX - e.plotLeft, o.chartY - e.plotTop, {
	          visiblePlotOnly: !0
	        }) || i && i.shouldStickOnContact(o) || this.inClass(o.target, "highcharts-tracker") || this.reset();
	      }
	      onDocumentMouseUp(t) {
	        let e = r[b(k.hoverChartIndex, -1)];
	        e && e.pointer.drop(t);
	      }
	      pinch(t) {
	        let e = this,
	          i = e.chart,
	          s = e.pinchDown,
	          o = t.touches || [],
	          r = o.length,
	          n = e.lastValidTouch,
	          h = e.hasZoom,
	          l = {},
	          d = 1 === r && (e.inClass(t.target, "highcharts-tracker") && i.runTrackerClick || e.runChartClick),
	          c = {},
	          u = e.chart.tooltip,
	          f = 1 === r && b(u && u.options.followTouchMove, !0),
	          m = e.selectionMarker;
	        r > 1 ? e.initiated = !0 : f && (e.initiated = !1), h && e.initiated && !d && !1 !== t.cancelable && t.preventDefault(), [].map.call(o, function (t) {
	          return e.normalize(t);
	        }), "touchstart" === t.type ? ([].forEach.call(o, function (t, e) {
	          s[e] = {
	            chartX: t.chartX,
	            chartY: t.chartY
	          };
	        }), n.x = [s[0].chartX, s[1] && s[1].chartX], n.y = [s[0].chartY, s[1] && s[1].chartY], i.axes.forEach(function (t) {
	          if (t.zoomEnabled) {
	            let e = i.bounds[t.horiz ? "h" : "v"],
	              s = t.minPixelPadding,
	              o = t.toPixels(Math.min(b(t.options.min, t.dataMin), t.dataMin)),
	              r = t.toPixels(Math.max(b(t.options.max, t.dataMax), t.dataMax)),
	              n = Math.min(o, r),
	              a = Math.max(o, r);
	            e.min = Math.min(t.pos, n - s), e.max = Math.max(t.pos + t.len, a + s);
	          }
	        }), e.res = !0) : f ? this.runPointActions(e.normalize(t)) : s.length && (g(i, "touchpan", {
	          originalEvent: t
	        }, () => {
	          m || (e.selectionMarker = m = p({
	            destroy: a,
	            touch: !0
	          }, i.plotBox)), e.pinchTranslate(s, o, l, m, c, n), e.hasPinched = h, e.scaleGroups(l, c);
	        }), e.res && (e.res = !1, this.reset(!1, 0)));
	      }
	      pinchTranslate(t, e, i, s, o, r) {
	        this.zoomHor && this.pinchTranslateDirection(!0, t, e, i, s, o, r), this.zoomVert && this.pinchTranslateDirection(!1, t, e, i, s, o, r);
	      }
	      pinchTranslateDirection(t, e, i, s, o, r, n, a) {
	        let h = this.chart,
	          l = t ? "x" : "y",
	          d = t ? "X" : "Y",
	          c = "chart" + d,
	          p = t ? "width" : "height",
	          u = h["plot" + (t ? "Left" : "Top")],
	          g = h.inverted,
	          f = h.bounds[t ? "h" : "v"],
	          m = 1 === e.length,
	          x = e[0][c],
	          y = !m && e[1][c],
	          b = function () {
	            "number" == typeof w && Math.abs(x - y) > 20 && (M = a || Math.abs(C - w) / Math.abs(x - y)), k = (u - C) / M + x, v = h["plot" + (t ? "Width" : "Height")] / M;
	          },
	          v,
	          S,
	          k,
	          M = a || 1,
	          C = i[0][c],
	          w = !m && i[1][c],
	          T;
	        b(), (S = k) < f.min ? (S = f.min, T = !0) : S + v > f.max && (S = f.max - v, T = !0), T ? (C -= .8 * (C - n[l][0]), "number" == typeof w && (w -= .8 * (w - n[l][1])), b()) : n[l] = [C, w], g || (r[l] = k - u, r[p] = v);
	        let A = g ? t ? "scaleY" : "scaleX" : "scale" + d,
	          P = g ? 1 / M : M;
	        o[p] = v, o[l] = S, s[A] = M * (g && !t ? -1 : 1), s["translate" + d] = P * u + (C - P * x);
	      }
	      reset(t, e) {
	        let i = this.chart,
	          s = i.hoverSeries,
	          o = i.hoverPoint,
	          r = i.hoverPoints,
	          n = i.tooltip,
	          a = n && n.shared ? r : o;
	        t && a && S(a).forEach(function (e) {
	          e.series.isCartesian && void 0 === e.plotX && (t = !1);
	        }), t ? n && a && S(a).length && (n.refresh(a), n.shared && r ? r.forEach(function (t) {
	          t.setState(t.state, !0), t.series.isCartesian && (t.series.xAxis.crosshair && t.series.xAxis.drawCrosshair(null, t), t.series.yAxis.crosshair && t.series.yAxis.drawCrosshair(null, t));
	        }) : o && (o.setState(o.state, !0), i.axes.forEach(function (t) {
	          t.crosshair && o.series[t.coll] === t && t.drawCrosshair(null, o);
	        }))) : (o && o.onMouseOut(), r && r.forEach(function (t) {
	          t.setState();
	        }), s && s.onMouseOut(), n && n.hide(e), this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove()), i.axes.forEach(function (t) {
	          t.hideCrosshair();
	        }), this.hoverX = i.hoverPoints = i.hoverPoint = null);
	      }
	      runPointActions(t, e, i) {
	        let s = this.chart,
	          o = s.series,
	          n = s.tooltip && s.tooltip.options.enabled ? s.tooltip : void 0,
	          a = !!n && n.shared,
	          l = e || s.hoverPoint,
	          d = l && l.series || s.hoverSeries,
	          c = (!t || "touchmove" !== t.type) && (!!e || d && d.directTouch && this.isDirectTouch),
	          p = this.getHoverData(l, d, o, c, a, t);
	        l = p.hoverPoint, d = p.hoverSeries;
	        let g = p.hoverPoints,
	          f = d && d.tooltipOptions.followPointer && !d.tooltipOptions.split,
	          m = a && d && !d.noSharedTooltip;
	        if (l && (i || l !== s.hoverPoint || n && n.isHidden)) {
	          if ((s.hoverPoints || []).forEach(function (t) {
	            -1 === g.indexOf(t) && t.setState();
	          }), s.hoverSeries !== d && d.onMouseOver(), this.applyInactiveState(g), (g || []).forEach(function (t) {
	            t.setState("hover");
	          }), s.hoverPoint && s.hoverPoint.firePointEvent("mouseOut"), !l.series) return;
	          s.hoverPoints = g, s.hoverPoint = l, l.firePointEvent("mouseOver", void 0, () => {
	            n && l && n.refresh(m ? g : l, t);
	          });
	        } else if (f && n && !n.isHidden) {
	          let e = n.getAnchor([{}], t);
	          s.isInsidePlot(e[0], e[1], {
	            visiblePlotOnly: !0
	          }) && n.updatePosition({
	            plotX: e[0],
	            plotY: e[1]
	          });
	        }
	        this.unDocMouseMove || (this.unDocMouseMove = h(s.container.ownerDocument, "mousemove", function (t) {
	          let e = r[k.hoverChartIndex];
	          e && e.pointer.onDocumentMouseMove(t);
	        }), this.eventsToUnbind.push(this.unDocMouseMove)), s.axes.forEach(function (e) {
	          let i;
	          let o = b((e.crosshair || {}).snap, !0);
	          !o || (i = s.hoverPoint) && i.series[e.coll] === e || (i = u(g, t => t.series && t.series[e.coll] === e)), i || !o ? e.drawCrosshair(t, i) : e.hideCrosshair();
	        });
	      }
	      scaleGroups(t, e) {
	        let i = this.chart;
	        i.series.forEach(function (s) {
	          let o = t || s.getPlotBox("series");
	          s.group && (s.xAxis && s.xAxis.zoomEnabled || i.mapView) && (s.group.attr(o), s.markerGroup && (s.markerGroup.attr(t || s.getPlotBox("marker")), s.markerGroup.clip(e ? i.clipRect : null)), s.dataLabelsGroup && s.dataLabelsGroup.attr(o));
	        }), i.clipRect.attr(e || i.clipBox);
	      }
	      setDOMEvents() {
	        let t = this.chart.container,
	          i = t.ownerDocument;
	        t.onmousedown = this.onContainerMouseDown.bind(this), t.onmousemove = this.onContainerMouseMove.bind(this), t.onclick = this.onContainerClick.bind(this), this.eventsToUnbind.push(h(t, "mouseenter", this.onContainerMouseEnter.bind(this))), this.eventsToUnbind.push(h(t, "mouseleave", this.onContainerMouseLeave.bind(this))), k.unbindDocumentMouseUp || (k.unbindDocumentMouseUp = h(i, "mouseup", this.onDocumentMouseUp.bind(this)));
	        let s = this.chart.renderTo.parentElement;
	        for (; s && "BODY" !== s.tagName;) this.eventsToUnbind.push(h(s, "scroll", () => {
	          delete this.chartPosition;
	        })), s = s.parentElement;
	        e.hasTouch && (this.eventsToUnbind.push(h(t, "touchstart", this.onContainerTouchStart.bind(this), {
	          passive: !1
	        })), this.eventsToUnbind.push(h(t, "touchmove", this.onContainerTouchMove.bind(this), {
	          passive: !1
	        })), k.unbindDocumentTouchEnd || (k.unbindDocumentTouchEnd = h(i, "touchend", this.onDocumentTouchEnd.bind(this), {
	          passive: !1
	        })));
	      }
	      setHoverChartIndex(t) {
	        let i = this.chart,
	          s = e.charts[b(k.hoverChartIndex, -1)];
	        s && s !== i && s.pointer.onContainerMouseLeave(t || {
	          relatedTarget: i.container
	        }), s && s.mouseIsDown || (k.hoverChartIndex = i.index);
	      }
	      touch(t, e) {
	        let i, s;
	        let o = this.chart;
	        this.setHoverChartIndex(), 1 === t.touches.length ? (t = this.normalize(t), o.isInsidePlot(t.chartX - o.plotLeft, t.chartY - o.plotTop, {
	          visiblePlotOnly: !0
	        }) && !o.openMenu ? (e && this.runPointActions(t), "touchmove" === t.type && (i = !!(s = this.pinchDown)[0] && Math.sqrt(Math.pow(s[0].chartX - t.chartX, 2) + Math.pow(s[0].chartY - t.chartY, 2)) >= 4), b(i, !0) && this.pinch(t)) : e && this.reset()) : 2 === t.touches.length && this.pinch(t);
	      }
	      touchSelect(t) {
	        return !!(this.chart.zooming.singleTouch && t.touches && 1 === t.touches.length);
	      }
	      zoomOption(t) {
	        let e = this.chart,
	          i = (e.options.chart, e.inverted),
	          s = e.zooming.type || "",
	          o,
	          r;
	        /touch/.test(t.type) && (s = b(e.zooming.pinchType, s)), this.zoomX = o = /x/.test(s), this.zoomY = r = /y/.test(s), this.zoomHor = o && !i || r && i, this.zoomVert = r && !i || o && i, this.hasZoom = o || r;
	      }
	    }
	    return (s = k || (k = {})).compose = function t(e) {
	      v(n, t) && h(e, "beforeRender", function () {
	        this.pointer = new s(this, this.options);
	      });
	    }, k;
	  }), i(e, "Core/Legend/Legend.js", [e["Core/Animation/AnimationUtilities.js"], e["Core/Templating.js"], e["Core/Globals.js"], e["Core/Series/Point.js"], e["Core/Renderer/RendererUtilities.js"], e["Core/Utilities.js"]], function (t, e, i, s, o, r) {
	    var n;
	    let {
	        animObject: a,
	        setAnimation: h
	      } = t,
	      {
	        format: l
	      } = e,
	      {
	        composed: d,
	        marginNames: c
	      } = i,
	      {
	        distribute: p
	      } = o,
	      {
	        addEvent: u,
	        createElement: g,
	        css: f,
	        defined: m,
	        discardElement: x,
	        find: y,
	        fireEvent: b,
	        isNumber: v,
	        merge: S,
	        pick: k,
	        pushUnique: M,
	        relativeLength: C,
	        stableSort: w,
	        syncTimeout: T
	      } = r;
	    class A {
	      constructor(t, e) {
	        this.allItems = [], this.initialItemY = 0, this.itemHeight = 0, this.itemMarginBottom = 0, this.itemMarginTop = 0, this.itemX = 0, this.itemY = 0, this.lastItemY = 0, this.lastLineHeight = 0, this.legendHeight = 0, this.legendWidth = 0, this.maxItemWidth = 0, this.maxLegendWidth = 0, this.offsetWidth = 0, this.padding = 0, this.pages = [], this.symbolHeight = 0, this.symbolWidth = 0, this.titleHeight = 0, this.totalItemWidth = 0, this.widthOption = 0, this.chart = t, this.setOptions(e), e.enabled && (this.render(), u(this.chart, "endResize", function () {
	          this.legend.positionCheckboxes();
	        })), u(this.chart, "render", () => {
	          this.options.enabled && this.proximate && (this.proximatePositions(), this.positionItems());
	        });
	      }
	      setOptions(t) {
	        let e = k(t.padding, 8);
	        this.options = t, this.chart.styledMode || (this.itemStyle = t.itemStyle, this.itemHiddenStyle = S(this.itemStyle, t.itemHiddenStyle)), this.itemMarginTop = t.itemMarginTop, this.itemMarginBottom = t.itemMarginBottom, this.padding = e, this.initialItemY = e - 5, this.symbolWidth = k(t.symbolWidth, 16), this.pages = [], this.proximate = "proximate" === t.layout && !this.chart.inverted, this.baseline = void 0;
	      }
	      update(t, e) {
	        let i = this.chart;
	        this.setOptions(S(!0, this.options, t)), this.destroy(), i.isDirtyLegend = i.isDirtyBox = !0, k(e, !0) && i.redraw(), b(this, "afterUpdate", {
	          redraw: e
	        });
	      }
	      colorizeItem(t, e) {
	        let {
	          area: i,
	          group: s,
	          label: o,
	          line: r,
	          symbol: n
	        } = t.legendItem || {};
	        if (s?.[e ? "removeClass" : "addClass"]("highcharts-legend-item-hidden"), !this.chart.styledMode) {
	          let {
	              itemHiddenStyle: s = {}
	            } = this,
	            a = s.color,
	            {
	              fillColor: h,
	              fillOpacity: l,
	              lineColor: d,
	              marker: c
	            } = t.options,
	            p = t => (!e && (t.fill && (t.fill = a), t.stroke && (t.stroke = a)), t);
	          o?.css(S(e ? this.itemStyle : s)), r?.attr(p({
	            stroke: d || t.color
	          })), n && n.attr(p(c && n.isMarker ? t.pointAttribs() : {
	            fill: t.color
	          })), i?.attr(p({
	            fill: h || t.color,
	            "fill-opacity": h ? 1 : l ?? .75
	          }));
	        }
	        b(this, "afterColorizeItem", {
	          item: t,
	          visible: e
	        });
	      }
	      positionItems() {
	        this.allItems.forEach(this.positionItem, this), this.chart.isResizing || this.positionCheckboxes();
	      }
	      positionItem(t) {
	        let {
	            group: e,
	            x: i = 0,
	            y: s = 0
	          } = t.legendItem || {},
	          o = this.options,
	          r = o.symbolPadding,
	          n = !o.rtl,
	          a = t.checkbox;
	        if (e && e.element) {
	          let o = {
	            translateX: n ? i : this.legendWidth - i - 2 * r - 4,
	            translateY: s
	          };
	          e[m(e.translateY) ? "animate" : "attr"](o, void 0, () => {
	            b(this, "afterPositionItem", {
	              item: t
	            });
	          });
	        }
	        a && (a.x = i, a.y = s);
	      }
	      destroyItem(t) {
	        let e = t.checkbox,
	          i = t.legendItem || {};
	        for (let t of ["group", "label", "line", "symbol"]) i[t] && (i[t] = i[t].destroy());
	        e && x(e), t.legendItem = void 0;
	      }
	      destroy() {
	        for (let t of this.getAllItems()) this.destroyItem(t);
	        for (let t of ["clipRect", "up", "down", "pager", "nav", "box", "title", "group"]) this[t] && (this[t] = this[t].destroy());
	        this.display = null;
	      }
	      positionCheckboxes() {
	        let t;
	        let e = this.group && this.group.alignAttr,
	          i = this.clipHeight || this.legendHeight,
	          s = this.titleHeight;
	        e && (t = e.translateY, this.allItems.forEach(function (o) {
	          let r;
	          let n = o.checkbox;
	          n && (r = t + s + n.y + (this.scrollOffset || 0) + 3, f(n, {
	            left: e.translateX + o.checkboxOffset + n.x - 20 + "px",
	            top: r + "px",
	            display: this.proximate || r > t - 6 && r < t + i - 6 ? "" : "none"
	          }));
	        }, this));
	      }
	      renderTitle() {
	        let t = this.options,
	          e = this.padding,
	          i = t.title,
	          s,
	          o = 0;
	        i.text && (this.title || (this.title = this.chart.renderer.label(i.text, e - 3, e - 4, void 0, void 0, void 0, t.useHTML, void 0, "legend-title").attr({
	          zIndex: 1
	        }), this.chart.styledMode || this.title.css(i.style), this.title.add(this.group)), i.width || this.title.css({
	          width: this.maxLegendWidth + "px"
	        }), o = (s = this.title.getBBox()).height, this.offsetWidth = s.width, this.contentGroup.attr({
	          translateY: o
	        })), this.titleHeight = o;
	      }
	      setText(t) {
	        let e = this.options;
	        t.legendItem.label.attr({
	          text: e.labelFormat ? l(e.labelFormat, t, this.chart) : e.labelFormatter.call(t)
	        });
	      }
	      renderItem(t) {
	        let e = t.legendItem = t.legendItem || {},
	          i = this.chart,
	          s = i.renderer,
	          o = this.options,
	          r = "horizontal" === o.layout,
	          n = this.symbolWidth,
	          a = o.symbolPadding || 0,
	          h = this.itemStyle,
	          l = this.itemHiddenStyle,
	          d = r ? k(o.itemDistance, 20) : 0,
	          c = !o.rtl,
	          p = !t.series,
	          u = !p && t.series.drawLegendSymbol ? t.series : t,
	          g = u.options,
	          f = !!this.createCheckboxForItem && g && g.showCheckbox,
	          m = o.useHTML,
	          x = t.options.className,
	          y = e.label,
	          b = n + a + d + (f ? 20 : 0);
	        !y && (e.group = s.g("legend-item").addClass("highcharts-" + u.type + "-series highcharts-color-" + t.colorIndex + (x ? " " + x : "") + (p ? " highcharts-series-" + t.index : "")).attr({
	          zIndex: 1
	        }).add(this.scrollGroup), e.label = y = s.text("", c ? n + a : -a, this.baseline || 0, m), i.styledMode || y.css(S(t.visible ? h : l)), y.attr({
	          align: c ? "left" : "right",
	          zIndex: 2
	        }).add(e.group), !this.baseline && (this.fontMetrics = s.fontMetrics(y), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, y.attr("y", this.baseline), this.symbolHeight = k(o.symbolHeight, this.fontMetrics.f), o.squareSymbol && (this.symbolWidth = k(o.symbolWidth, Math.max(this.symbolHeight, 16)), b = this.symbolWidth + a + d + (f ? 20 : 0), c && y.attr("x", this.symbolWidth + a))), u.drawLegendSymbol(this, t), this.setItemEvents && this.setItemEvents(t, y, m)), f && !t.checkbox && this.createCheckboxForItem && this.createCheckboxForItem(t), this.colorizeItem(t, t.visible), (i.styledMode || !h.width) && y.css({
	          width: (o.itemWidth || this.widthOption || i.spacingBox.width) - b + "px"
	        }), this.setText(t);
	        let v = y.getBBox(),
	          M = this.fontMetrics && this.fontMetrics.h || 0;
	        t.itemWidth = t.checkboxOffset = o.itemWidth || e.labelWidth || v.width + b, this.maxItemWidth = Math.max(this.maxItemWidth, t.itemWidth), this.totalItemWidth += t.itemWidth, this.itemHeight = t.itemHeight = Math.round(e.labelHeight || (v.height > 1.5 * M ? v.height : M));
	      }
	      layoutItem(t) {
	        let e = this.options,
	          i = this.padding,
	          s = "horizontal" === e.layout,
	          o = t.itemHeight,
	          r = this.itemMarginBottom,
	          n = this.itemMarginTop,
	          a = s ? k(e.itemDistance, 20) : 0,
	          h = this.maxLegendWidth,
	          l = e.alignColumns && this.totalItemWidth > h ? this.maxItemWidth : t.itemWidth,
	          d = t.legendItem || {};
	        s && this.itemX - i + l > h && (this.itemX = i, this.lastLineHeight && (this.itemY += n + this.lastLineHeight + r), this.lastLineHeight = 0), this.lastItemY = n + this.itemY + r, this.lastLineHeight = Math.max(o, this.lastLineHeight), d.x = this.itemX, d.y = this.itemY, s ? this.itemX += l : (this.itemY += n + o + r, this.lastLineHeight = o), this.offsetWidth = this.widthOption || Math.max((s ? this.itemX - i - (t.checkbox ? 0 : a) : l) + i, this.offsetWidth);
	      }
	      getAllItems() {
	        let t = [];
	        return this.chart.series.forEach(function (e) {
	          let i = e && e.options;
	          e && k(i.showInLegend, !m(i.linkedTo) && void 0, !0) && (t = t.concat((e.legendItem || {}).labels || ("point" === i.legendType ? e.data : e)));
	        }), b(this, "afterGetAllItems", {
	          allItems: t
	        }), t;
	      }
	      getAlignment() {
	        let t = this.options;
	        return this.proximate ? t.align.charAt(0) + "tv" : t.floating ? "" : t.align.charAt(0) + t.verticalAlign.charAt(0) + t.layout.charAt(0);
	      }
	      adjustMargins(t, e) {
	        let i = this.chart,
	          s = this.options,
	          o = this.getAlignment();
	        o && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function (r, n) {
	          r.test(o) && !m(t[n]) && (i[c[n]] = Math.max(i[c[n]], i.legend[(n + 1) % 2 ? "legendHeight" : "legendWidth"] + [1, -1, -1, 1][n] * s[n % 2 ? "x" : "y"] + k(s.margin, 12) + e[n] + (i.titleOffset[n] || 0)));
	        });
	      }
	      proximatePositions() {
	        let t;
	        let e = this.chart,
	          i = [],
	          s = "left" === this.options.align;
	        for (let o of (this.allItems.forEach(function (t) {
	          let o,
	            r,
	            n = s,
	            a,
	            h;
	          t.yAxis && (t.xAxis.options.reversed && (n = !n), t.points && (o = y(n ? t.points : t.points.slice(0).reverse(), function (t) {
	            return v(t.plotY);
	          })), r = this.itemMarginTop + t.legendItem.label.getBBox().height + this.itemMarginBottom, h = t.yAxis.top - e.plotTop, a = t.visible ? (o ? o.plotY : t.yAxis.height) + (h - .3 * r) : h + t.yAxis.height, i.push({
	            target: a,
	            size: r,
	            item: t
	          }));
	        }, this), p(i, e.plotHeight))) t = o.item.legendItem || {}, v(o.pos) && (t.y = e.plotTop - e.spacing[0] + o.pos);
	      }
	      render() {
	        let t = this.chart,
	          e = t.renderer,
	          i = this.options,
	          s = this.padding,
	          o = this.getAllItems(),
	          r,
	          n,
	          a,
	          h = this.group,
	          l,
	          d = this.box;
	        this.itemX = s, this.itemY = this.initialItemY, this.offsetWidth = 0, this.lastItemY = 0, this.widthOption = C(i.width, t.spacingBox.width - s), l = t.spacingBox.width - 2 * s - i.x, ["rm", "lm"].indexOf(this.getAlignment().substring(0, 2)) > -1 && (l /= 2), this.maxLegendWidth = this.widthOption || l, h || (this.group = h = e.g("legend").addClass(i.className || "").attr({
	          zIndex: 7
	        }).add(), this.contentGroup = e.g().attr({
	          zIndex: 1
	        }).add(h), this.scrollGroup = e.g().add(this.contentGroup)), this.renderTitle(), w(o, (t, e) => (t.options && t.options.legendIndex || 0) - (e.options && e.options.legendIndex || 0)), i.reversed && o.reverse(), this.allItems = o, this.display = r = !!o.length, this.lastLineHeight = 0, this.maxItemWidth = 0, this.totalItemWidth = 0, this.itemHeight = 0, o.forEach(this.renderItem, this), o.forEach(this.layoutItem, this), n = (this.widthOption || this.offsetWidth) + s, a = this.lastItemY + this.lastLineHeight + this.titleHeight, a = this.handleOverflow(a) + s, d || (this.box = d = e.rect().addClass("highcharts-legend-box").attr({
	          r: i.borderRadius
	        }).add(h)), t.styledMode || d.attr({
	          stroke: i.borderColor,
	          "stroke-width": i.borderWidth || 0,
	          fill: i.backgroundColor || "none"
	        }).shadow(i.shadow), n > 0 && a > 0 && d[d.placed ? "animate" : "attr"](d.crisp.call({}, {
	          x: 0,
	          y: 0,
	          width: n,
	          height: a
	        }, d.strokeWidth())), h[r ? "show" : "hide"](), t.styledMode && "none" === h.getStyle("display") && (n = a = 0), this.legendWidth = n, this.legendHeight = a, r && this.align(), this.proximate || this.positionItems(), b(this, "afterRender");
	      }
	      align(t = this.chart.spacingBox) {
	        let e = this.chart,
	          i = this.options,
	          s = t.y;
	        /(lth|ct|rth)/.test(this.getAlignment()) && e.titleOffset[0] > 0 ? s += e.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && e.titleOffset[2] > 0 && (s -= e.titleOffset[2]), s !== t.y && (t = S(t, {
	          y: s
	        })), e.hasRendered || (this.group.placed = !1), this.group.align(S(i, {
	          width: this.legendWidth,
	          height: this.legendHeight,
	          verticalAlign: this.proximate ? "top" : i.verticalAlign
	        }), !0, t);
	      }
	      handleOverflow(t) {
	        let e = this,
	          i = this.chart,
	          s = i.renderer,
	          o = this.options,
	          r = o.y,
	          n = "top" === o.verticalAlign,
	          a = this.padding,
	          h = o.maxHeight,
	          l = o.navigation,
	          d = k(l.animation, !0),
	          c = l.arrowSize || 12,
	          p = this.pages,
	          u = this.allItems,
	          g = function (t) {
	            "number" == typeof t ? S.attr({
	              height: t
	            }) : S && (e.clipRect = S.destroy(), e.contentGroup.clip()), e.contentGroup.div && (e.contentGroup.div.style.clip = t ? "rect(" + a + "px,9999px," + (a + t) + "px,0)" : "auto");
	          },
	          f = function (t) {
	            return e[t] = s.circle(0, 0, 1.3 * c).translate(c / 2, c / 2).add(v), i.styledMode || e[t].attr("fill", "rgba(0,0,0,0.0001)"), e[t];
	          },
	          m,
	          x,
	          y,
	          b = i.spacingBox.height + (n ? -r : r) - a,
	          v = this.nav,
	          S = this.clipRect;
	        return "horizontal" !== o.layout || "middle" === o.verticalAlign || o.floating || (b /= 2), h && (b = Math.min(b, h)), p.length = 0, t && b > 0 && t > b && !1 !== l.enabled ? (this.clipHeight = m = Math.max(b - 20 - this.titleHeight - a, 0), this.currentPage = k(this.currentPage, 1), this.fullHeight = t, u.forEach((t, e) => {
	          y = t.legendItem || {};
	          let i = y.y || 0,
	            s = Math.round(y.label.getBBox().height),
	            o = p.length;
	          (!o || i - p[o - 1] > m && (x || i) !== p[o - 1]) && (p.push(x || i), o++), y.pageIx = o - 1, x && ((u[e - 1].legendItem || {}).pageIx = o - 1), e === u.length - 1 && i + s - p[o - 1] > m && i > p[o - 1] && (p.push(i), y.pageIx = o), i !== x && (x = i);
	        }), S || (S = e.clipRect = s.clipRect(0, a - 2, 9999, 0), e.contentGroup.clip(S)), g(m), v || (this.nav = v = s.g().attr({
	          zIndex: 1
	        }).add(this.group), this.up = s.symbol("triangle", 0, 0, c, c).add(v), f("upTracker").on("click", function () {
	          e.scroll(-1, d);
	        }), this.pager = s.text("", 15, 10).addClass("highcharts-legend-navigation"), !i.styledMode && l.style && this.pager.css(l.style), this.pager.add(v), this.down = s.symbol("triangle-down", 0, 0, c, c).add(v), f("downTracker").on("click", function () {
	          e.scroll(1, d);
	        })), e.scroll(0), t = b) : v && (g(), this.nav = v.destroy(), this.scrollGroup.attr({
	          translateY: 1
	        }), this.clipHeight = 0), t;
	      }
	      scroll(t, e) {
	        let i = this.chart,
	          s = this.pages,
	          o = s.length,
	          r = this.clipHeight,
	          n = this.options.navigation,
	          l = this.pager,
	          d = this.padding,
	          c = this.currentPage + t;
	        if (c > o && (c = o), c > 0) {
	          void 0 !== e && h(e, i), this.nav.attr({
	            translateX: d,
	            translateY: r + this.padding + 7 + this.titleHeight,
	            visibility: "inherit"
	          }), [this.up, this.upTracker].forEach(function (t) {
	            t.attr({
	              class: 1 === c ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
	            });
	          }), l.attr({
	            text: c + "/" + o
	          }), [this.down, this.downTracker].forEach(function (t) {
	            t.attr({
	              x: 18 + this.pager.getBBox().width,
	              class: c === o ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
	            });
	          }, this), i.styledMode || (this.up.attr({
	            fill: 1 === c ? n.inactiveColor : n.activeColor
	          }), this.upTracker.css({
	            cursor: 1 === c ? "default" : "pointer"
	          }), this.down.attr({
	            fill: c === o ? n.inactiveColor : n.activeColor
	          }), this.downTracker.css({
	            cursor: c === o ? "default" : "pointer"
	          })), this.scrollOffset = -s[c - 1] + this.initialItemY, this.scrollGroup.animate({
	            translateY: this.scrollOffset
	          }), this.currentPage = c, this.positionCheckboxes();
	          let t = a(k(e, i.renderer.globalAnimation, !0));
	          T(() => {
	            b(this, "afterScroll", {
	              currentPage: c
	            });
	          }, t.duration);
	        }
	      }
	      setItemEvents(t, e, i) {
	        let o = this,
	          r = t.legendItem || {},
	          n = o.chart.renderer.boxWrapper,
	          a = t instanceof s,
	          h = "highcharts-legend-" + (a ? "point" : "series") + "-active",
	          l = o.chart.styledMode,
	          d = i ? [e, r.symbol] : [r.group],
	          c = e => {
	            o.allItems.forEach(i => {
	              t !== i && [i].concat(i.linkedSeries || []).forEach(t => {
	                t.setState(e, !a);
	              });
	            });
	          };
	        for (let i of d) i && i.on("mouseover", function () {
	          t.visible && c("inactive"), t.setState("hover"), t.visible && n.addClass(h), l || e.css(o.options.itemHoverStyle);
	        }).on("mouseout", function () {
	          o.chart.styledMode || e.css(S(t.visible ? o.itemStyle : o.itemHiddenStyle)), c(""), n.removeClass(h), t.setState();
	        }).on("click", function (e) {
	          let i = "legendItemClick",
	            s = function () {
	              t.setVisible && t.setVisible(), c(t.visible ? "inactive" : "");
	            };
	          n.removeClass(h), e = {
	            browserEvent: e
	          }, t.firePointEvent ? t.firePointEvent(i, e, s) : b(t, i, e, s);
	        });
	      }
	      createCheckboxForItem(t) {
	        t.checkbox = g("input", {
	          type: "checkbox",
	          className: "highcharts-legend-checkbox",
	          checked: t.selected,
	          defaultChecked: t.selected
	        }, this.options.itemCheckboxStyle, this.chart.container), u(t.checkbox, "click", function (e) {
	          let i = e.target;
	          b(t.series || t, "checkboxClick", {
	            checked: i.checked,
	            item: t
	          }, function () {
	            t.select();
	          });
	        });
	      }
	    }
	    return (n = A || (A = {})).compose = function t(e) {
	      M(d, t) && u(e, "beforeMargins", function () {
	        this.legend = new n(this, this.options.legend);
	      });
	    }, A;
	  }), i(e, "Core/Legend/LegendSymbol.js", [e["Core/Utilities.js"]], function (t) {
	    var e;
	    let {
	      extend: i,
	      merge: s,
	      pick: o
	    } = t;
	    return function (t) {
	      function e(t, e, r) {
	        let n = this.legendItem = this.legendItem || {},
	          {
	            chart: a,
	            options: h
	          } = this,
	          {
	            baseline: l = 0,
	            symbolWidth: d,
	            symbolHeight: c
	          } = t,
	          p = this.symbol || "circle",
	          u = c / 2,
	          g = a.renderer,
	          f = n.group,
	          m = l - Math.round(c * (r ? .4 : .3)),
	          x = {},
	          y,
	          b = h.marker,
	          v = 0;
	        if (a.styledMode || (x["stroke-width"] = Math.min(h.lineWidth || 0, 24), h.dashStyle ? x.dashstyle = h.dashStyle : "square" === h.linecap || (x["stroke-linecap"] = "round")), n.line = g.path().addClass("highcharts-graph").attr(x).add(f), r && (n.area = g.path().addClass("highcharts-area").add(f)), x["stroke-linecap"] && (v = Math.min(n.line.strokeWidth(), d) / 2), d) {
	          let t = [["M", v, m], ["L", d - v, m]];
	          n.line.attr({
	            d: t
	          }), n.area?.attr({
	            d: [...t, ["L", d - v, l], ["L", v, l]]
	          });
	        }
	        if (b && !1 !== b.enabled && d) {
	          let t = Math.min(o(b.radius, u), u);
	          0 === p.indexOf("url") && (b = s(b, {
	            width: c,
	            height: c
	          }), t = 0), n.symbol = y = g.symbol(p, d / 2 - t, m - t, 2 * t, 2 * t, i({
	            context: "legend"
	          }, b)).addClass("highcharts-point").add(f), y.isMarker = !0;
	        }
	      }
	      t.areaMarker = function (t, i) {
	        e.call(this, t, i, !0);
	      }, t.lineMarker = e, t.rectangle = function (t, e) {
	        let i = e.legendItem || {},
	          s = t.options,
	          r = t.symbolHeight,
	          n = s.squareSymbol,
	          a = n ? r : t.symbolWidth;
	        i.symbol = this.chart.renderer.rect(n ? (t.symbolWidth - r) / 2 : 0, t.baseline - r + 1, a, r, o(t.options.symbolRadius, r / 2)).addClass("highcharts-point").attr({
	          zIndex: 3
	        }).add(i.group);
	      };
	    }(e || (e = {})), e;
	  }), i(e, "Core/Series/SeriesDefaults.js", [], function () {
	    return {
	      lineWidth: 2,
	      allowPointSelect: !1,
	      crisp: !0,
	      showCheckbox: !1,
	      animation: {
	        duration: 1e3
	      },
	      enableMouseTracking: !0,
	      events: {},
	      marker: {
	        enabledThreshold: 2,
	        lineColor: "#ffffff",
	        lineWidth: 0,
	        radius: 4,
	        states: {
	          normal: {
	            animation: !0
	          },
	          hover: {
	            animation: {
	              duration: 150
	            },
	            enabled: !0,
	            radiusPlus: 2,
	            lineWidthPlus: 1
	          },
	          select: {
	            fillColor: "#cccccc",
	            lineColor: "#000000",
	            lineWidth: 2
	          }
	        }
	      },
	      point: {
	        events: {}
	      },
	      dataLabels: {
	        animation: {},
	        align: "center",
	        borderWidth: 0,
	        defer: !0,
	        formatter: function () {
	          let {
	            numberFormatter: t
	          } = this.series.chart;
	          return "number" != typeof this.y ? "" : t(this.y, -1);
	        },
	        padding: 5,
	        style: {
	          fontSize: "0.7em",
	          fontWeight: "bold",
	          color: "contrast",
	          textOutline: "1px contrast"
	        },
	        verticalAlign: "bottom",
	        x: 0,
	        y: 0
	      },
	      cropThreshold: 300,
	      opacity: 1,
	      pointRange: 0,
	      softThreshold: !0,
	      states: {
	        normal: {
	          animation: !0
	        },
	        hover: {
	          animation: {
	            duration: 150
	          },
	          lineWidthPlus: 1,
	          marker: {},
	          halo: {
	            size: 10,
	            opacity: .25
	          }
	        },
	        select: {
	          animation: {
	            duration: 0
	          }
	        },
	        inactive: {
	          animation: {
	            duration: 150
	          },
	          opacity: .2
	        }
	      },
	      stickyTracking: !0,
	      turboThreshold: 1e3,
	      findNearestPointBy: "x"
	    };
	  }), i(e, "Core/Series/SeriesRegistry.js", [e["Core/Globals.js"], e["Core/Defaults.js"], e["Core/Series/Point.js"], e["Core/Utilities.js"]], function (t, e, i, s) {
	    var o;
	    let {
	        defaultOptions: r
	      } = e,
	      {
	        extendClass: n,
	        merge: a
	      } = s;
	    return function (e) {
	      function s(t, s) {
	        let o = r.plotOptions || {},
	          n = s.defaultOptions,
	          a = s.prototype;
	        a.type = t, a.pointClass || (a.pointClass = i), n && (o[t] = n), e.seriesTypes[t] = s;
	      }
	      e.seriesTypes = t.seriesTypes, e.registerSeriesType = s, e.seriesType = function (t, o, h, l, d) {
	        let c = r.plotOptions || {};
	        return o = o || "", c[t] = a(c[o], h), s(t, n(e.seriesTypes[o] || function () {}, l)), e.seriesTypes[t].prototype.type = t, d && (e.seriesTypes[t].prototype.pointClass = n(i, d)), e.seriesTypes[t];
	      };
	    }(o || (o = {})), o;
	  }), i(e, "Core/Series/Series.js", [e["Core/Animation/AnimationUtilities.js"], e["Core/Defaults.js"], e["Core/Foundation.js"], e["Core/Globals.js"], e["Core/Legend/LegendSymbol.js"], e["Core/Series/Point.js"], e["Core/Series/SeriesDefaults.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Renderer/SVG/SVGElement.js"], e["Core/Utilities.js"]], function (t, e, i, s, o, r, n, a, h, l) {
	    let {
	        animObject: d,
	        setAnimation: c
	      } = t,
	      {
	        defaultOptions: p
	      } = e,
	      {
	        registerEventOptions: u
	      } = i,
	      {
	        hasTouch: g,
	        svg: f,
	        win: m
	      } = s,
	      {
	        seriesTypes: x
	      } = a,
	      {
	        arrayMax: y,
	        arrayMin: b,
	        clamp: v,
	        correctFloat: S,
	        defined: k,
	        destroyObjectProperties: M,
	        diffObjects: C,
	        erase: w,
	        error: T,
	        extend: A,
	        find: P,
	        fireEvent: L,
	        getClosestDistance: O,
	        getNestedProperty: D,
	        insertItem: E,
	        isArray: j,
	        isNumber: I,
	        isString: B,
	        merge: R,
	        objectEach: z,
	        pick: N,
	        removeEvent: W,
	        splat: G,
	        syncTimeout: H
	      } = l;
	    class X {
	      constructor() {
	        this.zoneAxis = "y";
	      }
	      init(t, e) {
	        let i;
	        L(this, "init", {
	          options: e
	        });
	        let s = this,
	          o = t.series;
	        this.eventsToUnbind = [], s.chart = t, s.options = s.setOptions(e);
	        let r = s.options,
	          n = !1 !== r.visible;
	        s.linkedSeries = [], s.bindAxes(), A(s, {
	          name: r.name,
	          state: "",
	          visible: n,
	          selected: !0 === r.selected
	        }), u(this, r);
	        let a = r.events;
	        (a && a.click || r.point && r.point.events && r.point.events.click || r.allowPointSelect) && (t.runTrackerClick = !0), s.getColor(), s.getSymbol(), s.parallelArrays.forEach(function (t) {
	          s[t + "Data"] || (s[t + "Data"] = []);
	        }), s.isCartesian && (t.hasCartesianSeries = !0), o.length && (i = o[o.length - 1]), s._i = N(i && i._i, -1) + 1, s.opacity = s.options.opacity, t.orderItems("series", E(this, o)), r.dataSorting && r.dataSorting.enabled ? s.setDataSortingOptions() : s.points || s.data || s.setData(r.data, !1), L(this, "afterInit");
	      }
	      is(t) {
	        return x[t] && this instanceof x[t];
	      }
	      bindAxes() {
	        let t;
	        let e = this,
	          i = e.options,
	          s = e.chart;
	        L(this, "bindAxes", null, function () {
	          (e.axisTypes || []).forEach(function (o) {
	            s[o].forEach(function (s) {
	              t = s.options, (N(i[o], 0) === s.index || void 0 !== i[o] && i[o] === t.id) && (E(e, s.series), e[o] = s, s.isDirty = !0);
	            }), e[o] || e.optionalAxis === o || T(18, !0, s);
	          });
	        }), L(this, "afterBindAxes");
	      }
	      updateParallelArrays(t, e, i) {
	        let s = t.series,
	          o = I(e) ? function (i) {
	            let o = "y" === i && s.toYData ? s.toYData(t) : t[i];
	            s[i + "Data"][e] = o;
	          } : function (t) {
	            Array.prototype[e].apply(s[t + "Data"], i);
	          };
	        s.parallelArrays.forEach(o);
	      }
	      hasData() {
	        return this.visible && void 0 !== this.dataMax && void 0 !== this.dataMin || this.visible && this.yData && this.yData.length > 0;
	      }
	      hasMarkerChanged(t, e) {
	        let i = t.marker,
	          s = e.marker || {};
	        return i && (s.enabled && !i.enabled || s.symbol !== i.symbol || s.height !== i.height || s.width !== i.width);
	      }
	      autoIncrement(t) {
	        let e = this.options,
	          i = e.pointIntervalUnit,
	          s = e.relativeXValue,
	          o = this.chart.time,
	          r = this.xIncrement,
	          n,
	          a;
	        return (r = N(r, e.pointStart, 0), this.pointInterval = a = N(this.pointInterval, e.pointInterval, 1), s && I(t) && (a *= t), i && (n = new o.Date(r), "day" === i ? o.set("Date", n, o.get("Date", n) + a) : "month" === i ? o.set("Month", n, o.get("Month", n) + a) : "year" === i && o.set("FullYear", n, o.get("FullYear", n) + a), a = n.getTime() - r), s && I(t)) ? r + a : (this.xIncrement = r + a, r);
	      }
	      setDataSortingOptions() {
	        let t = this.options;
	        A(this, {
	          requireSorting: !1,
	          sorted: !1,
	          enabledDataSorting: !0,
	          allowDG: !1
	        }), k(t.pointRange) || (t.pointRange = 1);
	      }
	      setOptions(t) {
	        let e;
	        let i = this.chart,
	          s = i.options,
	          o = s.plotOptions,
	          r = i.userOptions || {},
	          n = R(t),
	          a = i.styledMode,
	          h = {
	            plotOptions: o,
	            userOptions: n
	          };
	        L(this, "setOptions", h);
	        let l = h.plotOptions[this.type],
	          d = r.plotOptions || {},
	          c = d.series || {},
	          u = p.plotOptions[this.type] || {},
	          g = d[this.type] || {};
	        this.userOptions = h.userOptions;
	        let f = R(l, o.series, g, n);
	        this.tooltipOptions = R(p.tooltip, p.plotOptions.series?.tooltip, u?.tooltip, i.userOptions.tooltip, d.series?.tooltip, g.tooltip, n.tooltip), this.stickyTracking = N(n.stickyTracking, g.stickyTracking, c.stickyTracking, !!this.tooltipOptions.shared && !this.noSharedTooltip || f.stickyTracking), null === l.marker && delete f.marker, this.zoneAxis = f.zoneAxis || "y";
	        let m = this.zones = (f.zones || []).slice();
	        return (f.negativeColor || f.negativeFillColor) && !f.zones && (e = {
	          value: f[this.zoneAxis + "Threshold"] || f.threshold || 0,
	          className: "highcharts-negative"
	        }, a || (e.color = f.negativeColor, e.fillColor = f.negativeFillColor), m.push(e)), m.length && k(m[m.length - 1].value) && m.push(a ? {} : {
	          color: this.color,
	          fillColor: this.fillColor
	        }), L(this, "afterSetOptions", {
	          options: f
	        }), f;
	      }
	      getName() {
	        return N(this.options.name, "Series " + (this.index + 1));
	      }
	      getCyclic(t, e, i) {
	        let s, o;
	        let r = this.chart,
	          n = `${t}Index`,
	          a = `${t}Counter`,
	          h = i?.length || r.options.chart.colorCount;
	        !e && (k(o = N("color" === t ? this.options.colorIndex : void 0, this[n])) ? s = o : (r.series.length || (r[a] = 0), s = r[a] % h, r[a] += 1), i && (e = i[s])), void 0 !== s && (this[n] = s), this[t] = e;
	      }
	      getColor() {
	        this.chart.styledMode ? this.getCyclic("color") : this.options.colorByPoint ? this.color = "#cccccc" : this.getCyclic("color", this.options.color || p.plotOptions[this.type].color, this.chart.options.colors);
	      }
	      getPointsCollection() {
	        return (this.hasGroupedData ? this.points : this.data) || [];
	      }
	      getSymbol() {
	        let t = this.options.marker;
	        this.getCyclic("symbol", t.symbol, this.chart.options.symbols);
	      }
	      findPointIndex(t, e) {
	        let i, s, o;
	        let n = t.id,
	          a = t.x,
	          h = this.points,
	          l = this.options.dataSorting;
	        if (n) {
	          let t = this.chart.get(n);
	          t instanceof r && (i = t);
	        } else if (this.linkedParent || this.enabledDataSorting || this.options.relativeXValue) {
	          let e = e => !e.touched && e.index === t.index;
	          if (l && l.matchByName ? e = e => !e.touched && e.name === t.name : this.options.relativeXValue && (e = e => !e.touched && e.options.x === t.x), !(i = P(h, e))) return;
	        }
	        return i && void 0 !== (o = i && i.index) && (s = !0), void 0 === o && I(a) && (o = this.xData.indexOf(a, e)), -1 !== o && void 0 !== o && this.cropped && (o = o >= this.cropStart ? o - this.cropStart : o), !s && I(o) && h[o] && h[o].touched && (o = void 0), o;
	      }
	      updateData(t, e) {
	        let i = this.options,
	          s = i.dataSorting,
	          o = this.points,
	          r = [],
	          n = this.requireSorting,
	          a = t.length === o.length,
	          h,
	          l,
	          d,
	          c,
	          p = !0;
	        if (this.xIncrement = null, t.forEach(function (t, e) {
	          let l;
	          let d = k(t) && this.pointClass.prototype.optionsToObject.call({
	              series: this
	            }, t) || {},
	            p = d.x,
	            u = d.id;
	          u || I(p) ? (-1 === (l = this.findPointIndex(d, c)) || void 0 === l ? r.push(t) : o[l] && t !== i.data[l] ? (o[l].update(t, !1, null, !1), o[l].touched = !0, n && (c = l + 1)) : o[l] && (o[l].touched = !0), (!a || e !== l || s && s.enabled || this.hasDerivedData) && (h = !0)) : r.push(t);
	        }, this), h) for (l = o.length; l--;) (d = o[l]) && !d.touched && d.remove && d.remove(!1, e);else !a || s && s.enabled ? p = !1 : (t.forEach(function (t, e) {
	          t === o[e].y || o[e].destroyed || o[e].update(t, !1, null, !1);
	        }), r.length = 0);
	        return o.forEach(function (t) {
	          t && (t.touched = !1);
	        }), !!p && (r.forEach(function (t) {
	          this.addPoint(t, !1, null, null, !1);
	        }, this), null === this.xIncrement && this.xData && this.xData.length && (this.xIncrement = y(this.xData), this.autoIncrement()), !0);
	      }
	      setData(t, e = !0, i, s) {
	        let o = this,
	          r = o.points,
	          n = r && r.length || 0,
	          a = o.options,
	          h = o.chart,
	          l = a.dataSorting,
	          d = o.xAxis,
	          c = a.turboThreshold,
	          p = this.xData,
	          u = this.yData,
	          g = o.pointArrayMap,
	          f = g && g.length,
	          m = a.keys,
	          x,
	          y,
	          b,
	          v = 0,
	          S = 1,
	          k = null,
	          M;
	        h.options.chart.allowMutatingData || (a.data && delete o.options.data, o.userOptions.data && delete o.userOptions.data, M = R(!0, t)), t = M || t || [];
	        let C = t.length;
	        if (l && l.enabled && (t = this.sortData(t)), h.options.chart.allowMutatingData && !1 !== s && C && n && !o.cropped && !o.hasGroupedData && o.visible && !o.boosted && (b = this.updateData(t, i)), !b) {
	          if (o.xIncrement = null, o.colorCounter = 0, this.parallelArrays.forEach(function (t) {
	            o[t + "Data"].length = 0;
	          }), c && C > c) {
	            if (I(k = o.getFirstValidPoint(t))) for (x = 0; x < C; x++) p[x] = this.autoIncrement(), u[x] = t[x];else if (j(k)) {
	              if (f) {
	                if (k.length === f) for (x = 0; x < C; x++) p[x] = this.autoIncrement(), u[x] = t[x];else for (x = 0; x < C; x++) y = t[x], p[x] = y[0], u[x] = y.slice(1, f + 1);
	              } else if (m && (v = m.indexOf("x"), S = m.indexOf("y"), v = v >= 0 ? v : 0, S = S >= 0 ? S : 1), 1 === k.length && (S = 0), v === S) for (x = 0; x < C; x++) p[x] = this.autoIncrement(), u[x] = t[x][S];else for (x = 0; x < C; x++) y = t[x], p[x] = y[v], u[x] = y[S];
	            } else T(12, !1, h);
	          } else for (x = 0; x < C; x++) y = {
	            series: o
	          }, o.pointClass.prototype.applyOptions.apply(y, [t[x]]), o.updateParallelArrays(y, x);
	          for (u && B(u[0]) && T(14, !0, h), o.data = [], o.options.data = o.userOptions.data = t, x = n; x--;) r[x]?.destroy();
	          d && (d.minRange = d.userMinRange), o.isDirty = h.isDirtyBox = !0, o.isDirtyData = !!r, i = !1;
	        }
	        "point" === a.legendType && (this.processData(), this.generatePoints()), e && h.redraw(i);
	      }
	      sortData(t) {
	        let e = this,
	          i = e.options,
	          s = i.dataSorting,
	          o = s.sortKey || "y",
	          r = function (t, e) {
	            return k(e) && t.pointClass.prototype.optionsToObject.call({
	              series: t
	            }, e) || {};
	          };
	        t.forEach(function (i, s) {
	          t[s] = r(e, i), t[s].index = s;
	        }, this);
	        let n = t.concat().sort((t, e) => {
	          let i = D(o, t),
	            s = D(o, e);
	          return s < i ? -1 : s > i ? 1 : 0;
	        });
	        return n.forEach(function (t, e) {
	          t.x = e;
	        }, this), e.linkedSeries && e.linkedSeries.forEach(function (e) {
	          let i = e.options,
	            s = i.data;
	          i.dataSorting && i.dataSorting.enabled || !s || (s.forEach(function (i, o) {
	            s[o] = r(e, i), t[o] && (s[o].x = t[o].x, s[o].index = o);
	          }), e.setData(s, !1));
	        }), t;
	      }
	      getProcessedData(t) {
	        let e = this,
	          i = e.xAxis,
	          s = e.options,
	          o = s.cropThreshold,
	          r = t || e.getExtremesFromAll || s.getExtremesFromAll,
	          n = i?.logarithmic,
	          a = e.isCartesian,
	          h,
	          l,
	          d = 0,
	          c,
	          p,
	          u,
	          g = e.xData,
	          f = e.yData,
	          m = !1,
	          x = g.length;
	        i && (p = (c = i.getExtremes()).min, u = c.max, m = !!(i.categories && !i.names.length)), a && e.sorted && !r && (!o || x > o || e.forceCrop) && (g[x - 1] < p || g[0] > u ? (g = [], f = []) : e.yData && (g[0] < p || g[x - 1] > u) && (g = (h = this.cropData(e.xData, e.yData, p, u)).xData, f = h.yData, d = h.start, l = !0));
	        let y = O([n ? g.map(n.log2lin) : g], () => e.requireSorting && !m && T(15, !1, e.chart));
	        return {
	          xData: g,
	          yData: f,
	          cropped: l,
	          cropStart: d,
	          closestPointRange: y
	        };
	      }
	      processData(t) {
	        let e = this.xAxis;
	        if (this.isCartesian && !this.isDirty && !e.isDirty && !this.yAxis.isDirty && !t) return !1;
	        let i = this.getProcessedData();
	        this.cropped = i.cropped, this.cropStart = i.cropStart, this.processedXData = i.xData, this.processedYData = i.yData, this.closestPointRange = this.basePointRange = i.closestPointRange, L(this, "afterProcessData");
	      }
	      cropData(t, e, i, s) {
	        let o = t.length,
	          r,
	          n,
	          a = 0,
	          h = o;
	        for (r = 0; r < o; r++) if (t[r] >= i) {
	          a = Math.max(0, r - 1);
	          break;
	        }
	        for (n = r; n < o; n++) if (t[n] > s) {
	          h = n + 1;
	          break;
	        }
	        return {
	          xData: t.slice(a, h),
	          yData: e.slice(a, h),
	          start: a,
	          end: h
	        };
	      }
	      generatePoints() {
	        let t = this.options,
	          e = this.processedData || t.data,
	          i = this.processedXData,
	          s = this.processedYData,
	          o = this.pointClass,
	          r = i.length,
	          n = this.cropStart || 0,
	          a = this.hasGroupedData,
	          h = t.keys,
	          l = [],
	          d = t.dataGrouping && t.dataGrouping.groupAll ? n : 0,
	          c,
	          p,
	          u,
	          g,
	          f = this.data;
	        if (!f && !a) {
	          let t = [];
	          t.length = e.length, f = this.data = t;
	        }
	        for (h && a && (this.options.keys = !1), g = 0; g < r; g++) p = n + g, a ? ((u = new o(this, [i[g]].concat(G(s[g])))).dataGroup = this.groupMap[d + g], u.dataGroup.options && (u.options = u.dataGroup.options, A(u, u.dataGroup.options), delete u.dataLabels)) : (u = f[p]) || void 0 === e[p] || (f[p] = u = new o(this, e[p], i[g])), u && (u.index = a ? d + g : p, l[g] = u);
	        if (this.options.keys = h, f && (r !== (c = f.length) || a)) for (g = 0; g < c; g++) g !== n || a || (g += r), f[g] && (f[g].destroyElements(), f[g].plotX = void 0);
	        this.data = f, this.points = l, L(this, "afterGeneratePoints");
	      }
	      getXExtremes(t) {
	        return {
	          min: b(t),
	          max: y(t)
	        };
	      }
	      getExtremes(t, e) {
	        let i = this.xAxis,
	          s = this.yAxis,
	          o = this.processedXData || this.xData,
	          r = [],
	          n = this.requireSorting && !this.is("column") ? 1 : 0,
	          a = !!s && s.positiveValuesOnly,
	          h,
	          l,
	          d,
	          c,
	          p,
	          u,
	          g,
	          f = 0,
	          m = 0,
	          x = 0;
	        t = t || this.stackedYData || this.processedYData || [];
	        let v = t.length;
	        for (i && (f = (h = i.getExtremes()).min, m = h.max), u = 0; u < v; u++) if (c = o[u], l = (I(p = t[u]) || j(p)) && ((I(p) ? p > 0 : p.length) || !a), d = e || this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !i || (o[u + n] || c) >= f && (o[u - n] || c) <= m, l && d) {
	          if (g = p.length) for (; g--;) I(p[g]) && (r[x++] = p[g]);else r[x++] = p;
	        }
	        let S = {
	          activeYData: r,
	          dataMin: b(r),
	          dataMax: y(r)
	        };
	        return L(this, "afterGetExtremes", {
	          dataExtremes: S
	        }), S;
	      }
	      applyExtremes() {
	        let t = this.getExtremes();
	        return this.dataMin = t.dataMin, this.dataMax = t.dataMax, t;
	      }
	      getFirstValidPoint(t) {
	        let e = t.length,
	          i = 0,
	          s = null;
	        for (; null === s && i < e;) s = t[i], i++;
	        return s;
	      }
	      translate() {
	        this.processedXData || this.processData(), this.generatePoints();
	        let t = this.options,
	          e = t.stacking,
	          i = this.xAxis,
	          s = i.categories,
	          o = this.enabledDataSorting,
	          r = this.yAxis,
	          n = this.points,
	          a = n.length,
	          h = this.pointPlacementToXValue(),
	          l = !!h,
	          d = t.threshold,
	          c = t.startFromThreshold ? d : 0,
	          p,
	          u,
	          g,
	          f,
	          m = Number.MAX_VALUE;
	        function x(t) {
	          return v(t, -1e5, 1e5);
	        }
	        for (p = 0; p < a; p++) {
	          let t;
	          let a = n[p],
	            y = a.x,
	            b,
	            v,
	            M = a.y,
	            C = a.low,
	            w = e && r.stacking?.stacks[(this.negStacks && M < (c ? 0 : d) ? "-" : "") + this.stackKey];
	          u = i.translate(y, !1, !1, !1, !0, h), a.plotX = I(u) ? S(x(u)) : void 0, e && this.visible && w && w[y] && (f = this.getStackIndicator(f, y, this.index), !a.isNull && f.key && (v = (b = w[y]).points[f.key]), b && j(v) && (C = v[0], M = v[1], C === c && f.key === w[y].base && (C = N(I(d) ? d : r.min)), r.positiveValuesOnly && k(C) && C <= 0 && (C = void 0), a.total = a.stackTotal = N(b.total), a.percentage = k(a.y) && b.total ? a.y / b.total * 100 : void 0, a.stackY = M, this.irregularWidths || b.setOffset(this.pointXOffset || 0, this.barW || 0, void 0, void 0, void 0, this.xAxis))), a.yBottom = k(C) ? x(r.translate(C, !1, !0, !1, !0)) : void 0, this.dataModify && (M = this.dataModify.modifyValue(M, p)), I(M) && void 0 !== a.plotX && (t = I(t = r.translate(M, !1, !0, !1, !0)) ? x(t) : void 0), a.plotY = t, a.isInside = this.isPointInside(a), a.clientX = l ? S(i.translate(y, !1, !1, !1, !0, h)) : u, a.negative = (a.y || 0) < (d || 0), a.category = N(s && s[a.x], a.x), a.isNull || !1 === a.visible || (void 0 !== g && (m = Math.min(m, Math.abs(u - g))), g = u), a.zone = this.zones.length ? a.getZone() : void 0, !a.graphic && this.group && o && (a.isNew = !0);
	        }
	        this.closestPointRangePx = m, L(this, "afterTranslate");
	      }
	      getValidPoints(t, e, i) {
	        let s = this.chart;
	        return (t || this.points || []).filter(function (t) {
	          let {
	              plotX: o,
	              plotY: r
	            } = t,
	            n = !i && (t.isNull || !I(r));
	          return !n && (!e || !!s.isInsidePlot(o, r, {
	            inverted: s.inverted
	          })) && !1 !== t.visible;
	        });
	      }
	      getClipBox() {
	        let {
	            chart: t,
	            xAxis: e,
	            yAxis: i
	          } = this,
	          s = R(t.clipBox);
	        return e && e.len !== t.plotSizeX && (s.width = e.len), i && i.len !== t.plotSizeY && (s.height = i.len), s;
	      }
	      getSharedClipKey() {
	        return this.sharedClipKey = (this.options.xAxis || 0) + "," + (this.options.yAxis || 0), this.sharedClipKey;
	      }
	      setClip() {
	        let {
	            chart: t,
	            group: e,
	            markerGroup: i
	          } = this,
	          s = t.sharedClips,
	          o = t.renderer,
	          r = this.getClipBox(),
	          n = this.getSharedClipKey(),
	          a = s[n];
	        a ? a.animate(r) : s[n] = a = o.clipRect(r), e && e.clip(!1 === this.options.clip ? void 0 : a), i && i.clip();
	      }
	      animate(t) {
	        let {
	            chart: e,
	            group: i,
	            markerGroup: s
	          } = this,
	          o = e.inverted,
	          r = d(this.options.animation),
	          n = [this.getSharedClipKey(), r.duration, r.easing, r.defer].join(","),
	          a = e.sharedClips[n],
	          h = e.sharedClips[n + "m"];
	        if (t && i) {
	          let t = this.getClipBox();
	          if (a) a.attr("height", t.height);else {
	            t.width = 0, o && (t.x = e.plotHeight), a = e.renderer.clipRect(t), e.sharedClips[n] = a;
	            let i = {
	              x: -99,
	              y: -99,
	              width: o ? e.plotWidth + 199 : 99,
	              height: o ? 99 : e.plotHeight + 199
	            };
	            h = e.renderer.clipRect(i), e.sharedClips[n + "m"] = h;
	          }
	          i.clip(a), s && s.clip(h);
	        } else if (a && !a.hasClass("highcharts-animating")) {
	          let t = this.getClipBox(),
	            e = r.step;
	          s && s.element.childNodes.length && (r.step = function (t, i) {
	            e && e.apply(i, arguments), "width" === i.prop && h && h.element && h.attr(o ? "height" : "width", t + 99);
	          }), a.addClass("highcharts-animating").animate(t, r);
	        }
	      }
	      afterAnimate() {
	        this.setClip(), z(this.chart.sharedClips, (t, e, i) => {
	          t && !this.chart.container.querySelector(`[clip-path="url(#${t.id})"]`) && (t.destroy(), delete i[e]);
	        }), this.finishedAnimating = !0, L(this, "afterAnimate");
	      }
	      drawPoints(t = this.points) {
	        let e, i, s, o, r, n, a;
	        let h = this.chart,
	          l = h.styledMode,
	          {
	            colorAxis: d,
	            options: c
	          } = this,
	          p = c.marker,
	          u = this[this.specialGroup || "markerGroup"],
	          g = this.xAxis,
	          f = N(p.enabled, !g || !!g.isRadial || null, this.closestPointRangePx >= p.enabledThreshold * p.radius);
	        if (!1 !== p.enabled || this._hasPointMarkers) for (e = 0; e < t.length; e++) {
	          o = (s = (i = t[e]).graphic) ? "animate" : "attr", r = i.marker || {}, n = !!i.marker;
	          let c = (f && void 0 === r.enabled || r.enabled) && !i.isNull && !1 !== i.visible;
	          if (c) {
	            let t = N(r.symbol, this.symbol, "rect");
	            a = this.markerAttribs(i, i.selected && "select"), this.enabledDataSorting && (i.startXPos = g.reversed ? -(a.width || 0) : g.width);
	            let e = !1 !== i.isInside;
	            if (!s && e && ((a.width || 0) > 0 || i.hasImage) && (i.graphic = s = h.renderer.symbol(t, a.x, a.y, a.width, a.height, n ? r : p).add(u), this.enabledDataSorting && h.hasRendered && (s.attr({
	              x: i.startXPos
	            }), o = "animate")), s && "animate" === o && s[e ? "show" : "hide"](e).animate(a), s) {
	              let t = this.pointAttribs(i, l || !i.selected ? void 0 : "select");
	              l ? d && s.css({
	                fill: t.fill
	              }) : s[o](t);
	            }
	            s && s.addClass(i.getClassName(), !0);
	          } else s && (i.graphic = s.destroy());
	        }
	      }
	      markerAttribs(t, e) {
	        let i = this.options,
	          s = i.marker,
	          o = t.marker || {},
	          r = o.symbol || s.symbol,
	          n = {},
	          a,
	          h,
	          l = N(o.radius, s && s.radius);
	        e && (a = s.states[e], l = N((h = o.states && o.states[e]) && h.radius, a && a.radius, l && l + (a && a.radiusPlus || 0))), t.hasImage = r && 0 === r.indexOf("url"), t.hasImage && (l = 0);
	        let d = t.pos();
	        return I(l) && d && (n.x = d[0] - l, n.y = d[1] - l, i.crisp && (n.x = Math.floor(n.x))), l && (n.width = n.height = 2 * l), n;
	      }
	      pointAttribs(t, e) {
	        let i = this.options.marker,
	          s = t && t.options,
	          o = s && s.marker || {},
	          r = s && s.color,
	          n = t && t.color,
	          a = t && t.zone && t.zone.color,
	          h,
	          l,
	          d = this.color,
	          c,
	          p,
	          u = N(o.lineWidth, i.lineWidth),
	          g = 1;
	        return d = r || a || n || d, c = o.fillColor || i.fillColor || d, p = o.lineColor || i.lineColor || d, e = e || "normal", h = i.states[e] || {}, u = N((l = o.states && o.states[e] || {}).lineWidth, h.lineWidth, u + N(l.lineWidthPlus, h.lineWidthPlus, 0)), c = l.fillColor || h.fillColor || c, {
	          stroke: p = l.lineColor || h.lineColor || p,
	          "stroke-width": u,
	          fill: c,
	          opacity: g = N(l.opacity, h.opacity, g)
	        };
	      }
	      destroy(t) {
	        let e, i, s;
	        let o = this,
	          r = o.chart,
	          n = /AppleWebKit\/533/.test(m.navigator.userAgent),
	          a = o.data || [];
	        for (L(o, "destroy", {
	          keepEventsForUpdate: t
	        }), this.removeEvents(t), (o.axisTypes || []).forEach(function (t) {
	          (s = o[t]) && s.series && (w(s.series, o), s.isDirty = s.forceRedraw = !0);
	        }), o.legendItem && o.chart.legend.destroyItem(o), e = a.length; e--;) (i = a[e]) && i.destroy && i.destroy();
	        o.zones.forEach(M), l.clearTimeout(o.animationTimeout), z(o, function (t, e) {
	          t instanceof h && !t.survive && t[n && "group" === e ? "hide" : "destroy"]();
	        }), r.hoverSeries === o && (r.hoverSeries = void 0), w(r.series, o), r.orderItems("series"), z(o, function (e, i) {
	          t && "hcEvents" === i || delete o[i];
	        });
	      }
	      applyZones() {
	        let {
	            area: t,
	            chart: e,
	            graph: i,
	            zones: s,
	            points: o,
	            xAxis: r,
	            yAxis: n,
	            zoneAxis: a
	          } = this,
	          {
	            inverted: h,
	            renderer: l
	          } = e,
	          d = this[`${a}Axis`],
	          {
	            isXAxis: c,
	            len: p = 0
	          } = d || {},
	          u = (i?.strokeWidth() || 0) / 2 + 1,
	          g = (t, e = 0, i = 0) => {
	            h && (i = p - i);
	            let {
	                translated: s = 0,
	                lineClip: o
	              } = t,
	              r = i - s;
	            o?.push(["L", e, Math.abs(r) < u ? i - u * (r <= 0 ? -1 : 1) : s]);
	          };
	        if (s.length && (i || t) && d && I(d.min)) {
	          let e = d.getExtremes().max,
	            u = t => {
	              t.forEach((e, i) => {
	                ("M" === e[0] || "L" === e[0]) && (t[i] = [e[0], c ? p - e[1] : e[1], c ? e[2] : p - e[2]]);
	              });
	            };
	          if (s.forEach((t, i) => {
	            t.lineClip = [], t.translated = v(d.toPixels(N(t.value, e), !0) || 0, 0, p);
	          }), i && !this.showLine && i.hide(), t && t.hide(), "y" === a && o.length < r.len) for (let t of o) {
	            let {
	                plotX: e,
	                plotY: i,
	                zone: o
	              } = t,
	              r = o && s[s.indexOf(o) - 1];
	            o && g(o, e, i), r && g(r, e, i);
	          }
	          let f = [],
	            m = d.toPixels(d.getExtremes().min, !0);
	          s.forEach(e => {
	            let s = e.lineClip || [],
	              o = Math.round(e.translated || 0);
	            r.reversed && s.reverse();
	            let {
	                clip: a,
	                simpleClip: d
	              } = e,
	              p = 0,
	              g = 0,
	              x = r.len,
	              y = n.len;
	            c ? (p = o, x = m) : (g = o, y = m);
	            let b = [["M", p, g], ["L", x, g], ["L", x, y], ["L", p, y], ["Z"]],
	              v = [b[0], ...s, b[1], b[2], ...f, b[3], b[4]];
	            f = s.reverse(), m = o, h && (u(v), t && u(b)), a ? (a.animate({
	              d: v
	            }), d?.animate({
	              d: b
	            })) : (a = e.clip = l.path(v), t && (d = e.simpleClip = l.path(b))), i && e.graph?.clip(a), t && e.area?.clip(d);
	          });
	        } else this.visible && (i && i.show(), t && t.show());
	      }
	      plotGroup(t, e, i, s, o) {
	        let r = this[t],
	          n = !r,
	          a = {
	            visibility: i,
	            zIndex: s || .1
	          };
	        return k(this.opacity) && !this.chart.styledMode && "inactive" !== this.state && (a.opacity = this.opacity), r || (this[t] = r = this.chart.renderer.g().add(o)), r.addClass("highcharts-" + e + " highcharts-series-" + this.index + " highcharts-" + this.type + "-series " + (k(this.colorIndex) ? "highcharts-color-" + this.colorIndex + " " : "") + (this.options.className || "") + (r.hasClass("highcharts-tracker") ? " highcharts-tracker" : ""), !0), r.attr(a)[n ? "attr" : "animate"](this.getPlotBox(e)), r;
	      }
	      getPlotBox(t) {
	        let e = this.xAxis,
	          i = this.yAxis,
	          s = this.chart,
	          o = s.inverted && !s.polar && e && !1 !== this.invertible && "series" === t;
	        return s.inverted && (e = i, i = this.xAxis), {
	          translateX: e ? e.left : s.plotLeft,
	          translateY: i ? i.top : s.plotTop,
	          rotation: o ? 90 : 0,
	          rotationOriginX: o ? (e.len - i.len) / 2 : 0,
	          rotationOriginY: o ? (e.len + i.len) / 2 : 0,
	          scaleX: o ? -1 : 1,
	          scaleY: 1
	        };
	      }
	      removeEvents(t) {
	        let {
	          eventsToUnbind: e
	        } = this;
	        t || W(this), e.length && (e.forEach(t => {
	          t();
	        }), e.length = 0);
	      }
	      render() {
	        let t = this,
	          {
	            chart: e,
	            options: i,
	            hasRendered: s
	          } = t,
	          o = d(i.animation),
	          r = t.visible ? "inherit" : "hidden",
	          n = i.zIndex,
	          a = e.seriesGroup,
	          h = t.finishedAnimating ? 0 : o.duration;
	        L(this, "render"), t.plotGroup("group", "series", r, n, a), t.markerGroup = t.plotGroup("markerGroup", "markers", r, n, a), !1 !== i.clip && t.setClip(), h && t.animate?.(!0), t.drawGraph && (t.drawGraph(), t.applyZones()), t.visible && t.drawPoints(), t.drawDataLabels?.(), t.redrawPoints?.(), i.enableMouseTracking && t.drawTracker?.(), h && t.animate?.(), s || (h && o.defer && (h += o.defer), t.animationTimeout = H(() => {
	          t.afterAnimate();
	        }, h || 0)), t.isDirty = !1, t.hasRendered = !0, L(t, "afterRender");
	      }
	      redraw() {
	        let t = this.isDirty || this.isDirtyData;
	        this.translate(), this.render(), t && delete this.kdTree;
	      }
	      reserveSpace() {
	        return this.visible || !this.chart.options.chart.ignoreHiddenSeries;
	      }
	      searchPoint(t, e) {
	        let {
	            xAxis: i,
	            yAxis: s
	          } = this,
	          o = this.chart.inverted;
	        return this.searchKDTree({
	          clientX: o ? i.len - t.chartY + i.pos : t.chartX - i.pos,
	          plotY: o ? s.len - t.chartX + s.pos : t.chartY - s.pos
	        }, e, t);
	      }
	      buildKDTree(t) {
	        this.buildingKdTree = !0;
	        let e = this,
	          i = e.options.findNearestPointBy.indexOf("y") > -1 ? 2 : 1;
	        delete e.kdTree, H(function () {
	          e.kdTree = function t(i, s, o) {
	            let r, n;
	            let a = i?.length;
	            if (a) return r = e.kdAxisArray[s % o], i.sort((t, e) => (t[r] || 0) - (e[r] || 0)), {
	              point: i[n = Math.floor(a / 2)],
	              left: t(i.slice(0, n), s + 1, o),
	              right: t(i.slice(n + 1), s + 1, o)
	            };
	          }(e.getValidPoints(void 0, !e.directTouch), i, i), e.buildingKdTree = !1;
	        }, e.options.kdNow || t?.type === "touchstart" ? 0 : 1);
	      }
	      searchKDTree(t, e, i) {
	        let s = this,
	          [o, r] = this.kdAxisArray,
	          n = e ? "distX" : "dist",
	          a = (s.options.findNearestPointBy || "").indexOf("y") > -1 ? 2 : 1,
	          h = !!s.isBubble;
	        if (this.kdTree || this.buildingKdTree || this.buildKDTree(i), this.kdTree) return function t(e, i, a, l) {
	          let d = i.point,
	            c = s.kdAxisArray[a % l],
	            p,
	            u,
	            g = d;
	          !function (t, e) {
	            let i = t[o],
	              s = e[o],
	              n = k(i) && k(s) ? i - s : null,
	              a = t[r],
	              l = e[r],
	              d = k(a) && k(l) ? a - l : 0,
	              c = h && e.marker?.radius || 0;
	            e.dist = Math.sqrt((n && n * n || 0) + d * d) - c, e.distX = k(n) ? Math.abs(n) - c : Number.MAX_VALUE;
	          }(e, d);
	          let f = (e[c] || 0) - (d[c] || 0) + (h && d.marker?.radius || 0),
	            m = f < 0 ? "left" : "right",
	            x = f < 0 ? "right" : "left";
	          return i[m] && (g = (p = t(e, i[m], a + 1, l))[n] < g[n] ? p : d), i[x] && Math.sqrt(f * f) < g[n] && (g = (u = t(e, i[x], a + 1, l))[n] < g[n] ? u : g), g;
	        }(t, this.kdTree, a, a);
	      }
	      pointPlacementToXValue() {
	        let {
	            options: t,
	            xAxis: e
	          } = this,
	          i = t.pointPlacement;
	        return "between" === i && (i = e.reversed ? -.5 : .5), I(i) ? i * (t.pointRange || e.pointRange) : 0;
	      }
	      isPointInside(t) {
	        let {
	            chart: e,
	            xAxis: i,
	            yAxis: s
	          } = this,
	          {
	            plotX: o = -1,
	            plotY: r = -1
	          } = t,
	          n = r >= 0 && r <= (s ? s.len : e.plotHeight) && o >= 0 && o <= (i ? i.len : e.plotWidth);
	        return n;
	      }
	      drawTracker() {
	        let t = this,
	          e = t.options,
	          i = e.trackByArea,
	          s = [].concat((i ? t.areaPath : t.graphPath) || []),
	          o = t.chart,
	          r = o.pointer,
	          n = o.renderer,
	          a = o.options.tooltip?.snap || 0,
	          h = () => {
	            e.enableMouseTracking && o.hoverSeries !== t && t.onMouseOver();
	          },
	          l = "rgba(192,192,192," + (f ? 1e-4 : .002) + ")",
	          d = t.tracker;
	        d ? d.attr({
	          d: s
	        }) : t.graph && (t.tracker = d = n.path(s).attr({
	          visibility: t.visible ? "inherit" : "hidden",
	          zIndex: 2
	        }).addClass(i ? "highcharts-tracker-area" : "highcharts-tracker-line").add(t.group), o.styledMode || d.attr({
	          "stroke-linecap": "round",
	          "stroke-linejoin": "round",
	          stroke: l,
	          fill: i ? l : "none",
	          "stroke-width": t.graph.strokeWidth() + (i ? 0 : 2 * a)
	        }), [t.tracker, t.markerGroup, t.dataLabelsGroup].forEach(t => {
	          t && (t.addClass("highcharts-tracker").on("mouseover", h).on("mouseout", t => {
	            r.onTrackerMouseOut(t);
	          }), e.cursor && !o.styledMode && t.css({
	            cursor: e.cursor
	          }), g && t.on("touchstart", h));
	        })), L(this, "afterDrawTracker");
	      }
	      addPoint(t, e, i, s, o) {
	        let r, n;
	        let a = this.options,
	          h = this.data,
	          l = this.chart,
	          d = this.xAxis,
	          c = d && d.hasNames && d.names,
	          p = a.data,
	          u = this.xData;
	        e = N(e, !0);
	        let g = {
	          series: this
	        };
	        this.pointClass.prototype.applyOptions.apply(g, [t]);
	        let f = g.x;
	        if (n = u.length, this.requireSorting && f < u[n - 1]) for (r = !0; n && u[n - 1] > f;) n--;
	        this.updateParallelArrays(g, "splice", [n, 0, 0]), this.updateParallelArrays(g, n), c && g.name && (c[f] = g.name), p.splice(n, 0, t), (r || this.processedData) && (this.data.splice(n, 0, null), this.processData()), "point" === a.legendType && this.generatePoints(), i && (h[0] && h[0].remove ? h[0].remove(!1) : (h.shift(), this.updateParallelArrays(g, "shift"), p.shift())), !1 !== o && L(this, "addPoint", {
	          point: g
	        }), this.isDirty = !0, this.isDirtyData = !0, e && l.redraw(s);
	      }
	      removePoint(t, e, i) {
	        let s = this,
	          o = s.data,
	          r = o[t],
	          n = s.points,
	          a = s.chart,
	          h = function () {
	            n && n.length === o.length && n.splice(t, 1), o.splice(t, 1), s.options.data.splice(t, 1), s.updateParallelArrays(r || {
	              series: s
	            }, "splice", [t, 1]), r && r.destroy(), s.isDirty = !0, s.isDirtyData = !0, e && a.redraw();
	          };
	        c(i, a), e = N(e, !0), r ? r.firePointEvent("remove", null, h) : h();
	      }
	      remove(t, e, i, s) {
	        let o = this,
	          r = o.chart;
	        function n() {
	          o.destroy(s), r.isDirtyLegend = r.isDirtyBox = !0, r.linkSeries(s), N(t, !0) && r.redraw(e);
	        }
	        !1 !== i ? L(o, "remove", null, n) : n();
	      }
	      update(t, e) {
	        L(this, "update", {
	          options: t = C(t, this.userOptions)
	        });
	        let i = this,
	          s = i.chart,
	          o = i.userOptions,
	          r = i.initialType || i.type,
	          n = s.options.plotOptions,
	          a = x[r].prototype,
	          h = i.finishedAnimating && {
	            animation: !1
	          },
	          l = {},
	          d,
	          c,
	          p = ["colorIndex", "eventOptions", "navigatorSeries", "symbolIndex", "baseSeries"],
	          u = t.type || o.type || s.options.chart.type,
	          g = !(this.hasDerivedData || u && u !== this.type || void 0 !== t.pointStart || void 0 !== t.pointInterval || void 0 !== t.relativeXValue || t.joinBy || t.mapData || ["dataGrouping", "pointStart", "pointInterval", "pointIntervalUnit", "keys"].some(t => i.hasOptionChanged(t)));
	        u = u || r, g && (p.push("data", "isDirtyData", "isDirtyCanvas", "points", "processedData", "processedXData", "processedYData", "xIncrement", "cropped", "_hasPointMarkers", "hasDataLabels", "nodes", "layout", "level", "mapMap", "mapData", "minY", "maxY", "minX", "maxX"), !1 !== t.visible && p.push("area", "graph"), i.parallelArrays.forEach(function (t) {
	          p.push(t + "Data");
	        }), t.data && (t.dataSorting && A(i.options.dataSorting, t.dataSorting), this.setData(t.data, !1))), t = R(o, {
	          index: void 0 === o.index ? i.index : o.index,
	          pointStart: n?.series?.pointStart ?? o.pointStart ?? i.xData?.[0]
	        }, !g && {
	          data: i.options.data
	        }, t, h), g && t.data && (t.data = i.options.data), (p = ["group", "markerGroup", "dataLabelsGroup", "transformGroup"].concat(p)).forEach(function (t) {
	          p[t] = i[t], delete i[t];
	        });
	        let f = !1;
	        if (x[u]) {
	          if (f = u !== i.type, i.remove(!1, !1, !1, !0), f) {
	            if (Object.setPrototypeOf) Object.setPrototypeOf(i, x[u].prototype);else {
	              let t = Object.hasOwnProperty.call(i, "hcEvents") && i.hcEvents;
	              for (c in a) i[c] = void 0;
	              A(i, x[u].prototype), t ? i.hcEvents = t : delete i.hcEvents;
	            }
	          }
	        } else T(17, !0, s, {
	          missingModuleFor: u
	        });
	        if (p.forEach(function (t) {
	          i[t] = p[t];
	        }), i.init(s, t), g && this.points) for (let t of (!1 === (d = i.options).visible ? (l.graphic = 1, l.dataLabel = 1) : (this.hasMarkerChanged(d, o) && (l.graphic = 1), i.hasDataLabels?.() || (l.dataLabel = 1)), this.points)) t && t.series && (t.resolveColor(), Object.keys(l).length && t.destroyElements(l), !1 === d.showInLegend && t.legendItem && s.legend.destroyItem(t));
	        i.initialType = r, s.linkSeries(), s.setSortedData(), f && i.linkedSeries.length && (i.isDirtyData = !0), L(this, "afterUpdate"), N(e, !0) && s.redraw(!!g && void 0);
	      }
	      setName(t) {
	        this.name = this.options.name = this.userOptions.name = t, this.chart.isDirtyLegend = !0;
	      }
	      hasOptionChanged(t) {
	        let e = this.chart,
	          i = this.options[t],
	          s = e.options.plotOptions,
	          o = this.userOptions[t],
	          r = N(s?.[this.type]?.[t], s?.series?.[t]);
	        return o && !k(r) ? i !== o : i !== N(r, i);
	      }
	      onMouseOver() {
	        let t = this.chart,
	          e = t.hoverSeries,
	          i = t.pointer;
	        i.setHoverChartIndex(), e && e !== this && e.onMouseOut(), this.options.events.mouseOver && L(this, "mouseOver"), this.setState("hover"), t.hoverSeries = this;
	      }
	      onMouseOut() {
	        let t = this.options,
	          e = this.chart,
	          i = e.tooltip,
	          s = e.hoverPoint;
	        e.hoverSeries = null, s && s.onMouseOut(), this && t.events.mouseOut && L(this, "mouseOut"), i && !this.stickyTracking && (!i.shared || this.noSharedTooltip) && i.hide(), e.series.forEach(function (t) {
	          t.setState("", !0);
	        });
	      }
	      setState(t, e) {
	        let i = this,
	          s = i.options,
	          o = i.graph,
	          r = s.inactiveOtherPoints,
	          n = s.states,
	          a = N(n[t || "normal"] && n[t || "normal"].animation, i.chart.options.chart.animation),
	          h = s.lineWidth,
	          l = s.opacity;
	        if (t = t || "", i.state !== t && ([i.group, i.markerGroup, i.dataLabelsGroup].forEach(function (e) {
	          e && (i.state && e.removeClass("highcharts-series-" + i.state), t && e.addClass("highcharts-series-" + t));
	        }), i.state = t, !i.chart.styledMode)) {
	          if (n[t] && !1 === n[t].enabled) return;
	          if (t && (h = n[t].lineWidth || h + (n[t].lineWidthPlus || 0), l = N(n[t].opacity, l)), o && !o.dashstyle && I(h)) for (let t of [o, ...this.zones.map(t => t.graph)]) t?.animate({
	            "stroke-width": h
	          }, a);
	          r || [i.group, i.markerGroup, i.dataLabelsGroup, i.labelBySeries].forEach(function (t) {
	            t && t.animate({
	              opacity: l
	            }, a);
	          });
	        }
	        e && r && i.points && i.setAllPointsToState(t || void 0);
	      }
	      setAllPointsToState(t) {
	        this.points.forEach(function (e) {
	          e.setState && e.setState(t);
	        });
	      }
	      setVisible(t, e) {
	        let i = this,
	          s = i.chart,
	          o = s.options.chart.ignoreHiddenSeries,
	          r = i.visible;
	        i.visible = t = i.options.visible = i.userOptions.visible = void 0 === t ? !r : t;
	        let n = t ? "show" : "hide";
	        ["group", "dataLabelsGroup", "markerGroup", "tracker", "tt"].forEach(t => {
	          i[t]?.[n]();
	        }), (s.hoverSeries === i || s.hoverPoint?.series === i) && i.onMouseOut(), i.legendItem && s.legend.colorizeItem(i, t), i.isDirty = !0, i.options.stacking && s.series.forEach(t => {
	          t.options.stacking && t.visible && (t.isDirty = !0);
	        }), i.linkedSeries.forEach(e => {
	          e.setVisible(t, !1);
	        }), o && (s.isDirtyBox = !0), L(i, n), !1 !== e && s.redraw();
	      }
	      show() {
	        this.setVisible(!0);
	      }
	      hide() {
	        this.setVisible(!1);
	      }
	      select(t) {
	        this.selected = t = this.options.selected = void 0 === t ? !this.selected : t, this.checkbox && (this.checkbox.checked = t), L(this, t ? "select" : "unselect");
	      }
	      shouldShowTooltip(t, e, i = {}) {
	        return i.series = this, i.visiblePlotOnly = !0, this.chart.isInsidePlot(t, e, i);
	      }
	      drawLegendSymbol(t, e) {
	        o[this.options.legendSymbol || "rectangle"]?.call(this, t, e);
	      }
	    }
	    return X.defaultOptions = n, X.types = a.seriesTypes, X.registerType = a.registerSeriesType, A(X.prototype, {
	      axisTypes: ["xAxis", "yAxis"],
	      coll: "series",
	      colorCounter: 0,
	      directTouch: !1,
	      isCartesian: !0,
	      kdAxisArray: ["clientX", "plotY"],
	      parallelArrays: ["x", "y"],
	      pointClass: r,
	      requireSorting: !0,
	      sorted: !0
	    }), a.series = X, X;
	  }), i(e, "Core/Chart/Chart.js", [e["Core/Animation/AnimationUtilities.js"], e["Core/Axis/Axis.js"], e["Core/Defaults.js"], e["Core/Templating.js"], e["Core/Foundation.js"], e["Core/Globals.js"], e["Core/Renderer/RendererRegistry.js"], e["Core/Series/Series.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Renderer/SVG/SVGRenderer.js"], e["Core/Time.js"], e["Core/Utilities.js"], e["Core/Renderer/HTML/AST.js"], e["Core/Axis/Tick.js"]], function (t, e, i, s, o, r, n, a, h, l, d, c, p, u) {
	    let {
	        animate: g,
	        animObject: f,
	        setAnimation: m
	      } = t,
	      {
	        defaultOptions: x,
	        defaultTime: y
	      } = i,
	      {
	        numberFormat: b
	      } = s,
	      {
	        registerEventOptions: v
	      } = o,
	      {
	        charts: S,
	        doc: k,
	        marginNames: M,
	        svg: C,
	        win: w
	      } = r,
	      {
	        seriesTypes: T
	      } = h,
	      {
	        addEvent: A,
	        attr: P,
	        createElement: L,
	        clamp: O,
	        css: D,
	        defined: E,
	        diffObjects: j,
	        discardElement: I,
	        erase: B,
	        error: R,
	        extend: z,
	        find: N,
	        fireEvent: W,
	        getStyle: G,
	        isArray: H,
	        isNumber: X,
	        isObject: F,
	        isString: Y,
	        merge: U,
	        objectEach: V,
	        pick: $,
	        pInt: Z,
	        relativeLength: _,
	        removeEvent: q,
	        splat: K,
	        syncTimeout: J,
	        uniqueKey: Q
	      } = c;
	    class tt {
	      static chart(t, e, i) {
	        return new tt(t, e, i);
	      }
	      constructor(t, e, i) {
	        this.sharedClips = {};
	        let s = [...arguments];
	        (Y(t) || t.nodeName) && (this.renderTo = s.shift()), this.init(s[0], s[1]);
	      }
	      setZoomOptions() {
	        let t = this.options.chart,
	          e = t.zooming;
	        this.zooming = {
	          ...e,
	          type: $(t.zoomType, e.type),
	          key: $(t.zoomKey, e.key),
	          pinchType: $(t.pinchType, e.pinchType),
	          singleTouch: $(t.zoomBySingleTouch, e.singleTouch, !1),
	          resetButton: U(e.resetButton, t.resetZoomButton)
	        };
	      }
	      init(t, e) {
	        W(this, "init", {
	          args: arguments
	        }, function () {
	          let i = U(x, t),
	            s = i.chart;
	          this.userOptions = z({}, t), this.margin = [], this.spacing = [], this.bounds = {
	            h: {},
	            v: {}
	          }, this.labelCollectors = [], this.callback = e, this.isResizing = 0, this.options = i, this.axes = [], this.series = [], this.time = t.time && Object.keys(t.time).length ? new d(t.time) : r.time, this.numberFormatter = s.numberFormatter || b, this.styledMode = s.styledMode, this.hasCartesianSeries = s.showAxes, this.index = S.length, S.push(this), r.chartCount++, v(this, s), this.xAxis = [], this.yAxis = [], this.pointCount = this.colorCounter = this.symbolCounter = 0, this.setZoomOptions(), W(this, "afterInit"), this.firstRender();
	        });
	      }
	      initSeries(t) {
	        let e = this.options.chart,
	          i = t.type || e.type,
	          s = T[i];
	        s || R(17, !0, this, {
	          missingModuleFor: i
	        });
	        let o = new s();
	        return "function" == typeof o.init && o.init(this, t), o;
	      }
	      setSortedData() {
	        this.getSeriesOrderByLinks().forEach(function (t) {
	          t.points || t.data || !t.enabledDataSorting || t.setData(t.options.data, !1);
	        });
	      }
	      getSeriesOrderByLinks() {
	        return this.series.concat().sort(function (t, e) {
	          return t.linkedSeries.length || e.linkedSeries.length ? e.linkedSeries.length - t.linkedSeries.length : 0;
	        });
	      }
	      orderItems(t, e = 0) {
	        let i = this[t],
	          s = this.options[t] = K(this.options[t]).slice(),
	          o = this.userOptions[t] = this.userOptions[t] ? K(this.userOptions[t]).slice() : [];
	        if (this.hasRendered && (s.splice(e), o.splice(e)), i) for (let t = e, r = i.length; t < r; ++t) {
	          let e = i[t];
	          e && (e.index = t, e instanceof a && (e.name = e.getName()), e.options.isInternal || (s[t] = e.options, o[t] = e.userOptions));
	        }
	      }
	      isInsidePlot(t, e, i = {}) {
	        let {
	            inverted: s,
	            plotBox: o,
	            plotLeft: r,
	            plotTop: n,
	            scrollablePlotBox: a
	          } = this,
	          h = 0,
	          l = 0;
	        i.visiblePlotOnly && this.scrollingContainer && ({
	          scrollLeft: h,
	          scrollTop: l
	        } = this.scrollingContainer);
	        let d = i.series,
	          c = i.visiblePlotOnly && a || o,
	          p = i.inverted ? e : t,
	          u = i.inverted ? t : e,
	          g = {
	            x: p,
	            y: u,
	            isInsidePlot: !0,
	            options: i
	          };
	        if (!i.ignoreX) {
	          let t = d && (s && !this.polar ? d.yAxis : d.xAxis) || {
	              pos: r,
	              len: 1 / 0
	            },
	            e = i.paneCoordinates ? t.pos + p : r + p;
	          e >= Math.max(h + r, t.pos) && e <= Math.min(h + r + c.width, t.pos + t.len) || (g.isInsidePlot = !1);
	        }
	        if (!i.ignoreY && g.isInsidePlot) {
	          let t = !s && i.axis && !i.axis.isXAxis && i.axis || d && (s ? d.xAxis : d.yAxis) || {
	              pos: n,
	              len: 1 / 0
	            },
	            e = i.paneCoordinates ? t.pos + u : n + u;
	          e >= Math.max(l + n, t.pos) && e <= Math.min(l + n + c.height, t.pos + t.len) || (g.isInsidePlot = !1);
	        }
	        return W(this, "afterIsInsidePlot", g), g.isInsidePlot;
	      }
	      redraw(t) {
	        W(this, "beforeRedraw");
	        let e = this.hasCartesianSeries ? this.axes : this.colorAxis || [],
	          i = this.series,
	          s = this.pointer,
	          o = this.legend,
	          r = this.userOptions.legend,
	          n = this.renderer,
	          a = n.isHidden(),
	          h = [],
	          l,
	          d,
	          c,
	          p = this.isDirtyBox,
	          u = this.isDirtyLegend,
	          g;
	        for (n.rootFontSize = n.boxWrapper.getStyle("font-size"), this.setResponsive && this.setResponsive(!1), m(!!this.hasRendered && t, this), a && this.temporaryDisplay(), this.layOutTitles(!1), c = i.length; c--;) if (((g = i[c]).options.stacking || g.options.centerInCategory) && (d = !0, g.isDirty)) {
	          l = !0;
	          break;
	        }
	        if (l) for (c = i.length; c--;) (g = i[c]).options.stacking && (g.isDirty = !0);
	        i.forEach(function (t) {
	          t.isDirty && ("point" === t.options.legendType ? ("function" == typeof t.updateTotals && t.updateTotals(), u = !0) : r && (r.labelFormatter || r.labelFormat) && (u = !0)), t.isDirtyData && W(t, "updatedData");
	        }), u && o && o.options.enabled && (o.render(), this.isDirtyLegend = !1), d && this.getStacks(), e.forEach(function (t) {
	          t.updateNames(), t.setScale();
	        }), this.getMargins(), e.forEach(function (t) {
	          t.isDirty && (p = !0);
	        }), e.forEach(function (t) {
	          let e = t.min + "," + t.max;
	          t.extKey !== e && (t.extKey = e, h.push(function () {
	            W(t, "afterSetExtremes", z(t.eventArgs, t.getExtremes())), delete t.eventArgs;
	          })), (p || d) && t.redraw();
	        }), p && this.drawChartBox(), W(this, "predraw"), i.forEach(function (t) {
	          (p || t.isDirty) && t.visible && t.redraw(), t.isDirtyData = !1;
	        }), s && s.reset(!0), n.draw(), W(this, "redraw"), W(this, "render"), a && this.temporaryDisplay(!0), h.forEach(function (t) {
	          t.call();
	        });
	      }
	      get(t) {
	        let e = this.series;
	        function i(e) {
	          return e.id === t || e.options && e.options.id === t;
	        }
	        let s = N(this.axes, i) || N(this.series, i);
	        for (let t = 0; !s && t < e.length; t++) s = N(e[t].points || [], i);
	        return s;
	      }
	      getAxes() {
	        let t = this.userOptions;
	        for (let i of (W(this, "getAxes"), ["xAxis", "yAxis"])) {
	          let s = t[i] = K(t[i] || {});
	          for (let t of s) new e(this, t, i);
	        }
	        W(this, "afterGetAxes");
	      }
	      getSelectedPoints() {
	        return this.series.reduce((t, e) => (e.getPointsCollection().forEach(e => {
	          $(e.selectedStaging, e.selected) && t.push(e);
	        }), t), []);
	      }
	      getSelectedSeries() {
	        return this.series.filter(function (t) {
	          return t.selected;
	        });
	      }
	      setTitle(t, e, i) {
	        this.applyDescription("title", t), this.applyDescription("subtitle", e), this.applyDescription("caption", void 0), this.layOutTitles(i);
	      }
	      applyDescription(t, e) {
	        let i = this,
	          s = this.options[t] = U(this.options[t], e),
	          o = this[t];
	        o && e && (this[t] = o = o.destroy()), s && !o && ((o = this.renderer.text(s.text, 0, 0, s.useHTML).attr({
	          align: s.align,
	          class: "highcharts-" + t,
	          zIndex: s.zIndex || 4
	        }).add()).update = function (e, s) {
	          i.applyDescription(t, e), i.layOutTitles(s);
	        }, this.styledMode || o.css(z("title" === t ? {
	          fontSize: this.options.isStock ? "1em" : "1.2em"
	        } : {}, s.style)), this[t] = o);
	      }
	      layOutTitles(t = !0) {
	        let e = [0, 0, 0],
	          i = this.renderer,
	          s = this.spacingBox;
	        ["title", "subtitle", "caption"].forEach(function (t) {
	          let o = this[t],
	            r = this.options[t],
	            n = r.verticalAlign || "top",
	            a = "title" === t ? "top" === n ? -3 : 0 : "top" === n ? e[0] + 2 : 0;
	          if (o) {
	            o.css({
	              width: (r.width || s.width + (r.widthAdjust || 0)) + "px"
	            });
	            let t = i.fontMetrics(o).b,
	              h = Math.round(o.getBBox(r.useHTML).height);
	            o.align(z({
	              y: "bottom" === n ? t : a + t,
	              height: h
	            }, r), !1, "spacingBox"), r.floating || ("top" === n ? e[0] = Math.ceil(e[0] + h) : "bottom" === n && (e[2] = Math.ceil(e[2] + h)));
	          }
	        }, this), e[0] && "top" === (this.options.title.verticalAlign || "top") && (e[0] += this.options.title.margin), e[2] && "bottom" === this.options.caption.verticalAlign && (e[2] += this.options.caption.margin);
	        let o = !this.titleOffset || this.titleOffset.join(",") !== e.join(",");
	        this.titleOffset = e, W(this, "afterLayOutTitles"), !this.isDirtyBox && o && (this.isDirtyBox = this.isDirtyLegend = o, this.hasRendered && t && this.isDirtyBox && this.redraw());
	      }
	      getContainerBox() {
	        return {
	          width: G(this.renderTo, "width", !0) || 0,
	          height: G(this.renderTo, "height", !0) || 0
	        };
	      }
	      getChartSize() {
	        let t = this.options.chart,
	          e = t.width,
	          i = t.height,
	          s = this.getContainerBox();
	        this.chartWidth = Math.max(0, e || s.width || 600), this.chartHeight = Math.max(0, _(i, this.chartWidth) || (s.height > 1 ? s.height : 400)), this.containerBox = s;
	      }
	      temporaryDisplay(t) {
	        let e = this.renderTo,
	          i;
	        if (t) for (; e && e.style;) e.hcOrigStyle && (D(e, e.hcOrigStyle), delete e.hcOrigStyle), e.hcOrigDetached && (k.body.removeChild(e), e.hcOrigDetached = !1), e = e.parentNode;else for (; e && e.style && (k.body.contains(e) || e.parentNode || (e.hcOrigDetached = !0, k.body.appendChild(e)), ("none" === G(e, "display", !1) || e.hcOricDetached) && (e.hcOrigStyle = {
	          display: e.style.display,
	          height: e.style.height,
	          overflow: e.style.overflow
	        }, i = {
	          display: "block",
	          overflow: "hidden"
	        }, e !== this.renderTo && (i.height = 0), D(e, i), e.offsetWidth || e.style.setProperty("display", "block", "important")), (e = e.parentNode) !== k.body););
	      }
	      setClassName(t) {
	        this.container.className = "highcharts-container " + (t || "");
	      }
	      getContainer() {
	        let t = this.options,
	          e = t.chart,
	          i = "data-highcharts-chart",
	          s = Q(),
	          o,
	          r = this.renderTo;
	        r || (this.renderTo = r = e.renderTo), Y(r) && (this.renderTo = r = k.getElementById(r)), r || R(13, !0, this);
	        let a = Z(P(r, i));
	        X(a) && S[a] && S[a].hasRendered && S[a].destroy(), P(r, i, this.index), r.innerHTML = p.emptyHTML, e.skipClone || r.offsetWidth || this.temporaryDisplay(), this.getChartSize();
	        let h = this.chartWidth,
	          d = this.chartHeight;
	        D(r, {
	          overflow: "hidden"
	        }), this.styledMode || (o = z({
	          position: "relative",
	          overflow: "hidden",
	          width: h + "px",
	          height: d + "px",
	          textAlign: "left",
	          lineHeight: "normal",
	          zIndex: 0,
	          "-webkit-tap-highlight-color": "rgba(0,0,0,0)",
	          userSelect: "none",
	          "touch-action": "manipulation",
	          outline: "none"
	        }, e.style || {}));
	        let c = L("div", {
	          id: s
	        }, o, r);
	        this.container = c, this._cursor = c.style.cursor;
	        let u = e.renderer || !C ? n.getRendererType(e.renderer) : l;
	        if (this.renderer = new u(c, h, d, void 0, e.forExport, t.exporting && t.exporting.allowHTML, this.styledMode), this.containerBox = this.getContainerBox(), m(void 0, this), this.setClassName(e.className), this.styledMode) for (let e in t.defs) this.renderer.definition(t.defs[e]);else this.renderer.setStyle(e.style);
	        this.renderer.chartIndex = this.index, W(this, "afterGetContainer");
	      }
	      getMargins(t) {
	        let {
	          spacing: e,
	          margin: i,
	          titleOffset: s
	        } = this;
	        this.resetMargins(), s[0] && !E(i[0]) && (this.plotTop = Math.max(this.plotTop, s[0] + e[0])), s[2] && !E(i[2]) && (this.marginBottom = Math.max(this.marginBottom, s[2] + e[2])), this.legend && this.legend.display && this.legend.adjustMargins(i, e), W(this, "getMargins"), t || this.getAxisMargins();
	      }
	      getAxisMargins() {
	        let t = this,
	          e = t.axisOffset = [0, 0, 0, 0],
	          i = t.colorAxis,
	          s = t.margin,
	          o = function (t) {
	            t.forEach(function (t) {
	              t.visible && t.getOffset();
	            });
	          };
	        t.hasCartesianSeries ? o(t.axes) : i && i.length && o(i), M.forEach(function (i, o) {
	          E(s[o]) || (t[i] += e[o]);
	        }), t.setChartSize();
	      }
	      getOptions() {
	        return j(this.userOptions, x);
	      }
	      reflow(t) {
	        let e = this,
	          i = e.containerBox,
	          s = e.getContainerBox();
	        delete e.pointer.chartPosition, !e.isPrinting && !e.isResizing && i && s.width && ((s.width !== i.width || s.height !== i.height) && (c.clearTimeout(e.reflowTimeout), e.reflowTimeout = J(function () {
	          e.container && e.setSize(void 0, void 0, !1);
	        }, t ? 100 : 0)), e.containerBox = s);
	      }
	      setReflow() {
	        let t = this,
	          e = e => {
	            t.options?.chart.reflow && t.hasLoaded && t.reflow(e);
	          };
	        if ("function" == typeof ResizeObserver) new ResizeObserver(e).observe(t.renderTo);else {
	          let t = A(w, "resize", e);
	          A(this, "destroy", t);
	        }
	      }
	      setSize(t, e, i) {
	        let s = this,
	          o = s.renderer;
	        s.isResizing += 1, m(i, s);
	        let r = o.globalAnimation;
	        s.oldChartHeight = s.chartHeight, s.oldChartWidth = s.chartWidth, void 0 !== t && (s.options.chart.width = t), void 0 !== e && (s.options.chart.height = e), s.getChartSize();
	        let {
	          chartWidth: n,
	          chartHeight: a,
	          scrollablePixelsX: h = 0,
	          scrollablePixelsY: l = 0
	        } = s;
	        (s.isDirtyBox || n !== s.oldChartWidth || a !== s.oldChartHeight) && (s.styledMode || (r ? g : D)(s.container, {
	          width: `${n + h}px`,
	          height: `${a + l}px`
	        }, r), s.setChartSize(!0), o.setSize(n, a, r), s.axes.forEach(function (t) {
	          t.isDirty = !0, t.setScale();
	        }), s.isDirtyLegend = !0, s.isDirtyBox = !0, s.layOutTitles(), s.getMargins(), s.redraw(r), s.oldChartHeight = void 0, W(s, "resize"), setTimeout(() => {
	          s && W(s, "endResize", void 0, () => {
	            s.isResizing -= 1;
	          });
	        }, f(r).duration));
	      }
	      setChartSize(t) {
	        let e, i, s, o;
	        let r = this.inverted,
	          n = this.renderer,
	          a = this.chartWidth,
	          h = this.chartHeight,
	          l = this.options.chart,
	          d = this.spacing,
	          c = this.clipOffset;
	        this.plotLeft = e = Math.round(this.plotLeft), this.plotTop = i = Math.round(this.plotTop), this.plotWidth = s = Math.max(0, Math.round(a - e - this.marginRight)), this.plotHeight = o = Math.max(0, Math.round(h - i - this.marginBottom)), this.plotSizeX = r ? o : s, this.plotSizeY = r ? s : o, this.plotBorderWidth = l.plotBorderWidth || 0, this.spacingBox = n.spacingBox = {
	          x: d[3],
	          y: d[0],
	          width: a - d[3] - d[1],
	          height: h - d[0] - d[2]
	        }, this.plotBox = n.plotBox = {
	          x: e,
	          y: i,
	          width: s,
	          height: o
	        };
	        let p = 2 * Math.floor(this.plotBorderWidth / 2),
	          u = Math.ceil(Math.max(p, c[3]) / 2),
	          g = Math.ceil(Math.max(p, c[0]) / 2);
	        this.clipBox = {
	          x: u,
	          y: g,
	          width: Math.floor(this.plotSizeX - Math.max(p, c[1]) / 2 - u),
	          height: Math.max(0, Math.floor(this.plotSizeY - Math.max(p, c[2]) / 2 - g))
	        }, t || (this.axes.forEach(function (t) {
	          t.setAxisSize(), t.setAxisTranslation();
	        }), n.alignElements()), W(this, "afterSetChartSize", {
	          skipAxes: t
	        });
	      }
	      resetMargins() {
	        W(this, "resetMargins");
	        let t = this,
	          e = t.options.chart;
	        ["margin", "spacing"].forEach(function (i) {
	          let s = e[i],
	            o = F(s) ? s : [s, s, s, s];
	          ["Top", "Right", "Bottom", "Left"].forEach(function (s, r) {
	            t[i][r] = $(e[i + s], o[r]);
	          });
	        }), M.forEach(function (e, i) {
	          t[e] = $(t.margin[i], t.spacing[i]);
	        }), t.axisOffset = [0, 0, 0, 0], t.clipOffset = [0, 0, 0, 0];
	      }
	      drawChartBox() {
	        let t = this.options.chart,
	          e = this.renderer,
	          i = this.chartWidth,
	          s = this.chartHeight,
	          o = this.styledMode,
	          r = this.plotBGImage,
	          n = t.backgroundColor,
	          a = t.plotBackgroundColor,
	          h = t.plotBackgroundImage,
	          l = this.plotLeft,
	          d = this.plotTop,
	          c = this.plotWidth,
	          p = this.plotHeight,
	          u = this.plotBox,
	          g = this.clipRect,
	          f = this.clipBox,
	          m = this.chartBackground,
	          x = this.plotBackground,
	          y = this.plotBorder,
	          b,
	          v,
	          S,
	          k = "animate";
	        m || (this.chartBackground = m = e.rect().addClass("highcharts-background").add(), k = "attr"), o ? b = v = m.strokeWidth() : (v = (b = t.borderWidth || 0) + (t.shadow ? 8 : 0), S = {
	          fill: n || "none"
	        }, (b || m["stroke-width"]) && (S.stroke = t.borderColor, S["stroke-width"] = b), m.attr(S).shadow(t.shadow)), m[k]({
	          x: v / 2,
	          y: v / 2,
	          width: i - v - b % 2,
	          height: s - v - b % 2,
	          r: t.borderRadius
	        }), k = "animate", x || (k = "attr", this.plotBackground = x = e.rect().addClass("highcharts-plot-background").add()), x[k](u), !o && (x.attr({
	          fill: a || "none"
	        }).shadow(t.plotShadow), h && (r ? (h !== r.attr("href") && r.attr("href", h), r.animate(u)) : this.plotBGImage = e.image(h, l, d, c, p).add())), g ? g.animate({
	          width: f.width,
	          height: f.height
	        }) : this.clipRect = e.clipRect(f), k = "animate", y || (k = "attr", this.plotBorder = y = e.rect().addClass("highcharts-plot-border").attr({
	          zIndex: 1
	        }).add()), o || y.attr({
	          stroke: t.plotBorderColor,
	          "stroke-width": t.plotBorderWidth || 0,
	          fill: "none"
	        }), y[k](y.crisp({
	          x: l,
	          y: d,
	          width: c,
	          height: p
	        }, -y.strokeWidth())), this.isDirtyBox = !1, W(this, "afterDrawChartBox");
	      }
	      propFromSeries() {
	        let t, e, i;
	        let s = this,
	          o = s.options.chart,
	          r = s.options.series;
	        ["inverted", "angular", "polar"].forEach(function (n) {
	          for (e = T[o.type], i = o[n] || e && e.prototype[n], t = r && r.length; !i && t--;) (e = T[r[t].type]) && e.prototype[n] && (i = !0);
	          s[n] = i;
	        });
	      }
	      linkSeries(t) {
	        let e = this,
	          i = e.series;
	        i.forEach(function (t) {
	          t.linkedSeries.length = 0;
	        }), i.forEach(function (t) {
	          let {
	            linkedTo: i
	          } = t.options;
	          if (Y(i)) {
	            let s;
	            (s = ":previous" === i ? e.series[t.index - 1] : e.get(i)) && s.linkedParent !== t && (s.linkedSeries.push(t), t.linkedParent = s, s.enabledDataSorting && t.setDataSortingOptions(), t.visible = $(t.options.visible, s.options.visible, t.visible));
	          }
	        }), W(this, "afterLinkSeries", {
	          isUpdating: t
	        });
	      }
	      renderSeries() {
	        this.series.forEach(function (t) {
	          t.translate(), t.render();
	        });
	      }
	      render() {
	        let t = this.axes,
	          e = this.colorAxis,
	          i = this.renderer,
	          s = this.options.chart.axisLayoutRuns || 2,
	          o = t => {
	            t.forEach(t => {
	              t.visible && t.render();
	            });
	          },
	          r = 0,
	          n = !0,
	          a,
	          h = 0;
	        for (let e of (this.setTitle(), W(this, "beforeMargins"), this.getStacks?.(), this.getMargins(!0), this.setChartSize(), t)) {
	          let {
	              options: t
	            } = e,
	            {
	              labels: i
	            } = t;
	          if (e.horiz && e.visible && i.enabled && e.series.length && "colorAxis" !== e.coll && !this.polar) {
	            r = t.tickLength, e.createGroups();
	            let s = new u(e, 0, "", !0),
	              o = s.createLabel("x", i);
	            if (s.destroy(), o && $(i.reserveSpace, !X(t.crossing)) && (r = o.getBBox().height + i.distance + Math.max(t.offset || 0, 0)), r) {
	              o?.destroy();
	              break;
	            }
	          }
	        }
	        for (this.plotHeight = Math.max(this.plotHeight - r, 0); (n || a || s > 1) && h < s;) {
	          let e = this.plotWidth,
	            i = this.plotHeight;
	          for (let e of t) 0 === h ? e.setScale() : (e.horiz && n || !e.horiz && a) && e.setTickInterval(!0);
	          0 === h ? this.getAxisMargins() : this.getMargins(), n = e / this.plotWidth > (h ? 1 : 1.1), a = i / this.plotHeight > (h ? 1 : 1.05), h++;
	        }
	        this.drawChartBox(), this.hasCartesianSeries ? o(t) : e && e.length && o(e), this.seriesGroup || (this.seriesGroup = i.g("series-group").attr({
	          zIndex: 3
	        }).shadow(this.options.chart.seriesGroupShadow).add()), this.renderSeries(), this.addCredits(), this.setResponsive && this.setResponsive(), this.hasRendered = !0;
	      }
	      addCredits(t) {
	        let e = this,
	          i = U(!0, this.options.credits, t);
	        i.enabled && !this.credits && (this.credits = this.renderer.text(i.text + (this.mapCredits || ""), 0, 0).addClass("highcharts-credits").on("click", function () {
	          i.href && (w.location.href = i.href);
	        }).attr({
	          align: i.position.align,
	          zIndex: 8
	        }), e.styledMode || this.credits.css(i.style), this.credits.add().align(i.position), this.credits.update = function (t) {
	          e.credits = e.credits.destroy(), e.addCredits(t);
	        });
	      }
	      destroy() {
	        let t;
	        let e = this,
	          i = e.axes,
	          s = e.series,
	          o = e.container,
	          n = o && o.parentNode;
	        for (W(e, "destroy"), e.renderer.forExport ? B(S, e) : S[e.index] = void 0, r.chartCount--, e.renderTo.removeAttribute("data-highcharts-chart"), q(e), t = i.length; t--;) i[t] = i[t].destroy();
	        for (this.scroller && this.scroller.destroy && this.scroller.destroy(), t = s.length; t--;) s[t] = s[t].destroy();
	        ["title", "subtitle", "chartBackground", "plotBackground", "plotBGImage", "plotBorder", "seriesGroup", "clipRect", "credits", "pointer", "rangeSelector", "legend", "resetZoomButton", "tooltip", "renderer"].forEach(function (t) {
	          let i = e[t];
	          i && i.destroy && (e[t] = i.destroy());
	        }), o && (o.innerHTML = p.emptyHTML, q(o), n && I(o)), V(e, function (t, i) {
	          delete e[i];
	        });
	      }
	      firstRender() {
	        let t = this,
	          e = t.options;
	        t.getContainer(), t.resetMargins(), t.setChartSize(), t.propFromSeries(), t.getAxes();
	        let i = H(e.series) ? e.series : [];
	        e.series = [], i.forEach(function (e) {
	          t.initSeries(e);
	        }), t.linkSeries(), t.setSortedData(), W(t, "beforeRender"), t.render(), t.pointer.getChartPosition(), t.renderer.imgCount || t.hasLoaded || t.onload(), t.temporaryDisplay(!0);
	      }
	      onload() {
	        this.callbacks.concat([this.callback]).forEach(function (t) {
	          t && void 0 !== this.index && t.apply(this, [this]);
	        }, this), W(this, "load"), W(this, "render"), E(this.index) && this.setReflow(), this.warnIfA11yModuleNotLoaded(), this.hasLoaded = !0;
	      }
	      warnIfA11yModuleNotLoaded() {
	        let {
	          options: t,
	          title: e
	        } = this;
	        !t || this.accessibility || (this.renderer.boxWrapper.attr({
	          role: "img",
	          "aria-label": (e && e.element.textContent || "").replace(/</g, "&lt;")
	        }), t.accessibility && !1 === t.accessibility.enabled || R('Highcharts warning: Consider including the "accessibility.js" module to make your chart more usable for people with disabilities. Set the "accessibility.enabled" option to false to remove this warning. See https://www.highcharts.com/docs/accessibility/accessibility-module.', !1, this));
	      }
	      addSeries(t, e, i) {
	        let s;
	        let o = this;
	        return t && (e = $(e, !0), W(o, "addSeries", {
	          options: t
	        }, function () {
	          s = o.initSeries(t), o.isDirtyLegend = !0, o.linkSeries(), s.enabledDataSorting && s.setData(t.data, !1), W(o, "afterAddSeries", {
	            series: s
	          }), e && o.redraw(i);
	        })), s;
	      }
	      addAxis(t, e, i, s) {
	        return this.createAxis(e ? "xAxis" : "yAxis", {
	          axis: t,
	          redraw: i,
	          animation: s
	        });
	      }
	      addColorAxis(t, e, i) {
	        return this.createAxis("colorAxis", {
	          axis: t,
	          redraw: e,
	          animation: i
	        });
	      }
	      createAxis(t, i) {
	        let s = new e(this, i.axis, t);
	        return $(i.redraw, !0) && this.redraw(i.animation), s;
	      }
	      showLoading(t) {
	        let e = this,
	          i = e.options,
	          s = i.loading,
	          o = function () {
	            r && D(r, {
	              left: e.plotLeft + "px",
	              top: e.plotTop + "px",
	              width: e.plotWidth + "px",
	              height: e.plotHeight + "px"
	            });
	          },
	          r = e.loadingDiv,
	          n = e.loadingSpan;
	        r || (e.loadingDiv = r = L("div", {
	          className: "highcharts-loading highcharts-loading-hidden"
	        }, null, e.container)), n || (e.loadingSpan = n = L("span", {
	          className: "highcharts-loading-inner"
	        }, null, r), A(e, "redraw", o)), r.className = "highcharts-loading", p.setElementHTML(n, $(t, i.lang.loading, "")), e.styledMode || (D(r, z(s.style, {
	          zIndex: 10
	        })), D(n, s.labelStyle), e.loadingShown || (D(r, {
	          opacity: 0,
	          display: ""
	        }), g(r, {
	          opacity: s.style.opacity || .5
	        }, {
	          duration: s.showDuration || 0
	        }))), e.loadingShown = !0, o();
	      }
	      hideLoading() {
	        let t = this.options,
	          e = this.loadingDiv;
	        e && (e.className = "highcharts-loading highcharts-loading-hidden", this.styledMode || g(e, {
	          opacity: 0
	        }, {
	          duration: t.loading.hideDuration || 100,
	          complete: function () {
	            D(e, {
	              display: "none"
	            });
	          }
	        })), this.loadingShown = !1;
	      }
	      update(t, e, i, s) {
	        let o, r, n;
	        let a = this,
	          h = {
	            credits: "addCredits",
	            title: "setTitle",
	            subtitle: "setSubtitle",
	            caption: "setCaption"
	          },
	          l = t.isResponsiveOptions,
	          c = [];
	        W(a, "update", {
	          options: t
	        }), l || a.setResponsive(!1, !0), t = j(t, a.options), a.userOptions = U(a.userOptions, t);
	        let p = t.chart;
	        p && (U(!0, a.options.chart, p), this.setZoomOptions(), "className" in p && a.setClassName(p.className), ("inverted" in p || "polar" in p || "type" in p) && (a.propFromSeries(), o = !0), "alignTicks" in p && (o = !0), "events" in p && v(this, p), V(p, function (t, e) {
	          -1 !== a.propsRequireUpdateSeries.indexOf("chart." + e) && (r = !0), -1 !== a.propsRequireDirtyBox.indexOf(e) && (a.isDirtyBox = !0), -1 === a.propsRequireReflow.indexOf(e) || (a.isDirtyBox = !0, l || (n = !0));
	        }), !a.styledMode && p.style && a.renderer.setStyle(a.options.chart.style || {})), !a.styledMode && t.colors && (this.options.colors = t.colors), t.time && (this.time === y && (this.time = new d(t.time)), U(!0, a.options.time, t.time)), V(t, function (e, i) {
	          a[i] && "function" == typeof a[i].update ? a[i].update(e, !1) : "function" == typeof a[h[i]] ? a[h[i]](e) : "colors" !== i && -1 === a.collectionsWithUpdate.indexOf(i) && U(!0, a.options[i], t[i]), "chart" !== i && -1 !== a.propsRequireUpdateSeries.indexOf(i) && (r = !0);
	        }), this.collectionsWithUpdate.forEach(function (e) {
	          t[e] && (K(t[e]).forEach(function (t, s) {
	            let o;
	            let r = E(t.id);
	            r && (o = a.get(t.id)), !o && a[e] && (o = a[e][$(t.index, s)]) && (r && E(o.options.id) || o.options.isInternal) && (o = void 0), o && o.coll === e && (o.update(t, !1), i && (o.touched = !0)), !o && i && a.collectionsWithInit[e] && (a.collectionsWithInit[e][0].apply(a, [t].concat(a.collectionsWithInit[e][1] || []).concat([!1])).touched = !0);
	          }), i && a[e].forEach(function (t) {
	            t.touched || t.options.isInternal ? delete t.touched : c.push(t);
	          }));
	        }), c.forEach(function (t) {
	          t.chart && t.remove && t.remove(!1);
	        }), o && a.axes.forEach(function (t) {
	          t.update({}, !1);
	        }), r && a.getSeriesOrderByLinks().forEach(function (t) {
	          t.chart && t.update({}, !1);
	        }, this);
	        let u = p && p.width,
	          g = p && (Y(p.height) ? _(p.height, u || a.chartWidth) : p.height);
	        n || X(u) && u !== a.chartWidth || X(g) && g !== a.chartHeight ? a.setSize(u, g, s) : $(e, !0) && a.redraw(s), W(a, "afterUpdate", {
	          options: t,
	          redraw: e,
	          animation: s
	        });
	      }
	      setSubtitle(t, e) {
	        this.applyDescription("subtitle", t), this.layOutTitles(e);
	      }
	      setCaption(t, e) {
	        this.applyDescription("caption", t), this.layOutTitles(e);
	      }
	      showResetZoom() {
	        let t = this,
	          e = x.lang,
	          i = t.zooming.resetButton,
	          s = i.theme,
	          o = "chart" === i.relativeTo || "spacingBox" === i.relativeTo ? null : "scrollablePlotBox";
	        function r() {
	          t.zoomOut();
	        }
	        W(this, "beforeShowResetZoom", null, function () {
	          t.resetZoomButton = t.renderer.button(e.resetZoom, null, null, r, s).attr({
	            align: i.position.align,
	            title: e.resetZoomTitle
	          }).addClass("highcharts-reset-zoom").add().align(i.position, !1, o);
	        }), W(this, "afterShowResetZoom");
	      }
	      zoomOut() {
	        W(this, "selection", {
	          resetSelection: !0
	        }, this.zoom);
	      }
	      zoom(t) {
	        let e = this,
	          i = e.pointer,
	          s = !1,
	          o;
	        !t || t.resetSelection ? (e.axes.forEach(function (t) {
	          o = t.zoom();
	        }), i.initiated = !1) : t.xAxis.concat(t.yAxis).forEach(function (t) {
	          let r = t.axis,
	            n = r.isXAxis,
	            {
	              hasPinched: a,
	              mouseDownX: h,
	              mouseDownY: l
	            } = i;
	          (i[n ? "zoomX" : "zoomY"] && E(h) && E(l) && e.isInsidePlot(h - e.plotLeft, l - e.plotTop, {
	            axis: r,
	            ignoreX: a,
	            ignoreY: a
	          }) || !E(e.inverted ? h : l)) && (o = r.zoom(t.min, t.max), r.displayBtn && (s = !0));
	        });
	        let r = e.resetZoomButton;
	        s && !r ? e.showResetZoom() : !s && F(r) && (e.resetZoomButton = r.destroy()), o && e.redraw($(e.options.chart.animation, t && t.animation, e.pointCount < 100));
	      }
	      pan(t, e) {
	        let i;
	        let s = this,
	          o = s.hoverPoints,
	          r = "object" == typeof e ? e : {
	            enabled: e,
	            type: "x"
	          },
	          n = s.options.chart;
	        n && n.panning && (n.panning = r);
	        let a = r.type;
	        W(this, "pan", {
	          originalEvent: t
	        }, function () {
	          o && o.forEach(function (t) {
	            t.setState();
	          });
	          let e = s.xAxis;
	          "xy" === a ? e = e.concat(s.yAxis) : "y" === a && (e = s.yAxis);
	          let r = {};
	          e.forEach(function (e) {
	            if (!e.options.panningEnabled || e.options.isInternal) return;
	            let o = e.horiz,
	              n = t[o ? "chartX" : "chartY"],
	              h = o ? "mouseDownX" : "mouseDownY",
	              l = s[h],
	              d = e.minPointOffset || 0,
	              c = e.reversed && !s.inverted || !e.reversed && s.inverted ? -1 : 1,
	              p = e.getExtremes(),
	              u = e.toValue(l - n, !0) + d * c,
	              g = e.toValue(l + e.len - n, !0) - (d * c || e.isXAxis && e.pointRangePadding || 0),
	              f = g < u,
	              m = e.hasVerticalPanning(),
	              x = f ? g : u,
	              y = f ? u : g,
	              b = e.panningState,
	              v;
	            m && !e.isXAxis && (!b || b.isDirty) && e.series.forEach(function (t) {
	              let e = t.getProcessedData(!0),
	                i = t.getExtremes(e.yData, !0);
	              b || (b = {
	                startMin: Number.MAX_VALUE,
	                startMax: -Number.MAX_VALUE
	              }), X(i.dataMin) && X(i.dataMax) && (b.startMin = Math.min($(t.options.threshold, 1 / 0), i.dataMin, b.startMin), b.startMax = Math.max($(t.options.threshold, -1 / 0), i.dataMax, b.startMax));
	            });
	            let S = Math.min($(b && b.startMin, p.dataMin), d ? p.min : e.toValue(e.toPixels(p.min) - e.minPixelPadding)),
	              k = Math.max($(b && b.startMax, p.dataMax), d ? p.max : e.toValue(e.toPixels(p.max) + e.minPixelPadding));
	            e.panningState = b, e.isOrdinal || ((v = S - x) > 0 && (y += v, x = S), (v = y - k) > 0 && (y = k, x -= v), e.series.length && x !== p.min && y !== p.max && x >= S && y <= k && (e.setExtremes(x, y, !1, !1, {
	              trigger: "pan"
	            }), !s.resetZoomButton && x !== S && y !== k && a.match("y") && (s.showResetZoom(), e.displayBtn = !1), i = !0), r[h] = n);
	          }), V(r, (t, e) => {
	            s[e] = t;
	          }), i && s.redraw(!1), D(s.container, {
	            cursor: "move"
	          });
	        });
	      }
	    }
	    return z(tt.prototype, {
	      callbacks: [],
	      collectionsWithInit: {
	        xAxis: [tt.prototype.addAxis, [!0]],
	        yAxis: [tt.prototype.addAxis, [!1]],
	        series: [tt.prototype.addSeries]
	      },
	      collectionsWithUpdate: ["xAxis", "yAxis", "series"],
	      propsRequireDirtyBox: ["backgroundColor", "borderColor", "borderWidth", "borderRadius", "plotBackgroundColor", "plotBackgroundImage", "plotBorderColor", "plotBorderWidth", "plotShadow", "shadow"],
	      propsRequireReflow: ["margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "spacing", "spacingTop", "spacingRight", "spacingBottom", "spacingLeft"],
	      propsRequireUpdateSeries: ["chart.inverted", "chart.polar", "chart.ignoreHiddenSeries", "chart.type", "colors", "plotOptions", "time", "tooltip"]
	    }), tt;
	  }), i(e, "Extensions/ScrollablePlotArea.js", [e["Core/Animation/AnimationUtilities.js"], e["Core/Globals.js"], e["Core/Renderer/RendererRegistry.js"], e["Core/Utilities.js"]], function (t, e, i, s) {
	    let {
	        stop: o
	      } = t,
	      {
	        composed: r
	      } = e,
	      {
	        addEvent: n,
	        createElement: a,
	        css: h,
	        defined: l,
	        extend: d,
	        merge: c,
	        pick: p,
	        pushUnique: u
	      } = s;
	    function g() {
	      let t;
	      let {
	          axisOffset: e,
	          chartWidth: s,
	          chartHeight: r,
	          container: l,
	          plotHeight: d,
	          plotLeft: c,
	          plotTop: u,
	          plotWidth: g,
	          scrollablePixelsX: f = 0,
	          scrollablePixelsY: m = 0,
	          scrollingContainer: x
	        } = this,
	        y = !this.fixedDiv,
	        b = this.options.chart,
	        v = b.scrollablePlotArea,
	        {
	          scrollPositionX: S,
	          scrollPositionY: k
	        } = v,
	        M = i.getRendererType(),
	        {
	          fixedRenderer: C
	        } = this;
	      C ? C.setSize(s, r) : (this.fixedDiv = a("div", {
	        className: "highcharts-fixed"
	      }, {
	        position: "absolute",
	        overflow: "hidden",
	        pointerEvents: "none",
	        zIndex: (b.style?.zIndex || 0) + 2,
	        top: 0
	      }, void 0, !0), x?.parentNode.insertBefore(this.fixedDiv, x), h(this.renderTo, {
	        overflow: "visible"
	      }), this.fixedRenderer = C = new M(this.fixedDiv, s, r, b.style), this.scrollableMask = C.path().attr({
	        fill: b.backgroundColor || "#fff",
	        "fill-opacity": p(v.opacity, .85),
	        zIndex: -1
	      }).addClass("highcharts-scrollable-mask").add(), n(this, "afterShowResetZoom", this.moveFixedElements), n(this, "afterApplyDrilldown", this.moveFixedElements), n(this, "afterLayOutTitles", this.moveFixedElements)), (this.scrollableDirty || y) && (this.scrollableDirty = !1, this.moveFixedElements());
	      let w = s + f,
	        T = r + m;
	      o(this.container), h(l, {
	        width: `${w}px`,
	        height: `${T}px`
	      }), this.renderer.boxWrapper.attr({
	        width: w,
	        height: T,
	        viewBox: [0, 0, w, T].join(" ")
	      }), this.chartBackground?.attr({
	        width: w,
	        height: T
	      }), x && (h(x, {
	        width: `${this.chartWidth}px`,
	        height: `${this.chartHeight}px`
	      }), y && (S && (x.scrollLeft = f * S), k && (x.scrollTop = m * k)));
	      let A = u - e[0] - 1,
	        P = c - e[3] - 1,
	        L = u + d + e[2] + 1,
	        O = c + g + e[1] + 1,
	        D = c + g - f,
	        E = u + d - m;
	      t = f ? [["M", 0, A], ["L", c - 1, A], ["L", c - 1, L], ["L", 0, L], ["Z"], ["M", D, A], ["L", s, A], ["L", s, L], ["L", D, L], ["Z"]] : m ? [["M", P, 0], ["L", P, u - 1], ["L", O, u - 1], ["L", O, 0], ["Z"], ["M", P, E], ["L", P, r], ["L", O, r], ["L", O, E], ["Z"]] : [["M", 0, 0]], "adjustHeight" !== this.redrawTrigger && this.scrollableMask?.attr({
	        d: t
	      });
	    }
	    function f() {
	      let t;
	      let e = this.container,
	        i = this.fixedRenderer,
	        s = [".highcharts-breadcrumbs-group", ".highcharts-contextbutton", ".highcharts-caption", ".highcharts-credits", ".highcharts-legend", ".highcharts-legend-checkbox", ".highcharts-navigator-series", ".highcharts-navigator-xaxis", ".highcharts-navigator-yaxis", ".highcharts-navigator", ".highcharts-reset-zoom", ".highcharts-drillup-button", ".highcharts-scrollbar", ".highcharts-subtitle", ".highcharts-title"];
	      for (let o of (this.scrollablePixelsX && !this.inverted ? t = ".highcharts-yaxis" : this.scrollablePixelsX && this.inverted ? t = ".highcharts-xaxis" : this.scrollablePixelsY && !this.inverted ? t = ".highcharts-xaxis" : this.scrollablePixelsY && this.inverted && (t = ".highcharts-yaxis"), t && s.push(`${t}:not(.highcharts-radial-axis)`, `${t}-labels:not(.highcharts-radial-axis-labels)`), s)) [].forEach.call(e.querySelectorAll(o), t => {
	        (t.namespaceURI === i.SVG_NS ? i.box : i.box.parentNode).appendChild(t), t.style.pointerEvents = "auto";
	      });
	    }
	    function m() {
	      let t;
	      let e = {
	        WebkitOverflowScrolling: "touch",
	        overflowX: "hidden",
	        overflowY: "hidden"
	      };
	      this.scrollablePixelsX && (e.overflowX = "auto"), this.scrollablePixelsY && (e.overflowY = "auto"), this.scrollingParent = a("div", {
	        className: "highcharts-scrolling-parent"
	      }, {
	        position: "relative"
	      }, this.renderTo), this.scrollingContainer = a("div", {
	        className: "highcharts-scrolling"
	      }, e, this.scrollingParent), n(this.scrollingContainer, "scroll", () => {
	        this.pointer && (delete this.pointer.chartPosition, this.hoverPoint && (t = this.hoverPoint), this.pointer.runPointActions(void 0, t, !0));
	      }), this.innerContainer = a("div", {
	        className: "highcharts-inner-container"
	      }, null, this.scrollingContainer), this.innerContainer.appendChild(this.container), this.setUpScrolling = null;
	    }
	    function x() {
	      this.chart.scrollableDirty = !0;
	    }
	    function y(t) {
	      let e, i, s;
	      let o = this.options.chart.scrollablePlotArea,
	        r = o && o.minWidth,
	        n = o && o.minHeight;
	      if (!this.renderer.forExport && (r ? (this.scrollablePixelsX = e = Math.max(0, r - this.chartWidth), e && (this.scrollablePlotBox = this.renderer.scrollablePlotBox = c(this.plotBox), this.plotBox.width = this.plotWidth += e, this.inverted ? this.clipBox.height += e : this.clipBox.width += e, s = {
	        1: {
	          name: "right",
	          value: e
	        }
	      })) : n && (this.scrollablePixelsY = i = Math.max(0, n - this.chartHeight), l(i) && (this.scrollablePlotBox = this.renderer.scrollablePlotBox = c(this.plotBox), this.plotBox.height = this.plotHeight += i, this.inverted ? this.clipBox.width += i : this.clipBox.height += i, s = {
	        2: {
	          name: "bottom",
	          value: i
	        }
	      })), s && !t.skipAxes)) for (let t of this.axes) if (s[t.side]) {
	        let e = t.getPlotLinePath;
	        t.getPlotLinePath = function () {
	          let i = s[t.side].name,
	            o = s[t.side].value,
	            r = this[i];
	          this[i] = r - o;
	          let n = e.apply(this, arguments);
	          return this[i] = r, n;
	        };
	      } else t.setAxisSize(), t.setAxisTranslation();
	    }
	    function b() {
	      this.scrollablePixelsX || this.scrollablePixelsY ? (this.setUpScrolling && this.setUpScrolling(), this.applyFixed()) : this.fixedDiv && this.applyFixed();
	    }
	    function v() {
	      this.chart.scrollableDirty = !0;
	    }
	    return {
	      compose: function t(e, i, s) {
	        u(r, t) && (n(e, "afterInit", x), d(i.prototype, {
	          applyFixed: g,
	          moveFixedElements: f,
	          setUpScrolling: m
	        }), n(i, "afterSetChartSize", y), n(i, "render", b), n(s, "show", v));
	      }
	    };
	  }), i(e, "Core/Axis/Stacking/StackItem.js", [e["Core/Templating.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function (t, e, i) {
	    let {
	        format: s
	      } = t,
	      {
	        series: o
	      } = e,
	      {
	        destroyObjectProperties: r,
	        fireEvent: n,
	        isNumber: a,
	        pick: h
	      } = i;
	    return class {
	      constructor(t, e, i, s, o) {
	        let r = t.chart.inverted,
	          n = t.reversed;
	        this.axis = t;
	        let a = this.isNegative = !!i != !!n;
	        this.options = e = e || {}, this.x = s, this.total = null, this.cumulative = null, this.points = {}, this.hasValidPoints = !1, this.stack = o, this.leftCliff = 0, this.rightCliff = 0, this.alignOptions = {
	          align: e.align || (r ? a ? "left" : "right" : "center"),
	          verticalAlign: e.verticalAlign || (r ? "middle" : a ? "bottom" : "top"),
	          y: e.y,
	          x: e.x
	        }, this.textAlign = e.textAlign || (r ? a ? "right" : "left" : "center");
	      }
	      destroy() {
	        r(this, this.axis);
	      }
	      render(t) {
	        let e = this.axis.chart,
	          i = this.options,
	          o = i.format,
	          r = o ? s(o, this, e) : i.formatter.call(this);
	        if (this.label) this.label.attr({
	          text: r,
	          visibility: "hidden"
	        });else {
	          this.label = e.renderer.label(r, null, void 0, i.shape, void 0, void 0, i.useHTML, !1, "stack-labels");
	          let s = {
	            r: i.borderRadius || 0,
	            text: r,
	            padding: h(i.padding, 5),
	            visibility: "hidden"
	          };
	          e.styledMode || (s.fill = i.backgroundColor, s.stroke = i.borderColor, s["stroke-width"] = i.borderWidth, this.label.css(i.style || {})), this.label.attr(s), this.label.added || this.label.add(t);
	        }
	        this.label.labelrank = e.plotSizeY, n(this, "afterRender");
	      }
	      setOffset(t, e, i, s, r, l) {
	        let {
	            alignOptions: d,
	            axis: c,
	            label: p,
	            options: u,
	            textAlign: g
	          } = this,
	          f = c.chart,
	          m = this.getStackBox({
	            xOffset: t,
	            width: e,
	            boxBottom: i,
	            boxTop: s,
	            defaultX: r,
	            xAxis: l
	          }),
	          {
	            verticalAlign: x
	          } = d;
	        if (p && m) {
	          let t = p.getBBox(),
	            e = p.padding,
	            i = "justify" === h(u.overflow, "justify"),
	            s;
	          d.x = u.x || 0, d.y = u.y || 0;
	          let {
	            x: r,
	            y: n
	          } = this.adjustStackPosition({
	            labelBox: t,
	            verticalAlign: x,
	            textAlign: g
	          });
	          m.x -= r, m.y -= n, p.align(d, !1, m), (s = f.isInsidePlot(p.alignAttr.x + d.x + r, p.alignAttr.y + d.y + n)) || (i = !1), i && o.prototype.justifyDataLabel.call(c, p, d, p.alignAttr, t, m), p.attr({
	            x: p.alignAttr.x,
	            y: p.alignAttr.y,
	            rotation: u.rotation,
	            rotationOriginX: t.width / 2,
	            rotationOriginY: t.height / 2
	          }), h(!i && u.crop, !0) && (s = a(p.x) && a(p.y) && f.isInsidePlot(p.x - e + (p.width || 0), p.y) && f.isInsidePlot(p.x + e, p.y)), p[s ? "show" : "hide"]();
	        }
	        n(this, "afterSetOffset", {
	          xOffset: t,
	          width: e
	        });
	      }
	      adjustStackPosition({
	        labelBox: t,
	        verticalAlign: e,
	        textAlign: i
	      }) {
	        let s = {
	            bottom: 0,
	            middle: 1,
	            top: 2,
	            right: 1,
	            center: 0,
	            left: -1
	          },
	          o = s[e],
	          r = s[i];
	        return {
	          x: t.width / 2 + t.width / 2 * r,
	          y: t.height / 2 * o
	        };
	      }
	      getStackBox(t) {
	        let e = this.axis,
	          i = e.chart,
	          {
	            boxTop: s,
	            defaultX: o,
	            xOffset: r,
	            width: n,
	            boxBottom: l
	          } = t,
	          d = e.stacking.usePercentage ? 100 : h(s, this.total, 0),
	          c = e.toPixels(d),
	          p = t.xAxis || i.xAxis[0],
	          u = h(o, p.translate(this.x)) + r,
	          g = e.toPixels(l || a(e.min) && e.logarithmic && e.logarithmic.lin2log(e.min) || 0),
	          f = Math.abs(c - g),
	          m = i.inverted,
	          x = this.isNegative;
	        return m ? {
	          x: (x ? c : c - f) - i.plotLeft,
	          y: p.height - u - n,
	          width: f,
	          height: n
	        } : {
	          x: u + p.transB - i.plotLeft,
	          y: (x ? c - f : c) - i.plotTop,
	          width: n,
	          height: f
	        };
	      }
	    };
	  }), i(e, "Core/Axis/Stacking/StackingAxis.js", [e["Core/Animation/AnimationUtilities.js"], e["Core/Axis/Axis.js"], e["Core/Globals.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Axis/Stacking/StackItem.js"], e["Core/Utilities.js"]], function (t, e, i, s, o, r) {
	    var n;
	    let {
	        getDeferredAnimation: a
	      } = t,
	      {
	        composed: h
	      } = i,
	      {
	        series: {
	          prototype: l
	        }
	      } = s,
	      {
	        addEvent: d,
	        correctFloat: c,
	        defined: p,
	        destroyObjectProperties: u,
	        fireEvent: g,
	        isArray: f,
	        isNumber: m,
	        objectEach: x,
	        pick: y,
	        pushUnique: b
	      } = r;
	    function v() {
	      let t = this.inverted;
	      this.axes.forEach(t => {
	        t.stacking && t.stacking.stacks && t.hasVisibleSeries && (t.stacking.oldStacks = t.stacking.stacks);
	      }), this.series.forEach(e => {
	        let i = e.xAxis && e.xAxis.options || {};
	        e.options.stacking && e.reserveSpace() && (e.stackKey = [e.type, y(e.options.stack, ""), t ? i.top : i.left, t ? i.height : i.width].join(","));
	      });
	    }
	    function S() {
	      let t = this.stacking;
	      if (t) {
	        let e = t.stacks;
	        x(e, (t, i) => {
	          u(t), delete e[i];
	        }), t.stackTotalGroup?.destroy();
	      }
	    }
	    function k() {
	      this.stacking || (this.stacking = new P(this));
	    }
	    function M(t, e, i, s) {
	      return !p(t) || t.x !== e || s && t.stackKey !== s ? t = {
	        x: e,
	        index: 0,
	        key: s,
	        stackKey: s
	      } : t.index++, t.key = [i, e, t.index].join(","), t;
	    }
	    function C() {
	      let t;
	      let e = this,
	        i = e.yAxis,
	        s = e.stackKey || "",
	        o = i.stacking.stacks,
	        r = e.processedXData,
	        n = e.options.stacking,
	        a = e[n + "Stacker"];
	      a && [s, "-" + s].forEach(i => {
	        let s = r.length,
	          n,
	          h,
	          l;
	        for (; s--;) n = r[s], t = e.getStackIndicator(t, n, e.index, i), h = o[i]?.[n], (l = h?.points[t.key || ""]) && a.call(e, l, h, s);
	      });
	    }
	    function w(t, e, i) {
	      let s = e.total ? 100 / e.total : 0;
	      t[0] = c(t[0] * s), t[1] = c(t[1] * s), this.stackedYData[i] = t[1];
	    }
	    function T(t) {
	      (this.is("column") || this.is("columnrange")) && (this.options.centerInCategory && !this.options.stacking && this.chart.series.length > 1 ? l.setStackedPoints.call(this, t, "group") : t.stacking.resetStacks());
	    }
	    function A(t, e) {
	      let i, s, r, n, a, h, l, d, u;
	      let g = e || this.options.stacking;
	      if (!g || !this.reserveSpace() || ({
	        group: "xAxis"
	      }[g] || "yAxis") !== t.coll) return;
	      let m = this.processedXData,
	        x = this.processedYData,
	        b = [],
	        v = x.length,
	        S = this.options,
	        k = S.threshold || 0,
	        M = S.startFromThreshold ? k : 0,
	        C = S.stack,
	        w = e ? `${this.type},${g}` : this.stackKey || "",
	        T = "-" + w,
	        A = this.negStacks,
	        P = t.stacking,
	        L = P.stacks,
	        O = P.oldStacks;
	      for (P.stacksTouched += 1, l = 0; l < v; l++) {
	        d = m[l], u = x[l], h = (i = this.getStackIndicator(i, d, this.index)).key || "", L[a = (s = A && u < (M ? 0 : k)) ? T : w] || (L[a] = {}), L[a][d] || (O[a]?.[d] ? (L[a][d] = O[a][d], L[a][d].total = null) : L[a][d] = new o(t, t.options.stackLabels, !!s, d, C)), r = L[a][d], null !== u ? (r.points[h] = r.points[this.index] = [y(r.cumulative, M)], p(r.cumulative) || (r.base = h), r.touched = P.stacksTouched, i.index > 0 && !1 === this.singleStacks && (r.points[h][0] = r.points[this.index + "," + d + ",0"][0])) : (delete r.points[h], delete r.points[this.index]);
	        let e = r.total || 0;
	        "percent" === g ? (n = s ? w : T, e = A && L[n]?.[d] ? (n = L[n][d]).total = Math.max(n.total || 0, e) + Math.abs(u) || 0 : c(e + (Math.abs(u) || 0))) : "group" === g ? (f(u) && (u = u[0]), null !== u && e++) : e = c(e + (u || 0)), "group" === g ? r.cumulative = (e || 1) - 1 : r.cumulative = c(y(r.cumulative, M) + (u || 0)), r.total = e, null !== u && (r.points[h].push(r.cumulative), b[l] = r.cumulative, r.hasValidPoints = !0);
	      }
	      "percent" === g && (P.usePercentage = !0), "group" !== g && (this.stackedYData = b), P.oldStacks = {};
	    }
	    class P {
	      constructor(t) {
	        this.oldStacks = {}, this.stacks = {}, this.stacksTouched = 0, this.axis = t;
	      }
	      buildStacks() {
	        let t, e;
	        let i = this.axis,
	          s = i.series,
	          o = "xAxis" === i.coll,
	          r = i.options.reversedStacks,
	          n = s.length;
	        for (this.resetStacks(), this.usePercentage = !1, e = n; e--;) t = s[r ? e : n - e - 1], o && t.setGroupedPoints(i), t.setStackedPoints(i);
	        if (!o) for (e = 0; e < n; e++) s[e].modifyStacks();
	        g(i, "afterBuildStacks");
	      }
	      cleanStacks() {
	        this.oldStacks && (this.stacks = this.oldStacks, x(this.stacks, t => {
	          x(t, t => {
	            t.cumulative = t.total;
	          });
	        }));
	      }
	      resetStacks() {
	        x(this.stacks, t => {
	          x(t, (e, i) => {
	            m(e.touched) && e.touched < this.stacksTouched ? (e.destroy(), delete t[i]) : (e.total = null, e.cumulative = null);
	          });
	        });
	      }
	      renderStackTotals() {
	        let t = this.axis,
	          e = t.chart,
	          i = e.renderer,
	          s = this.stacks,
	          o = t.options.stackLabels?.animation,
	          r = a(e, o || !1),
	          n = this.stackTotalGroup = this.stackTotalGroup || i.g("stack-labels").attr({
	            zIndex: 6,
	            opacity: 0
	          }).add();
	        n.translate(e.plotLeft, e.plotTop), x(s, t => {
	          x(t, t => {
	            t.render(n);
	          });
	        }), n.animate({
	          opacity: 1
	        }, r);
	      }
	    }
	    return (n || (n = {})).compose = function t(e, i, s) {
	      if (b(h, t)) {
	        let t = i.prototype,
	          o = s.prototype;
	        d(e, "init", k), d(e, "destroy", S), t.getStacks = v, o.getStackIndicator = M, o.modifyStacks = C, o.percentStacker = w, o.setGroupedPoints = T, o.setStackedPoints = A;
	      }
	    }, n;
	  }), i(e, "Series/Line/LineSeries.js", [e["Core/Series/Series.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function (t, e, i) {
	    let {
	      defined: s,
	      merge: o,
	      isObject: r
	    } = i;
	    class n extends t {
	      drawGraph() {
	        let t = this.options,
	          e = (this.gappedPath || this.getGraphPath).call(this),
	          i = this.chart.styledMode;
	        [this, ...this.zones].forEach((s, n) => {
	          let a,
	            h = s.graph,
	            l = h ? "animate" : "attr",
	            d = s.dashStyle || t.dashStyle;
	          h ? (h.endX = this.preventGraphAnimation ? null : e.xMap, h.animate({
	            d: e
	          })) : e.length && (s.graph = h = this.chart.renderer.path(e).addClass("highcharts-graph" + (n ? ` highcharts-zone-graph-${n - 1} ` : " ") + (n && s.className || "")).attr({
	            zIndex: 1
	          }).add(this.group)), h && !i && (a = {
	            stroke: !n && t.lineColor || s.color || this.color || "#cccccc",
	            "stroke-width": t.lineWidth || 0,
	            fill: this.fillGraph && this.color || "none"
	          }, d ? a.dashstyle = d : "square" !== t.linecap && (a["stroke-linecap"] = a["stroke-linejoin"] = "round"), h[l](a).shadow(n < 2 && t.shadow && o({
	            filterUnits: "userSpaceOnUse"
	          }, r(t.shadow) ? t.shadow : {}))), h && (h.startX = e.xMap, h.isArea = e.isArea);
	        });
	      }
	      getGraphPath(t, e, i) {
	        let o = this,
	          r = o.options,
	          n = [],
	          a = [],
	          h,
	          l = r.step;
	        t = t || o.points;
	        let d = t.reversed;
	        return d && t.reverse(), (l = {
	          right: 1,
	          center: 2
	        }[l] || l && 3) && d && (l = 4 - l), (t = this.getValidPoints(t, !1, !(r.connectNulls && !e && !i))).forEach(function (d, c) {
	          let p;
	          let u = d.plotX,
	            g = d.plotY,
	            f = t[c - 1],
	            m = d.isNull || "number" != typeof g;
	          (d.leftCliff || f && f.rightCliff) && !i && (h = !0), m && !s(e) && c > 0 ? h = !r.connectNulls : m && !e ? h = !0 : (0 === c || h ? p = [["M", d.plotX, d.plotY]] : o.getPointSpline ? p = [o.getPointSpline(t, d, c)] : l ? (p = 1 === l ? [["L", f.plotX, g]] : 2 === l ? [["L", (f.plotX + u) / 2, f.plotY], ["L", (f.plotX + u) / 2, g]] : [["L", u, f.plotY]]).push(["L", u, g]) : p = [["L", u, g]], a.push(d.x), l && (a.push(d.x), 2 === l && a.push(d.x)), n.push.apply(n, p), h = !1);
	        }), n.xMap = a, o.graphPath = n, n;
	      }
	    }
	    return n.defaultOptions = o(t.defaultOptions, {
	      legendSymbol: "lineMarker"
	    }), e.registerSeriesType("line", n), n;
	  }), i(e, "Series/Area/AreaSeries.js", [e["Core/Color/Color.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function (t, e, i) {
	    let {
	        seriesTypes: {
	          line: o
	        }
	      } = e,
	      {
	        extend: r,
	        merge: n,
	        objectEach: a,
	        pick: h
	      } = i;
	    class l extends o {
	      drawGraph() {
	        this.areaPath = [], super.drawGraph.apply(this);
	        let {
	          areaPath: t,
	          options: e
	        } = this;
	        [this, ...this.zones].forEach((i, s) => {
	          let o = {},
	            r = i.fillColor || e.fillColor,
	            n = i.area,
	            a = n ? "animate" : "attr";
	          n ? (n.endX = this.preventGraphAnimation ? null : t.xMap, n.animate({
	            d: t
	          })) : (o.zIndex = 0, (n = i.area = this.chart.renderer.path(t).addClass("highcharts-area" + (s ? ` highcharts-zone-area-${s - 1} ` : " ") + (s && i.className || "")).add(this.group)).isArea = !0), this.chart.styledMode || (o.fill = r || i.color || this.color, o["fill-opacity"] = r ? 1 : e.fillOpacity ?? .75, n.css({
	            pointerEvents: this.stickyTracking ? "none" : "auto"
	          })), n[a](o), n.startX = t.xMap, n.shiftUnit = e.step ? 2 : 1;
	        });
	      }
	      getGraphPath(t) {
	        let e, i, s;
	        let r = o.prototype.getGraphPath,
	          n = this.options,
	          a = n.stacking,
	          l = this.yAxis,
	          d = [],
	          c = [],
	          p = this.index,
	          u = l.stacking.stacks[this.stackKey],
	          g = n.threshold,
	          f = Math.round(l.getThreshold(n.threshold)),
	          m = h(n.connectNulls, "percent" === a),
	          x = function (i, s, o) {
	            let r = t[i],
	              n = a && u[r.x].points[p],
	              h = r[o + "Null"] || 0,
	              m = r[o + "Cliff"] || 0,
	              x,
	              y,
	              b = !0;
	            m || h ? (x = (h ? n[0] : n[1]) + m, y = n[0] + m, b = !!h) : !a && t[s] && t[s].isNull && (x = y = g), void 0 !== x && (c.push({
	              plotX: e,
	              plotY: null === x ? f : l.getThreshold(x),
	              isNull: b,
	              isCliff: !0
	            }), d.push({
	              plotX: e,
	              plotY: null === y ? f : l.getThreshold(y),
	              doCurve: !1
	            }));
	          };
	        t = t || this.points, a && (t = this.getStackPoints(t));
	        for (let o = 0, r = t.length; o < r; ++o) a || (t[o].leftCliff = t[o].rightCliff = t[o].leftNull = t[o].rightNull = void 0), i = t[o].isNull, e = h(t[o].rectPlotX, t[o].plotX), s = a ? h(t[o].yBottom, f) : f, i && !m || (m || x(o, o - 1, "left"), i && !a && m || (c.push(t[o]), d.push({
	          x: o,
	          plotX: e,
	          plotY: s
	        })), m || x(o, o + 1, "right"));
	        let y = r.call(this, c, !0, !0);
	        d.reversed = !0;
	        let b = r.call(this, d, !0, !0),
	          v = b[0];
	        v && "M" === v[0] && (b[0] = ["L", v[1], v[2]]);
	        let S = y.concat(b);
	        S.length && S.push(["Z"]);
	        let k = r.call(this, c, !1, m);
	        return S.xMap = y.xMap, this.areaPath = S, k;
	      }
	      getStackPoints(t) {
	        let e = this,
	          i = [],
	          s = [],
	          o = this.xAxis,
	          r = this.yAxis,
	          n = r.stacking.stacks[this.stackKey],
	          l = {},
	          d = r.series,
	          c = d.length,
	          p = r.options.reversedStacks ? 1 : -1,
	          u = d.indexOf(e);
	        if (t = t || this.points, this.options.stacking) {
	          for (let e = 0; e < t.length; e++) t[e].leftNull = t[e].rightNull = void 0, l[t[e].x] = t[e];
	          a(n, function (t, e) {
	            null !== t.total && s.push(e);
	          }), s.sort(function (t, e) {
	            return t - e;
	          });
	          let g = d.map(t => t.visible);
	          s.forEach(function (t, a) {
	            let f = 0,
	              m,
	              x;
	            if (l[t] && !l[t].isNull) i.push(l[t]), [-1, 1].forEach(function (i) {
	              let o = 1 === i ? "rightNull" : "leftNull",
	                r = n[s[a + i]],
	                h = 0;
	              if (r) {
	                let i = u;
	                for (; i >= 0 && i < c;) {
	                  let s = d[i].index;
	                  !(m = r.points[s]) && (s === e.index ? l[t][o] = !0 : g[i] && (x = n[t].points[s]) && (h -= x[1] - x[0])), i += p;
	                }
	              }
	              l[t][1 === i ? "rightCliff" : "leftCliff"] = h;
	            });else {
	              let e = u;
	              for (; e >= 0 && e < c;) {
	                let i = d[e].index;
	                if (m = n[t].points[i]) {
	                  f = m[1];
	                  break;
	                }
	                e += p;
	              }
	              f = h(f, 0), f = r.translate(f, 0, 1, 0, 1), i.push({
	                isNull: !0,
	                plotX: o.translate(t, 0, 0, 0, 1),
	                x: t,
	                plotY: f,
	                yBottom: f
	              });
	            }
	          });
	        }
	        return i;
	      }
	    }
	    return l.defaultOptions = n(o.defaultOptions, {
	      threshold: 0,
	      legendSymbol: "areaMarker"
	    }), r(l.prototype, {
	      singleStacks: !1
	    }), e.registerSeriesType("area", l), l;
	  }), i(e, "Series/Spline/SplineSeries.js", [e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function (t, e) {
	    let {
	        line: i
	      } = t.seriesTypes,
	      {
	        merge: s,
	        pick: o
	      } = e;
	    class r extends i {
	      getPointSpline(t, e, i) {
	        let s, r, n, a;
	        let h = e.plotX || 0,
	          l = e.plotY || 0,
	          d = t[i - 1],
	          c = t[i + 1];
	        function p(t) {
	          return t && !t.isNull && !1 !== t.doCurve && !e.isCliff;
	        }
	        if (p(d) && p(c)) {
	          let t = d.plotX || 0,
	            i = d.plotY || 0,
	            o = c.plotX || 0,
	            p = c.plotY || 0,
	            u = 0;
	          s = (1.5 * h + t) / 2.5, r = (1.5 * l + i) / 2.5, n = (1.5 * h + o) / 2.5, a = (1.5 * l + p) / 2.5, n !== s && (u = (a - r) * (n - h) / (n - s) + l - a), r += u, a += u, r > i && r > l ? (r = Math.max(i, l), a = 2 * l - r) : r < i && r < l && (r = Math.min(i, l), a = 2 * l - r), a > p && a > l ? (a = Math.max(p, l), r = 2 * l - a) : a < p && a < l && (a = Math.min(p, l), r = 2 * l - a), e.rightContX = n, e.rightContY = a, e.controlPoints = {
	            low: [s, r],
	            high: [n, a]
	          };
	        }
	        let u = ["C", o(d.rightContX, d.plotX, 0), o(d.rightContY, d.plotY, 0), o(s, h, 0), o(r, l, 0), h, l];
	        return d.rightContX = d.rightContY = void 0, u;
	      }
	    }
	    return r.defaultOptions = s(i.defaultOptions), t.registerSeriesType("spline", r), r;
	  }), i(e, "Series/AreaSpline/AreaSplineSeries.js", [e["Series/Spline/SplineSeries.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function (t, e, i) {
	    let {
	        area: s,
	        area: {
	          prototype: o
	        }
	      } = e.seriesTypes,
	      {
	        extend: r,
	        merge: n
	      } = i;
	    class a extends t {}
	    return a.defaultOptions = n(t.defaultOptions, s.defaultOptions), r(a.prototype, {
	      getGraphPath: o.getGraphPath,
	      getStackPoints: o.getStackPoints,
	      drawGraph: o.drawGraph
	    }), e.registerSeriesType("areaspline", a), a;
	  }), i(e, "Series/Column/ColumnSeriesDefaults.js", [], function () {
	    return {
	      borderRadius: 3,
	      centerInCategory: !1,
	      groupPadding: .2,
	      marker: null,
	      pointPadding: .1,
	      minPointLength: 0,
	      cropThreshold: 50,
	      pointRange: null,
	      states: {
	        hover: {
	          halo: !1,
	          brightness: .1
	        },
	        select: {
	          color: "#cccccc",
	          borderColor: "#000000"
	        }
	      },
	      dataLabels: {
	        align: void 0,
	        verticalAlign: void 0,
	        y: void 0
	      },
	      startFromThreshold: !0,
	      stickyTracking: !1,
	      tooltip: {
	        distance: 6
	      },
	      threshold: 0,
	      borderColor: "#ffffff"
	    };
	  }), i(e, "Series/Column/ColumnSeries.js", [e["Core/Animation/AnimationUtilities.js"], e["Core/Color/Color.js"], e["Series/Column/ColumnSeriesDefaults.js"], e["Core/Globals.js"], e["Core/Series/Series.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function (t, e, i, s, o, r, n) {
	    let {
	        animObject: a
	      } = t,
	      {
	        parse: h
	      } = e,
	      {
	        hasTouch: l,
	        noop: d
	      } = s,
	      {
	        clamp: c,
	        defined: p,
	        extend: u,
	        fireEvent: g,
	        isArray: f,
	        isNumber: m,
	        merge: x,
	        pick: y,
	        objectEach: b,
	        relativeLength: v
	      } = n;
	    class S extends o {
	      animate(t) {
	        let e, i;
	        let s = this,
	          o = this.yAxis,
	          r = o.pos,
	          n = s.options,
	          h = this.chart.inverted,
	          l = {},
	          d = h ? "translateX" : "translateY";
	        t ? (l.scaleY = .001, i = c(o.toPixels(n.threshold), r, r + o.len), h ? l.translateX = i - o.len : l.translateY = i, s.clipBox && s.setClip(), s.group.attr(l)) : (e = Number(s.group.attr(d)), s.group.animate({
	          scaleY: 1
	        }, u(a(s.options.animation), {
	          step: function (t, i) {
	            s.group && (l[d] = e + i.pos * (r - e), s.group.attr(l));
	          }
	        })));
	      }
	      init(t, e) {
	        super.init.apply(this, arguments);
	        let i = this;
	        (t = i.chart).hasRendered && t.series.forEach(function (t) {
	          t.type === i.type && (t.isDirty = !0);
	        });
	      }
	      getColumnMetrics() {
	        let t = this,
	          e = t.options,
	          i = t.xAxis,
	          s = t.yAxis,
	          o = i.options.reversedStacks,
	          r = i.reversed && !o || !i.reversed && o,
	          n = {},
	          a,
	          h = 0;
	        !1 === e.grouping ? h = 1 : t.chart.series.forEach(function (e) {
	          let i;
	          let o = e.yAxis,
	            r = e.options;
	          e.type === t.type && e.reserveSpace() && s.len === o.len && s.pos === o.pos && (r.stacking && "group" !== r.stacking ? (void 0 === n[a = e.stackKey] && (n[a] = h++), i = n[a]) : !1 !== r.grouping && (i = h++), e.columnIndex = i);
	        });
	        let l = Math.min(Math.abs(i.transA) * (!i.brokenAxis?.hasBreaks && i.ordinal?.slope || e.pointRange || i.closestPointRange || i.tickInterval || 1), i.len),
	          d = l * e.groupPadding,
	          c = (l - 2 * d) / (h || 1),
	          p = Math.min(e.maxPointWidth || i.len, y(e.pointWidth, c * (1 - 2 * e.pointPadding))),
	          u = (c - p) / 2,
	          g = (t.columnIndex || 0) + (r ? 1 : 0),
	          f = u + (d + g * c - l / 2) * (r ? -1 : 1);
	        return t.columnMetrics = {
	          width: p,
	          offset: f,
	          paddedWidth: c,
	          columnCount: h
	        }, t.columnMetrics;
	      }
	      crispCol(t, e, i, s) {
	        this.chart;
	        let o = this.borderWidth,
	          r = -(o % 2 ? .5 : 0),
	          n = o % 2 ? .5 : 1;
	        this.options.crisp && (i = Math.round(t + i) + r - (t = Math.round(t) + r));
	        let a = Math.round(e + s) + n,
	          h = .5 >= Math.abs(e) && a > .5;
	        return s = a - (e = Math.round(e) + n), h && s && (e -= 1, s += 1), {
	          x: t,
	          y: e,
	          width: i,
	          height: s
	        };
	      }
	      adjustForMissingColumns(t, e, i, s) {
	        if (!i.isNull && s.columnCount > 1) {
	          let o = this.xAxis.series.filter(t => t.visible).map(t => t.index),
	            r = 0,
	            n = 0;
	          b(this.xAxis.stacking?.stacks, t => {
	            if ("number" == typeof i.x) {
	              let e = t[i.x.toString()];
	              if (e) {
	                let t = e.points[this.index];
	                if (f(t)) {
	                  let t = Object.keys(e.points).filter(t => !t.match(",") && e.points[t] && e.points[t].length > 1).map(parseFloat).filter(t => -1 !== o.indexOf(t)).sort((t, e) => e - t);
	                  r = t.indexOf(this.index), n = t.length;
	                }
	              }
	            }
	          });
	          let a = (n - 1) * s.paddedWidth + e;
	          t = (i.plotX || 0) + a / 2 - e - r * s.paddedWidth;
	        }
	        return t;
	      }
	      translate() {
	        let t = this,
	          e = t.chart,
	          i = t.options,
	          s = t.dense = t.closestPointRange * t.xAxis.transA < 2,
	          r = t.borderWidth = y(i.borderWidth, s ? 0 : 1),
	          n = t.xAxis,
	          a = t.yAxis,
	          h = i.threshold,
	          l = y(i.minPointLength, 5),
	          d = t.getColumnMetrics(),
	          u = d.width,
	          f = t.pointXOffset = d.offset,
	          x = t.dataMin,
	          b = t.dataMax,
	          v = t.barW = Math.max(u, 1 + 2 * r),
	          S = t.translatedThreshold = a.getThreshold(h);
	        e.inverted && (S -= .5), i.pointPadding && (v = Math.ceil(v)), o.prototype.translate.apply(t), t.points.forEach(function (s) {
	          let o = y(s.yBottom, S),
	            r = 999 + Math.abs(o),
	            g = s.plotX || 0,
	            k = c(s.plotY, -r, a.len + r);
	          s.stackBox;
	          let M,
	            C = Math.min(k, o),
	            w = Math.max(k, o) - C,
	            T = u,
	            A = g + f,
	            P = v;
	          l && Math.abs(w) < l && (w = l, M = !a.reversed && !s.negative || a.reversed && s.negative, m(h) && m(b) && s.y === h && b <= h && (a.min || 0) < h && (x !== b || (a.max || 0) <= h) && (M = !M, s.negative = !s.negative), C = Math.abs(C - S) > l ? o - l : S - (M ? l : 0)), p(s.options.pointWidth) && (A -= Math.round(((T = P = Math.ceil(s.options.pointWidth)) - u) / 2)), i.centerInCategory && !i.stacking && (A = t.adjustForMissingColumns(A, T, s, d)), s.barX = A, s.pointWidth = T, s.tooltipPos = e.inverted ? [c(a.len + a.pos - e.plotLeft - k, a.pos - e.plotLeft, a.len + a.pos - e.plotLeft), n.len + n.pos - e.plotTop - A - P / 2, w] : [n.left - e.plotLeft + A + P / 2, c(k + a.pos - e.plotTop, a.pos - e.plotTop, a.len + a.pos - e.plotTop), w], s.shapeType = t.pointClass.prototype.shapeType || "roundedRect", s.shapeArgs = t.crispCol(A, s.isNull ? S : C, P, s.isNull ? 0 : w);
	        }), g(this, "afterColumnTranslate");
	      }
	      drawGraph() {
	        this.group[this.dense ? "addClass" : "removeClass"]("highcharts-dense-data");
	      }
	      pointAttribs(t, e) {
	        let i = this.options,
	          s = this.pointAttrToOptions || {},
	          o = s.stroke || "borderColor",
	          r = s["stroke-width"] || "borderWidth",
	          n,
	          a,
	          l,
	          d = t && t.color || this.color,
	          c = t && t[o] || i[o] || d,
	          p = t && t.options.dashStyle || i.dashStyle,
	          u = t && t[r] || i[r] || this[r] || 0,
	          g = y(t && t.opacity, i.opacity, 1);
	        t && this.zones.length && (a = t.getZone(), d = t.options.color || a && (a.color || t.nonZonedColor) || this.color, a && (c = a.borderColor || c, p = a.dashStyle || p, u = a.borderWidth || u)), e && t && (l = (n = x(i.states[e], t.options.states && t.options.states[e] || {})).brightness, d = n.color || void 0 !== l && h(d).brighten(n.brightness).get() || d, c = n[o] || c, u = n[r] || u, p = n.dashStyle || p, g = y(n.opacity, g));
	        let f = {
	          fill: d,
	          stroke: c,
	          "stroke-width": u,
	          opacity: g
	        };
	        return p && (f.dashstyle = p), f;
	      }
	      drawPoints(t = this.points) {
	        let e;
	        let i = this,
	          s = this.chart,
	          o = i.options,
	          r = s.renderer,
	          n = o.animationLimit || 250;
	        t.forEach(function (t) {
	          let a = t.plotY,
	            h = t.graphic,
	            l = !!h,
	            d = h && s.pointCount < n ? "animate" : "attr";
	          m(a) && null !== t.y ? (e = t.shapeArgs, h && t.hasNewShapeType() && (h = h.destroy()), i.enabledDataSorting && (t.startXPos = i.xAxis.reversed ? -(e && e.width || 0) : i.xAxis.width), !h && (t.graphic = h = r[t.shapeType](e).add(t.group || i.group), h && i.enabledDataSorting && s.hasRendered && s.pointCount < n && (h.attr({
	            x: t.startXPos
	          }), l = !0, d = "animate")), h && l && h[d](x(e)), s.styledMode || h[d](i.pointAttribs(t, t.selected && "select")).shadow(!1 !== t.allowShadow && o.shadow), h && (h.addClass(t.getClassName(), !0), h.attr({
	            visibility: t.visible ? "inherit" : "hidden"
	          }))) : h && (t.graphic = h.destroy());
	        });
	      }
	      drawTracker(t = this.points) {
	        let e;
	        let i = this,
	          s = i.chart,
	          o = s.pointer,
	          r = function (t) {
	            let e = o.getPointFromEvent(t);
	            void 0 !== e && i.options.enableMouseTracking && (o.isDirectTouch = !0, e.onMouseOver(t));
	          };
	        t.forEach(function (t) {
	          e = f(t.dataLabels) ? t.dataLabels : t.dataLabel ? [t.dataLabel] : [], t.graphic && (t.graphic.element.point = t), e.forEach(function (e) {
	            e.div ? e.div.point = t : e.element.point = t;
	          });
	        }), i._hasTracking || (i.trackerGroups.forEach(function (t) {
	          i[t] && (i[t].addClass("highcharts-tracker").on("mouseover", r).on("mouseout", function (t) {
	            o.onTrackerMouseOut(t);
	          }), l && i[t].on("touchstart", r), !s.styledMode && i.options.cursor && i[t].css({
	            cursor: i.options.cursor
	          }));
	        }), i._hasTracking = !0), g(this, "afterDrawTracker");
	      }
	      remove() {
	        let t = this,
	          e = t.chart;
	        e.hasRendered && e.series.forEach(function (e) {
	          e.type === t.type && (e.isDirty = !0);
	        }), o.prototype.remove.apply(t, arguments);
	      }
	    }
	    return S.defaultOptions = x(o.defaultOptions, i), u(S.prototype, {
	      directTouch: !0,
	      getSymbol: d,
	      negStacks: !0,
	      trackerGroups: ["group", "dataLabelsGroup"]
	    }), r.registerSeriesType("column", S), S;
	  }), i(e, "Core/Series/DataLabel.js", [e["Core/Animation/AnimationUtilities.js"], e["Core/Templating.js"], e["Core/Globals.js"], e["Core/Utilities.js"]], function (t, e, i, s) {
	    var o;
	    let {
	        getDeferredAnimation: r
	      } = t,
	      {
	        format: n
	      } = e,
	      {
	        composed: a
	      } = i,
	      {
	        defined: h,
	        extend: l,
	        fireEvent: d,
	        isArray: c,
	        isString: p,
	        merge: u,
	        objectEach: g,
	        pick: f,
	        pInt: m,
	        pushUnique: x,
	        splat: y
	      } = s;
	    return function (t) {
	      function e() {
	        return k(this).some(t => t?.enabled);
	      }
	      function i(t, e, i, s, o) {
	        let r = this,
	          n = this.chart,
	          a = this.isCartesian && n.inverted,
	          d = this.enabledDataSorting,
	          c = t.plotX,
	          p = t.plotY,
	          u = i.rotation,
	          g = i.align,
	          m = h(c) && h(p) && n.isInsidePlot(c, Math.round(p), {
	            inverted: a,
	            paneCoordinates: !0,
	            series: r
	          }),
	          x = i => {
	            d && r.xAxis && !S && r.setDataLabelStartPos(t, e, o, m, i);
	          },
	          y,
	          b,
	          v,
	          S = "justify" === f(i.overflow, d ? "none" : "justify"),
	          k = this.visible && !1 !== t.visible && h(c) && (t.series.forceDL || d && !S || m || f(i.inside, !!this.options.stacking) && s && n.isInsidePlot(c, a ? s.x + 1 : s.y + s.height - 1, {
	            inverted: a,
	            paneCoordinates: !0,
	            series: r
	          })),
	          M = t.pos();
	        if (k && M) {
	          u && e.attr({
	            align: g
	          });
	          let t = e.getBBox(!0),
	            a = [0, 0];
	          if (y = n.renderer.fontMetrics(e).b, s = l({
	            x: M[0],
	            y: Math.round(M[1]),
	            width: 0,
	            height: 0
	          }, s), l(i, {
	            width: t.width,
	            height: t.height
	          }), u ? (S = !1, b = n.renderer.rotCorr(y, u), v = {
	            x: s.x + (i.x || 0) + s.width / 2 + b.x,
	            y: s.y + (i.y || 0) + {
	              top: 0,
	              middle: .5,
	              bottom: 1
	            }[i.verticalAlign] * s.height
	          }, a = [t.x - Number(e.attr("x")), t.y - Number(e.attr("y"))], x(v), e[o ? "attr" : "animate"](v)) : (x(s), e.align(i, void 0, s), v = e.alignAttr), S && s.height >= 0) this.justifyDataLabel(e, i, v, t, s, o);else if (f(i.crop, !0)) {
	            let {
	              x: e,
	              y: i
	            } = v;
	            e += a[0], i += a[1], k = n.isInsidePlot(e, i, {
	              paneCoordinates: !0,
	              series: r
	            }) && n.isInsidePlot(e + t.width, i + t.height, {
	              paneCoordinates: !0,
	              series: r
	            });
	          }
	          i.shape && !u && e[o ? "attr" : "animate"]({
	            anchorX: M[0],
	            anchorY: M[1]
	          });
	        }
	        o && d && (e.placed = !1), k || d && !S ? e.show() : (e.hide(), e.placed = !1);
	      }
	      function s() {
	        return this.plotGroup("dataLabelsGroup", "data-labels", this.hasRendered ? "inherit" : "hidden", this.options.dataLabels.zIndex || 6);
	      }
	      function o(t) {
	        let e = this.hasRendered || 0,
	          i = this.initDataLabelsGroup().attr({
	            opacity: +e
	          });
	        return !e && i && (this.visible && i.show(), this.options.animation ? i.animate({
	          opacity: 1
	        }, t) : i.attr({
	          opacity: 1
	        })), i;
	      }
	      function b(t) {
	        let e;
	        t = t || this.points;
	        let i = this,
	          s = i.chart,
	          o = i.options,
	          a = s.renderer,
	          {
	            backgroundColor: l,
	            plotBackgroundColor: c
	          } = s.options.chart,
	          u = a.getContrast(p(c) && c || p(l) && l || "#000000"),
	          x = k(i),
	          {
	            animation: b,
	            defer: v
	          } = x[0],
	          M = v ? r(s, b, i) : {
	            defer: 0,
	            duration: 0
	          };
	        d(this, "drawDataLabels"), i.hasDataLabels?.() && (e = this.initDataLabels(M), t.forEach(t => {
	          let r = t.dataLabels || [];
	          y(S(x, t.dlOptions || t.options?.dataLabels)).forEach((l, d) => {
	            let c = l.enabled && t.visible && (!t.isNull || t.dataLabelOnNull) && function (t, e) {
	                let i = e.filter;
	                if (i) {
	                  let e = i.operator,
	                    s = t[i.property],
	                    o = i.value;
	                  return ">" === e && s > o || "<" === e && s < o || ">=" === e && s >= o || "<=" === e && s <= o || "==" === e && s == o || "===" === e && s === o || "!=" === e && s != o || "!==" === e && s !== o;
	                }
	                return !0;
	              }(t, l),
	              {
	                backgroundColor: x,
	                borderColor: y,
	                distance: b,
	                style: v = {}
	              } = l,
	              S,
	              k,
	              M,
	              C,
	              w = {},
	              T = r[d],
	              A = !T,
	              P;
	            if (c && (k = f(l[t.formatPrefix + "Format"], l.format), S = t.getLabelConfig(), M = h(k) ? n(k, S, s) : (l[t.formatPrefix + "Formatter"] || l.formatter).call(S, l), C = l.rotation, !s.styledMode && (v.color = f(l.color, v.color, p(i.color) ? i.color : void 0, "#000000"), "contrast" === v.color ? ("none" !== x && (P = x), t.contrastColor = a.getContrast("auto" !== P && P || t.color || i.color), v.color = P || !h(b) && l.inside || 0 > m(b || 0) || o.stacking ? t.contrastColor : u) : delete t.contrastColor, o.cursor && (v.cursor = o.cursor)), w = {
	              r: l.borderRadius || 0,
	              rotation: C,
	              padding: l.padding,
	              zIndex: 1
	            }, s.styledMode || (w.fill = "auto" === x ? t.color : x, w.stroke = "auto" === y ? t.color : y, w["stroke-width"] = l.borderWidth), g(w, (t, e) => {
	              void 0 === t && delete w[e];
	            })), !T || c && h(M) && !!T.div == !!l.useHTML && (T.rotation && l.rotation || T.rotation === l.rotation) || (T = void 0, A = !0), c && h(M) && (T ? w.text = M : (T = C ? a.text(M, 0, 0, l.useHTML).addClass("highcharts-data-label") : a.label(M, 0, 0, l.shape, void 0, void 0, l.useHTML, void 0, "data-label")) && T.addClass(" highcharts-data-label-color-" + t.colorIndex + " " + (l.className || "") + (l.useHTML ? " highcharts-tracker" : "")), T)) {
	              T.options = l, T.attr(w), s.styledMode || T.css(v).shadow(l.shadow);
	              let o = l[t.formatPrefix + "TextPath"] || l.textPath;
	              o && !l.useHTML && (T.setTextPath(t.getDataLabelPath?.(T) || t.graphic, o), t.dataLabelPath && !o.enabled && (t.dataLabelPath = t.dataLabelPath.destroy())), T.added || T.add(e), i.alignDataLabel(t, T, l, void 0, A), T.isActive = !0, r[d] && r[d] !== T && r[d].destroy(), r[d] = T;
	            }
	          });
	          let l = r.length;
	          for (; l--;) r[l] && r[l].isActive ? r[l].isActive = !1 : (r[l]?.destroy(), r.splice(l, 1));
	          t.dataLabel = r[0], t.dataLabels = r;
	        })), d(this, "afterDrawDataLabels");
	      }
	      function v(t, e, i, s, o, r) {
	        let n = this.chart,
	          a = e.align,
	          h = e.verticalAlign,
	          l = t.box ? 0 : t.padding || 0,
	          {
	            x: d = 0,
	            y: c = 0
	          } = e,
	          p,
	          u;
	        return (p = (i.x || 0) + l) < 0 && ("right" === a && d >= 0 ? (e.align = "left", e.inside = !0) : d -= p, u = !0), (p = (i.x || 0) + s.width - l) > n.plotWidth && ("left" === a && d <= 0 ? (e.align = "right", e.inside = !0) : d += n.plotWidth - p, u = !0), (p = i.y + l) < 0 && ("bottom" === h && c >= 0 ? (e.verticalAlign = "top", e.inside = !0) : c -= p, u = !0), (p = (i.y || 0) + s.height - l) > n.plotHeight && ("top" === h && c <= 0 ? (e.verticalAlign = "bottom", e.inside = !0) : c += n.plotHeight - p, u = !0), u && (e.x = d, e.y = c, t.placed = !r, t.align(e, void 0, o)), u;
	      }
	      function S(t, e) {
	        let i = [],
	          s;
	        if (c(t) && !c(e)) i = t.map(function (t) {
	          return u(t, e);
	        });else if (c(e) && !c(t)) i = e.map(function (e) {
	          return u(t, e);
	        });else if (c(t) || c(e)) {
	          if (c(t) && c(e)) for (s = Math.max(t.length, e.length); s--;) i[s] = u(t[s], e[s]);
	        } else i = u(t, e);
	        return i;
	      }
	      function k(t) {
	        let e = t.chart.options.plotOptions;
	        return y(S(S(e?.series?.dataLabels, e?.[t.type]?.dataLabels), t.options.dataLabels));
	      }
	      function M(t, e, i, s, o) {
	        let r = this.chart,
	          n = r.inverted,
	          a = this.xAxis,
	          h = a.reversed,
	          l = ((n ? e.height : e.width) || 0) / 2,
	          d = t.pointWidth,
	          c = d ? d / 2 : 0;
	        e.startXPos = n ? o.x : h ? -l - c : a.width - l + c, e.startYPos = n ? h ? this.yAxis.height - l + c : -l - c : o.y, s ? "hidden" === e.visibility && (e.show(), e.attr({
	          opacity: 0
	        }).animate({
	          opacity: 1
	        })) : e.attr({
	          opacity: 1
	        }).animate({
	          opacity: 0
	        }, void 0, e.hide), r.hasRendered && (i && e.attr({
	          x: e.startXPos,
	          y: e.startYPos
	        }), e.placed = !0);
	      }
	      t.compose = function t(r) {
	        if (x(a, t)) {
	          let t = r.prototype;
	          t.initDataLabelsGroup = s, t.initDataLabels = o, t.alignDataLabel = i, t.drawDataLabels = b, t.justifyDataLabel = v, t.setDataLabelStartPos = M, t.hasDataLabels = e;
	        }
	      };
	    }(o || (o = {})), o;
	  }), i(e, "Series/Column/ColumnDataLabel.js", [e["Core/Series/DataLabel.js"], e["Core/Globals.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function (t, e, i, s) {
	    var o;
	    let {
	        composed: r
	      } = e,
	      {
	        series: n
	      } = i,
	      {
	        merge: a,
	        pick: h,
	        pushUnique: l
	      } = s;
	    return function (e) {
	      function i(t, e, i, s, o) {
	        let r = this.chart.inverted,
	          l = t.series,
	          d = (l.xAxis ? l.xAxis.len : this.chart.plotSizeX) || 0,
	          c = (l.yAxis ? l.yAxis.len : this.chart.plotSizeY) || 0,
	          p = t.dlBox || t.shapeArgs,
	          u = h(t.below, t.plotY > h(this.translatedThreshold, c)),
	          g = h(i.inside, !!this.options.stacking);
	        if (p) {
	          if (s = a(p), !("allow" === i.overflow && !1 === i.crop)) {
	            s.y < 0 && (s.height += s.y, s.y = 0);
	            let t = s.y + s.height - c;
	            t > 0 && t < s.height && (s.height -= t);
	          }
	          r && (s = {
	            x: c - s.y - s.height,
	            y: d - s.x - s.width,
	            width: s.height,
	            height: s.width
	          }), g || (r ? (s.x += u ? 0 : s.width, s.width = 0) : (s.y += u ? s.height : 0, s.height = 0));
	        }
	        i.align = h(i.align, !r || g ? "center" : u ? "right" : "left"), i.verticalAlign = h(i.verticalAlign, r || g ? "middle" : u ? "top" : "bottom"), n.prototype.alignDataLabel.call(this, t, e, i, s, o), i.inside && t.contrastColor && e.css({
	          color: t.contrastColor
	        });
	      }
	      e.compose = function e(s) {
	        t.compose(n), l(r, e) && (s.prototype.alignDataLabel = i);
	      };
	    }(o || (o = {})), o;
	  }), i(e, "Series/Bar/BarSeries.js", [e["Series/Column/ColumnSeries.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function (t, e, i) {
	    let {
	      extend: s,
	      merge: o
	    } = i;
	    class r extends t {}
	    return r.defaultOptions = o(t.defaultOptions, {}), s(r.prototype, {
	      inverted: !0
	    }), e.registerSeriesType("bar", r), r;
	  }), i(e, "Series/Scatter/ScatterSeriesDefaults.js", [], function () {
	    return {
	      lineWidth: 0,
	      findNearestPointBy: "xy",
	      jitter: {
	        x: 0,
	        y: 0
	      },
	      marker: {
	        enabled: !0
	      },
	      tooltip: {
	        headerFormat: '<span style="color:{point.color}">â</span> <span style="font-size: 0.8em"> {series.name}</span><br/>',
	        pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>"
	      }
	    };
	  }), i(e, "Series/Scatter/ScatterSeries.js", [e["Series/Scatter/ScatterSeriesDefaults.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function (t, e, i) {
	    let {
	        column: s,
	        line: o
	      } = e.seriesTypes,
	      {
	        addEvent: r,
	        extend: n,
	        merge: a
	      } = i;
	    class h extends o {
	      applyJitter() {
	        let t = this,
	          e = this.options.jitter,
	          i = this.points.length;
	        e && this.points.forEach(function (s, o) {
	          ["x", "y"].forEach(function (r, n) {
	            let a,
	              h = "plot" + r.toUpperCase(),
	              l,
	              d,
	              c;
	            e[r] && !s.isNull && (a = t[r + "Axis"], c = e[r] * a.transA, a && !a.isLog && (l = Math.max(0, s[h] - c), d = Math.min(a.len, s[h] + c), s[h] = l + (d - l) * function (t) {
	              let e = 1e4 * Math.sin(t);
	              return e - Math.floor(e);
	            }(o + n * i), "x" === r && (s.clientX = s.plotX)));
	          });
	        });
	      }
	      drawGraph() {
	        this.options.lineWidth ? super.drawGraph() : this.graph && (this.graph = this.graph.destroy());
	      }
	    }
	    return h.defaultOptions = a(o.defaultOptions, t), n(h.prototype, {
	      drawTracker: s.prototype.drawTracker,
	      sorted: !1,
	      requireSorting: !1,
	      noSharedTooltip: !0,
	      trackerGroups: ["group", "markerGroup", "dataLabelsGroup"]
	    }), r(h, "afterTranslate", function () {
	      this.applyJitter();
	    }), e.registerSeriesType("scatter", h), h;
	  }), i(e, "Series/CenteredUtilities.js", [e["Core/Globals.js"], e["Core/Series/Series.js"], e["Core/Utilities.js"]], function (t, e, i) {
	    var s, o;
	    let {
	        deg2rad: r
	      } = t,
	      {
	        fireEvent: n,
	        isNumber: a,
	        pick: h,
	        relativeLength: l
	      } = i;
	    return (o = s || (s = {})).getCenter = function () {
	      let t = this.options,
	        i = this.chart,
	        s = 2 * (t.slicedOffset || 0),
	        o = i.plotWidth - 2 * s,
	        r = i.plotHeight - 2 * s,
	        d = t.center,
	        c = Math.min(o, r),
	        p = t.thickness,
	        u,
	        g = t.size,
	        f = t.innerSize || 0,
	        m,
	        x;
	      "string" == typeof g && (g = parseFloat(g)), "string" == typeof f && (f = parseFloat(f));
	      let y = [h(d[0], "50%"), h(d[1], "50%"), h(g && g < 0 ? void 0 : t.size, "100%"), h(f && f < 0 ? void 0 : t.innerSize || 0, "0%")];
	      for (!i.angular || this instanceof e || (y[3] = 0), m = 0; m < 4; ++m) x = y[m], u = m < 2 || 2 === m && /%$/.test(x), y[m] = l(x, [o, r, c, y[2]][m]) + (u ? s : 0);
	      return y[3] > y[2] && (y[3] = y[2]), a(p) && 2 * p < y[2] && p > 0 && (y[3] = y[2] - 2 * p), n(this, "afterGetCenter", {
	        positions: y
	      }), y;
	    }, o.getStartAndEndRadians = function (t, e) {
	      let i = a(t) ? t : 0,
	        s = a(e) && e > i && e - i < 360 ? e : i + 360;
	      return {
	        start: r * (i + -90),
	        end: r * (s + -90)
	      };
	    }, s;
	  }), i(e, "Series/Pie/PiePoint.js", [e["Core/Animation/AnimationUtilities.js"], e["Core/Series/Point.js"], e["Core/Utilities.js"]], function (t, e, i) {
	    let {
	        setAnimation: s
	      } = t,
	      {
	        addEvent: o,
	        defined: r,
	        extend: n,
	        isNumber: a,
	        isString: h,
	        pick: l,
	        relativeLength: d
	      } = i;
	    class c extends e {
	      getConnectorPath(t) {
	        let e = t.dataLabelPosition,
	          i = t.options || {},
	          s = i.connectorShape,
	          o = this.connectorShapes[s] || s;
	        return e && o.call(this, {
	          ...e.computed,
	          alignment: e.alignment
	        }, e.connectorPosition, i) || [];
	      }
	      getTranslate() {
	        return this.sliced && this.slicedTranslation || {
	          translateX: 0,
	          translateY: 0
	        };
	      }
	      haloPath(t) {
	        let e = this.shapeArgs;
	        return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(e.x, e.y, e.r + t, e.r + t, {
	          innerR: e.r - 1,
	          start: e.start,
	          end: e.end,
	          borderRadius: e.borderRadius
	        });
	      }
	      constructor(t, e, i) {
	        super(t, e, i), this.half = 0, this.name ?? (this.name = "Slice");
	        let s = t => {
	          this.slice("select" === t.type);
	        };
	        o(this, "select", s), o(this, "unselect", s);
	      }
	      isValid() {
	        return a(this.y) && this.y >= 0;
	      }
	      setVisible(t, e = !0) {
	        t !== this.visible && this.update({
	          visible: t ?? !this.visible
	        }, e, void 0, !1);
	      }
	      slice(t, e, i) {
	        let o = this.series,
	          n = o.chart;
	        s(i, n), e = l(e, !0), this.sliced = this.options.sliced = t = r(t) ? t : !this.sliced, o.options.data[o.data.indexOf(this)] = this.options, this.graphic && this.graphic.animate(this.getTranslate());
	      }
	    }
	    return n(c.prototype, {
	      connectorShapes: {
	        fixedOffset: function (t, e, i) {
	          let s = e.breakAt,
	            o = e.touchingSliceAt,
	            r = i.softConnector ? ["C", t.x + ("left" === t.alignment ? -5 : 5), t.y, 2 * s.x - o.x, 2 * s.y - o.y, s.x, s.y] : ["L", s.x, s.y];
	          return [["M", t.x, t.y], r, ["L", o.x, o.y]];
	        },
	        straight: function (t, e) {
	          let i = e.touchingSliceAt;
	          return [["M", t.x, t.y], ["L", i.x, i.y]];
	        },
	        crookedLine: function (t, e, i) {
	          let {
	              breakAt: s,
	              touchingSliceAt: o
	            } = e,
	            {
	              series: r
	            } = this,
	            [n, a, h] = r.center,
	            l = h / 2,
	            {
	              plotLeft: c,
	              plotWidth: p
	            } = r.chart,
	            u = "left" === t.alignment,
	            {
	              x: g,
	              y: f
	            } = t,
	            m = s.x;
	          if (i.crookDistance) {
	            let t = d(i.crookDistance, 1);
	            m = u ? n + l + (p + c - n - l) * (1 - t) : c + (n - l) * t;
	          } else m = n + (a - f) * Math.tan((this.angle || 0) - Math.PI / 2);
	          let x = [["M", g, f]];
	          return (u ? m <= g && m >= s.x : m >= g && m <= s.x) && x.push(["L", m, f]), x.push(["L", s.x, s.y], ["L", o.x, o.y]), x;
	        }
	      }
	    }), c;
	  }), i(e, "Series/Pie/PieSeriesDefaults.js", [], function () {
	    return {
	      borderRadius: 3,
	      center: [null, null],
	      clip: !1,
	      colorByPoint: !0,
	      dataLabels: {
	        connectorPadding: 5,
	        connectorShape: "crookedLine",
	        crookDistance: void 0,
	        distance: 30,
	        enabled: !0,
	        formatter: function () {
	          return this.point.isNull ? void 0 : this.point.name;
	        },
	        softConnector: !0,
	        x: 0
	      },
	      fillColor: void 0,
	      ignoreHiddenPoint: !0,
	      inactiveOtherPoints: !0,
	      legendType: "point",
	      marker: null,
	      size: null,
	      showInLegend: !1,
	      slicedOffset: 10,
	      stickyTracking: !1,
	      tooltip: {
	        followPointer: !0
	      },
	      borderColor: "#ffffff",
	      borderWidth: 1,
	      lineWidth: void 0,
	      states: {
	        hover: {
	          brightness: .1
	        }
	      }
	    };
	  }), i(e, "Series/Pie/PieSeries.js", [e["Series/CenteredUtilities.js"], e["Series/Column/ColumnSeries.js"], e["Core/Globals.js"], e["Series/Pie/PiePoint.js"], e["Series/Pie/PieSeriesDefaults.js"], e["Core/Series/Series.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Renderer/SVG/Symbols.js"], e["Core/Utilities.js"]], function (t, e, i, s, o, r, n, a, h) {
	    let {
	        getStartAndEndRadians: l
	      } = t,
	      {
	        noop: d
	      } = i,
	      {
	        clamp: c,
	        extend: p,
	        fireEvent: u,
	        merge: g,
	        pick: f,
	        relativeLength: m,
	        splat: x
	      } = h;
	    class y extends r {
	      animate(t) {
	        let e = this,
	          i = e.points,
	          s = e.startAngleRad;
	        t || i.forEach(function (t) {
	          let i = t.graphic,
	            o = t.shapeArgs;
	          i && o && (i.attr({
	            r: f(t.startR, e.center && e.center[3] / 2),
	            start: s,
	            end: s
	          }), i.animate({
	            r: o.r,
	            start: o.start,
	            end: o.end
	          }, e.options.animation));
	        });
	      }
	      drawEmpty() {
	        let t, e;
	        let i = this.startAngleRad,
	          s = this.endAngleRad,
	          o = this.options;
	        0 === this.total && this.center ? (t = this.center[0], e = this.center[1], this.graph || (this.graph = this.chart.renderer.arc(t, e, this.center[1] / 2, 0, i, s).addClass("highcharts-empty-series").add(this.group)), this.graph.attr({
	          d: a.arc(t, e, this.center[2] / 2, 0, {
	            start: i,
	            end: s,
	            innerR: this.center[3] / 2
	          })
	        }), this.chart.styledMode || this.graph.attr({
	          "stroke-width": o.borderWidth,
	          fill: o.fillColor || "none",
	          stroke: o.color || "#cccccc"
	        })) : this.graph && (this.graph = this.graph.destroy());
	      }
	      drawPoints() {
	        let t = this.chart.renderer;
	        this.points.forEach(function (e) {
	          e.graphic && e.hasNewShapeType() && (e.graphic = e.graphic.destroy()), e.graphic || (e.graphic = t[e.shapeType](e.shapeArgs).add(e.series.group), e.delayedRendering = !0);
	        });
	      }
	      generatePoints() {
	        super.generatePoints(), this.updateTotals();
	      }
	      getX(t, e, i, s) {
	        let o = this.center,
	          r = this.radii ? this.radii[i.index] || 0 : o[2] / 2,
	          n = s.dataLabelPosition,
	          a = n?.distance || 0,
	          h = Math.asin(c((t - o[1]) / (r + a), -1, 1)),
	          l = o[0] + (e ? -1 : 1) * (Math.cos(h) * (r + a)) + (a > 0 ? (e ? -1 : 1) * (s.padding || 0) : 0);
	        return l;
	      }
	      hasData() {
	        return !!this.processedXData.length;
	      }
	      redrawPoints() {
	        let t, e, i, s;
	        let o = this,
	          r = o.chart;
	        this.drawEmpty(), o.group && !r.styledMode && o.group.shadow(o.options.shadow), o.points.forEach(function (n) {
	          let a = {};
	          e = n.graphic, !n.isNull && e ? (s = n.shapeArgs, t = n.getTranslate(), r.styledMode || (i = o.pointAttribs(n, n.selected && "select")), n.delayedRendering ? (e.setRadialReference(o.center).attr(s).attr(t), r.styledMode || e.attr(i).attr({
	            "stroke-linejoin": "round"
	          }), n.delayedRendering = !1) : (e.setRadialReference(o.center), r.styledMode || g(!0, a, i), g(!0, a, s, t), e.animate(a)), e.attr({
	            visibility: n.visible ? "inherit" : "hidden"
	          }), e.addClass(n.getClassName(), !0)) : e && (n.graphic = e.destroy());
	        });
	      }
	      sortByAngle(t, e) {
	        t.sort(function (t, i) {
	          return void 0 !== t.angle && (i.angle - t.angle) * e;
	        });
	      }
	      translate(t) {
	        u(this, "translate"), this.generatePoints();
	        let e = this.options,
	          i = e.slicedOffset,
	          s = l(e.startAngle, e.endAngle),
	          o = this.startAngleRad = s.start,
	          r = this.endAngleRad = s.end,
	          n = r - o,
	          a = this.points,
	          h = e.ignoreHiddenPoint,
	          d = a.length,
	          c,
	          p,
	          g,
	          f,
	          m,
	          x,
	          y,
	          b = 0;
	        for (t || (this.center = t = this.getCenter()), x = 0; x < d; x++) {
	          y = a[x], c = o + b * n, y.isValid() && (!h || y.visible) && (b += y.percentage / 100), p = o + b * n;
	          let e = {
	            x: t[0],
	            y: t[1],
	            r: t[2] / 2,
	            innerR: t[3] / 2,
	            start: Math.round(1e3 * c) / 1e3,
	            end: Math.round(1e3 * p) / 1e3
	          };
	          y.shapeType = "arc", y.shapeArgs = e, (g = (p + c) / 2) > 1.5 * Math.PI ? g -= 2 * Math.PI : g < -Math.PI / 2 && (g += 2 * Math.PI), y.slicedTranslation = {
	            translateX: Math.round(Math.cos(g) * i),
	            translateY: Math.round(Math.sin(g) * i)
	          }, f = Math.cos(g) * t[2] / 2, m = Math.sin(g) * t[2] / 2, y.tooltipPos = [t[0] + .7 * f, t[1] + .7 * m], y.half = g < -Math.PI / 2 || g > Math.PI / 2 ? 1 : 0, y.angle = g;
	        }
	        u(this, "afterTranslate");
	      }
	      updateTotals() {
	        let t = this.points,
	          e = t.length,
	          i = this.options.ignoreHiddenPoint,
	          s,
	          o,
	          r = 0;
	        for (s = 0; s < e; s++) (o = t[s]).isValid() && (!i || o.visible) && (r += o.y);
	        for (s = 0, this.total = r; s < e; s++) (o = t[s]).percentage = r > 0 && (o.visible || !i) ? o.y / r * 100 : 0, o.total = r;
	      }
	    }
	    return y.defaultOptions = g(r.defaultOptions, o), p(y.prototype, {
	      axisTypes: [],
	      directTouch: !0,
	      drawGraph: void 0,
	      drawTracker: e.prototype.drawTracker,
	      getCenter: t.getCenter,
	      getSymbol: d,
	      isCartesian: !1,
	      noSharedTooltip: !0,
	      pointAttribs: e.prototype.pointAttribs,
	      pointClass: s,
	      requireSorting: !1,
	      searchPoint: d,
	      trackerGroups: ["group", "dataLabelsGroup"]
	    }), n.registerSeriesType("pie", y), y;
	  }), i(e, "Series/Pie/PieDataLabel.js", [e["Core/Series/DataLabel.js"], e["Core/Globals.js"], e["Core/Renderer/RendererUtilities.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function (t, e, i, s, o) {
	    var r;
	    let {
	        composed: n,
	        noop: a
	      } = e,
	      {
	        distribute: h
	      } = i,
	      {
	        series: l
	      } = s,
	      {
	        arrayMax: d,
	        clamp: c,
	        defined: p,
	        pick: u,
	        pushUnique: g,
	        relativeLength: f
	      } = o;
	    return function (e) {
	      let i = {
	        radialDistributionY: function (t, e) {
	          return (e.dataLabelPosition?.top || 0) + t.distributeBox.pos;
	        },
	        radialDistributionX: function (t, e, i, s, o) {
	          let r = o.dataLabelPosition;
	          return t.getX(i < (r?.top || 0) + 2 || i > (r?.bottom || 0) - 2 ? s : i, e.half, e, o);
	        },
	        justify: function (t, e, i, s) {
	          return s[0] + (t.half ? -1 : 1) * (i + (e.dataLabelPosition?.distance || 0));
	        },
	        alignToPlotEdges: function (t, e, i, s) {
	          let o = t.getBBox().width;
	          return e ? o + s : i - o - s;
	        },
	        alignToConnectors: function (t, e, i, s) {
	          let o = 0,
	            r;
	          return t.forEach(function (t) {
	            (r = t.dataLabel.getBBox().width) > o && (o = r);
	          }), e ? o + s : i - o - s;
	        }
	      };
	      function s(t, e) {
	        let {
	            center: i,
	            options: s
	          } = this,
	          o = i[2] / 2,
	          r = t.angle || 0,
	          n = Math.cos(r),
	          a = Math.sin(r),
	          h = i[0] + n * o,
	          l = i[1] + a * o,
	          d = Math.min((s.slicedOffset || 0) + (s.borderWidth || 0), e / 5);
	        return {
	          natural: {
	            x: h + n * e,
	            y: l + a * e
	          },
	          computed: {},
	          alignment: e < 0 ? "center" : t.half ? "right" : "left",
	          connectorPosition: {
	            breakAt: {
	              x: h + n * d,
	              y: l + a * d
	            },
	            touchingSliceAt: {
	              x: h,
	              y: l
	            }
	          },
	          distance: e
	        };
	      }
	      function o() {
	        let t = this,
	          e = t.points,
	          i = t.chart,
	          s = i.plotWidth,
	          o = i.plotHeight,
	          r = i.plotLeft,
	          n = Math.round(i.chartWidth / 3),
	          a = t.center,
	          c = a[2] / 2,
	          g = a[1],
	          m = [[], []],
	          x = [0, 0, 0, 0],
	          y = t.dataLabelPositioners,
	          b,
	          v,
	          S,
	          k = 0;
	        t.visible && t.hasDataLabels?.() && (e.forEach(t => {
	          (t.dataLabels || []).forEach(t => {
	            t.shortened && (t.attr({
	              width: "auto"
	            }).css({
	              width: "auto",
	              textOverflow: "clip"
	            }), t.shortened = !1);
	          });
	        }), l.prototype.drawDataLabels.apply(t), e.forEach(t => {
	          (t.dataLabels || []).forEach((e, i) => {
	            let s = a[2] / 2,
	              o = e.options,
	              r = f(o?.distance || 0, s);
	            0 === i && m[t.half].push(t), !p(o?.style?.width) && e.getBBox().width > n && (e.css({
	              width: Math.round(.7 * n) + "px"
	            }), e.shortened = !0), e.dataLabelPosition = this.getDataLabelPosition(t, r), k = Math.max(k, r);
	          });
	        }), m.forEach((e, n) => {
	          let l = e.length,
	            d = [],
	            f,
	            m,
	            b = 0,
	            M;
	          l && (t.sortByAngle(e, n - .5), k > 0 && (f = Math.max(0, g - c - k), m = Math.min(g + c + k, i.plotHeight), e.forEach(t => {
	            (t.dataLabels || []).forEach((e, s) => {
	              let o = e.dataLabelPosition;
	              o && o.distance > 0 && (o.top = Math.max(0, g - c - o.distance), o.bottom = Math.min(g + c + o.distance, i.plotHeight), b = e.getBBox().height || 21, t.distributeBox = {
	                target: (e.dataLabelPosition?.natural.y || 0) - o.top + b / 2,
	                size: b,
	                rank: t.y
	              }, d.push(t.distributeBox));
	            });
	          }), h(d, M = m + b - f, M / 5)), e.forEach(i => {
	            (i.dataLabels || []).forEach(h => {
	              let l = h.options || {},
	                g = i.distributeBox,
	                f = h.dataLabelPosition,
	                m = f?.natural.y || 0,
	                b = l.connectorPadding || 0,
	                k = 0,
	                M = m,
	                C = "inherit";
	              if (f) {
	                if (d && p(g) && f.distance > 0 && (void 0 === g.pos ? C = "hidden" : (S = g.size, M = y.radialDistributionY(i, h))), l.justify) k = y.justify(i, h, c, a);else switch (l.alignTo) {
	                  case "connectors":
	                    k = y.alignToConnectors(e, n, s, r);
	                    break;
	                  case "plotEdges":
	                    k = y.alignToPlotEdges(h, n, s, r);
	                    break;
	                  default:
	                    k = y.radialDistributionX(t, i, M, m, h);
	                }
	                if (f.attribs = {
	                  visibility: C,
	                  align: f.alignment
	                }, f.posAttribs = {
	                  x: k + (l.x || 0) + ({
	                    left: b,
	                    right: -b
	                  }[f.alignment] || 0),
	                  y: M + (l.y || 0) - h.getBBox().height / 2
	                }, f.computed.x = k, f.computed.y = M, u(l.crop, !0)) {
	                  let t;
	                  k - (v = h.getBBox().width) < b && 1 === n ? (t = Math.round(v - k + b), x[3] = Math.max(t, x[3])) : k + v > s - b && 0 === n && (t = Math.round(k + v - s + b), x[1] = Math.max(t, x[1])), M - S / 2 < 0 ? x[0] = Math.max(Math.round(-M + S / 2), x[0]) : M + S / 2 > o && (x[2] = Math.max(Math.round(M + S / 2 - o), x[2])), f.sideOverflow = t;
	                }
	              }
	            });
	          }));
	        }), (0 === d(x) || this.verifyDataLabelOverflow(x)) && (this.placeDataLabels(), this.points.forEach(e => {
	          (e.dataLabels || []).forEach(s => {
	            let {
	                connectorColor: o,
	                connectorWidth: r = 1
	              } = s.options || {},
	              n = s.dataLabelPosition;
	            if (r) {
	              let a;
	              b = s.connector, n && n.distance > 0 ? (a = !b, b || (s.connector = b = i.renderer.path().addClass("highcharts-data-label-connector  highcharts-color-" + e.colorIndex + (e.className ? " " + e.className : "")).add(t.dataLabelsGroup)), i.styledMode || b.attr({
	                "stroke-width": r,
	                stroke: o || e.color || "#666666"
	              }), b[a ? "attr" : "animate"]({
	                d: e.getConnectorPath(s)
	              }), b.attr({
	                visibility: n.attribs?.visibility
	              })) : b && (s.connector = b.destroy());
	            }
	          });
	        })));
	      }
	      function r() {
	        this.points.forEach(t => {
	          (t.dataLabels || []).forEach(t => {
	            let e = t.dataLabelPosition;
	            e ? (e.sideOverflow && (t.css({
	              width: Math.max(t.getBBox().width - e.sideOverflow, 0) + "px",
	              textOverflow: (t.options?.style || {}).textOverflow || "ellipsis"
	            }), t.shortened = !0), t.attr(e.attribs), t[t.moved ? "animate" : "attr"](e.posAttribs), t.moved = !0) : t && t.attr({
	              y: -9999
	            });
	          }), delete t.distributeBox;
	        }, this);
	      }
	      function m(t) {
	        let e = this.center,
	          i = this.options,
	          s = i.center,
	          o = i.minSize || 80,
	          r = o,
	          n = null !== i.size;
	        return !n && (null !== s[0] ? r = Math.max(e[2] - Math.max(t[1], t[3]), o) : (r = Math.max(e[2] - t[1] - t[3], o), e[0] += (t[3] - t[1]) / 2), null !== s[1] ? r = c(r, o, e[2] - Math.max(t[0], t[2])) : (r = c(r, o, e[2] - t[0] - t[2]), e[1] += (t[0] - t[2]) / 2), r < e[2] ? (e[2] = r, e[3] = Math.min(i.thickness ? Math.max(0, r - 2 * i.thickness) : Math.max(0, f(i.innerSize || 0, r)), r), this.translate(e), this.drawDataLabels && this.drawDataLabels()) : n = !0), n;
	      }
	      e.compose = function e(h) {
	        if (t.compose(l), g(n, e)) {
	          let t = h.prototype;
	          t.dataLabelPositioners = i, t.alignDataLabel = a, t.drawDataLabels = o, t.getDataLabelPosition = s, t.placeDataLabels = r, t.verifyDataLabelOverflow = m;
	        }
	      };
	    }(r || (r = {})), r;
	  }), i(e, "Extensions/OverlappingDataLabels.js", [e["Core/Globals.js"], e["Core/Utilities.js"]], function (t, e) {
	    let {
	        composed: i
	      } = t,
	      {
	        addEvent: s,
	        fireEvent: o,
	        isNumber: r,
	        objectEach: n,
	        pick: a,
	        pushUnique: h
	      } = e;
	    function l(t) {
	      let e = t.length,
	        i = this.renderer,
	        s = (t, e) => !(e.x >= t.x + t.width || e.x + e.width <= t.x || e.y >= t.y + t.height || e.y + e.height <= t.y),
	        n = t => {
	          let e = t.box ? 0 : t.padding || 0,
	            s,
	            o,
	            n,
	            a = 0,
	            h = 0,
	            l,
	            d;
	          if (t && (!t.alignAttr || t.placed)) return s = t.alignAttr || {
	            x: t.attr("x"),
	            y: t.attr("y")
	          }, o = t.parentGroup, t.width || (n = t.getBBox(), t.width = n.width, t.height = n.height, a = i.fontMetrics(t.element).h), l = t.width - 2 * e, (d = {
	            left: "0",
	            center: "0.5",
	            right: "1"
	          }[t.alignValue]) ? h = +d * l : r(t.x) && Math.round(t.x) !== t.translateX && (h = t.x - (t.translateX || 0)), {
	            x: s.x + (o.translateX || 0) + e - (h || 0),
	            y: s.y + (o.translateY || 0) + e - a,
	            width: t.width - 2 * e,
	            height: (t.height || 0) - 2 * e
	          };
	        },
	        a,
	        h,
	        l,
	        c,
	        p,
	        u = !1;
	      for (let i = 0; i < e; i++) (a = t[i]) && (a.oldOpacity = a.opacity, a.newOpacity = 1, a.absoluteBox = n(a));
	      t.sort((t, e) => (e.labelrank || 0) - (t.labelrank || 0));
	      for (let i = 0; i < e; ++i) {
	        c = (h = t[i]) && h.absoluteBox;
	        for (let o = i + 1; o < e; ++o) p = (l = t[o]) && l.absoluteBox, c && p && h !== l && 0 !== h.newOpacity && 0 !== l.newOpacity && "hidden" !== h.visibility && "hidden" !== l.visibility && s(c, p) && ((h.labelrank < l.labelrank ? h : l).newOpacity = 0);
	      }
	      for (let e of t) d(e, this) && (u = !0);
	      u && o(this, "afterHideAllOverlappingLabels");
	    }
	    function d(t, e) {
	      let i,
	        s = !1;
	      return t && (i = t.newOpacity, t.oldOpacity !== i && (t.hasClass("highcharts-data-label") ? (t[i ? "removeClass" : "addClass"]("highcharts-data-label-hidden"), s = !0, t[t.isOld ? "animate" : "attr"]({
	        opacity: i
	      }, void 0, function () {
	        e.styledMode || t.css({
	          pointerEvents: i ? "auto" : "none"
	        });
	      }), o(e, "afterHideOverlappingLabel")) : t.attr({
	        opacity: i
	      })), t.isOld = !0), s;
	    }
	    function c() {
	      let t = this,
	        e = [];
	      for (let i of t.labelCollectors || []) e = e.concat(i());
	      for (let i of t.yAxis || []) i.stacking && i.options.stackLabels && !i.options.stackLabels.allowOverlap && n(i.stacking.stacks, t => {
	        n(t, t => {
	          t.label && e.push(t.label);
	        });
	      });
	      for (let i of t.series || []) if (i.visible && i.hasDataLabels?.()) {
	        let s = i => {
	          for (let s of i) s.visible && (s.dataLabels || []).forEach(i => {
	            let o = i.options || {};
	            i.labelrank = a(o.labelrank, s.labelrank, s.shapeArgs?.height), o.allowOverlap ?? Number(o.distance) > 0 ? (i.oldOpacity = i.opacity, i.newOpacity = 1, d(i, t)) : e.push(i);
	          });
	        };
	        s(i.nodes || []), s(i.points);
	      }
	      this.hideOverlappingLabels(e);
	    }
	    return {
	      compose: function t(e) {
	        if (h(i, t)) {
	          let t = e.prototype;
	          t.hideOverlappingLabels = l, s(e, "render", c);
	        }
	      }
	    };
	  }), i(e, "Extensions/BorderRadius.js", [e["Core/Defaults.js"], e["Core/Globals.js"], e["Core/Utilities.js"]], function (t, e, i) {
	    let {
	        defaultOptions: s
	      } = t,
	      {
	        composed: o,
	        noop: r
	      } = e,
	      {
	        addEvent: n,
	        extend: a,
	        isObject: h,
	        merge: l,
	        pushUnique: d,
	        relativeLength: c
	      } = i,
	      p = {
	        radius: 0,
	        scope: "stack",
	        where: void 0
	      },
	      u = r,
	      g = r;
	    function f(t, e, i, s, o = {}) {
	      let r = u(t, e, i, s, o),
	        {
	          innerR: n = 0,
	          r: a = i,
	          start: h = 0,
	          end: l = 0
	        } = o;
	      if (o.open || !o.borderRadius) return r;
	      let d = l - h,
	        p = Math.sin(d / 2),
	        g = Math.max(Math.min(c(o.borderRadius || 0, a - n), (a - n) / 2, a * p / (1 + p)), 0),
	        f = Math.min(g, 2 * (d / Math.PI) * n),
	        m = r.length - 1;
	      for (; m--;) !function (t, e, i) {
	        let s, o, r;
	        let n = t[e],
	          a = t[e + 1];
	        if ("Z" === a[0] && (a = t[0]), ("M" === n[0] || "L" === n[0]) && "A" === a[0] ? (s = n, o = a, r = !0) : "A" === n[0] && ("M" === a[0] || "L" === a[0]) && (s = a, o = n), s && o && o.params) {
	          let n = o[1],
	            a = o[5],
	            h = o.params,
	            {
	              start: l,
	              end: d,
	              cx: c,
	              cy: p
	            } = h,
	            u = a ? n - i : n + i,
	            g = u ? Math.asin(i / u) : 0,
	            f = a ? g : -g,
	            m = Math.cos(g) * u;
	          r ? (h.start = l + f, s[1] = c + m * Math.cos(l), s[2] = p + m * Math.sin(l), t.splice(e + 1, 0, ["A", i, i, 0, 0, 1, c + n * Math.cos(h.start), p + n * Math.sin(h.start)])) : (h.end = d - f, o[6] = c + n * Math.cos(h.end), o[7] = p + n * Math.sin(h.end), t.splice(e + 1, 0, ["A", i, i, 0, 0, 1, c + m * Math.cos(d), p + m * Math.sin(d)])), o[4] = Math.abs(h.end - h.start) < Math.PI ? 0 : 1;
	        }
	      }(r, m, m > 1 ? f : g);
	      return r;
	    }
	    function m() {
	      if (this.options.borderRadius && !(this.chart.is3d && this.chart.is3d())) {
	        let {
	            options: t,
	            yAxis: e
	          } = this,
	          i = "percent" === t.stacking,
	          o = s.plotOptions?.[this.type]?.borderRadius,
	          r = x(t.borderRadius, h(o) ? o : {}),
	          n = e.options.reversed;
	        for (let s of this.points) {
	          let {
	            shapeArgs: o
	          } = s;
	          if ("roundedRect" === s.shapeType && o) {
	            let {
	                width: h = 0,
	                height: l = 0,
	                y: d = 0
	              } = o,
	              p = d,
	              u = l;
	            if ("stack" === r.scope && s.stackTotal) {
	              let o = e.translate(i ? 100 : s.stackTotal, !1, !0, !1, !0),
	                r = e.translate(t.threshold || 0, !1, !0, !1, !0),
	                n = this.crispCol(0, Math.min(o, r), 0, Math.abs(o - r));
	              p = n.y, u = n.height;
	            }
	            let g = (s.negative ? -1 : 1) * (n ? -1 : 1) == -1,
	              f = r.where;
	            !f && this.is("waterfall") && Math.abs((s.yBottom || 0) - (this.translatedThreshold || 0)) > this.borderWidth && (f = "all"), f || (f = "end");
	            let m = Math.min(c(r.radius, h), h / 2, "all" === f ? l / 2 : 1 / 0) || 0;
	            "end" === f && (g && (p -= m), u += m), a(o, {
	              brBoxHeight: u,
	              brBoxY: p,
	              r: m
	            });
	          }
	        }
	      }
	    }
	    function x(t, e) {
	      return h(t) || (t = {
	        radius: t || 0
	      }), l(p, e, t);
	    }
	    function y() {
	      let t = x(this.options.borderRadius);
	      for (let e of this.points) {
	        let i = e.shapeArgs;
	        i && (i.borderRadius = c(t.radius, (i.r || 0) - (i.innerR || 0)));
	      }
	    }
	    function b(t, e, i, s, o = {}) {
	      let r = g(t, e, i, s, o),
	        {
	          r: n = 0,
	          brBoxHeight: a = s,
	          brBoxY: h = e
	        } = o,
	        l = e - h,
	        d = h + a - (e + s),
	        c = l - n > -.1 ? 0 : n,
	        p = d - n > -.1 ? 0 : n,
	        u = Math.max(c && l, 0),
	        f = Math.max(p && d, 0),
	        m = [t + c, e],
	        x = [t + i - c, e],
	        y = [t + i, e + c],
	        b = [t + i, e + s - p],
	        v = [t + i - p, e + s],
	        S = [t + p, e + s],
	        k = [t, e + s - p],
	        M = [t, e + c],
	        C = (t, e) => Math.sqrt(Math.pow(t, 2) - Math.pow(e, 2));
	      if (u) {
	        let t = C(c, c - u);
	        m[0] -= t, x[0] += t, y[1] = M[1] = e + c - u;
	      }
	      if (s < c - u) {
	        let o = C(c, c - u - s);
	        y[0] = b[0] = t + i - c + o, v[0] = Math.min(y[0], v[0]), S[0] = Math.max(b[0], S[0]), k[0] = M[0] = t + c - o, y[1] = M[1] = e + s;
	      }
	      if (f) {
	        let t = C(p, p - f);
	        v[0] += t, S[0] -= t, b[1] = k[1] = e + s - p + f;
	      }
	      if (s < p - f) {
	        let o = C(p, p - f - s);
	        y[0] = b[0] = t + i - p + o, x[0] = Math.min(y[0], x[0]), m[0] = Math.max(b[0], m[0]), k[0] = M[0] = t + p - o, b[1] = k[1] = e;
	      }
	      return r.length = 0, r.push(["M", ...m], ["L", ...x], ["A", c, c, 0, 0, 1, ...y], ["L", ...b], ["A", p, p, 0, 0, 1, ...v], ["L", ...S], ["A", p, p, 0, 0, 1, ...k], ["L", ...M], ["A", c, c, 0, 0, 1, ...m], ["Z"]), r;
	    }
	    return {
	      compose: function t(e, i, s, r) {
	        if (d(o, t)) {
	          let t = r.prototype.symbols;
	          n(e, "afterColumnTranslate", m, {
	            order: 9
	          }), n(i, "afterTranslate", y), s.symbolCustomAttribs.push("borderRadius", "brBoxHeight", "brBoxY"), u = t.arc, g = t.roundedRect, t.arc = f, t.roundedRect = b;
	        }
	      },
	      optionsToObject: x
	    };
	  }), i(e, "Core/Responsive.js", [e["Core/Globals.js"], e["Core/Utilities.js"]], function (t, e) {
	    var i;
	    let {
	        composed: s
	      } = t,
	      {
	        diffObjects: o,
	        extend: r,
	        find: n,
	        merge: a,
	        pick: h,
	        pushUnique: l,
	        uniqueKey: d
	      } = e;
	    return function (t) {
	      function e(t, e) {
	        let i = t.condition,
	          s = i.callback || function () {
	            return this.chartWidth <= h(i.maxWidth, Number.MAX_VALUE) && this.chartHeight <= h(i.maxHeight, Number.MAX_VALUE) && this.chartWidth >= h(i.minWidth, 0) && this.chartHeight >= h(i.minHeight, 0);
	          };
	        s.call(this) && e.push(t._id);
	      }
	      function i(t, e) {
	        let i = this.options.responsive,
	          s = this.currentResponsive,
	          r = [],
	          h;
	        !e && i && i.rules && i.rules.forEach(t => {
	          void 0 === t._id && (t._id = d()), this.matchResponsiveRule(t, r);
	        }, this);
	        let l = a(...r.map(t => n((i || {}).rules || [], e => e._id === t)).map(t => t && t.chartOptions));
	        l.isResponsiveOptions = !0, r = r.toString() || void 0;
	        let c = s && s.ruleIds;
	        r !== c && (s && this.update(s.undoOptions, t, !0), r ? ((h = o(l, this.options, !0, this.collectionsWithUpdate)).isResponsiveOptions = !0, this.currentResponsive = {
	          ruleIds: r,
	          mergedOptions: l,
	          undoOptions: h
	        }, this.update(l, t, !0)) : this.currentResponsive = void 0);
	      }
	      t.compose = function t(o) {
	        return l(s, t) && r(o.prototype, {
	          matchResponsiveRule: e,
	          setResponsive: i
	        }), o;
	      };
	    }(i || (i = {})), i;
	  }), i(e, "masters/highcharts.src.js", [e["Core/Globals.js"], e["Core/Utilities.js"], e["Core/Defaults.js"], e["Core/Animation/Fx.js"], e["Core/Animation/AnimationUtilities.js"], e["Core/Renderer/HTML/AST.js"], e["Core/Templating.js"], e["Core/Renderer/RendererUtilities.js"], e["Core/Renderer/SVG/SVGElement.js"], e["Core/Renderer/SVG/SVGRenderer.js"], e["Core/Renderer/HTML/HTMLElement.js"], e["Core/Renderer/HTML/HTMLRenderer.js"], e["Core/Axis/Axis.js"], e["Core/Axis/DateTimeAxis.js"], e["Core/Axis/LogarithmicAxis.js"], e["Core/Axis/PlotLineOrBand/PlotLineOrBand.js"], e["Core/Axis/Tick.js"], e["Core/Tooltip.js"], e["Core/Series/Point.js"], e["Core/Pointer.js"], e["Core/Legend/Legend.js"], e["Core/Chart/Chart.js"], e["Extensions/ScrollablePlotArea.js"], e["Core/Axis/Stacking/StackingAxis.js"], e["Core/Axis/Stacking/StackItem.js"], e["Core/Series/Series.js"], e["Core/Series/SeriesRegistry.js"], e["Series/Column/ColumnSeries.js"], e["Series/Column/ColumnDataLabel.js"], e["Series/Pie/PieSeries.js"], e["Series/Pie/PieDataLabel.js"], e["Core/Series/DataLabel.js"], e["Extensions/OverlappingDataLabels.js"], e["Extensions/BorderRadius.js"], e["Core/Responsive.js"], e["Core/Color/Color.js"], e["Core/Time.js"]], function (t, e, i, s, o, r, n, a, h, l, d, c, p, u, g, f, m, x, y, b, v, S, k, M, C, w, T, A, P, L, O, D, E, j, I, B, R) {
	    return t.animate = o.animate, t.animObject = o.animObject, t.getDeferredAnimation = o.getDeferredAnimation, t.setAnimation = o.setAnimation, t.stop = o.stop, t.timers = s.timers, t.AST = r, t.Axis = p, t.Chart = S, t.chart = S.chart, t.Fx = s, t.Legend = v, t.PlotLineOrBand = f, t.Point = y, t.Pointer = b, t.Series = w, t.StackItem = C, t.SVGElement = h, t.SVGRenderer = l, t.Templating = n, t.Tick = m, t.Time = R, t.Tooltip = x, t.Color = B, t.color = B.parse, c.compose(l), d.compose(h), b.compose(S), v.compose(S), t.defaultOptions = i.defaultOptions, t.getOptions = i.getOptions, t.time = i.defaultTime, t.setOptions = i.setOptions, t.dateFormat = n.dateFormat, t.format = n.format, t.numberFormat = n.numberFormat, e.extend(t, e), t.distribute = a.distribute, t.seriesType = T.seriesType, P.compose(A), j.compose(w, L, h, l), D.compose(w), u.compose(p), g.compose(p), E.compose(S), O.compose(L), f.compose(p), I.compose(S), k.compose(p, S, w), M.compose(p, S, w), x.compose(b), t;
	  }), e["masters/highcharts.src.js"]._modules = e, e["masters/highcharts.src.js"];
	}); 
} (highcharts));

var highchartsExports = highcharts.exports;
var Highcharts$1 = /*@__PURE__*/getDefaultExportFromCjs(highchartsExports);

var _default$w = /*#__PURE__*/function (_Controller) {
  function _default() {
    _classCallCheck$1(this, _default);
    return _callSuper(this, _default, arguments);
  }
  _inherits$1(_default, _Controller);
  return _createClass$1(_default, [{
    key: "initialize",
    value: function initialize() {
      this.getJson();
      this.addCurrentPeriodClassToDefaultPeriod();
    }

    // A user clicked on a period link eg "3y"
    // Update the 'period' stimulus 'value' data attribute on the controller element in the DOM with
    // the data-period attribute on the clicked link, and then refresh the graph, which will request
    // json for the selected time period eg "3y"
  }, {
    key: "periodChanged",
    value: function periodChanged(event) {
      this.periodValue = event.target.getAttribute("data-period");
      this.removeCurrentClassFromAllPeriods();
      this.addCurrentClassToSelectedPeriod(event.target);
      this.getJson();
    }
  }, {
    key: "removeCurrentClassFromAllPeriods",
    value: function removeCurrentClassFromAllPeriods() {
      this.periodTargets.forEach(function (el) {
        el.classList.remove("current-period");
      });
    }
  }, {
    key: "addCurrentPeriodClassToDefaultPeriod",
    value: function addCurrentPeriodClassToDefaultPeriod() {
      var _this = this;
      this.periodTargets.forEach(function (el) {
        if (el.getAttribute("data-period") == _this.periodValue) {
          _this.addCurrentClassToSelectedPeriod(el);
        }
      });
    }
  }, {
    key: "addCurrentClassToSelectedPeriod",
    value: function addCurrentClassToSelectedPeriod(el) {
      el.classList.add(this.currentPeriodClass);
    }
  }, {
    key: "updateChart",
    value: function updateChart(json) {
      Highcharts$1.chart(this.chartTarget, {
        chart: {
          zoomType: "x"
        },
        credits: {
          enabled: false
        },
        title: {
          text: this.titleValue,
          align: "left"
        },
        xAxis: {
          type: "datetime"
        },
        yAxis: {
          type: this.yAxisTypeValue,
          title: {
            text: this.yAxisLabelValue
          }
        },
        tooltip: {
          headerFormat: "<b>{series.name}</b><br>",
          pointFormat: "{point.x:%e-%b-%Y}: {point.y:.2f}"
        },
        plotOptions: {
          series: {
            animation: {
              duration: 500
            },
            marker: {
              enabled: true
            }
          }
        },
        series: json,
        responsive: {
          rules: [{
            condition: {
              maxWidth: 500
            },
            chartOptions: {
              plotOptions: {
                series: {
                  marker: {
                    radius: 2.5
                  }
                }
              }
            }
          }]
        }
      });
    }
  }, {
    key: "getJson",
    value: function getJson() {
      var _this2 = this;
      fetch(this.urlValue + "?" + new URLSearchParams$1({
        period: this.periodValue
      }), {
        credentials: "same-origin",
        headers: new Headers({
          "content-type": "application/json"
        })
      }).then(function (response) {
        return response.json();
      }).then(function (json) {
        _this2.updateChart(json);
      });
    }
  }]);
}(Controller);
_defineProperty$2(_default$w, "targets", ["chart",
// chart container
"period" // array of period (10y, 3y..) links
]);
_defineProperty$2(_default$w, "values", {
  url: String,
  // API endpoint for chart json
  title: String,
  // Chart title
  period: String,
  // State for the last selected period
  yAxisLabel: String,
  // eg Kg
  yAxisType: String // linear or logarithmic
});
_defineProperty$2(_default$w, "classes", ["currentPeriod" // Maps to a CSS class name via data attribute on controller element
]);

var Rails$2 = window.Rails;
var _ = window._;

// This controller has 3 related functions
// - Keep a users session alive
//   Keep the user's session alive if they are 'active' (there are keypresses,
//   clicks or resize events on the same page) by sending a throttled ajax
//   request to reset the session window which will prevent their session
//   expiring and throwing them out when they are for example writing a long
//   letter (which they would otherwise not finish before their session expires)
// - Auto logging-out a user after a period of inactivity
//   Check after a period of inactivity to see if their session has expired.
//   If it has then refresh the page which will redirect them to the login page.
// - Signalling to other open tabs when the user's session has expired or they
//   have manually logged out - so that all tabs go to the login page at around
//   the same time.
//
// Goals:
// - Performance and code clarity more important than having an accurate session
//   window - if it is extended for a minute or two that is OK.
// - The server should always be the judge of whether the session has timed out
// - Query the server as little as possible - partly for performance and partly
//   to avoid noise in the server logs
// - Keep event handler activity minimal to preserve CPU cycles - ie use
//   throttle or debounce
//
// Possible enhancements:
// - After a period of inactivity, show a dialog asking if user wants to extend
//   the session - this would involve starting a separate timer and displaying
//   the countdown
//
// Scenarios to test:
// - Keypresses, clicks and window resizing - any of these should reset session
//   and thus the user remains logged in as long as one of these events occurs
//   within sessionTimeoutSeconds
// - User closes lid on laptop overnight and reopens in the morning - what is
//   expected?
// - Network disconnected - what do we do?
// - user gets within 10 seconds of session timeout and starts typing - session
//   window should be reset
// - user has > 1 tab open and logs out of one - ideally it should log out of
//   other tabs before too long. We do by setting a localStorage value to signal
//   to other tabs
//
// Known issues:
// - user sitting on register page will keep polling checkAlivePath
// - if a user becomes active on a page within throttlePeriodSeconds of
//   sessionTimeoutSeconds then there is no currently opportunity for
//   throttledRegisterUserActivity to reset kick in a trump
//   checkForSessionExpiryTimeout - so the session will log out. We might need
//   an extra step before calling checkForSessionExpiry - a final chance to
//   check if the user was
//   active
// - Not quite sure if putting the data attribute config settings in the body
//   tag is the right thing to do - perhaps should be in a config .js.erb
var _default$v = /*#__PURE__*/function (_Controller) {
  function _default() {
    var _this;
    _classCallCheck$1(this, _default);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _callSuper(this, _default, [].concat(args));
    _defineProperty$2(_this, "checkForSessionExpiryTimeout", null);
    _defineProperty$2(_this, "userActivityDetected", false);
    _defineProperty$2(_this, "checkAlivePath", null);
    _defineProperty$2(_this, "keepAlivePath", null);
    _defineProperty$2(_this, "loginPath", null);
    _defineProperty$2(_this, "throttledRegisterUserActivity", null);
    _defineProperty$2(_this, "sessionTimeoutSeconds", 0);
    _defineProperty$2(_this, "defaultSessionTimeoutSeconds", 20 * 60);
    // 20 mins
    _defineProperty$2(_this, "throttlePeriodSeconds", 0);
    _defineProperty$2(_this, "defaultThrottlePeriodSeconds", 20);
    return _this;
  }
  _inherits$1(_default, _Controller);
  return _createClass$1(_default, [{
    key: "initialize",
    value: function initialize() {
      this.throttlePeriodSeconds = parseInt(this.data.get("register-user-activity-after") || this.defaultThrottlePeriodSeconds);
      this.sessionTimeoutSeconds = parseInt(this.data.get("timeout") || this.defaultSessionTimeoutSeconds);
      this.sessionTimeoutSeconds += 10; // To allow for network roundtrips etc
      this.checkAlivePath = this.data.get("check-alive-path");
      this.loginPath = this.data.get("login-path");
      this.keepAlivePath = this.data.get("keep-alive-path");
      this.logSettings();

      // Throttle the user activity callback because we only need to know about user activity
      // only very occasionally, so that we can periodically tell there server the user was active.
      // Here, even if there are hundreds of events (click, keypress etc) within throttlePeriodSeconds,
      // our function is only called at most once in that period, when throttlePeriodSeconds has
      // passed (since trailing = true). This suits is as we want to avoid making any call to the
      // server unless the user has been on the page for at least throttlePeriodSeconds.
      // See https://lodash.com/docs/#trottle
      this.throttledRegisterUserActivity = _.throttle(this.registerUserActivity.bind(this), this.throttlePeriodSeconds * 1000, {
        "leading": false,
        "trailing": true
      });
    }
  }, {
    key: "connect",
    value: function connect() {
      if (this.onLoginPage) {
        this.log("connect: onLoginPage - skipping session time");
      } else {
        this.addHandlersToMonitorUserActivity();
        this.resetCheckForSessionExpiryTimeout(this.sessionTimeoutSeconds);
      }
    }
  }, {
    key: "disconnect",
    value: function disconnect() {
      if (!this.onLoginPage) {
        this.removeUserActivityHandlers();
        clearTimeout(this.checkForSessionExpiryTimeout);
      }
    }
  }, {
    key: "sendLogoutMessageToAnyOpenTabs",
    value: function sendLogoutMessageToAnyOpenTabs() {
      window.localStorage.setItem("logout-event", "logout" + Math.random());
    }

    // Debounced event handler for key/click/resize
    // If we come in there then the user has interacted with the page
    // within throttlePeriodSeconds
  }, {
    key: "registerUserActivity",
    value: function registerUserActivity() {
      this.sendRequestToKeepSessionAlive();
      this.resetCheckForSessionExpiryTimeout(this.sessionTimeoutSeconds);
    }

    // Timeout handler for checking if the session has expired
  }, {
    key: "resetCheckForSessionExpiryTimeout",
    value: function resetCheckForSessionExpiryTimeout(intervalSeconds) {
      this.log("resetting session expiry timeout ".concat(intervalSeconds));
      clearTimeout(this.checkForSessionExpiryTimeout);
      this.checkForSessionExpiryTimeout = setTimeout(this.checkForSessionExpiry.bind(this), intervalSeconds * 1000);
    }

    // Here we really expect the session to have expired. In case it hasn't
    // we reset the timeout to check again. We could reset the timeout to be
    // sessionTimeoutSeconds, but if when we checked for expiry we had only just
    // missed it, we will end up staying on this page (assuming the user is
    // inactive) for nearly twice as long as we need to. So we set the timeout
    // to be throttlePeriodSeconds * 2, which gives time for the
    // throttledRegisterUserActivity handler to reset the session again if it
    // fires.
  }, {
    key: "checkForSessionExpiry",
    value: function checkForSessionExpiry() {
      this.sendRequestToTestForSessionExpiry();
      this.resetCheckForSessionExpiryTimeout(this.throttlePeriodSeconds * 2);
    }
  }, {
    key: "sendRequestToKeepSessionAlive",
    value: function sendRequestToKeepSessionAlive() {
      this.ajaxGet(this.keepAlivePath);
    }
  }, {
    key: "sendRequestToTestForSessionExpiry",
    value: function sendRequestToTestForSessionExpiry() {
      this.log("checking for session expiry");
      this.ajaxGet(this.checkAlivePath);
    }
  }, {
    key: "ajaxGet",
    value: function ajaxGet(path) {
      Rails$2.ajax({
        type: "GET",
        url: path,
        dataType: "text",
        error: this.reloadPageIfAjaxRequestWasUnauthorised.bind(this)
      });
    }
  }, {
    key: "reloadPageIfAjaxRequestWasUnauthorised",
    value: function reloadPageIfAjaxRequestWasUnauthorised(responseText, status, xhr) {
      if (xhr.status == 401) {
        window.location.reload();
        this.sendLogoutMessageToAnyOpenTabs();
      }
    }
  }, {
    key: "addHandlersToMonitorUserActivity",
    value: function addHandlersToMonitorUserActivity() {
      document.addEventListener("click", this.throttledRegisterUserActivity.bind(this));
      document.addEventListener("keydown", this.throttledRegisterUserActivity.bind(this));
      window.addEventListener("resize", this.throttledRegisterUserActivity.bind(this));
      window.addEventListener("storage", this.storageChange.bind(this));
    }
  }, {
    key: "removeUserActivityHandlers",
    value: function removeUserActivityHandlers() {
      document.removeEventListener("click", this.throttledRegisterUserActivity.bind(this));
      document.removeEventListener("keydown", this.throttledRegisterUserActivity.bind(this));
      window.removeEventListener("resize", this.throttledRegisterUserActivity.bind(this));
      window.removeEventListener("storage", this.storageChange.bind(this));
    }
  }, {
    key: "logSettings",
    value: function logSettings() {
      if (this.debug) {
        this.log("keepAlivePath ".concat(this.keepAlivePath));
        this.log("checkAlivePath ".concat(this.checkAlivePath));
        this.log("loginPath ".concat(this.loginPath));
        this.log("sessionTimeoutSeconds ".concat(this.sessionTimeoutSeconds));
        this.log("throttlePeriodSeconds ".concat(this.throttlePeriodSeconds));
      }
    }
  }, {
    key: "log",
    value: function log(msg) {
      if (this.debug) {
        console.log(msg);
      }
    }

    // An event handler to watch for changes in the value of the local storage item called
    // 'logged_in'. We use localStorage as a cross-tab communication protocol: when the user has
    // logged out of one tab, this mechanism is used to signal to any other logged-in tabs that they
    // should log themselves out.
    // This applies in 2 circumstances:
    // - the user has clicked the "Log Out" link in the navbar - the sendLogoutMessageToAnyOpenTabs()
    //   action defined above is called
    // - our tab has timed out due to inactivity; other open tabs may not timeout for another few
    //   minutes (depending on the polling frequency etc) so we give them a nudge.
  }, {
    key: "storageChange",
    value: function storageChange(event) {
      if (event.key == "logout-event") {
        setTimeout(this.sendRequestToTestForSessionExpiry.bind(this), 2000);
      }
    }
  }, {
    key: "onLoginPage",
    get: function get() {
      return window.location.pathname == this.loginPath;
    }

    // If you add data-session-debug=1 then logging will be enabled
    // This is evaluated each time we can add debugging into a running page
  }, {
    key: "debug",
    get: function get() {
      return this.data.get("debug") === "true";
    }
  }]);
}(Controller);

var _default$u = /*#__PURE__*/function (_Controller) {
  function _default() {
    _classCallCheck$1(this, _default);
    return _callSuper(this, _default, arguments);
  }
  _inherits$1(_default, _Controller);
  return _createClass$1(_default, [{
    key: "connect",
    value: function connect() {
      this.toggleClass = this.data.get("class") || "hidden";
    }
  }, {
    key: "toggle",
    value: function toggle(event) {
      var _this = this;
      this.toggleableTargets.forEach(function (target) {
        target.classList.toggle(_this.toggleClass);
      });
    }
  }]);
}(Controller);
_defineProperty$2(_default$u, "targets", ["toggleable"]);

var _default$t = /*#__PURE__*/function (_Controller) {
  function _default() {
    _classCallCheck$1(this, _default);
    return _callSuper(this, _default, arguments);
  }
  _inherits$1(_default, _Controller);
  return _createClass$1(_default, [{
    key: "connect",
    value: function connect() {
      this.toggleClass = this.data.get("class") || "hidden";
    }
  }, {
    key: "select",
    value: function select(event) {
      var _this = this;
      event.preventDefault();
      var selectedOption = event.currentTarget.value;
      this.itemTargets.filter(function (target) {
        return _this.isMatch(target.dataset.showOnSelectedOption, selectedOption);
      }).forEach(function (target) {
        target.classList.remove(_this.toggleClass);
        Array.from(target.getElementsByTagName("input")).forEach(function (input) {
          input.disabled = false;
        });
      });
      this.itemTargets.filter(function (target) {
        return !_this.isMatch(target.dataset.showOnSelectedOption, selectedOption);
      }).forEach(function (target) {
        target.classList.add(_this.toggleClass);
        Array.from(target.getElementsByTagName("input")).forEach(function (input) {
          input.disabled = true;
        });
      });
    }
  }, {
    key: "isMatch",
    value: function isMatch(candidate, target) {
      var candidates = [this.parsePotentialJson(candidate)].flat();
      return candidates.includes(target);
    }

    // Support both "regular" strings and JSON encoded arrays for
    // data-show-on-selected-option attributes
  }, {
    key: "parsePotentialJson",
    value: function parsePotentialJson(valueOrJson) {
      try {
        return JSON.parse(valueOrJson);
      } catch (error) {
        return valueOrJson;
      }
    }
  }]);
}(Controller);
_defineProperty$2(_default$t, "targets", ["item"]);

var _default$s = /*#__PURE__*/function (_Controller) {
  function _default() {
    _classCallCheck$1(this, _default);
    return _callSuper(this, _default, arguments);
  }
  _inherits$1(_default, _Controller);
  return _createClass$1(_default, [{
    key: "connect",
    value: function connect() {}
  }, {
    key: "initialize",
    value: function initialize() {
      this.activeTabClasses = (this.data.get("activeTab") || "active").split(" ");
      this.showTab();
    }
  }, {
    key: "change",
    value: function change(event) {
      event.preventDefault();
      this.index = this.tabTargets.indexOf(event.currentTarget);
    }
  }, {
    key: "showTab",
    value: function showTab() {
      var _this = this;
      this.tabTargets.forEach(function (tab, index) {
        var panel = _this.panelTargets[index];
        if (index === _this.index) {
          var _tab$classList;
          panel.classList.remove("hidden");
          (_tab$classList = tab.classList).add.apply(_tab$classList, _toConsumableArray(_this.activeTabClasses));
        } else {
          var _tab$classList2;
          panel.classList.add("hidden");
          (_tab$classList2 = tab.classList).remove.apply(_tab$classList2, _toConsumableArray(_this.activeTabClasses));
        }
      });
    }
  }, {
    key: "index",
    get: function get() {
      return parseInt(this.data.get("index") || 0);
    },
    set: function set(value) {
      this.data.set("index", value);
      this.showTab();
    }
  }]);
}(Controller);
_defineProperty$2(_default$s, "targets", ["tab", "panel"]);

var highchartsMore = {exports: {}};

/**
 * Highcharts JS v11.3.0 (2024-01-10)
 *
 * (c) 2009-2024 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */

(function (module) {
	!function (t) {
	  module.exports ? (t.default = t, module.exports = t) : t("undefined" != typeof Highcharts ? Highcharts : void 0);
	}(function (t) {

	  var e = t ? t._modules : {};
	  function i(t, e, i, s) {
	    t.hasOwnProperty(e) || (t[e] = s.apply(null, i), "function" == typeof CustomEvent && window.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", {
	      detail: {
	        path: e,
	        module: t[e]
	      }
	    })));
	  }
	  i(e, "Extensions/Pane/PaneComposition.js", [e["Core/Globals.js"], e["Core/Utilities.js"]], function (t, e) {
	    let {
	        composed: i
	      } = t,
	      {
	        addEvent: s,
	        correctFloat: o,
	        defined: a,
	        pick: r,
	        pushUnique: n
	      } = e;
	    function l(t) {
	      let e;
	      let i = this;
	      return t && i.pane.forEach(s => {
	        let o = t.chartX - i.plotLeft,
	          a = t.chartY - i.plotTop;
	        h(o, a, s.center) && (e = s);
	      }), e;
	    }
	    function h(t, e, i, s, r) {
	      let n = !0,
	        l = i[0],
	        h = i[1],
	        p = Math.sqrt(Math.pow(t - l, 2) + Math.pow(e - h, 2));
	      if (a(s) && a(r)) {
	        let i = Math.atan2(o(e - h, 8), o(t - l, 8));
	        r !== s && (n = s > r ? i >= s && i <= Math.PI || i <= r && i >= -Math.PI : i >= s && i <= o(r, 8));
	      }
	      return p <= Math.ceil(i[2] / 2) && n;
	    }
	    function p(t) {
	      this.polar && (t.options.inverted && ([t.x, t.y] = [t.y, t.x]), t.isInsidePlot = this.pane.some(e => h(t.x, t.y, e.center, e.axis && e.axis.normalizedStartAngleRad, e.axis && e.axis.normalizedEndAngleRad)));
	    }
	    function d(t) {
	      let e = this.chart;
	      t.hoverPoint && t.hoverPoint.plotX && t.hoverPoint.plotY && e.hoverPane && !h(t.hoverPoint.plotX, t.hoverPoint.plotY, e.hoverPane.center) && (t.hoverPoint = void 0);
	    }
	    function c(t) {
	      let e = this.chart;
	      e.polar ? (e.hoverPane = e.getHoverPane(t), t.filter = function (i) {
	        return i.visible && !(!t.shared && i.directTouch) && r(i.options.enableMouseTracking, !0) && (!e.hoverPane || i.xAxis.pane === e.hoverPane);
	      }) : e.hoverPane = void 0;
	    }
	    return {
	      compose: function t(e, o) {
	        if (n(i, t)) {
	          let t = e.prototype;
	          t.collectionsWithUpdate.push("pane"), t.getHoverPane = l, s(e, "afterIsInsidePlot", p), s(o, "afterGetHoverData", d), s(o, "beforeGetHoverData", c);
	        }
	      }
	    };
	  }), i(e, "Extensions/Pane/PaneDefaults.js", [], function () {
	    let t = {
	      shape: "circle",
	      borderWidth: 1,
	      borderColor: "#cccccc",
	      backgroundColor: {
	        linearGradient: {
	          x1: 0,
	          y1: 0,
	          x2: 0,
	          y2: 1
	        },
	        stops: [[0, "#ffffff"], [1, "#e6e6e6"]]
	      },
	      from: -Number.MAX_VALUE,
	      innerRadius: 0,
	      to: Number.MAX_VALUE,
	      outerRadius: "105%"
	    };
	    return {
	      pane: {
	        center: ["50%", "50%"],
	        size: "85%",
	        innerSize: "0%",
	        startAngle: 0
	      },
	      background: t
	    };
	  }), i(e, "Extensions/Pane/Pane.js", [e["Series/CenteredUtilities.js"], e["Extensions/Pane/PaneComposition.js"], e["Extensions/Pane/PaneDefaults.js"], e["Core/Utilities.js"]], function (t, e, i, s) {
	    let {
	      extend: o,
	      merge: a,
	      splat: r
	    } = s;
	    class n {
	      constructor(t, e) {
	        this.coll = "pane", this.init(t, e);
	      }
	      init(t, e) {
	        this.chart = e, this.background = [], e.pane.push(this), this.setOptions(t);
	      }
	      setOptions(t) {
	        this.options = t = a(i.pane, this.chart.angular ? {
	          background: {}
	        } : void 0, t);
	      }
	      render() {
	        let t = this.options,
	          e = this.chart.renderer;
	        this.group || (this.group = e.g("pane-group").attr({
	          zIndex: t.zIndex || 0
	        }).add()), this.updateCenter();
	        let s = this.options.background;
	        if (s) {
	          s = r(s);
	          let t = Math.max(s.length, this.background.length || 0);
	          for (let e = 0; e < t; e++) s[e] && this.axis ? this.renderBackground(a(i.background, s[e]), e) : this.background[e] && (this.background[e] = this.background[e].destroy(), this.background.splice(e, 1));
	        }
	      }
	      renderBackground(t, e) {
	        let i = {
	            class: "highcharts-pane " + (t.className || "")
	          },
	          s = "animate";
	        this.chart.styledMode || o(i, {
	          fill: t.backgroundColor,
	          stroke: t.borderColor,
	          "stroke-width": t.borderWidth
	        }), this.background[e] || (this.background[e] = this.chart.renderer.path().add(this.group), s = "attr"), this.background[e][s]({
	          d: this.axis.getPlotBandPath(t.from, t.to, t)
	        }).attr(i);
	      }
	      updateCenter(e) {
	        this.center = (e || this.axis || {}).center = t.getCenter.call(this);
	      }
	      update(t, e) {
	        a(!0, this.options, t), this.setOptions(this.options), this.render(), this.chart.axes.forEach(function (t) {
	          t.pane === this && (t.pane = null, t.update({}, e));
	        }, this);
	      }
	    }
	    return n.compose = e.compose, n;
	  }), i(e, "Series/AreaRange/AreaRangePoint.js", [e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function (t, e) {
	    let {
	        area: {
	          prototype: {
	            pointClass: i,
	            pointClass: {
	              prototype: s
	            }
	          }
	        }
	      } = t.seriesTypes,
	      {
	        defined: o,
	        isNumber: a,
	        merge: r
	      } = e;
	    return class extends i {
	      setState() {
	        let t = this.state,
	          e = this.series,
	          i = e.chart.polar;
	        e.options.marker, e.symbol, o(this.plotHigh) || (this.plotHigh = e.yAxis.toPixels(this.high, !0)), o(this.plotLow) || (this.plotLow = this.plotY = e.yAxis.toPixels(this.low, !0)), e.lowerStateMarkerGraphic = e.stateMarkerGraphic, e.stateMarkerGraphic = e.upperStateMarkerGraphic, this.graphic = this.graphics && this.graphics[1], this.plotY = this.plotHigh, i && a(this.plotHighX) && (this.plotX = this.plotHighX), s.setState.apply(this, arguments), this.state = t, this.plotY = this.plotLow, this.graphic = this.graphics && this.graphics[0], i && a(this.plotLowX) && (this.plotX = this.plotLowX), e.upperStateMarkerGraphic = e.stateMarkerGraphic, e.stateMarkerGraphic = e.lowerStateMarkerGraphic, e.lowerStateMarkerGraphic = void 0;
	        let r = e.modifyMarkerSettings();
	        s.setState.apply(this, arguments), e.restoreMarkerSettings(r);
	      }
	      haloPath() {
	        let t = this.series.chart.polar,
	          e = [];
	        return this.plotY = this.plotLow, t && a(this.plotLowX) && (this.plotX = this.plotLowX), this.isInside && (e = s.haloPath.apply(this, arguments)), this.plotY = this.plotHigh, t && a(this.plotHighX) && (this.plotX = this.plotHighX), this.isTopInside && (e = e.concat(s.haloPath.apply(this, arguments))), e;
	      }
	      isValid() {
	        return a(this.low) && a(this.high);
	      }
	    };
	  }), i(e, "Series/AreaRange/AreaRangeSeries.js", [e["Series/AreaRange/AreaRangePoint.js"], e["Core/Globals.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function (t, e, i, s) {
	    let {
	        noop: o
	      } = e,
	      {
	        area: a,
	        area: {
	          prototype: r
	        },
	        column: {
	          prototype: n
	        }
	      } = i.seriesTypes,
	      {
	        addEvent: l,
	        defined: h,
	        extend: p,
	        isArray: d,
	        isNumber: c,
	        pick: u,
	        merge: g
	      } = s;
	    class f extends a {
	      toYData(t) {
	        return [t.low, t.high];
	      }
	      highToXY(t) {
	        let e = this.chart,
	          i = this.xAxis.postTranslate(t.rectPlotX || 0, this.yAxis.len - (t.plotHigh || 0));
	        t.plotHighX = i.x - e.plotLeft, t.plotHigh = i.y - e.plotTop, t.plotLowX = t.plotX;
	      }
	      getGraphPath(t) {
	        let e = [],
	          i = [],
	          s = r.getGraphPath,
	          o = this.options,
	          a = this.chart.polar,
	          n = a && !1 !== o.connectEnds,
	          l = o.connectNulls,
	          h,
	          p,
	          d,
	          c = o.step;
	        for (h = (t = t || this.points).length; h--;) {
	          p = t[h];
	          let s = a ? {
	            plotX: p.rectPlotX,
	            plotY: p.yBottom,
	            doCurve: !1
	          } : {
	            plotX: p.plotX,
	            plotY: p.plotY,
	            doCurve: !1
	          };
	          p.isNull || n || l || t[h + 1] && !t[h + 1].isNull || i.push(s), d = {
	            polarPlotY: p.polarPlotY,
	            rectPlotX: p.rectPlotX,
	            yBottom: p.yBottom,
	            plotX: u(p.plotHighX, p.plotX),
	            plotY: p.plotHigh,
	            isNull: p.isNull
	          }, i.push(d), e.push(d), p.isNull || n || l || t[h - 1] && !t[h - 1].isNull || i.push(s);
	        }
	        let g = s.call(this, t);
	        c && (!0 === c && (c = "left"), o.step = {
	          left: "right",
	          center: "center",
	          right: "left"
	        }[c]);
	        let f = s.call(this, e),
	          b = s.call(this, i);
	        o.step = c;
	        let m = [].concat(g, f);
	        return !this.chart.polar && b[0] && "M" === b[0][0] && (b[0] = ["L", b[0][1], b[0][2]]), this.graphPath = m, this.areaPath = g.concat(b), m.isArea = !0, m.xMap = g.xMap, this.areaPath.xMap = g.xMap, m;
	      }
	      drawDataLabels() {
	        let t, e, i, s, o;
	        let a = this.points,
	          n = a.length,
	          l = [],
	          h = this.options.dataLabels,
	          c = this.chart.inverted;
	        if (h) {
	          if (d(h) ? (s = h[0] || {
	            enabled: !1
	          }, o = h[1] || {
	            enabled: !1
	          }) : ((s = p({}, h)).x = h.xHigh, s.y = h.yHigh, (o = p({}, h)).x = h.xLow, o.y = h.yLow), s.enabled || this.hasDataLabels?.()) {
	            for (t = n; t--;) if (e = a[t]) {
	              let {
	                plotHigh: o = 0,
	                plotLow: a = 0
	              } = e;
	              i = s.inside ? o < a : o > a, e.y = e.high, e._plotY = e.plotY, e.plotY = o, l[t] = e.dataLabel, e.dataLabel = e.dataLabelUpper, e.below = i, c ? s.align || (s.align = i ? "right" : "left") : s.verticalAlign || (s.verticalAlign = i ? "top" : "bottom");
	            }
	            for (this.options.dataLabels = s, r.drawDataLabels && r.drawDataLabels.apply(this, arguments), t = n; t--;) (e = a[t]) && (e.dataLabelUpper = e.dataLabel, e.dataLabel = l[t], delete e.dataLabels, e.y = e.low, e.plotY = e._plotY);
	          }
	          if (o.enabled || this.hasDataLabels?.()) {
	            for (t = n; t--;) if (e = a[t]) {
	              let {
	                plotHigh: t = 0,
	                plotLow: s = 0
	              } = e;
	              i = o.inside ? t < s : t > s, e.below = !i, c ? o.align || (o.align = i ? "left" : "right") : o.verticalAlign || (o.verticalAlign = i ? "bottom" : "top");
	            }
	            this.options.dataLabels = o, r.drawDataLabels && r.drawDataLabels.apply(this, arguments);
	          }
	          if (s.enabled) for (t = n; t--;) (e = a[t]) && (e.dataLabels = [e.dataLabelUpper, e.dataLabel].filter(function (t) {
	            return !!t;
	          }));
	          this.options.dataLabels = h;
	        }
	      }
	      alignDataLabel() {
	        n.alignDataLabel.apply(this, arguments);
	      }
	      modifyMarkerSettings() {
	        let t = {
	          marker: this.options.marker,
	          symbol: this.symbol
	        };
	        if (this.options.lowMarker) {
	          let {
	            options: {
	              marker: t,
	              lowMarker: e
	            }
	          } = this;
	          this.options.marker = g(t, e), e.symbol && (this.symbol = e.symbol);
	        }
	        return t;
	      }
	      restoreMarkerSettings(t) {
	        this.options.marker = t.marker, this.symbol = t.symbol;
	      }
	      drawPoints() {
	        let t, e;
	        let i = this.points.length,
	          s = this.modifyMarkerSettings();
	        for (r.drawPoints.apply(this, arguments), this.restoreMarkerSettings(s), t = 0; t < i;) (e = this.points[t]).graphics = e.graphics || [], e.origProps = {
	          plotY: e.plotY,
	          plotX: e.plotX,
	          isInside: e.isInside,
	          negative: e.negative,
	          zone: e.zone,
	          y: e.y
	        }, (e.graphic || e.graphics[0]) && (e.graphics[0] = e.graphic), e.graphic = e.graphics[1], e.plotY = e.plotHigh, h(e.plotHighX) && (e.plotX = e.plotHighX), e.y = u(e.high, e.origProps.y), e.negative = e.y < (this.options.threshold || 0), this.zones.length && (e.zone = e.getZone()), this.chart.polar || (e.isInside = e.isTopInside = void 0 !== e.plotY && e.plotY >= 0 && e.plotY <= this.yAxis.len && e.plotX >= 0 && e.plotX <= this.xAxis.len), t++;
	        for (r.drawPoints.apply(this, arguments), t = 0; t < i;) (e = this.points[t]).graphics = e.graphics || [], (e.graphic || e.graphics[1]) && (e.graphics[1] = e.graphic), e.graphic = e.graphics[0], e.origProps && (p(e, e.origProps), delete e.origProps), t++;
	      }
	      hasMarkerChanged(t, e) {
	        let i = t.lowMarker,
	          s = e.lowMarker || {};
	        return i && (!1 === i.enabled || s.symbol !== i.symbol || s.height !== i.height || s.width !== i.width) || super.hasMarkerChanged(t, e);
	      }
	    }
	    return f.defaultOptions = g(a.defaultOptions, {
	      lineWidth: 1,
	      threshold: null,
	      tooltip: {
	        pointFormat: '<span style="color:{series.color}">â</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'
	      },
	      trackByArea: !0,
	      dataLabels: {
	        align: void 0,
	        verticalAlign: void 0,
	        xLow: 0,
	        xHigh: 0,
	        yLow: 0,
	        yHigh: 0
	      }
	    }), l(f, "afterTranslate", function () {
	      "low,high" === this.pointArrayMap.join(",") && this.points.forEach(t => {
	        let e = t.high,
	          i = t.plotY;
	        t.isNull ? t.plotY = void 0 : (t.plotLow = i, t.plotHigh = c(e) ? this.yAxis.translate(this.dataModify ? this.dataModify.modifyValue(e) : e, !1, !0, void 0, !0) : void 0, this.dataModify && (t.yBottom = t.plotHigh));
	      });
	    }, {
	      order: 0
	    }), l(f, "afterTranslate", function () {
	      this.chart.inverted, this.points.forEach(t => {
	        if (this.chart.polar) this.highToXY(t), t.plotLow = t.plotY, t.tooltipPos = [((t.plotHighX || 0) + (t.plotLowX || 0)) / 2, ((t.plotHigh || 0) + (t.plotLow || 0)) / 2];else {
	          let e = t.pos(!1, t.plotLow),
	            i = t.pos(!1, t.plotHigh);
	          e && i && (e[0] = (e[0] + i[0]) / 2, e[1] = (e[1] + i[1]) / 2), t.tooltipPos = e;
	        }
	      });
	    }, {
	      order: 3
	    }), p(f.prototype, {
	      deferTranslatePolar: !0,
	      pointArrayMap: ["low", "high"],
	      pointClass: t,
	      pointValKey: "low",
	      setStackedPoints: o
	    }), i.registerSeriesType("arearange", f), f;
	  }), i(e, "Series/AreaSplineRange/AreaSplineRangeSeries.js", [e["Series/AreaRange/AreaRangeSeries.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function (t, e, i) {
	    let {
	        spline: {
	          prototype: s
	        }
	      } = e.seriesTypes,
	      {
	        merge: o,
	        extend: a
	      } = i;
	    class r extends t {}
	    return r.defaultOptions = o(t.defaultOptions), a(r.prototype, {
	      getPointSpline: s.getPointSpline
	    }), e.registerSeriesType("areasplinerange", r), r;
	  }), i(e, "Series/BoxPlot/BoxPlotSeriesDefaults.js", [], function () {
	    return {
	      threshold: null,
	      tooltip: {
	        pointFormat: '<span style="color:{point.color}">â</span> <b>{series.name}</b><br/>Maximum: {point.high}<br/>Upper quartile: {point.q3}<br/>Median: {point.median}<br/>Lower quartile: {point.q1}<br/>Minimum: {point.low}<br/>'
	      },
	      whiskerLength: "50%",
	      fillColor: "#ffffff",
	      lineWidth: 1,
	      medianWidth: 2,
	      whiskerWidth: 2
	    };
	  }), i(e, "Series/BoxPlot/BoxPlotSeries.js", [e["Series/BoxPlot/BoxPlotSeriesDefaults.js"], e["Series/Column/ColumnSeries.js"], e["Core/Globals.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function (t, e, i, s, o) {
	    let {
	        noop: a
	      } = i,
	      {
	        extend: r,
	        merge: n,
	        pick: l
	      } = o;
	    class h extends e {
	      pointAttribs() {
	        return {};
	      }
	      translate() {
	        let t = this.yAxis,
	          e = this.pointArrayMap;
	        super.translate.apply(this), this.points.forEach(function (i) {
	          e.forEach(function (e) {
	            null !== i[e] && (i[e + "Plot"] = t.translate(i[e], 0, 1, 0, 1));
	          }), i.plotHigh = i.highPlot;
	        });
	      }
	      drawPoints() {
	        let t = this.points,
	          e = this.options,
	          i = this.chart,
	          s = i.renderer,
	          o = !1 !== this.doQuartiles,
	          a = this.options.whiskerLength,
	          r,
	          n,
	          h,
	          p,
	          d,
	          c,
	          u,
	          g = 0,
	          f,
	          b,
	          m,
	          y,
	          x,
	          P,
	          S;
	        for (let M of t) {
	          b = M.graphic;
	          let t = b ? "animate" : "attr",
	            L = M.shapeArgs,
	            k = {},
	            v = {},
	            C = {},
	            w = {},
	            A = M.color || this.color;
	          if (void 0 !== M.plotY) {
	            let N;
	            m = Math.round(L.width), x = (y = Math.floor(L.x)) + m, P = Math.round(m / 2), r = Math.floor(o ? M.q1Plot : M.lowPlot), n = Math.floor(o ? M.q3Plot : M.lowPlot), h = Math.floor(M.highPlot), p = Math.floor(M.lowPlot), b || (M.graphic = b = s.g("point").add(this.group), M.stem = s.path().addClass("highcharts-boxplot-stem").add(b), a && (M.whiskers = s.path().addClass("highcharts-boxplot-whisker").add(b)), o && (M.box = s.path(f).addClass("highcharts-boxplot-box").add(b)), M.medianShape = s.path(c).addClass("highcharts-boxplot-median").add(b)), i.styledMode || (v.stroke = M.stemColor || e.stemColor || A, v["stroke-width"] = l(M.stemWidth, e.stemWidth, e.lineWidth), v.dashstyle = M.stemDashStyle || e.stemDashStyle || e.dashStyle, M.stem.attr(v), a && (C.stroke = M.whiskerColor || e.whiskerColor || A, C["stroke-width"] = l(M.whiskerWidth, e.whiskerWidth, e.lineWidth), C.dashstyle = M.whiskerDashStyle || e.whiskerDashStyle || e.dashStyle, M.whiskers.attr(C)), o && (k.fill = M.fillColor || e.fillColor || A, k.stroke = e.lineColor || A, k["stroke-width"] = e.lineWidth || 0, k.dashstyle = M.boxDashStyle || e.boxDashStyle || e.dashStyle, M.box.attr(k)), w.stroke = M.medianColor || e.medianColor || A, w["stroke-width"] = l(M.medianWidth, e.medianWidth, e.lineWidth), w.dashstyle = M.medianDashStyle || e.medianDashStyle || e.dashStyle, M.medianShape.attr(w)), N = [["M", g = y + P + (u = M.stem.strokeWidth() % 2 / 2), n], ["L", g, h], ["M", g, r], ["L", g, p]], M.stem[t]({
	              d: N
	            }), o && (r = Math.floor(r) + (u = M.box.strokeWidth() % 2 / 2), n = Math.floor(n) + u, y += u, x += u, N = [["M", y, n], ["L", y, r], ["L", x, r], ["L", x, n], ["L", y, n], ["Z"]], M.box[t]({
	              d: N
	            })), a && (h += u = M.whiskers.strokeWidth() % 2 / 2, p += u, N = [["M", g - (S = /%$/.test(a) ? P * parseFloat(a) / 100 : a / 2), h], ["L", g + S, h], ["M", g - S, p], ["L", g + S, p]], M.whiskers[t]({
	              d: N
	            })), N = [["M", y, d = Math.round(M.medianPlot) + (u = M.medianShape.strokeWidth() % 2 / 2)], ["L", x, d]], M.medianShape[t]({
	              d: N
	            });
	          }
	        }
	      }
	      toYData(t) {
	        return [t.low, t.q1, t.median, t.q3, t.high];
	      }
	    }
	    return h.defaultOptions = n(e.defaultOptions, t), r(h.prototype, {
	      pointArrayMap: ["low", "q1", "median", "q3", "high"],
	      pointValKey: "high",
	      drawDataLabels: a,
	      setStackedPoints: a
	    }), s.registerSeriesType("boxplot", h), h;
	  }), i(e, "Series/Bubble/BubbleLegendDefaults.js", [], function () {
	    return {
	      borderColor: void 0,
	      borderWidth: 2,
	      className: void 0,
	      color: void 0,
	      connectorClassName: void 0,
	      connectorColor: void 0,
	      connectorDistance: 60,
	      connectorWidth: 1,
	      enabled: !1,
	      labels: {
	        className: void 0,
	        allowOverlap: !1,
	        format: "",
	        formatter: void 0,
	        align: "right",
	        style: {
	          fontSize: "0.9em",
	          color: "#000000"
	        },
	        x: 0,
	        y: 0
	      },
	      maxSize: 60,
	      minSize: 10,
	      legendIndex: 0,
	      ranges: {
	        value: void 0,
	        borderColor: void 0,
	        color: void 0,
	        connectorColor: void 0
	      },
	      sizeBy: "area",
	      sizeByAbsoluteValue: !1,
	      zIndex: 1,
	      zThreshold: 0
	    };
	  }), i(e, "Series/Bubble/BubbleLegendItem.js", [e["Core/Color/Color.js"], e["Core/Templating.js"], e["Core/Globals.js"], e["Core/Utilities.js"]], function (t, e, i, s) {
	    let {
	        parse: o
	      } = t,
	      {
	        noop: a
	      } = i,
	      {
	        arrayMax: r,
	        arrayMin: n,
	        isNumber: l,
	        merge: h,
	        pick: p,
	        stableSort: d
	      } = s;
	    return class {
	      constructor(t, e) {
	        this.setState = a, this.init(t, e);
	      }
	      init(t, e) {
	        this.options = t, this.visible = !0, this.chart = e.chart, this.legend = e;
	      }
	      addToLegend(t) {
	        t.splice(this.options.legendIndex, 0, this);
	      }
	      drawLegendSymbol(t) {
	        let e;
	        this.chart;
	        let i = p(t.options.itemDistance, 20),
	          s = this.legendItem || {},
	          o = this.options,
	          a = o.ranges,
	          r = o.connectorDistance;
	        if (!a || !a.length || !l(a[0].value)) {
	          t.options.bubbleLegend.autoRanges = !0;
	          return;
	        }
	        d(a, function (t, e) {
	          return e.value - t.value;
	        }), this.ranges = a, this.setOptions(), this.render();
	        let n = this.getMaxLabelSize(),
	          h = this.ranges[0].radius,
	          c = 2 * h;
	        e = (e = r - h + n.width) > 0 ? e : 0, this.maxLabel = n, this.movementX = "left" === o.labels.align ? e : 0, s.labelWidth = c + e + i, s.labelHeight = c + n.height / 2;
	      }
	      setOptions() {
	        let t = this.ranges,
	          e = this.options,
	          i = this.chart.series[e.seriesIndex],
	          s = this.legend.baseline,
	          a = {
	            zIndex: e.zIndex,
	            "stroke-width": e.borderWidth
	          },
	          r = {
	            zIndex: e.zIndex,
	            "stroke-width": e.connectorWidth
	          },
	          n = {
	            align: this.legend.options.rtl || "left" === e.labels.align ? "right" : "left",
	            zIndex: e.zIndex
	          },
	          l = i.options.marker.fillOpacity,
	          d = this.chart.styledMode;
	        t.forEach(function (c, u) {
	          d || (a.stroke = p(c.borderColor, e.borderColor, i.color), a.fill = p(c.color, e.color, 1 !== l ? o(i.color).setOpacity(l).get("rgba") : i.color), r.stroke = p(c.connectorColor, e.connectorColor, i.color)), t[u].radius = this.getRangeRadius(c.value), t[u] = h(t[u], {
	            center: t[0].radius - t[u].radius + s
	          }), d || h(!0, t[u], {
	            bubbleAttribs: h(a),
	            connectorAttribs: h(r),
	            labelAttribs: n
	          });
	        }, this);
	      }
	      getRangeRadius(t) {
	        let e = this.options,
	          i = this.options.seriesIndex,
	          s = this.chart.series[i],
	          o = e.ranges[0].value,
	          a = e.ranges[e.ranges.length - 1].value,
	          r = e.minSize,
	          n = e.maxSize;
	        return s.getRadius.call(this, a, o, r, n, t);
	      }
	      render() {
	        let t = this.legendItem || {},
	          e = this.chart.renderer,
	          i = this.options.zThreshold;
	        for (let s of (this.symbols || (this.symbols = {
	          connectors: [],
	          bubbleItems: [],
	          labels: []
	        }), t.symbol = e.g("bubble-legend"), t.label = e.g("bubble-legend-item").css(this.legend.itemStyle || {}), t.symbol.translateX = 0, t.symbol.translateY = 0, t.symbol.add(t.label), t.label.add(t.group), this.ranges)) s.value >= i && this.renderRange(s);
	        this.hideOverlappingLabels();
	      }
	      renderRange(t) {
	        let e = this.ranges[0],
	          i = this.legend,
	          s = this.options,
	          o = s.labels,
	          a = this.chart,
	          r = a.series[s.seriesIndex],
	          n = a.renderer,
	          l = this.symbols,
	          h = l.labels,
	          p = t.center,
	          d = Math.abs(t.radius),
	          c = s.connectorDistance || 0,
	          u = o.align,
	          g = i.options.rtl,
	          f = s.borderWidth,
	          b = s.connectorWidth,
	          m = e.radius || 0,
	          y = p - d - f / 2 + b / 2,
	          x = (y % 1 ? 1 : .5) - (b % 2 ? 0 : .5),
	          P = n.styledMode,
	          S = g || "left" === u ? -c : c;
	        "center" === u && (S = 0, s.connectorDistance = 0, t.labelAttribs.align = "center"), l.bubbleItems.push(n.circle(m, p + x, d).attr(P ? {} : t.bubbleAttribs).addClass((P ? "highcharts-color-" + r.colorIndex + " " : "") + "highcharts-bubble-legend-symbol " + (s.className || "")).add(this.legendItem.symbol)), l.connectors.push(n.path(n.crispLine([["M", m, y], ["L", m + S, y]], s.connectorWidth)).attr(P ? {} : t.connectorAttribs).addClass((P ? "highcharts-color-" + this.options.seriesIndex + " " : "") + "highcharts-bubble-legend-connectors " + (s.connectorClassName || "")).add(this.legendItem.symbol));
	        let M = n.text(this.formatLabel(t)).attr(P ? {} : t.labelAttribs).css(P ? {} : o.style).addClass("highcharts-bubble-legend-labels " + (s.labels.className || "")).add(this.legendItem.symbol),
	          L = {
	            x: m + S + s.labels.x,
	            y: y + s.labels.y + .4 * M.getBBox().height
	          };
	        M.attr(L), h.push(M), M.placed = !0, M.alignAttr = L;
	      }
	      getMaxLabelSize() {
	        let t, e;
	        let i = this.symbols.labels;
	        return i.forEach(function (i) {
	          e = i.getBBox(!0), t = t ? e.width > t.width ? e : t : e;
	        }), t || {};
	      }
	      formatLabel(t) {
	        let i = this.options,
	          s = i.labels.formatter,
	          o = i.labels.format,
	          {
	            numberFormatter: a
	          } = this.chart;
	        return o ? e.format(o, t) : s ? s.call(t) : a(t.value, 1);
	      }
	      hideOverlappingLabels() {
	        let t = this.chart,
	          e = this.options.labels.allowOverlap,
	          i = this.symbols;
	        !e && i && (t.hideOverlappingLabels(i.labels), i.labels.forEach(function (t, e) {
	          t.newOpacity ? t.newOpacity !== t.oldOpacity && i.connectors[e].show() : i.connectors[e].hide();
	        }));
	      }
	      getRanges() {
	        let t = this.legend.bubbleLegend,
	          e = t.chart.series,
	          i = t.options.ranges,
	          s,
	          o,
	          a = Number.MAX_VALUE,
	          d = -Number.MAX_VALUE;
	        return e.forEach(function (t) {
	          t.isBubble && !t.ignoreSeries && (o = t.zData.filter(l)).length && (a = p(t.options.zMin, Math.min(a, Math.max(n(o), !1 === t.options.displayNegative ? t.options.zThreshold : -Number.MAX_VALUE))), d = p(t.options.zMax, Math.max(d, r(o))));
	        }), s = a === d ? [{
	          value: d
	        }] : [{
	          value: a
	        }, {
	          value: (a + d) / 2
	        }, {
	          value: d,
	          autoRanges: !0
	        }], i.length && i[0].radius && s.reverse(), s.forEach(function (t, e) {
	          i && i[e] && (s[e] = h(i[e], t));
	        }), s;
	      }
	      predictBubbleSizes() {
	        let t = this.chart,
	          e = t.legend.options,
	          i = e.floating,
	          s = "horizontal" === e.layout,
	          o = s ? t.legend.lastLineHeight : 0,
	          a = t.plotSizeX,
	          r = t.plotSizeY,
	          n = t.series[this.options.seriesIndex],
	          l = n.getPxExtremes(),
	          h = Math.ceil(l.minPxSize),
	          p = Math.ceil(l.maxPxSize),
	          d,
	          c = n.options.maxSize;
	        return i || !/%$/.test(c) ? d = p : (d = (Math.min(r, a) + o) * (c = parseFloat(c)) / 100 / (c / 100 + 1), (s && r - d >= a || !s && a - d >= r) && (d = p)), [h, Math.ceil(d)];
	      }
	      updateRanges(t, e) {
	        let i = this.legend.options.bubbleLegend;
	        i.minSize = t, i.maxSize = e, i.ranges = this.getRanges();
	      }
	      correctSizes() {
	        let t = this.legend,
	          e = this.chart,
	          i = e.series[this.options.seriesIndex],
	          s = i.getPxExtremes(),
	          o = s.maxPxSize,
	          a = this.options.maxSize;
	        Math.abs(Math.ceil(o) - a) > 1 && (this.updateRanges(this.options.minSize, s.maxPxSize), t.render());
	      }
	    };
	  }), i(e, "Series/Bubble/BubbleLegendComposition.js", [e["Series/Bubble/BubbleLegendDefaults.js"], e["Series/Bubble/BubbleLegendItem.js"], e["Core/Defaults.js"], e["Core/Globals.js"], e["Core/Utilities.js"]], function (t, e, i, s, o) {
	    let {
	        setOptions: a
	      } = i,
	      {
	        composed: r
	      } = s,
	      {
	        addEvent: n,
	        objectEach: l,
	        pushUnique: h,
	        wrap: p
	      } = o;
	    function d(t, e, i) {
	      let s, o, a;
	      let r = this.legend,
	        n = c(this) >= 0;
	      r && r.options.enabled && r.bubbleLegend && r.options.bubbleLegend.autoRanges && n ? (s = r.bubbleLegend.options, o = r.bubbleLegend.predictBubbleSizes(), r.bubbleLegend.updateRanges(o[0], o[1]), s.placed || (r.group.placed = !1, r.allItems.forEach(t => {
	        (a = t.legendItem || {}).group && (a.group.translateY = void 0);
	      })), r.render(), this.getMargins(), this.axes.forEach(function (t) {
	        t.visible && t.render(), s.placed || (t.setScale(), t.updateNames(), l(t.ticks, function (t) {
	          t.isNew = !0, t.isNewLabel = !0;
	        }));
	      }), s.placed = !0, this.getMargins(), t.call(this, e, i), r.bubbleLegend.correctSizes(), b(r, u(r))) : (t.call(this, e, i), r && r.options.enabled && r.bubbleLegend && (r.render(), b(r, u(r))));
	    }
	    function c(t) {
	      let e = t.series,
	        i = 0;
	      for (; i < e.length;) {
	        if (e[i] && e[i].isBubble && e[i].visible && e[i].zData.length) return i;
	        i++;
	      }
	      return -1;
	    }
	    function u(t) {
	      let e = t.allItems,
	        i = [],
	        s = e.length,
	        o,
	        a,
	        r,
	        n = 0,
	        l = 0;
	      for (n = 0; n < s; n++) if (a = e[n].legendItem || {}, r = (e[n + 1] || {}).legendItem || {}, a.labelHeight && (e[n].itemHeight = a.labelHeight), e[n] === e[s - 1] || a.y !== r.y) {
	        for (i.push({
	          height: 0
	        }), o = i[i.length - 1]; l <= n; l++) e[l].itemHeight > o.height && (o.height = e[l].itemHeight);
	        o.step = n;
	      }
	      return i;
	    }
	    function g(t) {
	      let i = this.bubbleLegend,
	        s = this.options,
	        o = s.bubbleLegend,
	        a = c(this.chart);
	      i && i.ranges && i.ranges.length && (o.ranges.length && (o.autoRanges = !!o.ranges[0].autoRanges), this.destroyItem(i)), a >= 0 && s.enabled && o.enabled && (o.seriesIndex = a, this.bubbleLegend = new e(o, this), this.bubbleLegend.addToLegend(t.allItems));
	    }
	    function f(t) {
	      let e;
	      if (t.defaultPrevented) return !1;
	      let i = this.chart,
	        s = this.visible,
	        o = this.chart.legend;
	      o && o.bubbleLegend && (this.visible = !s, this.ignoreSeries = s, e = c(i) >= 0, o.bubbleLegend.visible !== e && (o.update({
	        bubbleLegend: {
	          enabled: e
	        }
	      }), o.bubbleLegend.visible = e), this.visible = s);
	    }
	    function b(t, e) {
	      let i = t.allItems,
	        s = t.options.rtl,
	        o,
	        a,
	        r,
	        n,
	        l = 0;
	      i.forEach((t, i) => {
	        (n = t.legendItem || {}).group && (o = n.group.translateX || 0, a = n.y || 0, ((r = t.movementX) || s && t.ranges) && (r = s ? o - t.options.maxSize / 2 : o + r, n.group.attr({
	          translateX: r
	        })), i > e[l].step && l++, n.group.attr({
	          translateY: Math.round(a + e[l].height / 2)
	        }), n.y = a + e[l].height / 2);
	      });
	    }
	    return {
	      compose: function e(i, s, o) {
	        h(r, e) && (a({
	          legend: {
	            bubbleLegend: t
	          }
	        }), p(i.prototype, "drawChartBox", d), n(s, "afterGetAllItems", g), n(o, "legendItemClick", f));
	      }
	    };
	  }), i(e, "Series/Bubble/BubblePoint.js", [e["Core/Series/Point.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function (t, e, i) {
	    let {
	        seriesTypes: {
	          scatter: {
	            prototype: {
	              pointClass: s
	            }
	          }
	        }
	      } = e,
	      {
	        extend: o
	      } = i;
	    class a extends s {
	      haloPath(e) {
	        return t.prototype.haloPath.call(this, 0 === e ? 0 : (this.marker && this.marker.radius || 0) + e);
	      }
	    }
	    return o(a.prototype, {
	      ttBelow: !1
	    }), a;
	  }), i(e, "Series/Bubble/BubbleSeries.js", [e["Series/Bubble/BubbleLegendComposition.js"], e["Series/Bubble/BubblePoint.js"], e["Core/Color/Color.js"], e["Core/Globals.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function (t, e, i, s, o, a) {
	    let {
	        parse: r
	      } = i,
	      {
	        composed: n,
	        noop: l
	      } = s,
	      {
	        series: h,
	        seriesTypes: {
	          column: {
	            prototype: p
	          },
	          scatter: d
	        }
	      } = o,
	      {
	        addEvent: c,
	        arrayMax: u,
	        arrayMin: g,
	        clamp: f,
	        extend: b,
	        isNumber: m,
	        merge: y,
	        pick: x,
	        pushUnique: P
	      } = a;
	    function S() {
	      let t = this.len,
	        {
	          coll: e,
	          isXAxis: i,
	          min: s
	        } = this,
	        o = i ? "xData" : "yData",
	        a = (this.max || 0) - (s || 0),
	        r = 0,
	        n = t,
	        l = t / a,
	        h;
	      ("xAxis" === e || "yAxis" === e) && (this.series.forEach(t => {
	        if (t.bubblePadding && t.reserveSpace()) {
	          this.allowZoomOutside = !0, h = !0;
	          let e = t[o];
	          if (i && ((t.onPoint || t).getRadii(0, 0, t), t.onPoint && (t.radii = t.onPoint.radii)), a > 0) {
	            let i = e.length;
	            for (; i--;) if (m(e[i]) && this.dataMin <= e[i] && e[i] <= this.max) {
	              let o = t.radii && t.radii[i] || 0;
	              r = Math.min((e[i] - s) * l - o, r), n = Math.max((e[i] - s) * l + o, n);
	            }
	          }
	        }
	      }), h && a > 0 && !this.logarithmic && (n -= t, l *= (t + Math.max(0, r) - Math.min(n, t)) / t, [["min", "userMin", r], ["max", "userMax", n]].forEach(t => {
	        void 0 === x(this.options[t[0]], this[t[1]]) && (this[t[0]] += t[2] / l);
	      })));
	    }
	    class M extends d {
	      static compose(e, i, s, o) {
	        t.compose(i, s, o), P(n, this.compose) && c(e, "foundExtremes", S);
	      }
	      animate(t) {
	        !t && this.points.length < this.options.animationLimit && this.points.forEach(function (t) {
	          let {
	            graphic: e
	          } = t;
	          e && e.width && (this.hasRendered || e.attr({
	            x: t.plotX,
	            y: t.plotY,
	            width: 1,
	            height: 1
	          }), e.animate(this.markerAttribs(t), this.options.animation));
	        }, this);
	      }
	      getRadii() {
	        let t = this.zData,
	          e = this.yData,
	          i = [],
	          s,
	          o,
	          a,
	          r = this.chart.bubbleZExtremes,
	          {
	            minPxSize: n,
	            maxPxSize: l
	          } = this.getPxExtremes();
	        if (!r) {
	          let t,
	            e = Number.MAX_VALUE,
	            i = -Number.MAX_VALUE;
	          this.chart.series.forEach(s => {
	            if (s.bubblePadding && s.reserveSpace()) {
	              let o = (s.onPoint || s).getZExtremes();
	              o && (e = Math.min(x(e, o.zMin), o.zMin), i = Math.max(x(i, o.zMax), o.zMax), t = !0);
	            }
	          }), t ? (r = {
	            zMin: e,
	            zMax: i
	          }, this.chart.bubbleZExtremes = r) : r = {
	            zMin: 0,
	            zMax: 0
	          };
	        }
	        for (o = 0, s = t.length; o < s; o++) a = t[o], i.push(this.getRadius(r.zMin, r.zMax, n, l, a, e && e[o]));
	        this.radii = i;
	      }
	      getRadius(t, e, i, s, o, a) {
	        let r = this.options,
	          n = "width" !== r.sizeBy,
	          l = r.zThreshold,
	          h = e - t,
	          p = .5;
	        if (null === a || null === o) return null;
	        if (m(o)) {
	          if (r.sizeByAbsoluteValue && (o = Math.abs(o - l), e = h = Math.max(e - l, Math.abs(t - l)), t = 0), o < t) return i / 2 - 1;
	          h > 0 && (p = (o - t) / h);
	        }
	        return n && p >= 0 && (p = Math.sqrt(p)), Math.ceil(i + p * (s - i)) / 2;
	      }
	      hasData() {
	        return !!this.processedXData.length;
	      }
	      pointAttribs(t, e) {
	        let i = this.options.marker,
	          s = i.fillOpacity,
	          o = h.prototype.pointAttribs.call(this, t, e);
	        return 1 !== s && (o.fill = r(o.fill).setOpacity(s).get("rgba")), o;
	      }
	      translate() {
	        super.translate.call(this), this.getRadii(), this.translateBubble();
	      }
	      translateBubble() {
	        let {
	            data: t,
	            options: e,
	            radii: i
	          } = this,
	          {
	            minPxSize: s
	          } = this.getPxExtremes(),
	          o = t.length;
	        for (; o--;) {
	          let a = t[o],
	            r = i ? i[o] : 0;
	          "z" === this.zoneAxis && (a.negative = (a.z || 0) < (e.zThreshold || 0)), m(r) && r >= s / 2 ? (a.marker = b(a.marker, {
	            radius: r,
	            width: 2 * r,
	            height: 2 * r
	          }), a.dlBox = {
	            x: a.plotX - r,
	            y: a.plotY - r,
	            width: 2 * r,
	            height: 2 * r
	          }) : (a.shapeArgs = a.plotY = a.dlBox = void 0, a.isInside = !1);
	        }
	      }
	      getPxExtremes() {
	        let t = Math.min(this.chart.plotWidth, this.chart.plotHeight),
	          e = e => {
	            let i;
	            return "string" == typeof e && (i = /%$/.test(e), e = parseInt(e, 10)), i ? t * e / 100 : e;
	          },
	          i = e(x(this.options.minSize, 8)),
	          s = Math.max(e(x(this.options.maxSize, "20%")), i);
	        return {
	          minPxSize: i,
	          maxPxSize: s
	        };
	      }
	      getZExtremes() {
	        let t = this.options,
	          e = (this.zData || []).filter(m);
	        if (e.length) {
	          let i = x(t.zMin, f(g(e), !1 === t.displayNegative ? t.zThreshold || 0 : -Number.MAX_VALUE, Number.MAX_VALUE)),
	            s = x(t.zMax, u(e));
	          if (m(i) && m(s)) return {
	            zMin: i,
	            zMax: s
	          };
	        }
	      }
	    }
	    return M.defaultOptions = y(d.defaultOptions, {
	      dataLabels: {
	        formatter: function () {
	          let {
	              numberFormatter: t
	            } = this.series.chart,
	            {
	              z: e
	            } = this.point;
	          return m(e) ? t(e, -1) : "";
	        },
	        inside: !0,
	        verticalAlign: "middle"
	      },
	      animationLimit: 250,
	      marker: {
	        lineColor: null,
	        lineWidth: 1,
	        fillOpacity: .5,
	        radius: null,
	        states: {
	          hover: {
	            radiusPlus: 0
	          }
	        },
	        symbol: "circle"
	      },
	      minSize: 8,
	      maxSize: "20%",
	      softThreshold: !1,
	      states: {
	        hover: {
	          halo: {
	            size: 5
	          }
	        }
	      },
	      tooltip: {
	        pointFormat: "({point.x}, {point.y}), Size: {point.z}"
	      },
	      turboThreshold: 0,
	      zThreshold: 0,
	      zoneAxis: "z"
	    }), b(M.prototype, {
	      alignDataLabel: p.alignDataLabel,
	      applyZones: l,
	      bubblePadding: !0,
	      isBubble: !0,
	      pointArrayMap: ["y", "z"],
	      pointClass: e,
	      parallelArrays: ["x", "y", "z"],
	      trackerGroups: ["group", "dataLabelsGroup"],
	      specialGroup: "group",
	      zoneAxis: "z"
	    }), c(M, "updatedData", t => {
	      delete t.target.chart.bubbleZExtremes;
	    }), c(M, "remove", t => {
	      delete t.target.chart.bubbleZExtremes;
	    }), o.registerSeriesType("bubble", M), M;
	  }), i(e, "Series/ColumnRange/ColumnRangePoint.js", [e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function (t, e) {
	    let {
	        seriesTypes: {
	          column: {
	            prototype: {
	              pointClass: {
	                prototype: i
	              }
	            }
	          },
	          arearange: {
	            prototype: {
	              pointClass: s
	            }
	          }
	        }
	      } = t,
	      {
	        extend: o,
	        isNumber: a
	      } = e;
	    class r extends s {
	      isValid() {
	        return a(this.low);
	      }
	    }
	    return o(r.prototype, {
	      setState: i.setState
	    }), r;
	  }), i(e, "Series/ColumnRange/ColumnRangeSeries.js", [e["Series/ColumnRange/ColumnRangePoint.js"], e["Core/Globals.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function (t, e, i, s) {
	    let {
	        noop: o
	      } = e,
	      {
	        seriesTypes: {
	          arearange: a,
	          column: r,
	          column: {
	            prototype: n
	          }
	        }
	      } = i,
	      {
	        addEvent: l,
	        clamp: h,
	        extend: p,
	        isNumber: d,
	        merge: c,
	        pick: u
	      } = s;
	    class g extends a {
	      setOptions() {
	        return c(!0, arguments[0], {
	          stacking: void 0
	        }), a.prototype.setOptions.apply(this, arguments);
	      }
	      translate() {
	        return n.translate.apply(this);
	      }
	      pointAttribs() {
	        return n.pointAttribs.apply(this, arguments);
	      }
	      translate3dPoints() {
	        return n.translate3dPoints.apply(this, arguments);
	      }
	      translate3dShapes() {
	        return n.translate3dShapes.apply(this, arguments);
	      }
	      afterColumnTranslate() {
	        let t, e, i, s;
	        let o = this.yAxis,
	          a = this.xAxis,
	          r = a.startAngleRad,
	          n = this.chart,
	          l = this.xAxis.isRadial,
	          p = Math.max(n.chartWidth, n.chartHeight) + 999;
	        this.points.forEach(g => {
	          let f = g.shapeArgs || {},
	            b = this.options.minPointLength,
	            m = g.plotY,
	            y = o.translate(g.high, 0, 1, 0, 1);
	          if (d(y) && d(m)) {
	            if (g.plotHigh = h(y, -p, p), g.plotLow = h(m, -p, p), s = g.plotHigh, Math.abs(t = u(g.rectPlotY, g.plotY) - g.plotHigh) < b ? (e = b - t, t += e, s -= e / 2) : t < 0 && (t *= -1, s -= t), l && this.polar) i = g.barX + r, g.shapeType = "arc", g.shapeArgs = this.polar.arc(s + t, s, i, i + g.pointWidth);else {
	              f.height = t, f.y = s;
	              let {
	                x: e = 0,
	                width: i = 0
	              } = f;
	              g.shapeArgs = c(g.shapeArgs, this.crispCol(e, s, i, t)), g.tooltipPos = n.inverted ? [o.len + o.pos - n.plotLeft - s - t / 2, a.len + a.pos - n.plotTop - e - i / 2, t] : [a.left - n.plotLeft + e + i / 2, o.pos - n.plotTop + s + t / 2, t];
	            }
	          }
	        });
	      }
	    }
	    return g.defaultOptions = c(r.defaultOptions, a.defaultOptions, {
	      borderRadius: {
	        where: "all"
	      },
	      pointRange: null,
	      marker: null,
	      states: {
	        hover: {
	          halo: !1
	        }
	      }
	    }), l(g, "afterColumnTranslate", function () {
	      g.prototype.afterColumnTranslate.apply(this);
	    }, {
	      order: 5
	    }), p(g.prototype, {
	      directTouch: !0,
	      pointClass: t,
	      trackerGroups: ["group", "dataLabelsGroup"],
	      adjustForMissingColumns: n.adjustForMissingColumns,
	      animate: n.animate,
	      crispCol: n.crispCol,
	      drawGraph: o,
	      drawPoints: n.drawPoints,
	      getSymbol: o,
	      drawTracker: n.drawTracker,
	      getColumnMetrics: n.getColumnMetrics
	    }), i.registerSeriesType("columnrange", g), g;
	  }), i(e, "Series/ColumnPyramid/ColumnPyramidSeriesDefaults.js", [], function () {
	    return {};
	  }), i(e, "Series/ColumnPyramid/ColumnPyramidSeries.js", [e["Series/ColumnPyramid/ColumnPyramidSeriesDefaults.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function (t, e, i) {
	    let {
	        column: s
	      } = e.seriesTypes,
	      {
	        clamp: o,
	        merge: a,
	        pick: r
	      } = i;
	    class n extends s {
	      translate() {
	        let t = this.chart,
	          e = this.options,
	          i = this.dense = this.closestPointRange * this.xAxis.transA < 2,
	          s = this.borderWidth = r(e.borderWidth, i ? 0 : 1),
	          a = this.yAxis,
	          n = e.threshold,
	          l = r(e.minPointLength, 5),
	          h = this.getColumnMetrics(),
	          p = h.width,
	          d = this.pointXOffset = h.offset,
	          c = this.translatedThreshold = a.getThreshold(n),
	          u = this.barW = Math.max(p, 1 + 2 * s);
	        for (let i of (t.inverted && (c -= .5), e.pointPadding && (u = Math.ceil(u)), super.translate(), this.points)) {
	          let s = r(i.yBottom, c),
	            g = 999 + Math.abs(s),
	            f = o(i.plotY, -g, a.len + g),
	            b = u / 2,
	            m = Math.min(f, s),
	            y = Math.max(f, s) - m,
	            x = i.plotX + d,
	            P,
	            S,
	            M,
	            L,
	            k,
	            v,
	            C,
	            w,
	            A,
	            N,
	            T,
	            X;
	          e.centerInCategory && (x = this.adjustForMissingColumns(x, p, i, h)), i.barX = x, i.pointWidth = p, i.tooltipPos = t.inverted ? [a.len + a.pos - t.plotLeft - f, this.xAxis.len - x - b, y] : [x + b, f + a.pos - t.plotTop, y], P = n + (i.total || i.y), "percent" === e.stacking && (P = n + (i.y < 0) ? -100 : 100), M = a.toPixels(P, !0), L = (S = t.plotHeight - M - (t.plotHeight - c)) ? b * (m - M) / S : 0, k = S ? b * (m + y - M) / S : 0, C = x - L + b, w = x + L + b, A = x + k + b, N = x - k + b, T = m - l, X = m + y, i.y < 0 && (T = m, X = m + y + l), t.inverted && (v = a.width - m, S = M - (a.width - c), L = b * (M - v) / S, k = b * (M - (v - y)) / S, w = (C = x + b + L) - 2 * L, A = x - k + b, N = x + k + b, T = m, X = m + y - l, i.y < 0 && (X = m + y + l)), i.shapeType = "path", i.shapeArgs = {
	            x: C,
	            y: T,
	            width: w - C,
	            height: y,
	            d: [["M", C, T], ["L", w, T], ["L", A, X], ["L", N, X], ["Z"]]
	          };
	        }
	      }
	    }
	    return n.defaultOptions = a(s.defaultOptions, t), e.registerSeriesType("columnpyramid", n), n;
	  }), i(e, "Series/ErrorBar/ErrorBarSeriesDefaults.js", [], function () {
	    return {
	      color: "#000000",
	      grouping: !1,
	      linkedTo: ":previous",
	      tooltip: {
	        pointFormat: '<span style="color:{point.color}">â</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'
	      },
	      whiskerWidth: null
	    };
	  }), i(e, "Series/ErrorBar/ErrorBarSeries.js", [e["Series/BoxPlot/BoxPlotSeries.js"], e["Series/Column/ColumnSeries.js"], e["Series/ErrorBar/ErrorBarSeriesDefaults.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function (t, e, i, s, o) {
	    let {
	        arearange: a
	      } = s.seriesTypes,
	      {
	        addEvent: r,
	        merge: n,
	        extend: l
	      } = o;
	    class h extends t {
	      getColumnMetrics() {
	        return this.linkedParent && this.linkedParent.columnMetrics || e.prototype.getColumnMetrics.call(this);
	      }
	      drawDataLabels() {
	        let t = this.pointValKey;
	        if (a) for (let e of (a.prototype.drawDataLabels.call(this), this.points)) e.y = e[t];
	      }
	      toYData(t) {
	        return [t.low, t.high];
	      }
	    }
	    return h.defaultOptions = n(t.defaultOptions, i), r(h, "afterTranslate", function () {
	      for (let t of this.points) t.plotLow = t.plotY;
	    }, {
	      order: 0
	    }), l(h.prototype, {
	      pointArrayMap: ["low", "high"],
	      pointValKey: "high",
	      doQuartiles: !1
	    }), s.registerSeriesType("errorbar", h), h;
	  }), i(e, "Series/Gauge/GaugePoint.js", [e["Core/Series/SeriesRegistry.js"]], function (t) {
	    let {
	      series: {
	        prototype: {
	          pointClass: e
	        }
	      }
	    } = t;
	    return class extends e {
	      setState(t) {
	        this.state = t;
	      }
	    };
	  }), i(e, "Series/Gauge/GaugeSeries.js", [e["Series/Gauge/GaugePoint.js"], e["Core/Globals.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function (t, e, i, s) {
	    let {
	        noop: o
	      } = e,
	      {
	        series: a,
	        seriesTypes: {
	          column: r
	        }
	      } = i,
	      {
	        clamp: n,
	        isNumber: l,
	        extend: h,
	        merge: p,
	        pick: d,
	        pInt: c,
	        defined: u
	      } = s;
	    class g extends a {
	      translate() {
	        let t = this.yAxis,
	          e = this.options,
	          i = t.center;
	        this.generatePoints(), this.points.forEach(s => {
	          let o = p(e.dial, s.dial),
	            a = c(o.radius) * i[2] / 200,
	            r = c(o.baseLength) * a / 100,
	            h = c(o.rearLength) * a / 100,
	            d = o.baseWidth,
	            g = o.topWidth,
	            f = e.overshoot,
	            b = t.startAngleRad + t.translate(s.y, void 0, void 0, void 0, !0);
	          (l(f) || !1 === e.wrap) && (f = l(f) ? f / 180 * Math.PI : 0, b = n(b, t.startAngleRad - f, t.endAngleRad + f)), b = 180 * b / Math.PI, s.shapeType = "path";
	          let m = o.path || [["M", -h, -d / 2], ["L", r, -d / 2], ["L", a, -g / 2], ["L", a, g / 2], ["L", r, d / 2], ["L", -h, d / 2], ["Z"]];
	          s.shapeArgs = {
	            d: m,
	            translateX: i[0],
	            translateY: i[1],
	            rotation: b
	          }, s.plotX = i[0], s.plotY = i[1], u(s.y) && t.max - t.min && (s.percentage = (s.y - t.min) / (t.max - t.min) * 100);
	        });
	      }
	      drawPoints() {
	        let t = this,
	          e = t.chart,
	          i = t.yAxis.center,
	          s = t.pivot,
	          o = t.options,
	          a = o.pivot,
	          r = e.renderer;
	        t.points.forEach(i => {
	          let s = i.graphic,
	            a = i.shapeArgs,
	            n = a.d,
	            l = p(o.dial, i.dial);
	          s ? (s.animate(a), a.d = n) : i.graphic = r[i.shapeType](a).addClass("highcharts-dial").add(t.group), e.styledMode || i.graphic[s ? "animate" : "attr"]({
	            stroke: l.borderColor,
	            "stroke-width": l.borderWidth,
	            fill: l.backgroundColor
	          });
	        }), s ? s.animate({
	          translateX: i[0],
	          translateY: i[1]
	        }) : a && (t.pivot = r.circle(0, 0, a.radius).attr({
	          zIndex: 2
	        }).addClass("highcharts-pivot").translate(i[0], i[1]).add(t.group), e.styledMode || t.pivot.attr({
	          fill: a.backgroundColor,
	          stroke: a.borderColor,
	          "stroke-width": a.borderWidth
	        }));
	      }
	      animate(t) {
	        let e = this;
	        t || e.points.forEach(t => {
	          let i = t.graphic;
	          i && (i.attr({
	            rotation: 180 * e.yAxis.startAngleRad / Math.PI
	          }), i.animate({
	            rotation: t.shapeArgs.rotation
	          }, e.options.animation));
	        });
	      }
	      render() {
	        this.group = this.plotGroup("group", "series", this.visible ? "inherit" : "hidden", this.options.zIndex, this.chart.seriesGroup), a.prototype.render.call(this), this.group.clip(this.chart.clipRect);
	      }
	      setData(t, e) {
	        a.prototype.setData.call(this, t, !1), this.processData(), this.generatePoints(), d(e, !0) && this.chart.redraw();
	      }
	      hasData() {
	        return !!this.points.length;
	      }
	    }
	    return g.defaultOptions = p(a.defaultOptions, {
	      dataLabels: {
	        borderColor: "#cccccc",
	        borderRadius: 3,
	        borderWidth: 1,
	        crop: !1,
	        defer: !1,
	        enabled: !0,
	        verticalAlign: "top",
	        y: 15,
	        zIndex: 2
	      },
	      dial: {
	        backgroundColor: "#000000",
	        baseLength: "70%",
	        baseWidth: 3,
	        borderColor: "#cccccc",
	        borderWidth: 0,
	        radius: "80%",
	        rearLength: "10%",
	        topWidth: 1
	      },
	      pivot: {
	        radius: 5,
	        borderWidth: 0,
	        borderColor: "#cccccc",
	        backgroundColor: "#000000"
	      },
	      tooltip: {
	        headerFormat: ""
	      },
	      showInLegend: !1
	    }), h(g.prototype, {
	      angular: !0,
	      directTouch: !0,
	      drawGraph: o,
	      drawTracker: r.prototype.drawTracker,
	      fixedBox: !0,
	      forceDL: !0,
	      noSharedTooltip: !0,
	      pointClass: t,
	      trackerGroups: ["group", "dataLabelsGroup"]
	    }), i.registerSeriesType("gauge", g), g;
	  }), i(e, "Series/DragNodesComposition.js", [e["Core/Globals.js"], e["Core/Utilities.js"]], function (t, e) {
	    let {
	        composed: i
	      } = t,
	      {
	        addEvent: s,
	        pushUnique: o
	      } = e;
	    function a() {
	      let t, e, i;
	      let o = this;
	      o.container && (t = s(o.container, "mousedown", t => {
	        let a = o.hoverPoint;
	        a && a.series && a.series.hasDraggableNodes && a.series.options.draggable && (a.series.onMouseDown(a, t), e = s(o.container, "mousemove", t => a && a.series && a.series.onMouseMove(a, t)), i = s(o.container.ownerDocument, "mouseup", t => (e(), i(), a && a.series && a.series.onMouseUp(a, t))));
	      })), s(o, "destroy", function () {
	        t();
	      });
	    }
	    return {
	      compose: function t(e) {
	        o(i, t) && s(e, "load", a);
	      },
	      onMouseDown: function (t, e) {
	        let i = this.chart.pointer.normalize(e);
	        t.fixedPosition = {
	          chartX: i.chartX,
	          chartY: i.chartY,
	          plotX: t.plotX,
	          plotY: t.plotY
	        }, t.inDragMode = !0;
	      },
	      onMouseMove: function (t, e) {
	        if (t.fixedPosition && t.inDragMode) {
	          let i, s;
	          let o = this.chart,
	            a = o.pointer.normalize(e),
	            r = t.fixedPosition.chartX - a.chartX,
	            n = t.fixedPosition.chartY - a.chartY,
	            l = o.graphLayoutsLookup;
	          (Math.abs(r) > 5 || Math.abs(n) > 5) && (i = t.fixedPosition.plotX - r, s = t.fixedPosition.plotY - n, o.isInsidePlot(i, s) && (t.plotX = i, t.plotY = s, t.hasDragged = !0, this.redrawHalo(t), l.forEach(t => {
	            t.restartSimulation();
	          })));
	        }
	      },
	      onMouseUp: function (t, e) {
	        t.fixedPosition && (t.hasDragged && (this.layout.enableSimulation ? this.layout.start() : this.chart.redraw()), t.inDragMode = t.hasDragged = !1, this.options.fixedDraggable || delete t.fixedPosition);
	      },
	      redrawHalo: function (t) {
	        t && this.halo && this.halo.attr({
	          d: t.haloPath(this.options.states.hover.halo.size)
	        });
	      }
	    };
	  }), i(e, "Series/GraphLayoutComposition.js", [e["Core/Animation/AnimationUtilities.js"], e["Core/Globals.js"], e["Core/Utilities.js"]], function (t, e, i) {
	    let {
	        setAnimation: s
	      } = t,
	      {
	        composed: o
	      } = e,
	      {
	        addEvent: a,
	        pushUnique: r
	      } = i;
	    function n() {
	      this.graphLayoutsLookup && (this.graphLayoutsLookup.forEach(t => {
	        t.updateSimulation();
	      }), this.redraw());
	    }
	    function l() {
	      this.graphLayoutsLookup && (this.graphLayoutsLookup.forEach(t => {
	        t.updateSimulation(!1);
	      }), this.redraw());
	    }
	    function h() {
	      this.graphLayoutsLookup && this.graphLayoutsLookup.forEach(t => {
	        t.stop();
	      });
	    }
	    function p() {
	      let t,
	        e = !1,
	        i = i => {
	          i.maxIterations-- && isFinite(i.temperature) && !i.isStable() && !i.enableSimulation && (i.beforeStep && i.beforeStep(), i.step(), t = !1, e = !0);
	        };
	      if (this.graphLayoutsLookup) {
	        for (s(!1, this), this.graphLayoutsLookup.forEach(t => t.start()); !t;) t = !0, this.graphLayoutsLookup.forEach(i);
	        e && this.series.forEach(t => {
	          t && t.layout && t.render();
	        });
	      }
	    }
	    return {
	      compose: function t(e) {
	        r(o, t) && (a(e, "afterPrint", n), a(e, "beforePrint", l), a(e, "predraw", h), a(e, "render", p));
	      },
	      integrations: {},
	      layouts: {}
	    };
	  }), i(e, "Series/PackedBubble/PackedBubblePoint.js", [e["Core/Chart/Chart.js"], e["Core/Series/Point.js"], e["Core/Series/SeriesRegistry.js"]], function (t, e, i) {
	    let {
	      seriesTypes: {
	        bubble: {
	          prototype: {
	            pointClass: s
	          }
	        }
	      }
	    } = i;
	    return class extends s {
	      destroy() {
	        return this.series.layout && this.series.layout.removeElementFromCollection(this, this.series.layout.nodes), e.prototype.destroy.apply(this, arguments);
	      }
	      firePointEvent() {
	        let t = this.series,
	          i = t.options;
	        if (this.isParentNode && i.parentNode) {
	          let t = i.allowPointSelect;
	          i.allowPointSelect = i.parentNode.allowPointSelect, e.prototype.firePointEvent.apply(this, arguments), i.allowPointSelect = t;
	        } else e.prototype.firePointEvent.apply(this, arguments);
	      }
	      select() {
	        let i = this.series,
	          s = i.chart;
	        this.isParentNode ? (s.getSelectedPoints = s.getSelectedParentNodes, e.prototype.select.apply(this, arguments), s.getSelectedPoints = t.prototype.getSelectedPoints) : e.prototype.select.apply(this, arguments);
	      }
	    };
	  }), i(e, "Series/PackedBubble/PackedBubbleSeriesDefaults.js", [e["Core/Utilities.js"]], function (t) {
	    let {
	      isNumber: e
	    } = t;
	    return {
	      minSize: "10%",
	      maxSize: "50%",
	      sizeBy: "area",
	      zoneAxis: "y",
	      crisp: !1,
	      tooltip: {
	        pointFormat: "Value: {point.value}"
	      },
	      draggable: !0,
	      useSimulation: !0,
	      parentNode: {
	        allowPointSelect: !1
	      },
	      dataLabels: {
	        formatter: function () {
	          let {
	              numberFormatter: t
	            } = this.series.chart,
	            {
	              value: i
	            } = this.point;
	          return e(i) ? t(i, -1) : "";
	        },
	        parentNodeFormatter: function () {
	          return this.name;
	        },
	        parentNodeTextPath: {
	          enabled: !0
	        },
	        padding: 0,
	        style: {
	          transition: "opacity 2000ms"
	        }
	      },
	      layoutAlgorithm: {
	        initialPositions: "circle",
	        initialPositionRadius: 20,
	        bubblePadding: 5,
	        parentNodeLimit: !1,
	        seriesInteraction: !0,
	        dragBetweenSeries: !1,
	        parentNodeOptions: {
	          maxIterations: 400,
	          gravitationalConstant: .03,
	          maxSpeed: 50,
	          initialPositionRadius: 100,
	          seriesInteraction: !0,
	          marker: {
	            fillColor: null,
	            fillOpacity: 1,
	            lineWidth: null,
	            lineColor: null,
	            symbol: "circle"
	          }
	        },
	        enableSimulation: !0,
	        type: "packedbubble",
	        integration: "packedbubble",
	        maxIterations: 1e3,
	        splitSeries: !1,
	        maxSpeed: 5,
	        gravitationalConstant: .01,
	        friction: -.981
	      }
	    };
	  }), i(e, "Series/Networkgraph/VerletIntegration.js", [], function () {
	    return {
	      attractive: function (t, e, i) {
	        let s = t.getMass(),
	          o = -i.x * e * this.diffTemperature,
	          a = -i.y * e * this.diffTemperature;
	        t.fromNode.fixedPosition || (t.fromNode.plotX -= o * s.fromNode / t.fromNode.degree, t.fromNode.plotY -= a * s.fromNode / t.fromNode.degree), t.toNode.fixedPosition || (t.toNode.plotX += o * s.toNode / t.toNode.degree, t.toNode.plotY += a * s.toNode / t.toNode.degree);
	      },
	      attractiveForceFunction: function (t, e) {
	        return (e - t) / t;
	      },
	      barycenter: function () {
	        let t = this.options.gravitationalConstant,
	          e = this.barycenter.xFactor,
	          i = this.barycenter.yFactor;
	        e = (e - (this.box.left + this.box.width) / 2) * t, i = (i - (this.box.top + this.box.height) / 2) * t, this.nodes.forEach(function (t) {
	          t.fixedPosition || (t.plotX -= e / t.mass / t.degree, t.plotY -= i / t.mass / t.degree);
	        });
	      },
	      getK: function (t) {
	        return Math.pow(t.box.width * t.box.height / t.nodes.length, .5);
	      },
	      integrate: function (t, e) {
	        let i = -t.options.friction,
	          s = t.options.maxSpeed,
	          o = e.prevX,
	          a = e.prevY,
	          r = (e.plotX + e.dispX - o) * i,
	          n = (e.plotY + e.dispY - a) * i,
	          l = Math.abs,
	          h = l(r) / (r || 1),
	          p = l(n) / (n || 1);
	        r = h * Math.min(s, Math.abs(r)), n = p * Math.min(s, Math.abs(n)), e.prevX = e.plotX + e.dispX, e.prevY = e.plotY + e.dispY, e.plotX += r, e.plotY += n, e.temperature = t.vectorLength({
	          x: r,
	          y: n
	        });
	      },
	      repulsive: function (t, e, i) {
	        let s = e * this.diffTemperature / t.mass / t.degree;
	        t.fixedPosition || (t.plotX += i.x * s, t.plotY += i.y * s);
	      },
	      repulsiveForceFunction: function (t, e) {
	        return (e - t) / t * (e > t ? 1 : 0);
	      }
	    };
	  }), i(e, "Series/PackedBubble/PackedBubbleIntegration.js", [e["Core/Globals.js"], e["Series/Networkgraph/VerletIntegration.js"]], function (t, e) {
	    let {
	        noop: i
	      } = t,
	      s = {
	        barycenter: function () {
	          let t, e;
	          let i = this.options.gravitationalConstant,
	            s = this.box,
	            o = this.nodes;
	          for (let a of o) this.options.splitSeries && !a.isParentNode ? (t = a.series.parentNode.plotX, e = a.series.parentNode.plotY) : (t = s.width / 2, e = s.height / 2), a.fixedPosition || (a.plotX -= (a.plotX - t) * i / (a.mass * Math.sqrt(o.length)), a.plotY -= (a.plotY - e) * i / (a.mass * Math.sqrt(o.length)));
	        },
	        getK: i,
	        integrate: e.integrate,
	        repulsive: function (t, e, i, s) {
	          let o = e * this.diffTemperature / t.mass / t.degree,
	            a = i.x * o,
	            r = i.y * o;
	          t.fixedPosition || (t.plotX += a, t.plotY += r), s.fixedPosition || (s.plotX -= a, s.plotY -= r);
	        },
	        repulsiveForceFunction: function (t, e, i, s) {
	          return Math.min(t, (i.marker.radius + s.marker.radius) / 2);
	        }
	      };
	    return s;
	  }), i(e, "Series/Networkgraph/EulerIntegration.js", [], function () {
	    return {
	      attractive: function (t, e, i, s) {
	        let o = t.getMass(),
	          a = i.x / s * e,
	          r = i.y / s * e;
	        t.fromNode.fixedPosition || (t.fromNode.dispX -= a * o.fromNode / t.fromNode.degree, t.fromNode.dispY -= r * o.fromNode / t.fromNode.degree), t.toNode.fixedPosition || (t.toNode.dispX += a * o.toNode / t.toNode.degree, t.toNode.dispY += r * o.toNode / t.toNode.degree);
	      },
	      attractiveForceFunction: function (t, e) {
	        return t * t / e;
	      },
	      barycenter: function () {
	        let t = this.options.gravitationalConstant,
	          e = this.barycenter.xFactor,
	          i = this.barycenter.yFactor;
	        this.nodes.forEach(function (s) {
	          if (!s.fixedPosition) {
	            let o = s.getDegree(),
	              a = o * (1 + o / 2);
	            s.dispX += (e - s.plotX) * t * a / s.degree, s.dispY += (i - s.plotY) * t * a / s.degree;
	          }
	        });
	      },
	      getK: function (t) {
	        return Math.pow(t.box.width * t.box.height / t.nodes.length, .3);
	      },
	      integrate: function (t, e) {
	        let i;
	        e.dispX += e.dispX * t.options.friction, e.dispY += e.dispY * t.options.friction, 0 !== (i = e.temperature = t.vectorLength({
	          x: e.dispX,
	          y: e.dispY
	        })) && (e.plotX += e.dispX / i * Math.min(Math.abs(e.dispX), t.temperature), e.plotY += e.dispY / i * Math.min(Math.abs(e.dispY), t.temperature));
	      },
	      repulsive: function (t, e, i, s) {
	        t.dispX += i.x / s * e / t.degree, t.dispY += i.y / s * e / t.degree;
	      },
	      repulsiveForceFunction: function (t, e) {
	        return e * e / t;
	      }
	    };
	  }), i(e, "Series/Networkgraph/QuadTreeNode.js", [], function () {
	    class t {
	      constructor(t) {
	        this.body = !1, this.isEmpty = !1, this.isInternal = !1, this.nodes = [], this.box = t, this.boxSize = Math.min(t.width, t.height);
	      }
	      divideBox() {
	        let e = this.box.width / 2,
	          i = this.box.height / 2;
	        this.nodes[0] = new t({
	          left: this.box.left,
	          top: this.box.top,
	          width: e,
	          height: i
	        }), this.nodes[1] = new t({
	          left: this.box.left + e,
	          top: this.box.top,
	          width: e,
	          height: i
	        }), this.nodes[2] = new t({
	          left: this.box.left + e,
	          top: this.box.top + i,
	          width: e,
	          height: i
	        }), this.nodes[3] = new t({
	          left: this.box.left,
	          top: this.box.top + i,
	          width: e,
	          height: i
	        });
	      }
	      getBoxPosition(t) {
	        let e = t.plotX < this.box.left + this.box.width / 2,
	          i = t.plotY < this.box.top + this.box.height / 2;
	        return e ? i ? 0 : 3 : i ? 1 : 2;
	      }
	      insert(e, i) {
	        let s;
	        this.isInternal ? this.nodes[this.getBoxPosition(e)].insert(e, i - 1) : (this.isEmpty = !1, this.body ? i ? (this.isInternal = !0, this.divideBox(), !0 !== this.body && (this.nodes[this.getBoxPosition(this.body)].insert(this.body, i - 1), this.body = !0), this.nodes[this.getBoxPosition(e)].insert(e, i - 1)) : ((s = new t({
	          top: e.plotX || NaN,
	          left: e.plotY || NaN,
	          width: .1,
	          height: .1
	        })).body = e, s.isInternal = !1, this.nodes.push(s)) : (this.isInternal = !1, this.body = e));
	      }
	      updateMassAndCenter() {
	        let t = 0,
	          e = 0,
	          i = 0;
	        if (this.isInternal) {
	          for (let s of this.nodes) s.isEmpty || (t += s.mass, e += s.plotX * s.mass, i += s.plotY * s.mass);
	          e /= t, i /= t;
	        } else this.body && (t = this.body.mass, e = this.body.plotX, i = this.body.plotY);
	        this.mass = t, this.plotX = e, this.plotY = i;
	      }
	    }
	    return t;
	  }), i(e, "Series/Networkgraph/QuadTree.js", [e["Series/Networkgraph/QuadTreeNode.js"]], function (t) {
	    return class {
	      constructor(e, i, s, o) {
	        this.box = {
	          left: e,
	          top: i,
	          width: s,
	          height: o
	        }, this.maxDepth = 25, this.root = new t(this.box), this.root.isInternal = !0, this.root.isRoot = !0, this.root.divideBox();
	      }
	      calculateMassAndCenter() {
	        this.visitNodeRecursive(null, null, function (t) {
	          t.updateMassAndCenter();
	        });
	      }
	      insertNodes(t) {
	        for (let e of t) this.root.insert(e, this.maxDepth);
	      }
	      visitNodeRecursive(t, e, i) {
	        let s;
	        if (t || (t = this.root), t === this.root && e && (s = e(t)), !1 !== s) {
	          for (let o of t.nodes) {
	            if (o.isInternal) {
	              if (e && (s = e(o)), !1 === s) continue;
	              this.visitNodeRecursive(o, e, i);
	            } else o.body && e && e(o.body);
	            i && i(o);
	          }
	          t === this.root && i && i(t);
	        }
	      }
	    };
	  }), i(e, "Series/Networkgraph/ReingoldFruchtermanLayout.js", [e["Series/Networkgraph/EulerIntegration.js"], e["Core/Globals.js"], e["Series/GraphLayoutComposition.js"], e["Series/Networkgraph/QuadTree.js"], e["Core/Utilities.js"], e["Series/Networkgraph/VerletIntegration.js"]], function (t, e, i, s, o, a) {
	    let {
	        win: r
	      } = e,
	      {
	        clamp: n,
	        defined: l,
	        isFunction: h,
	        fireEvent: p,
	        pick: d
	      } = o;
	    class c {
	      constructor() {
	        this.box = {}, this.currentStep = 0, this.initialRendering = !0, this.links = [], this.nodes = [], this.series = [], this.simulation = !1;
	      }
	      static compose(e) {
	        i.compose(e), i.integrations.euler = t, i.integrations.verlet = a, i.layouts["reingold-fruchterman"] = c;
	      }
	      init(t) {
	        this.options = t, this.nodes = [], this.links = [], this.series = [], this.box = {
	          x: 0,
	          y: 0,
	          width: 0,
	          height: 0
	        }, this.setInitialRendering(!0), this.integration = i.integrations[t.integration], this.enableSimulation = t.enableSimulation, this.attractiveForce = d(t.attractiveForce, this.integration.attractiveForceFunction), this.repulsiveForce = d(t.repulsiveForce, this.integration.repulsiveForceFunction), this.approximation = t.approximation;
	      }
	      updateSimulation(t) {
	        this.enableSimulation = d(t, this.options.enableSimulation);
	      }
	      start() {
	        let t = this.series,
	          e = this.options;
	        this.currentStep = 0, this.forces = t[0] && t[0].forces || [], this.chart = t[0] && t[0].chart, this.initialRendering && (this.initPositions(), t.forEach(function (t) {
	          t.finishedAnimating = !0, t.render();
	        })), this.setK(), this.resetSimulation(e), this.enableSimulation && this.step();
	      }
	      step() {
	        let t = this.series;
	        for (let t of (this.currentStep++, "barnes-hut" === this.approximation && (this.createQuadTree(), this.quadTree.calculateMassAndCenter()), this.forces || [])) this[t + "Forces"](this.temperature);
	        if (this.applyLimits(), this.temperature = this.coolDown(this.startTemperature, this.diffTemperature, this.currentStep), this.prevSystemTemperature = this.systemTemperature, this.systemTemperature = this.getSystemTemperature(), this.enableSimulation) {
	          for (let e of t) e.chart && e.render();
	          this.maxIterations-- && isFinite(this.temperature) && !this.isStable() ? (this.simulation && r.cancelAnimationFrame(this.simulation), this.simulation = r.requestAnimationFrame(() => this.step())) : (this.simulation = !1, this.series.forEach(t => {
	            p(t, "afterSimulation");
	          }));
	        }
	      }
	      stop() {
	        this.simulation && r.cancelAnimationFrame(this.simulation);
	      }
	      setArea(t, e, i, s) {
	        this.box = {
	          left: t,
	          top: e,
	          width: i,
	          height: s
	        };
	      }
	      setK() {
	        this.k = this.options.linkLength || this.integration.getK(this);
	      }
	      addElementsToCollection(t, e) {
	        for (let i of t) -1 === e.indexOf(i) && e.push(i);
	      }
	      removeElementFromCollection(t, e) {
	        let i = e.indexOf(t);
	        -1 !== i && e.splice(i, 1);
	      }
	      clear() {
	        this.nodes.length = 0, this.links.length = 0, this.series.length = 0, this.resetSimulation();
	      }
	      resetSimulation() {
	        this.forcedStop = !1, this.systemTemperature = 0, this.setMaxIterations(), this.setTemperature(), this.setDiffTemperature();
	      }
	      restartSimulation() {
	        this.simulation ? this.resetSimulation() : (this.setInitialRendering(!1), this.enableSimulation ? this.start() : this.setMaxIterations(1), this.chart && this.chart.redraw(), this.setInitialRendering(!0));
	      }
	      setMaxIterations(t) {
	        this.maxIterations = d(t, this.options.maxIterations);
	      }
	      setTemperature() {
	        this.temperature = this.startTemperature = Math.sqrt(this.nodes.length);
	      }
	      setDiffTemperature() {
	        this.diffTemperature = this.startTemperature / (this.options.maxIterations + 1);
	      }
	      setInitialRendering(t) {
	        this.initialRendering = t;
	      }
	      createQuadTree() {
	        this.quadTree = new s(this.box.left, this.box.top, this.box.width, this.box.height), this.quadTree.insertNodes(this.nodes);
	      }
	      initPositions() {
	        let t = this.options.initialPositions;
	        if (h(t)) for (let e of (t.call(this), this.nodes)) l(e.prevX) || (e.prevX = e.plotX), l(e.prevY) || (e.prevY = e.plotY), e.dispX = 0, e.dispY = 0;else "circle" === t ? this.setCircularPositions() : this.setRandomPositions();
	      }
	      setCircularPositions() {
	        let t;
	        let e = this.box,
	          i = this.nodes,
	          s = i.length + 1,
	          o = 2 * Math.PI / s,
	          a = i.filter(function (t) {
	            return 0 === t.linksTo.length;
	          }),
	          r = {},
	          n = this.options.initialPositionRadius,
	          l = t => {
	            for (let e of t.linksFrom || []) r[e.toNode.id] || (r[e.toNode.id] = !0, h.push(e.toNode), l(e.toNode));
	          },
	          h = [];
	        for (let t of a) h.push(t), l(t);
	        if (h.length) for (let t of i) -1 === h.indexOf(t) && h.push(t);else h = i;
	        for (let i = 0, s = h.length; i < s; ++i) (t = h[i]).plotX = t.prevX = d(t.plotX, e.width / 2 + n * Math.cos(i * o)), t.plotY = t.prevY = d(t.plotY, e.height / 2 + n * Math.sin(i * o)), t.dispX = 0, t.dispY = 0;
	      }
	      setRandomPositions() {
	        let t;
	        let e = this.box,
	          i = this.nodes,
	          s = i.length + 1,
	          o = t => {
	            let e = t * t / Math.PI;
	            return e - Math.floor(e);
	          };
	        for (let a = 0, r = i.length; a < r; ++a) (t = i[a]).plotX = t.prevX = d(t.plotX, e.width * o(a)), t.plotY = t.prevY = d(t.plotY, e.height * o(s + a)), t.dispX = 0, t.dispY = 0;
	      }
	      force(t, ...e) {
	        this.integration[t].apply(this, e);
	      }
	      barycenterForces() {
	        this.getBarycenter(), this.force("barycenter");
	      }
	      getBarycenter() {
	        let t = 0,
	          e = 0,
	          i = 0;
	        for (let s of this.nodes) e += s.plotX * s.mass, i += s.plotY * s.mass, t += s.mass;
	        return this.barycenter = {
	          x: e,
	          y: i,
	          xFactor: e / t,
	          yFactor: i / t
	        }, this.barycenter;
	      }
	      barnesHutApproximation(t, e) {
	        let i, s;
	        let o = this.getDistXY(t, e),
	          a = this.vectorLength(o);
	        return t !== e && 0 !== a && (e.isInternal ? e.boxSize / a < this.options.theta && 0 !== a ? (s = this.repulsiveForce(a, this.k), this.force("repulsive", t, s * e.mass, o, a), i = !1) : i = !0 : (s = this.repulsiveForce(a, this.k), this.force("repulsive", t, s * e.mass, o, a))), i;
	      }
	      repulsiveForces() {
	        if ("barnes-hut" === this.approximation) for (let t of this.nodes) this.quadTree.visitNodeRecursive(null, e => this.barnesHutApproximation(t, e));else {
	          let t, e, i;
	          for (let s of this.nodes) for (let o of this.nodes) s === o || s.fixedPosition || (i = this.getDistXY(s, o), 0 !== (e = this.vectorLength(i)) && (t = this.repulsiveForce(e, this.k), this.force("repulsive", s, t * o.mass, i, e)));
	        }
	      }
	      attractiveForces() {
	        let t, e, i;
	        for (let s of this.links) s.fromNode && s.toNode && (t = this.getDistXY(s.fromNode, s.toNode), 0 !== (e = this.vectorLength(t)) && (i = this.attractiveForce(e, this.k), this.force("attractive", s, i, t, e)));
	      }
	      applyLimits() {
	        let t = this.nodes;
	        for (let e of t) {
	          if (e.fixedPosition) return;
	          this.integration.integrate(this, e), this.applyLimitBox(e, this.box), e.dispX = 0, e.dispY = 0;
	        }
	      }
	      applyLimitBox(t, e) {
	        let i = t.radius;
	        t.plotX = n(t.plotX, e.left + i, e.width - i), t.plotY = n(t.plotY, e.top + i, e.height - i);
	      }
	      coolDown(t, e, i) {
	        return t - e * i;
	      }
	      isStable() {
	        return 1e-5 > Math.abs(this.systemTemperature - this.prevSystemTemperature) || this.temperature <= 0;
	      }
	      getSystemTemperature() {
	        let t = 0;
	        for (let e of this.nodes) t += e.temperature;
	        return t;
	      }
	      vectorLength(t) {
	        return Math.sqrt(t.x * t.x + t.y * t.y);
	      }
	      getDistR(t, e) {
	        let i = this.getDistXY(t, e);
	        return this.vectorLength(i);
	      }
	      getDistXY(t, e) {
	        let i = t.plotX - e.plotX,
	          s = t.plotY - e.plotY;
	        return {
	          x: i,
	          y: s,
	          absX: Math.abs(i),
	          absY: Math.abs(s)
	        };
	      }
	    }
	    return c;
	  }), i(e, "Series/PackedBubble/PackedBubbleLayout.js", [e["Series/GraphLayoutComposition.js"], e["Core/Globals.js"], e["Series/PackedBubble/PackedBubbleIntegration.js"], e["Series/Networkgraph/ReingoldFruchtermanLayout.js"], e["Core/Utilities.js"]], function (t, e, i, s, o) {
	    let {
	        composed: a
	      } = e,
	      {
	        addEvent: r,
	        pick: n,
	        pushUnique: l
	      } = o;
	    function h() {
	      let t = this.series,
	        e = [];
	      return t.forEach(t => {
	        t.parentNode && t.parentNode.selected && e.push(t.parentNode);
	      }), e;
	    }
	    function p() {
	      this.allDataPoints && delete this.allDataPoints;
	    }
	    class d extends s {
	      constructor() {
	        super(...arguments), this.index = NaN, this.nodes = [], this.series = [];
	      }
	      static compose(e) {
	        if (s.compose(e), t.integrations.packedbubble = i, t.layouts.packedbubble = d, l(a, this.compose)) {
	          r(e, "beforeRedraw", p);
	          let t = e.prototype;
	          t.getSelectedParentNodes = h;
	        }
	      }
	      beforeStep() {
	        this.options.marker && this.series.forEach(t => {
	          t && t.calculateParentRadius();
	        });
	      }
	      isStable() {
	        let t = Math.abs(this.prevSystemTemperature - this.systemTemperature),
	          e = 10 * this.systemTemperature / Math.sqrt(this.nodes.length);
	        return 1 > Math.abs(e) && t < 1e-5 || this.temperature <= 0;
	      }
	      setCircularPositions() {
	        let t = this.box,
	          e = this.nodes,
	          i = e.length + 1,
	          s = 2 * Math.PI / i,
	          o = this.options.initialPositionRadius,
	          a,
	          r,
	          l = 0;
	        for (let i of e) this.options.splitSeries && !i.isParentNode ? (a = i.series.parentNode.plotX, r = i.series.parentNode.plotY) : (a = t.width / 2, r = t.height / 2), i.plotX = i.prevX = n(i.plotX, a + o * Math.cos(i.index || l * s)), i.plotY = i.prevY = n(i.plotY, r + o * Math.sin(i.index || l * s)), i.dispX = 0, i.dispY = 0, l++;
	      }
	      repulsiveForces() {
	        let t, e, i;
	        let s = this,
	          o = s.options.bubblePadding;
	        s.nodes.forEach(a => {
	          a.degree = a.mass, a.neighbours = 0, s.nodes.forEach(r => {
	            t = 0, a !== r && !a.fixedPosition && (s.options.seriesInteraction || a.series === r.series) && (i = s.getDistXY(a, r), (e = s.vectorLength(i) - (a.marker.radius + r.marker.radius + o)) < 0 && (a.degree += .01, a.neighbours++, t = s.repulsiveForce(-e / Math.sqrt(a.neighbours), s.k, a, r)), s.force("repulsive", a, t * r.mass, i, r, e));
	          });
	        });
	      }
	      applyLimitBox(t, e) {
	        let i, s;
	        this.options.splitSeries && !t.isParentNode && this.options.parentNodeLimit && (i = this.getDistXY(t, t.series.parentNode), (s = t.series.parentNodeRadius - t.marker.radius - this.vectorLength(i)) < 0 && s > -2 * t.marker.radius && (t.plotX -= .01 * i.x, t.plotY -= .01 * i.y)), super.applyLimitBox(t, e);
	      }
	    }
	    return t.layouts.packedbubble = d, d;
	  }), i(e, "Series/SimulationSeriesUtilities.js", [e["Core/Utilities.js"], e["Core/Animation/AnimationUtilities.js"]], function (t, e) {
	    let {
	        merge: i,
	        syncTimeout: s
	      } = t,
	      {
	        animObject: o
	      } = e;
	    return {
	      initDataLabels: function () {
	        let t = this.options.dataLabels;
	        if (!this.dataLabelsGroup) {
	          let e = this.initDataLabelsGroup();
	          return !this.chart.styledMode && t?.style && e.css(t.style), e.attr({
	            opacity: 0
	          }), this.visible && e.show(), e;
	        }
	        return this.dataLabelsGroup.attr(i({
	          opacity: 1
	        }, this.getPlotBox("data-labels"))), this.dataLabelsGroup;
	      },
	      initDataLabelsDefer: function () {
	        let t = this.options.dataLabels;
	        t?.defer && this.options.layoutAlgorithm?.enableSimulation ? s(() => {
	          this.deferDataLabels = !1;
	        }, t ? o(t.animation).defer : 0) : this.deferDataLabels = !1;
	      }
	    };
	  }), i(e, "Series/PackedBubble/PackedBubbleSeries.js", [e["Core/Color/Color.js"], e["Series/DragNodesComposition.js"], e["Series/GraphLayoutComposition.js"], e["Core/Globals.js"], e["Series/PackedBubble/PackedBubblePoint.js"], e["Series/PackedBubble/PackedBubbleSeriesDefaults.js"], e["Series/PackedBubble/PackedBubbleLayout.js"], e["Core/Series/SeriesRegistry.js"], e["Series/SimulationSeriesUtilities.js"], e["Core/Utilities.js"]], function (t, e, i, s, o, a, r, n, l, h) {
	    let {
	        parse: p
	      } = t,
	      {
	        noop: d
	      } = s,
	      {
	        series: {
	          prototype: c
	        },
	        seriesTypes: {
	          bubble: u
	        }
	      } = n,
	      {
	        initDataLabels: g,
	        initDataLabelsDefer: f
	      } = l,
	      {
	        addEvent: b,
	        clamp: m,
	        defined: y,
	        extend: x,
	        fireEvent: P,
	        isArray: S,
	        isNumber: M,
	        merge: L,
	        pick: k
	      } = h;
	    class v extends u {
	      constructor() {
	        super(...arguments), this.parentNodeMass = 0, this.deferDataLabels = !0;
	      }
	      static compose(t, i, s, o) {
	        u.compose(t, i, s, o), e.compose(i), r.compose(i);
	      }
	      accumulateAllPoints() {
	        let t;
	        let e = this.chart,
	          i = [];
	        for (let s of e.series) if (s.is("packedbubble") && s.reserveSpace()) {
	          t = s.yData || [];
	          for (let e = 0; e < t.length; e++) i.push([null, null, t[e], s.index, e, {
	            id: e,
	            marker: {
	              radius: 0
	            }
	          }]);
	        }
	        return i;
	      }
	      addLayout() {
	        let t = this.options.layoutAlgorithm = this.options.layoutAlgorithm || {},
	          e = t.type || "packedbubble",
	          s = this.chart.options.chart,
	          o = this.chart.graphLayoutsStorage,
	          a = this.chart.graphLayoutsLookup,
	          r;
	        o || (this.chart.graphLayoutsStorage = o = {}, this.chart.graphLayoutsLookup = a = []), (r = o[e]) || (t.enableSimulation = y(s.forExport) ? !s.forExport : t.enableSimulation, o[e] = r = new i.layouts[e](), r.init(t), a.splice(r.index, 0, r)), this.layout = r, this.points.forEach(t => {
	          t.mass = 2, t.degree = 1, t.collisionNmb = 1;
	        }), r.setArea(0, 0, this.chart.plotWidth, this.chart.plotHeight), r.addElementsToCollection([this], r.series), r.addElementsToCollection(this.points, r.nodes);
	      }
	      addSeriesLayout() {
	        let t = this.options.layoutAlgorithm = this.options.layoutAlgorithm || {},
	          e = t.type || "packedbubble",
	          s = this.chart.graphLayoutsStorage,
	          o = this.chart.graphLayoutsLookup,
	          a = L(t, t.parentNodeOptions, {
	            enableSimulation: this.layout.options.enableSimulation
	          }),
	          r = s[e + "-series"];
	        r || (s[e + "-series"] = r = new i.layouts[e](), r.init(a), o.splice(r.index, 0, r)), this.parentNodeLayout = r, this.createParentNodes();
	      }
	      calculateParentRadius() {
	        let t = this.seriesBox();
	        this.parentNodeRadius = m(Math.sqrt(2 * this.parentNodeMass / Math.PI) + 20, 20, t ? Math.max(Math.sqrt(Math.pow(t.width, 2) + Math.pow(t.height, 2)) / 2 + 20, 20) : Math.sqrt(2 * this.parentNodeMass / Math.PI) + 20), this.parentNode && (this.parentNode.marker.radius = this.parentNode.radius = this.parentNodeRadius);
	      }
	      calculateZExtremes() {
	        let t = this.chart,
	          e = t.series,
	          i = this.options.zMin,
	          s = this.options.zMax,
	          o = 1 / 0,
	          a = -1 / 0;
	        return i && s ? [i, s] : (e.forEach(t => {
	          t.yData.forEach(t => {
	            y(t) && (t > a && (a = t), t < o && (o = t));
	          });
	        }), [i = k(i, o), s = k(s, a)]);
	      }
	      checkOverlap(t, e) {
	        let i = t[0] - e[0],
	          s = t[1] - e[1],
	          o = t[2] + e[2];
	        return Math.sqrt(i * i + s * s) - Math.abs(o) < -.001;
	      }
	      createParentNodes() {
	        let t = this.pointClass,
	          e = this.chart,
	          i = this.parentNodeLayout,
	          s = this.layout.options,
	          o,
	          a = this.parentNode,
	          r = {
	            radius: this.parentNodeRadius,
	            lineColor: this.color,
	            fillColor: p(this.color).brighten(.4).get()
	          };
	        s.parentNodeOptions && (r = L(s.parentNodeOptions.marker || {}, r)), this.parentNodeMass = 0, this.points.forEach(t => {
	          this.parentNodeMass += Math.PI * Math.pow(t.marker.radius, 2);
	        }), this.calculateParentRadius(), i.nodes.forEach(t => {
	          t.seriesIndex === this.index && (o = !0);
	        }), i.setArea(0, 0, e.plotWidth, e.plotHeight), o || (a || (a = new t(this, {
	          mass: this.parentNodeRadius / 2,
	          marker: r,
	          dataLabels: {
	            inside: !1
	          },
	          states: {
	            normal: {
	              marker: r
	            },
	            hover: {
	              marker: r
	            }
	          },
	          dataLabelOnNull: !0,
	          degree: this.parentNodeRadius,
	          isParentNode: !0,
	          seriesIndex: this.index
	        })), this.parentNode && (a.plotX = this.parentNode.plotX, a.plotY = this.parentNode.plotY), this.parentNode = a, i.addElementsToCollection([this], i.series), i.addElementsToCollection([a], i.nodes));
	      }
	      deferLayout() {
	        let t = this.options.layoutAlgorithm;
	        this.visible && (this.addLayout(), t.splitSeries && this.addSeriesLayout());
	      }
	      destroy() {
	        this.chart.graphLayoutsLookup && this.chart.graphLayoutsLookup.forEach(t => {
	          t.removeElementFromCollection(this, t.series);
	        }, this), this.parentNode && this.parentNodeLayout && (this.parentNodeLayout.removeElementFromCollection(this.parentNode, this.parentNodeLayout.nodes), this.parentNode.dataLabel && (this.parentNode.dataLabel = this.parentNode.dataLabel.destroy())), c.destroy.apply(this, arguments);
	      }
	      drawDataLabels() {
	        !this.deferDataLabels && (c.drawDataLabels.call(this, this.points), this.parentNode && (this.parentNode.formatPrefix = "parentNode", c.drawDataLabels.call(this, [this.parentNode])));
	      }
	      drawGraph() {
	        if (!this.layout || !this.layout.options.splitSeries) return;
	        let t = this.chart,
	          e = this.layout.options.parentNodeOptions.marker,
	          i = {
	            fill: e.fillColor || p(this.color).brighten(.4).get(),
	            opacity: e.fillOpacity,
	            stroke: e.lineColor || this.color,
	            "stroke-width": k(e.lineWidth, this.options.lineWidth)
	          },
	          s = {};
	        this.parentNodesGroup = this.plotGroup("parentNodesGroup", "parentNode", this.visible ? "inherit" : "hidden", .1, t.seriesGroup), this.group?.attr({
	          zIndex: 2
	        }), this.calculateParentRadius(), this.parentNode && y(this.parentNode.plotX) && y(this.parentNode.plotY) && y(this.parentNodeRadius) && (s = L({
	          x: this.parentNode.plotX - this.parentNodeRadius,
	          y: this.parentNode.plotY - this.parentNodeRadius,
	          width: 2 * this.parentNodeRadius,
	          height: 2 * this.parentNodeRadius
	        }, i), this.parentNode.graphic || (this.graph = this.parentNode.graphic = t.renderer.symbol(i.symbol).add(this.parentNodesGroup)), this.parentNode.graphic.attr(s));
	      }
	      drawTracker() {
	        let t;
	        let e = this.parentNode;
	        super.drawTracker(), e && (t = S(e.dataLabels) ? e.dataLabels : e.dataLabel ? [e.dataLabel] : [], e.graphic && (e.graphic.element.point = e), t.forEach(t => {
	          t.div ? t.div.point = e : t.element.point = e;
	        }));
	      }
	      getPointRadius() {
	        let t, e, i, s;
	        let o = this.chart,
	          a = o.plotWidth,
	          r = o.plotHeight,
	          n = this.options,
	          l = n.useSimulation,
	          h = Math.min(a, r),
	          p = {},
	          d = [],
	          c = o.allDataPoints || [],
	          u = c.length;
	        ["minSize", "maxSize"].forEach(t => {
	          let e = parseInt(n[t], 10),
	            i = /%$/.test(n[t]);
	          p[t] = i ? h * e / 100 : e * Math.sqrt(u);
	        }), o.minRadius = t = p.minSize / Math.sqrt(u), o.maxRadius = e = p.maxSize / Math.sqrt(u);
	        let g = l ? this.calculateZExtremes() : [t, e];
	        c.forEach((o, a) => {
	          i = l ? m(o[2], g[0], g[1]) : o[2], 0 === (s = this.getRadius(g[0], g[1], t, e, i)) && (s = null), c[a][2] = s, d.push(s);
	        }), this.radii = d;
	      }
	      init() {
	        return c.init.apply(this, arguments), f.call(this), this.eventsToUnbind.push(b(this, "updatedData", function () {
	          this.chart.series.forEach(t => {
	            t.type === this.type && (t.isDirty = !0);
	          }, this);
	        })), this;
	      }
	      onMouseUp(t) {
	        if (t.fixedPosition && !t.removed) {
	          let i;
	          let s = this.layout,
	            o = this.parentNodeLayout;
	          o && s.options.dragBetweenSeries && o.nodes.forEach(e => {
	            t && t.marker && e !== t.series.parentNode && (i = s.getDistXY(t, e), s.vectorLength(i) - e.marker.radius - t.marker.radius < 0 && (e.series.addPoint(L(t.options, {
	              plotX: t.plotX,
	              plotY: t.plotY
	            }), !1), s.removeElementFromCollection(t, s.nodes), t.remove()));
	          }), e.onMouseUp.apply(this, arguments);
	        }
	      }
	      placeBubbles(t) {
	        let e = this.checkOverlap,
	          i = this.positionBubble,
	          s = [],
	          o = 1,
	          a = 0,
	          r = 0,
	          n,
	          l = [],
	          h,
	          p = t.sort((t, e) => e[2] - t[2]);
	        if (p.length) {
	          if (s.push([[0, 0, p[0][2], p[0][3], p[0][4]]]), p.length > 1) for (s.push([[0, 0 - p[1][2] - p[0][2], p[1][2], p[1][3], p[1][4]]]), h = 2; h < p.length; h++) p[h][2] = p[h][2] || 1, e(n = i(s[o][a], s[o - 1][r], p[h]), s[o][0]) ? (s.push([]), r = 0, s[o + 1].push(i(s[o][a], s[o][0], p[h])), o++, a = 0) : o > 1 && s[o - 1][r + 1] && e(n, s[o - 1][r + 1]) ? (r++, s[o].push(i(s[o][a], s[o - 1][r], p[h])), a++) : (a++, s[o].push(n));
	          this.chart.stages = s, this.chart.rawPositions = [].concat.apply([], s), this.resizeRadius(), l = this.chart.rawPositions;
	        }
	        return l;
	      }
	      pointAttribs(t, e) {
	        let i = this.options,
	          s = t && t.isParentNode,
	          o = i.marker;
	        s && i.layoutAlgorithm && i.layoutAlgorithm.parentNodeOptions && (o = i.layoutAlgorithm.parentNodeOptions.marker);
	        let a = o.fillOpacity,
	          r = c.pointAttribs.call(this, t, e);
	        return 1 !== a && (r["fill-opacity"] = a), r;
	      }
	      positionBubble(t, e, i) {
	        let s = Math.pow,
	          o = (0, Math.sqrt)(s(t[0] - e[0], 2) + s(t[1] - e[1], 2)),
	          a = (0, Math.acos)((s(o, 2) + s(i[2] + e[2], 2) - s(i[2] + t[2], 2)) / (2 * (i[2] + e[2]) * o)),
	          r = (0, Math.asin)((0, Math.abs)(t[0] - e[0]) / o),
	          n = t[1] - e[1] < 0 ? 0 : Math.PI,
	          l = (t[0] - e[0]) * (t[1] - e[1]) < 0 ? 1 : -1,
	          h = n + a + r * l,
	          p = e[0] + (e[2] + i[2]) * Math.sin(h),
	          d = e[1] - (e[2] + i[2]) * Math.cos(h);
	        return [p, d, i[2], i[3], i[4]];
	      }
	      render() {
	        let t = [];
	        c.render.apply(this, arguments), !this.options.dataLabels.allowOverlap && (this.data.forEach(e => {
	          S(e.dataLabels) && e.dataLabels.forEach(e => {
	            t.push(e);
	          });
	        }), this.options.useSimulation && this.chart.hideOverlappingLabels(t));
	      }
	      resizeRadius() {
	        let t, e, i, s, o;
	        let a = this.chart,
	          r = a.rawPositions,
	          n = Math.min,
	          l = Math.max,
	          h = a.plotLeft,
	          p = a.plotTop,
	          d = a.plotHeight,
	          c = a.plotWidth;
	        for (let a of (t = i = Number.POSITIVE_INFINITY, e = s = Number.NEGATIVE_INFINITY, r)) o = a[2], t = n(t, a[0] - o), e = l(e, a[0] + o), i = n(i, a[1] - o), s = l(s, a[1] + o);
	        let u = [e - t, s - i],
	          g = [(c - h) / u[0], (d - p) / u[1]],
	          f = n.apply([], g);
	        if (Math.abs(f - 1) > 1e-10) {
	          for (let t of r) t[2] *= f;
	          this.placeBubbles(r);
	        } else a.diffY = d / 2 + p - i - (s - i) / 2, a.diffX = c / 2 + h - t - (e - t) / 2;
	      }
	      seriesBox() {
	        let t;
	        let e = this.chart,
	          i = this.data,
	          s = Math.max,
	          o = Math.min,
	          a = [e.plotLeft, e.plotLeft + e.plotWidth, e.plotTop, e.plotTop + e.plotHeight];
	        return i.forEach(e => {
	          y(e.plotX) && y(e.plotY) && e.marker.radius && (t = e.marker.radius, a[0] = o(a[0], e.plotX - t), a[1] = s(a[1], e.plotX + t), a[2] = o(a[2], e.plotY - t), a[3] = s(a[3], e.plotY + t));
	        }), M(a.width / a.height) ? a : null;
	      }
	      setVisible() {
	        let t = this;
	        c.setVisible.apply(t, arguments), t.parentNodeLayout && t.graph ? t.visible ? (t.graph.show(), t.parentNode.dataLabel && t.parentNode.dataLabel.show()) : (t.graph.hide(), t.parentNodeLayout.removeElementFromCollection(t.parentNode, t.parentNodeLayout.nodes), t.parentNode.dataLabel && t.parentNode.dataLabel.hide()) : t.layout && (t.visible ? t.layout.addElementsToCollection(t.points, t.layout.nodes) : t.points.forEach(e => {
	          t.layout.removeElementFromCollection(e, t.layout.nodes);
	        }));
	      }
	      translate() {
	        let t, e, i;
	        let s = this.chart,
	          o = this.data,
	          a = this.index,
	          r = this.options.useSimulation;
	        for (let n of (this.processedXData = this.xData, this.generatePoints(), y(s.allDataPoints) || (s.allDataPoints = this.accumulateAllPoints(), this.getPointRadius()), r ? i = s.allDataPoints : (i = this.placeBubbles(s.allDataPoints), this.options.draggable = !1), i)) n[3] === a && (t = o[n[4]], e = k(n[2], void 0), r || (t.plotX = n[0] - s.plotLeft + s.diffX, t.plotY = n[1] - s.plotTop + s.diffY), M(e) && (t.marker = x(t.marker, {
	          radius: e,
	          width: 2 * e,
	          height: 2 * e
	        }), t.radius = e));
	        r && this.deferLayout(), P(this, "afterTranslate");
	      }
	    }
	    return v.defaultOptions = L(u.defaultOptions, a), x(v.prototype, {
	      pointClass: o,
	      axisTypes: [],
	      directTouch: !0,
	      forces: ["barycenter", "repulsive"],
	      hasDraggableNodes: !0,
	      isCartesian: !1,
	      noSharedTooltip: !0,
	      pointArrayMap: ["value"],
	      pointValKey: "value",
	      requireSorting: !1,
	      trackerGroups: ["group", "dataLabelsGroup", "parentNodesGroup"],
	      initDataLabels: g,
	      alignDataLabel: c.alignDataLabel,
	      indexateNodes: d,
	      onMouseDown: e.onMouseDown,
	      onMouseMove: e.onMouseMove,
	      redrawHalo: e.redrawHalo,
	      searchPoint: d
	    }), n.registerSeriesType("packedbubble", v), v;
	  }), i(e, "Series/Polygon/PolygonSeriesDefaults.js", [], function () {
	    return {
	      marker: {
	        enabled: !1,
	        states: {
	          hover: {
	            enabled: !1
	          }
	        }
	      },
	      stickyTracking: !1,
	      tooltip: {
	        followPointer: !0,
	        pointFormat: ""
	      },
	      trackByArea: !0,
	      legendSymbol: "rectangle"
	    };
	  }), i(e, "Series/Polygon/PolygonSeries.js", [e["Core/Globals.js"], e["Series/Polygon/PolygonSeriesDefaults.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function (t, e, i, s) {
	    let {
	        noop: o
	      } = t,
	      {
	        area: a,
	        line: r,
	        scatter: n
	      } = i.seriesTypes,
	      {
	        extend: l,
	        merge: h
	      } = s;
	    class p extends n {
	      getGraphPath() {
	        let t = r.prototype.getGraphPath.call(this),
	          e = t.length + 1;
	        for (; e--;) (e === t.length || "M" === t[e][0]) && e > 0 && t.splice(e, 0, ["Z"]);
	        return this.areaPath = t, t;
	      }
	      drawGraph() {
	        this.options.fillColor = this.color, a.prototype.drawGraph.call(this);
	      }
	    }
	    return p.defaultOptions = h(n.defaultOptions, e), l(p.prototype, {
	      type: "polygon",
	      drawTracker: r.prototype.drawTracker,
	      setStackedPoints: o
	    }), i.registerSeriesType("polygon", p), p;
	  }), i(e, "Core/Axis/RadialAxis.js", [e["Core/Defaults.js"], e["Core/Globals.js"], e["Core/Utilities.js"]], function (t, e, i) {
	    var s;
	    let {
	        defaultOptions: o
	      } = t,
	      {
	        composed: a,
	        noop: r
	      } = e,
	      {
	        addEvent: n,
	        correctFloat: l,
	        defined: h,
	        extend: p,
	        fireEvent: d,
	        isObject: c,
	        merge: u,
	        pick: g,
	        pushUnique: f,
	        relativeLength: b,
	        wrap: m
	      } = i;
	    return function (t) {
	      let e = {
	          gridLineWidth: 1,
	          labels: {
	            align: void 0,
	            x: 0,
	            y: void 0,
	            style: {
	              textOverflow: "none"
	            }
	          },
	          maxPadding: 0,
	          minPadding: 0,
	          showLastLabel: !1,
	          tickLength: 0
	        },
	        i = {
	          endOnTick: !1,
	          gridLineWidth: 0,
	          labels: {
	            align: "center",
	            distance: -25,
	            x: 0,
	            y: void 0
	          },
	          lineWidth: 1,
	          minorGridLineWidth: 0,
	          minorTickInterval: "auto",
	          minorTickLength: 10,
	          minorTickPosition: "inside",
	          minorTickWidth: 1,
	          startOnTick: !1,
	          tickLength: 10,
	          tickPixelInterval: 100,
	          tickPosition: "inside",
	          tickWidth: 2,
	          title: {
	            rotation: 0,
	            text: ""
	          },
	          zIndex: 2
	        },
	        s = {
	          gridLineInterpolation: "circle",
	          gridLineWidth: 1,
	          labels: {
	            align: "right",
	            x: -3,
	            y: -2
	          },
	          showLastLabel: !1,
	          title: {
	            x: 4,
	            text: null,
	            rotation: 90
	          }
	        };
	      function y() {
	        this.autoConnect = this.isCircular && void 0 === g(this.userMax, this.options.max) && l(this.endAngleRad - this.startAngleRad) === l(2 * Math.PI), !this.isCircular && this.chart.inverted && this.max++, this.autoConnect && (this.max += this.categories && 1 || this.pointRange || this.closestPointRange || 0);
	      }
	      function x() {
	        return () => {
	          if (this.isRadial && this.tickPositions && this.options.labels && !0 !== this.options.labels.allowOverlap) return this.tickPositions.map(t => this.ticks[t] && this.ticks[t].label).filter(t => !!t);
	        };
	      }
	      function P() {
	        return r;
	      }
	      function S(t, e, i) {
	        let s = this.pane.center,
	          o = t.value,
	          a,
	          r,
	          n;
	        return this.isCircular ? (h(o) ? t.point && (t.point.shapeArgs || {}).start && (o = this.chart.inverted ? this.translate(t.point.rectPlotY, !0) : t.point.x) : (r = t.chartX || 0, n = t.chartY || 0, o = this.translate(Math.atan2(n - i, r - e) - this.startAngleRad, !0)), r = (a = this.getPosition(o)).x, n = a.y) : (h(o) || (r = t.chartX, n = t.chartY), h(r) && h(n) && (i = s[1] + this.chart.plotTop, o = this.translate(Math.min(Math.sqrt(Math.pow(r - e, 2) + Math.pow(n - i, 2)), s[2] / 2) - s[3] / 2, !0))), [o, r || 0, n || 0];
	      }
	      function M(t, e, i) {
	        let s = this.pane.center,
	          o = this.chart,
	          a = this.left || 0,
	          r = this.top || 0,
	          n,
	          l = g(e, s[2] / 2 - this.offset),
	          h;
	        return void 0 === i && (i = this.horiz ? 0 : this.center && -this.center[3] / 2), i && (l += i), this.isCircular || void 0 !== e ? ((h = this.chart.renderer.symbols.arc(a + s[0], r + s[1], l, l, {
	          start: this.startAngleRad,
	          end: this.endAngleRad,
	          open: !0,
	          innerR: 0
	        })).xBounds = [a + s[0]], h.yBounds = [r + s[1] - l]) : (n = this.postTranslate(this.angleRad, l), h = [["M", this.center[0] + o.plotLeft, this.center[1] + o.plotTop], ["L", n.x, n.y]]), h;
	      }
	      function L() {
	        let t = this.constructor.prototype;
	        t.getOffset.call(this), this.chart.axisOffset[this.side] = 0;
	      }
	      function k(t, e, i) {
	        let s = this.chart,
	          o = t => {
	            if ("string" == typeof t) {
	              let e = parseInt(t, 10);
	              return d.test(t) && (e = e * n / 100), e;
	            }
	            return t;
	          },
	          a = this.center,
	          r = this.startAngleRad,
	          n = a[2] / 2,
	          l = Math.min(this.offset, 0),
	          h = this.left || 0,
	          p = this.top || 0,
	          d = /%$/,
	          c = this.isCircular,
	          u,
	          f,
	          b,
	          m,
	          y,
	          x,
	          P = g(o(i.outerRadius), n),
	          S = o(i.innerRadius),
	          M = g(o(i.thickness), 10);
	        if ("polygon" === this.options.gridLineInterpolation) x = this.getPlotLinePath({
	          value: t
	        }).concat(this.getPlotLinePath({
	          value: e,
	          reverse: !0
	        }));else {
	          t = Math.max(t, this.min), e = Math.min(e, this.max);
	          let o = this.translate(t),
	            n = this.translate(e);
	          c || (P = o || 0, S = n || 0), "circle" !== i.shape && c ? (u = r + (o || 0), f = r + (n || 0)) : (u = -Math.PI / 2, f = 1.5 * Math.PI, y = !0), P -= l, M -= l, x = s.renderer.symbols.arc(h + a[0], p + a[1], P, P, {
	            start: Math.min(u, f),
	            end: Math.max(u, f),
	            innerR: g(S, P - M),
	            open: y
	          }), c && (b = (f + u) / 2, m = h + a[0] + a[2] / 2 * Math.cos(b), x.xBounds = b > -Math.PI / 2 && b < Math.PI / 2 ? [m, s.plotWidth] : [0, m], x.yBounds = [p + a[1] + a[2] / 2 * Math.sin(b)], x.yBounds[0] += b > -Math.PI && b < 0 || b > Math.PI ? -10 : 10);
	        }
	        return x;
	      }
	      function v(t) {
	        let e = this.pane.center,
	          i = this.chart,
	          s = i.inverted,
	          o = t.reverse,
	          a = this.pane.options.background ? this.pane.options.background[0] || this.pane.options.background : {},
	          r = a.innerRadius || "0%",
	          n = a.outerRadius || "100%",
	          l = e[0] + i.plotLeft,
	          h = e[1] + i.plotTop,
	          p = this.height,
	          d = t.isCrosshair,
	          c = e[3] / 2,
	          u = t.value,
	          g,
	          f,
	          m,
	          y,
	          x,
	          P,
	          S,
	          M,
	          L,
	          k = this.getPosition(u),
	          v = k.x,
	          C = k.y;
	        if (d && (u = (M = this.getCrosshairPosition(t, l, h))[0], v = M[1], C = M[2]), this.isCircular) f = Math.sqrt(Math.pow(v - l, 2) + Math.pow(C - h, 2)), m = "string" == typeof r ? b(r, 1) : r / f, y = "string" == typeof n ? b(n, 1) : n / f, e && c && (m < (g = c / f) && (m = g), y < g && (y = g)), L = [["M", l + m * (v - l), h - m * (h - C)], ["L", v - (1 - y) * (v - l), C + (1 - y) * (h - C)]];else if ((u = this.translate(u)) && (u < 0 || u > p) && (u = 0), "circle" === this.options.gridLineInterpolation) L = this.getLinePath(0, u, c);else if (L = [], i[s ? "yAxis" : "xAxis"].forEach(t => {
	          t.pane === this.pane && (x = t);
	        }), x) {
	          S = x.tickPositions, x.autoConnect && (S = S.concat([S[0]])), o && (S = S.slice().reverse()), u && (u += c);
	          for (let t = 0; t < S.length; t++) P = x.getPosition(S[t], u), L.push(t ? ["L", P.x, P.y] : ["M", P.x, P.y]);
	        }
	        return L;
	      }
	      function C(t, e) {
	        let i = this.translate(t);
	        return this.postTranslate(this.isCircular ? i : this.angleRad, g(this.isCircular ? e : i < 0 ? 0 : i, this.center[2] / 2) - this.offset);
	      }
	      function w() {
	        let t = this.center,
	          e = this.chart,
	          i = this.options.title;
	        return {
	          x: e.plotLeft + t[0] + (i.x || 0),
	          y: e.plotTop + t[1] - {
	            high: .5,
	            middle: .25,
	            low: 0
	          }[i.align] * t[2] + (i.y || 0)
	        };
	      }
	      function A(t) {
	        t.beforeSetTickPositions = y, t.createLabelCollector = x, t.getCrosshairPosition = S, t.getLinePath = M, t.getOffset = L, t.getPlotBandPath = k, t.getPlotLinePath = v, t.getPosition = C, t.getTitlePosition = w, t.postTranslate = D, t.setAxisSize = B, t.setAxisTranslation = z, t.setOptions = O;
	      }
	      function N() {
	        let t = this.chart,
	          e = this.options,
	          i = t.angular && this.isXAxis,
	          s = this.pane,
	          o = s && s.options;
	        if (!i && s && (t.angular || t.polar)) {
	          let t = 2 * Math.PI,
	            i = (g(o.startAngle, 0) - 90) * Math.PI / 180,
	            s = (g(o.endAngle, g(o.startAngle, 0) + 360) - 90) * Math.PI / 180;
	          this.angleRad = (e.angle || 0) * Math.PI / 180, this.startAngleRad = i, this.endAngleRad = s, this.offset = e.offset || 0;
	          let a = (i % t + t) % t,
	            r = (s % t + t) % t;
	          a > Math.PI && (a -= t), r > Math.PI && (r -= t), this.normalizedStartAngleRad = a, this.normalizedEndAngleRad = r;
	        }
	      }
	      function T(t) {
	        this.isRadial && (t.align = void 0, t.preventDefault());
	      }
	      function X() {
	        if (this.chart && this.chart.labelCollectors) {
	          let t = this.labelCollector ? this.chart.labelCollectors.indexOf(this.labelCollector) : -1;
	          t >= 0 && this.chart.labelCollectors.splice(t, 1);
	        }
	      }
	      function Y(t) {
	        let e;
	        let i = this.chart,
	          s = (i.inverted, i.angular),
	          o = i.polar,
	          a = this.isXAxis,
	          n = this.coll,
	          l = t.userOptions.pane || 0,
	          h = this.pane = i.pane && i.pane[l];
	        if ("colorAxis" === n) {
	          this.isRadial = !1;
	          return;
	        }
	        s ? (s && a ? (this.isHidden = !0, this.createLabelCollector = P, this.getOffset = r, this.redraw = E, this.render = E, this.setScale = r, this.setCategories = r, this.setTitle = r) : A(this), e = !a) : o && (A(this), e = this.horiz), s || o ? (this.isRadial = !0, this.labelCollector || (this.labelCollector = this.createLabelCollector()), this.labelCollector && i.labelCollectors.push(this.labelCollector)) : this.isRadial = !1, h && e && (h.axis = this), this.isCircular = e;
	      }
	      function R() {
	        this.isRadial && this.beforeSetTickPositions();
	      }
	      function I(t) {
	        let e = this.label;
	        if (!e) return;
	        let i = this.axis,
	          s = e.getBBox(),
	          o = i.options.labels,
	          a = (i.translate(this.pos) + i.startAngleRad + Math.PI / 2) / Math.PI * 180 % 360,
	          r = Math.round(a),
	          n = h(o.y) ? 0 : -(.3 * s.height),
	          l = o.y,
	          p,
	          d = 20,
	          c = o.align,
	          u = "end",
	          f = r < 0 ? r + 360 : r,
	          m = f,
	          y = 0,
	          x = 0;
	        i.isRadial && (p = i.getPosition(this.pos, i.center[2] / 2 + b(g(o.distance, -25), i.center[2] / 2, -i.center[2] / 2)), "auto" === o.rotation ? e.attr({
	          rotation: a
	        }) : h(l) || (l = i.chart.renderer.fontMetrics(e).b - s.height / 2), h(c) || (i.isCircular ? (s.width > i.len * i.tickInterval / (i.max - i.min) && (d = 0), c = a > d && a < 180 - d ? "left" : a > 180 + d && a < 360 - d ? "right" : "center") : c = "center", e.attr({
	          align: c
	        })), "auto" === c && 2 === i.tickPositions.length && i.isCircular && (f > 90 && f < 180 ? f = 180 - f : f > 270 && f <= 360 && (f = 540 - f), m > 180 && m <= 360 && (m = 360 - m), (i.pane.options.startAngle === r || i.pane.options.startAngle === r + 360 || i.pane.options.startAngle === r - 360) && (u = "start"), c = r >= -90 && r <= 90 || r >= -360 && r <= -270 || r >= 270 && r <= 360 ? "start" === u ? "right" : "left" : "start" === u ? "left" : "right", m > 70 && m < 110 && (c = "center"), f < 15 || f >= 180 && f < 195 ? y = .3 * s.height : f >= 15 && f <= 35 ? y = "start" === u ? 0 : .75 * s.height : f >= 195 && f <= 215 ? y = "start" === u ? .75 * s.height : 0 : f > 35 && f <= 90 ? y = "start" === u ? -(.25 * s.height) : s.height : f > 215 && f <= 270 && (y = "start" === u ? s.height : -(.25 * s.height)), m < 15 ? x = "start" === u ? -(.15 * s.height) : .15 * s.height : m > 165 && m <= 180 && (x = "start" === u ? .15 * s.height : -(.15 * s.height)), e.attr({
	          align: c
	        }), e.translate(x, y + n)), t.pos.x = p.x + (o.x || 0), t.pos.y = p.y + (l || 0));
	      }
	      function j(t) {
	        this.axis.getPosition && p(t.pos, this.axis.getPosition(this.pos));
	      }
	      function D(t, e) {
	        let i = this.chart,
	          s = this.center;
	        return t = this.startAngleRad + t, {
	          x: i.plotLeft + s[0] + Math.cos(t) * e,
	          y: i.plotTop + s[1] + Math.sin(t) * e
	        };
	      }
	      function E() {
	        this.isDirty = !1;
	      }
	      function B() {
	        let t, e;
	        let i = this.constructor.prototype;
	        i.setAxisSize.call(this), this.isRadial && (this.pane.updateCenter(this), t = this.center = this.pane.center.slice(), this.isCircular ? this.sector = this.endAngleRad - this.startAngleRad : (e = this.postTranslate(this.angleRad, t[3] / 2), t[0] = e.x - this.chart.plotLeft, t[1] = e.y - this.chart.plotTop), this.len = this.width = this.height = (t[2] - t[3]) * g(this.sector, 1) / 2);
	      }
	      function z() {
	        let t = this.constructor.prototype;
	        t.setAxisTranslation.call(this), this.center && (this.isCircular ? this.transA = (this.endAngleRad - this.startAngleRad) / (this.max - this.min || 1) : this.transA = (this.center[2] - this.center[3]) / 2 / (this.max - this.min || 1), this.isXAxis ? this.minPixelPadding = this.transA * this.minPointOffset : this.minPixelPadding = 0);
	      }
	      function O(t) {
	        let {
	            coll: a
	          } = this,
	          {
	            angular: r,
	            inverted: n,
	            polar: l
	          } = this.chart,
	          h = {};
	        r ? this.isXAxis || (h = u(o.yAxis, i)) : l && (h = this.horiz ? u(o.xAxis, e) : u("xAxis" === a ? o.xAxis : o.yAxis, s)), n && "yAxis" === a && (h.stackLabels = c(o.yAxis, !0) ? o.yAxis.stackLabels : {}, h.reversedStacks = !0);
	        let p = this.options = u(h, t);
	        p.plotBands || (p.plotBands = []), d(this, "afterSetOptions");
	      }
	      function W(t, e, i, s, o, a, r) {
	        let n;
	        let l = this.axis;
	        return l.isRadial ? ["M", e, i, "L", (n = l.getPosition(this.pos, l.center[2] / 2 + s)).x, n.y] : t.call(this, e, i, s, o, a, r);
	      }
	      t.compose = function t(e, i) {
	        return f(a, t) && (n(e, "afterInit", N), n(e, "autoLabelAlign", T), n(e, "destroy", X), n(e, "init", Y), n(e, "initialAxisTranslation", R), n(i, "afterGetLabelPosition", I), n(i, "afterGetPosition", j), m(i.prototype, "getMarkPath", W)), e;
	      };
	    }(s || (s = {})), s;
	  }), i(e, "Series/PolarComposition.js", [e["Core/Animation/AnimationUtilities.js"], e["Core/Globals.js"], e["Core/Series/Series.js"], e["Extensions/Pane/Pane.js"], e["Core/Axis/RadialAxis.js"], e["Core/Utilities.js"]], function (t, e, i, s, o, a) {
	    let {
	        animObject: r
	      } = t,
	      {
	        composed: n
	      } = e,
	      {
	        addEvent: l,
	        defined: h,
	        find: p,
	        isNumber: d,
	        merge: c,
	        pick: u,
	        pushUnique: g,
	        relativeLength: f,
	        splat: b,
	        uniqueKey: m,
	        wrap: y
	      } = a;
	    function x() {
	      (this.pane || []).forEach(t => {
	        t.render();
	      });
	    }
	    function P(t) {
	      let e = t.args[0].xAxis,
	        i = t.args[0].yAxis,
	        s = t.args[0].chart;
	      e && i && ("polygon" === i.gridLineInterpolation ? (e.startOnTick = !0, e.endOnTick = !0) : "polygon" === e.gridLineInterpolation && s.inverted && (i.startOnTick = !0, i.endOnTick = !0));
	    }
	    function S() {
	      this.pane || (this.pane = []), this.options.pane = b(this.options.pane), this.options.pane.forEach(t => {
	        new s(t, this);
	      }, this);
	    }
	    function M(t) {
	      let e = t.args.marker,
	        i = this.chart.xAxis[0],
	        s = this.chart.yAxis[0],
	        o = this.chart.inverted,
	        a = o ? s : i,
	        r = o ? i : s;
	      if (this.chart.polar) {
	        t.preventDefault();
	        let i = (e.attr ? e.attr("start") : e.start) - a.startAngleRad,
	          s = e.attr ? e.attr("r") : e.r,
	          o = (e.attr ? e.attr("end") : e.end) - a.startAngleRad,
	          n = e.attr ? e.attr("innerR") : e.innerR;
	        t.result.x = i + a.pos, t.result.width = o - i, t.result.y = r.len + r.pos - n, t.result.height = n - s;
	      }
	    }
	    function L(t) {
	      let e = this.chart;
	      if (e.polar && e.hoverPane && e.hoverPane.axis) {
	        t.preventDefault();
	        let i = e.hoverPane.center,
	          s = this.mouseDownX || 0,
	          o = this.mouseDownY || 0,
	          a = t.args.chartY,
	          r = t.args.chartX,
	          n = 2 * Math.PI,
	          l = e.hoverPane.axis.startAngleRad,
	          h = e.hoverPane.axis.endAngleRad,
	          p = e.inverted ? e.xAxis[0] : e.yAxis[0],
	          d = {},
	          c = "arc";
	        if (d.x = i[0] + e.plotLeft, d.y = i[1] + e.plotTop, this.zoomHor) {
	          let t = l > 0 ? h - l : Math.abs(l) + Math.abs(h),
	            u = Math.atan2(o - e.plotTop - i[1], s - e.plotLeft - i[0]) - l,
	            g = Math.atan2(a - e.plotTop - i[1], r - e.plotLeft - i[0]) - l;
	          if (d.r = i[2] / 2, d.innerR = i[3] / 2, u <= 0 && (u += n), g <= 0 && (g += n), g < u && (g = [u, u = g][0]), t < n) {
	            let e = h + (n - t) / 2;
	            l + g > e && (g = u, u = l <= 0 ? l : 0);
	          }
	          let f = d.start = Math.max(u + l, l),
	            b = d.end = Math.min(g + l, h);
	          if ("polygon" === p.options.gridLineInterpolation) {
	            let t = e.hoverPane.axis,
	              s = (t.tickInterval, f - t.startAngleRad + t.pos),
	              o = p.getPlotLinePath({
	                value: p.max
	              }),
	              a = t.toValue(s),
	              r = t.toValue(s + (b - f));
	            if (a < t.getExtremes().min) {
	              let {
	                min: e,
	                max: i
	              } = t.getExtremes();
	              a = i - (e - a);
	            }
	            if (r < t.getExtremes().min) {
	              let {
	                min: e,
	                max: i
	              } = t.getExtremes();
	              r = i - (e - r);
	            }
	            r < a && (r = [a, a = r][0]), (o = w(o, a, r, t)).push(["L", i[0] + e.plotLeft, e.plotTop + i[1]]), d.d = o, c = "path";
	          }
	        }
	        if (this.zoomVert) {
	          let t = e.inverted ? e.xAxis[0] : e.yAxis[0],
	            n = Math.sqrt(Math.pow(s - e.plotLeft - i[0], 2) + Math.pow(o - e.plotTop - i[1], 2)),
	            p = Math.sqrt(Math.pow(r - e.plotLeft - i[0], 2) + Math.pow(a - e.plotTop - i[1], 2));
	          if (p < n && (n = [p, p = n][0]), p > i[2] / 2 && (p = i[2] / 2), n < i[3] / 2 && (n = i[3] / 2), this.zoomHor || (d.start = l, d.end = h), d.r = p, d.innerR = n, "polygon" === t.options.gridLineInterpolation) {
	            let e = t.toValue(t.len + t.pos - n),
	              i = t.toValue(t.len + t.pos - p),
	              s = t.getPlotLinePath({
	                value: i
	              }).concat(t.getPlotLinePath({
	                value: e,
	                reverse: !0
	              }));
	            d.d = s, c = "path";
	          }
	        }
	        if (this.zoomHor && this.zoomVert && "polygon" === p.options.gridLineInterpolation) {
	          let t = e.hoverPane.axis,
	            i = d.start || 0,
	            s = d.end || 0,
	            o = i - t.startAngleRad + t.pos,
	            a = t.toValue(o),
	            r = t.toValue(o + (s - i));
	          if (d.d instanceof Array) {
	            let t = d.d.slice(0, d.d.length / 2),
	              i = d.d.slice(d.d.length / 2, d.d.length);
	            i = [...i].reverse();
	            let s = e.hoverPane.axis;
	            t = w(t, a, r, s), (i = w(i, a, r, s)) && (i[0][0] = "L"), i = [...i].reverse(), d.d = t.concat(i), c = "path";
	          }
	        }
	        t.attrs = d, t.shapeType = c;
	      }
	    }
	    function k() {
	      let t = this.chart;
	      t.polar && (this.polar = new E(this), t.inverted && (this.isRadialSeries = !0, this.is("column") && (this.isRadialBar = !0)));
	    }
	    function v() {
	      if (this.chart.polar && this.xAxis) {
	        let {
	            xAxis: t,
	            yAxis: i
	          } = this,
	          s = this.chart;
	        this.kdByAngle = s.tooltip && s.tooltip.shared, this.kdByAngle || s.inverted ? this.searchPoint = C : this.options.findNearestPointBy = "xy";
	        let o = this.points,
	          a = o.length;
	        for (; a--;) this.is("column") || this.is("columnrange") || this.polar.toXY(o[a]), s.hasParallelCoordinates || this.yAxis.reversed || (u(o[a].y, Number.MIN_VALUE) < i.min || o[a].x < t.min || o[a].x > t.max ? (o[a].isNull = !0, o[a].plotY = NaN) : o[a].isNull = o[a].isValid && !o[a].isValid());
	        this.hasClipCircleSetter || (this.hasClipCircleSetter = !!this.eventsToUnbind.push(l(this, "afterRender", function () {
	          let t;
	          s.polar && !1 !== this.options.clip && (t = this.yAxis.pane.center, this.clipCircle ? this.clipCircle.animate({
	            x: t[0],
	            y: t[1],
	            r: t[2] / 2,
	            innerR: t[3] / 2
	          }) : this.clipCircle = function (t, e, i, s, o) {
	            let a = m(),
	              r = t.createElement("clipPath").attr({
	                id: a
	              }).add(t.defs),
	              n = o ? t.arc(e, i, s, o, 0, 2 * Math.PI).add(r) : t.circle(e, i, s).add(r);
	            return n.id = a, n.clipPath = r, n;
	          }(s.renderer, t[0], t[1], t[2] / 2, t[3] / 2), this.group.clip(this.clipCircle), this.setClip = e.noop);
	        })));
	      }
	    }
	    function C(t) {
	      let e = this.chart,
	        i = this.xAxis,
	        s = this.yAxis,
	        o = i.pane && i.pane.center,
	        a = t.chartX - (o && o[0] || 0) - e.plotLeft,
	        r = t.chartY - (o && o[1] || 0) - e.plotTop,
	        n = e.inverted ? {
	          clientX: t.chartX - s.pos,
	          plotY: t.chartY - i.pos
	        } : {
	          clientX: 180 + Math.atan2(a, r) * (-180 / Math.PI)
	        };
	      return this.searchKDTree(n);
	    }
	    function w(t, e, i, s) {
	      let o = s.tickInterval,
	        a = s.tickPositions,
	        r = p(a, t => t >= i),
	        n = p([...a].reverse(), t => t <= e);
	      return h(r) || (r = a[a.length - 1]), h(n) || (n = a[0], r += o, t[0][0] = "L", t.unshift(t[t.length - 3])), (t = t.slice(a.indexOf(n), a.indexOf(r) + 1))[0][0] = "M", t;
	    }
	    function A(t, e) {
	      return p(this.pane || [], t => t.options.id === e) || t.call(this, e);
	    }
	    function N(t, e, s, o, a, r) {
	      let n, l, h;
	      let p = this.chart,
	        d = u(o.inside, !!this.options.stacking);
	      if (p.polar) {
	        if (n = e.rectPlotX / Math.PI * 180, p.inverted) this.forceDL = p.isInsidePlot(e.plotX, e.plotY), d && e.shapeArgs ? (l = e.shapeArgs, a = c(a, {
	          x: (h = this.yAxis.postTranslate(((l.start || 0) + (l.end || 0)) / 2 - this.xAxis.startAngleRad, e.barX + e.pointWidth / 2)).x - p.plotLeft,
	          y: h.y - p.plotTop
	        })) : e.tooltipPos && (a = c(a, {
	          x: e.tooltipPos[0],
	          y: e.tooltipPos[1]
	        })), o.align = u(o.align, "center"), o.verticalAlign = u(o.verticalAlign, "middle");else {
	          var g;
	          null === (g = o).align && (g.align = n > 20 && n < 160 ? "left" : n > 200 && n < 340 ? "right" : "center"), null === g.verticalAlign && (g.verticalAlign = n < 45 || n > 315 ? "bottom" : n > 135 && n < 225 ? "top" : "middle"), o = g;
	        }
	        i.prototype.alignDataLabel.call(this, e, s, o, a, r), this.isRadialBar && e.shapeArgs && e.shapeArgs.start === e.shapeArgs.end ? s.hide() : s.show();
	      } else t.call(this, e, s, o, a, r);
	    }
	    function T() {
	      let t = this.options,
	        e = t.stacking,
	        i = this.chart,
	        s = this.xAxis,
	        o = this.yAxis,
	        r = o.reversed,
	        n = o.center,
	        l = s.startAngleRad,
	        p = s.endAngleRad,
	        c = p - l,
	        u = t.threshold,
	        g = 0,
	        b,
	        m,
	        y,
	        x,
	        P,
	        S = 0,
	        M = 0,
	        L,
	        k,
	        v,
	        C,
	        w,
	        A,
	        N,
	        T;
	      if (s.isRadial) for (y = (b = this.points).length, x = o.translate(o.min), P = o.translate(o.max), u = t.threshold || 0, i.inverted && d(u) && h(g = o.translate(u)) && (g < 0 ? g = 0 : g > c && (g = c), this.translatedThreshold = g + l); y--;) {
	        if (A = (m = b[y]).barX, k = m.x, v = m.y, m.shapeType = "arc", i.inverted) {
	          m.plotY = o.translate(v), e && o.stacking ? (w = o.stacking.stacks[(v < 0 ? "-" : "") + this.stackKey], this.visible && w && w[k] && !m.isNull && (C = w[k].points[this.getStackIndicator(void 0, k, this.index).key], S = o.translate(C[0]), M = o.translate(C[1]), h(S) && (S = a.clamp(S, 0, c)))) : (S = g, M = m.plotY), S > M && (M = [S, S = M][0]), r ? M > x ? M = x : S < P ? S = P : (S > x || M < P) && (S = M = c) : S < x ? S = x : M > P ? M = P : (M < x || S > P) && (S = M = 0), o.min > o.max && (S = M = r ? c : 0), S += l, M += l, n && (m.barX = A += n[3] / 2), N = Math.max(A, 0), T = Math.max(A + m.pointWidth, 0);
	          let i = t.borderRadius,
	            s = "object" == typeof i ? i.radius : i,
	            p = f(s || 0, T - N);
	          m.shapeArgs = {
	            x: n[0],
	            y: n[1],
	            r: T,
	            innerR: N,
	            start: S,
	            end: M,
	            borderRadius: p
	          }, m.opacity = S === M ? 0 : void 0, m.plotY = (h(this.translatedThreshold) && (S < this.translatedThreshold ? S : M)) - l;
	        } else S = A + l, m.shapeArgs = this.polar.arc(m.yBottom, m.plotY, S, S + m.pointWidth), m.shapeArgs.borderRadius = 0;
	        this.polar.toXY(m), i.inverted ? (L = o.postTranslate(m.rectPlotY, A + m.pointWidth / 2), m.tooltipPos = [L.x - i.plotLeft, L.y - i.plotTop]) : m.tooltipPos = [m.plotX, m.plotY], n && (m.ttBelow = m.plotY > n[1]);
	      }
	    }
	    function X(t, e) {
	      let i, s;
	      let o = this;
	      if (this.chart.polar) {
	        e = e || this.points;
	        for (let t = 0; t < e.length; t++) if (!e[t].isNull) {
	          i = t;
	          break;
	        }
	        !1 !== this.options.connectEnds && void 0 !== i && (this.connectEnds = !0, e.splice(e.length, 0, e[i]), s = !0), e.forEach(t => {
	          void 0 === t.polarPlotY && o.polar.toXY(t);
	        });
	      }
	      let a = t.apply(this, [].slice.call(arguments, 1));
	      return s && e.pop(), a;
	    }
	    function Y(t, e) {
	      let i = this.chart,
	        s = {
	          xAxis: [],
	          yAxis: []
	        };
	      return i.polar ? i.axes.forEach(t => {
	        if ("colorAxis" === t.coll) return;
	        let o = t.isXAxis,
	          a = t.center,
	          r = e.chartX - a[0] - i.plotLeft,
	          n = e.chartY - a[1] - i.plotTop;
	        s[o ? "xAxis" : "yAxis"].push({
	          axis: t,
	          value: t.translate(o ? Math.PI - Math.atan2(r, n) : Math.sqrt(Math.pow(r, 2) + Math.pow(n, 2)), !0)
	        });
	      }) : s = t.call(this, e), s;
	    }
	    function R(t, e) {
	      this.chart.polar || t.call(this, e);
	    }
	    function I(t, i) {
	      let s = this,
	        o = this.chart,
	        a = this.group,
	        n = this.markerGroup,
	        l = this.xAxis && this.xAxis.center,
	        h = o.plotLeft,
	        p = o.plotTop,
	        d = this.options.animation,
	        c,
	        g,
	        f,
	        b,
	        m,
	        y;
	      o.polar ? s.isRadialBar ? i || (s.startAngleRad = u(s.translatedThreshold, s.xAxis.startAngleRad), e.seriesTypes.pie.prototype.animate.call(s, i)) : (d = r(d), s.is("column") ? i || (g = l[3] / 2, s.points.forEach(t => {
	        f = t.graphic, m = (b = t.shapeArgs) && b.r, y = b && b.innerR, f && b && (f.attr({
	          r: g,
	          innerR: g
	        }), f.animate({
	          r: m,
	          innerR: y
	        }, s.options.animation));
	      })) : i ? (c = {
	        translateX: l[0] + h,
	        translateY: l[1] + p,
	        scaleX: .001,
	        scaleY: .001
	      }, a.attr(c), n && n.attr(c)) : (c = {
	        translateX: h,
	        translateY: p,
	        scaleX: 1,
	        scaleY: 1
	      }, a.animate(c, d), n && n.animate(c, d))) : t.call(this, i);
	    }
	    function j(t, e, i, s) {
	      let o, a;
	      if (this.chart.polar) {
	        if (s) {
	          a = function t(e, i, s, o) {
	            let a, r, n, l, h, p;
	            let d = o ? 1 : 0;
	            a = i >= 0 && i <= e.length - 1 ? i : i < 0 ? e.length - 1 + i : 0;
	            let c = a - 1 < 0 ? e.length - (1 + d) : a - 1,
	              u = a + 1 > e.length - 1 ? d : a + 1,
	              g = e[c],
	              f = e[u],
	              b = g.plotX,
	              m = g.plotY,
	              y = f.plotX,
	              x = f.plotY,
	              P = e[a].plotX,
	              S = e[a].plotY;
	            r = (1.5 * P + b) / 2.5, n = (1.5 * S + m) / 2.5, l = (1.5 * P + y) / 2.5, h = (1.5 * S + x) / 2.5;
	            let M = Math.sqrt(Math.pow(r - P, 2) + Math.pow(n - S, 2)),
	              L = Math.sqrt(Math.pow(l - P, 2) + Math.pow(h - S, 2)),
	              k = Math.atan2(n - S, r - P),
	              v = Math.atan2(h - S, l - P);
	            p = Math.PI / 2 + (k + v) / 2, Math.abs(k - p) > Math.PI / 2 && (p -= Math.PI), r = P + Math.cos(p) * M, n = S + Math.sin(p) * M, l = P + Math.cos(Math.PI + p) * L, h = S + Math.sin(Math.PI + p) * L;
	            let C = {
	              rightContX: l,
	              rightContY: h,
	              leftContX: r,
	              leftContY: n,
	              plotX: P,
	              plotY: S
	            };
	            return s && (C.prevPointCont = t(e, c, !1, o)), C;
	          }(e, s, !0, this.connectEnds);
	          let t = a.prevPointCont && a.prevPointCont.rightContX,
	            i = a.prevPointCont && a.prevPointCont.rightContY;
	          o = ["C", d(t) ? t : a.plotX, d(i) ? i : a.plotY, d(a.leftContX) ? a.leftContX : a.plotX, d(a.leftContY) ? a.leftContY : a.plotY, a.plotX, a.plotY];
	        } else o = ["M", i.plotX, i.plotY];
	      } else o = t.call(this, e, i, s);
	      return o;
	    }
	    function D(t, e, i = this.plotY) {
	      let {
	          plotX: s,
	          series: o
	        } = this,
	        {
	          chart: a
	        } = o;
	      return a.polar && !this.destroyed && d(s) && d(i) ? [s + (e ? a.plotLeft : 0), i + (e ? a.plotTop : 0)] : t.call(this, e, i);
	    }
	    class E {
	      static compose(t, e, i, a, r, h, p, d, c, u) {
	        if (s.compose(e, i), o.compose(t, r), g(n, this.compose)) {
	          let t = e.prototype,
	            s = h.prototype,
	            o = i.prototype,
	            r = a.prototype;
	          if (l(e, "afterDrawChartBox", x), l(e, "getAxes", S), l(e, "init", P), y(t, "get", A), y(o, "getCoordinates", Y), y(o, "pinch", R), l(i, "getSelectionMarkerAttrs", L), l(i, "getSelectionBox", M), l(a, "afterInit", k), l(a, "afterTranslate", v, {
	            order: 2
	          }), l(a, "afterColumnTranslate", T, {
	            order: 4
	          }), y(r, "animate", I), y(s, "pos", D), d) {
	            let t = d.prototype;
	            y(t, "alignDataLabel", N), y(t, "animate", I);
	          }
	          if (c) {
	            let t = c.prototype;
	            y(t, "getGraphPath", X);
	          }
	          if (u) {
	            let t = u.prototype;
	            if (y(t, "getPointSpline", j), p) {
	              let e = p.prototype;
	              e.getPointSpline = t.getPointSpline;
	            }
	          }
	        }
	      }
	      constructor(t) {
	        this.series = t;
	      }
	      arc(t, e, i, s) {
	        let o = this.series,
	          a = o.xAxis.center,
	          r = o.yAxis.len,
	          n = a[3] / 2,
	          l = r - e + n,
	          h = r - u(t, r) + n;
	        return o.yAxis.reversed && (l < 0 && (l = n), h < 0 && (h = n)), {
	          x: a[0],
	          y: a[1],
	          r: l,
	          innerR: h,
	          start: i,
	          end: s
	        };
	      }
	      toXY(t) {
	        let e = this.series,
	          i = e.chart,
	          s = e.xAxis,
	          o = e.yAxis,
	          a = t.plotX,
	          r = i.inverted,
	          n = t.y,
	          l = t.plotY,
	          h = r ? a : o.len - l,
	          p;
	        if (r && e && !e.isRadialBar && (t.plotY = l = d(n) ? o.translate(n) : 0), t.rectPlotX = a, t.rectPlotY = l, o.center && (h += o.center[3] / 2), d(l)) {
	          let e = r ? o.postTranslate(l, h) : s.postTranslate(a, h);
	          t.plotX = t.polarPlotX = e.x - i.plotLeft, t.plotY = t.polarPlotY = e.y - i.plotTop;
	        }
	        e.kdByAngle ? ((p = (a / Math.PI * 180 + s.pane.options.startAngle) % 360) < 0 && (p += 360), t.clientX = p) : t.clientX = t.plotX;
	      }
	    }
	    return E;
	  }), i(e, "Core/Axis/WaterfallAxis.js", [e["Core/Globals.js"], e["Core/Axis/Stacking/StackItem.js"], e["Core/Utilities.js"]], function (t, e, i) {
	    var s;
	    let {
	        composed: o
	      } = t,
	      {
	        addEvent: a,
	        objectEach: r,
	        pushUnique: n
	      } = i;
	    return function (t) {
	      function i() {
	        let t = this.waterfall.stacks;
	        t && (t.changed = !1, delete t.alreadyChanged);
	      }
	      function s() {
	        let t = this.options.stackLabels;
	        t && t.enabled && this.waterfall.stacks && this.waterfall.renderStackTotals();
	      }
	      function l() {
	        this.waterfall || (this.waterfall = new p(this));
	      }
	      function h() {
	        let t = this.axes,
	          e = this.series;
	        for (let i of e) if (i.options.stacking) {
	          for (let e of t) e.isXAxis || (e.waterfall.stacks.changed = !0);
	          break;
	        }
	      }
	      t.compose = function t(e, r) {
	        n(o, t) && (a(e, "init", l), a(e, "afterBuildStacks", i), a(e, "afterRender", s), a(r, "beforeRedraw", h));
	      };
	      class p {
	        constructor(t) {
	          this.axis = t, this.stacks = {
	            changed: !1
	          };
	        }
	        renderStackTotals() {
	          let t = this.axis,
	            i = t.waterfall.stacks,
	            s = t.stacking && t.stacking.stackTotalGroup,
	            o = new e(t, t.options.stackLabels || {}, !1, 0, void 0);
	          this.dummyStackItem = o, s && r(i, t => {
	            r(t, (t, i) => {
	              o.total = t.stackTotal, o.x = +i, t.label && (o.label = t.label), e.prototype.render.call(o, s), t.label = o.label, delete o.label;
	            });
	          }), o.total = null;
	        }
	      }
	      t.Composition = p;
	    }(s || (s = {})), s;
	  }), i(e, "Series/Waterfall/WaterfallPoint.js", [e["Series/Column/ColumnSeries.js"], e["Core/Series/Point.js"], e["Core/Utilities.js"]], function (t, e, i) {
	    let {
	      isNumber: s
	    } = i;
	    class o extends t.prototype.pointClass {
	      getClassName() {
	        let t = e.prototype.getClassName.call(this);
	        return this.isSum ? t += " highcharts-sum" : this.isIntermediateSum && (t += " highcharts-intermediate-sum"), t;
	      }
	      isValid() {
	        return s(this.y) || this.isSum || !!this.isIntermediateSum;
	      }
	    }
	    return o;
	  }), i(e, "Series/Waterfall/WaterfallSeriesDefaults.js", [], function () {
	    return {
	      dataLabels: {
	        inside: !0
	      },
	      lineWidth: 1,
	      lineColor: "#333333",
	      dashStyle: "Dot",
	      borderColor: "#333333",
	      states: {
	        hover: {
	          lineWidthPlus: 0
	        }
	      }
	    };
	  }), i(e, "Series/Waterfall/WaterfallSeries.js", [e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"], e["Core/Axis/WaterfallAxis.js"], e["Series/Waterfall/WaterfallPoint.js"], e["Series/Waterfall/WaterfallSeriesDefaults.js"]], function (t, e, i, s, o) {
	    let {
	        column: a,
	        line: r
	      } = t.seriesTypes,
	      {
	        addEvent: n,
	        arrayMax: l,
	        arrayMin: h,
	        correctFloat: p,
	        extend: d,
	        isNumber: c,
	        merge: u,
	        objectEach: g,
	        pick: f
	      } = e;
	    function b(t, e) {
	      return Object.hasOwnProperty.call(t, e);
	    }
	    class m extends a {
	      generatePoints() {
	        a.prototype.generatePoints.apply(this);
	        for (let t = 0, e = this.points.length; t < e; t++) {
	          let e = this.points[t],
	            i = this.processedYData[t];
	          c(i) && (e.isIntermediateSum || e.isSum) && (e.y = p(i));
	        }
	      }
	      processData(t) {
	        let e, i, s, o, a, r;
	        let n = this.options,
	          l = this.yData,
	          h = n.data,
	          d = l.length,
	          c = n.threshold || 0;
	        s = i = o = a = 0;
	        for (let t = 0; t < d; t++) r = l[t], e = h && h[t] ? h[t] : {}, "sum" === r || e.isSum ? l[t] = p(s) : "intermediateSum" === r || e.isIntermediateSum ? (l[t] = p(i), i = 0) : (s += r, i += r), o = Math.min(s, o), a = Math.max(s, a);
	        super.processData.call(this, t), n.stacking || (this.dataMin = o + c, this.dataMax = a);
	      }
	      toYData(t) {
	        return t.isSum ? "sum" : t.isIntermediateSum ? "intermediateSum" : t.y;
	      }
	      updateParallelArrays(t, e) {
	        super.updateParallelArrays.call(this, t, e), ("sum" === this.yData[0] || "intermediateSum" === this.yData[0]) && (this.yData[0] = null);
	      }
	      pointAttribs(t, e) {
	        let i = this.options.upColor;
	        i && !t.options.color && c(t.y) && (t.color = t.y > 0 ? i : void 0);
	        let s = a.prototype.pointAttribs.call(this, t, e);
	        return delete s.dashstyle, s;
	      }
	      getGraphPath() {
	        return [["M", 0, 0]];
	      }
	      getCrispPath() {
	        let t = this.data.filter(t => c(t.y)),
	          e = this.yAxis,
	          i = t.length,
	          s = Math.round(this.graph.strokeWidth()) % 2 / 2,
	          o = Math.round(this.borderWidth) % 2 / 2,
	          a = this.xAxis.reversed,
	          r = this.yAxis.reversed,
	          n = this.options.stacking,
	          l = [];
	        for (let h = 1; h < i; h++) {
	          if (!(this.options.connectNulls || c(this.data[t[h].index - 1].y))) continue;
	          let i = t[h].box,
	            p = t[h - 1],
	            d = p.y || 0,
	            u = t[h - 1].box;
	          if (!i || !u) continue;
	          let g = e.waterfall.stacks[this.stackKey],
	            f = d > 0 ? -u.height : 0;
	          if (g && u && i) {
	            let t;
	            let d = g[h - 1];
	            if (n) {
	              let i = d.connectorThreshold;
	              t = Math.round(e.translate(i, !1, !0, !1, !0) + (r ? f : 0)) - s;
	            } else t = u.y + p.minPointLengthOffset + o - s;
	            l.push(["M", (u.x || 0) + (a ? 0 : u.width || 0), t], ["L", (i.x || 0) + (a && i.width || 0), t]);
	          }
	          if (u && l.length && (!n && d < 0 && !r || d > 0 && r)) {
	            let t = l[l.length - 2];
	            t && "number" == typeof t[2] && (t[2] += u.height || 0);
	            let e = l[l.length - 1];
	            e && "number" == typeof e[2] && (e[2] += u.height || 0);
	          }
	        }
	        return l;
	      }
	      drawGraph() {
	        r.prototype.drawGraph.call(this), this.graph && this.graph.attr({
	          d: this.getCrispPath()
	        });
	      }
	      setStackedPoints(t) {
	        let e = this.options,
	          i = t.waterfall?.stacks,
	          s = e.threshold || 0,
	          o = this.stackKey,
	          a = this.xData,
	          r = a.length,
	          n = s,
	          l = n,
	          h,
	          p = 0,
	          d = 0,
	          c = 0,
	          u,
	          g,
	          f,
	          b,
	          m,
	          y,
	          x,
	          P,
	          S = (t, e, i, s) => {
	            if (h) {
	              if (u) for (; i < u; i++) h.stackState[i] += s;else h.stackState[0] = t, u = h.stackState.length;
	              h.stackState.push(h.stackState[u - 1] + e);
	            }
	          };
	        if (t.stacking && i && this.reserveSpace()) {
	          P = i.changed, (x = i.alreadyChanged) && 0 > x.indexOf(o) && (P = !0), i[o] || (i[o] = {});
	          let t = i[o];
	          if (t) for (let i = 0; i < r; i++) (!t[y = a[i]] || P) && (t[y] = {
	            negTotal: 0,
	            posTotal: 0,
	            stackTotal: 0,
	            threshold: 0,
	            stateIndex: 0,
	            stackState: [],
	            label: P && t[y] ? t[y].label : void 0
	          }), h = t[y], (m = this.yData[i]) >= 0 ? h.posTotal += m : h.negTotal += m, b = e.data[i], g = h.absolutePos = h.posTotal, f = h.absoluteNeg = h.negTotal, h.stackTotal = g + f, u = h.stackState.length, b && b.isIntermediateSum ? (S(c, d, 0, c), c = d, d = s, n ^= l, l ^= n, n ^= l) : b && b.isSum ? (S(s, p, u, 0), n = s) : (S(n, m, 0, p), b && (p += m, d += m)), h.stateIndex++, h.threshold = n, n += h.stackTotal;
	          i.changed = !1, i.alreadyChanged || (i.alreadyChanged = []), i.alreadyChanged.push(o);
	        }
	      }
	      getExtremes() {
	        let t, e, i;
	        let s = this.options.stacking;
	        return s ? (t = this.yAxis.waterfall.stacks, e = this.stackedYNeg = [], i = this.stackedYPos = [], "overlap" === s ? g(t[this.stackKey], function (t) {
	          e.push(h(t.stackState)), i.push(l(t.stackState));
	        }) : g(t[this.stackKey], function (t) {
	          e.push(t.negTotal + t.threshold), i.push(t.posTotal + t.threshold);
	        }), {
	          dataMin: h(e),
	          dataMax: l(i)
	        }) : {
	          dataMin: this.dataMin,
	          dataMax: this.dataMax
	        };
	      }
	    }
	    return m.defaultOptions = u(a.defaultOptions, o), m.compose = i.compose, d(m.prototype, {
	      pointValKey: "y",
	      showLine: !0,
	      pointClass: s
	    }), n(m, "afterColumnTranslate", function () {
	      let {
	          options: t,
	          points: e,
	          yAxis: i
	        } = this,
	        s = f(t.minPointLength, 5),
	        o = s / 2,
	        a = t.threshold || 0,
	        r = t.stacking,
	        n = i.waterfall.stacks[this.stackKey],
	        l = a,
	        h = a,
	        p,
	        g,
	        m,
	        y;
	      for (let t = 0; t < e.length; t++) {
	        let f = e[t],
	          x = this.processedYData[t],
	          P = f.shapeArgs,
	          S = d({
	            x: 0,
	            y: 0,
	            width: 0,
	            height: 0
	          }, P || {});
	        f.box = S;
	        let M = [0, x],
	          L = f.y || 0;
	        if (r) {
	          if (n) {
	            let e = n[t];
	            "overlap" === r ? (g = e.stackState[e.stateIndex--], p = L >= 0 ? g : g - L, b(e, "absolutePos") && delete e.absolutePos, b(e, "absoluteNeg") && delete e.absoluteNeg) : (L >= 0 ? (g = e.threshold + e.posTotal, e.posTotal -= L, p = g) : (g = e.threshold + e.negTotal, e.negTotal -= L, p = g - L), !e.posTotal && c(e.absolutePos) && b(e, "absolutePos") && (e.posTotal = e.absolutePos, delete e.absolutePos), !e.negTotal && c(e.absoluteNeg) && b(e, "absoluteNeg") && (e.negTotal = e.absoluteNeg, delete e.absoluteNeg)), f.isSum || (e.connectorThreshold = e.threshold + e.stackTotal), i.reversed ? (m = L >= 0 ? p - L : p + L, y = p) : (m = p, y = p - L), f.below = m <= a, S.y = i.translate(m, !1, !0, !1, !0), S.height = Math.abs(S.y - i.translate(y, !1, !0, !1, !0));
	            let s = i.waterfall.dummyStackItem;
	            s && (s.x = t, s.label = n[t].label, s.setOffset(this.pointXOffset || 0, this.barW || 0, this.stackedYNeg[t], this.stackedYPos[t], void 0, this.xAxis));
	          }
	        } else p = Math.max(h, h + L) + M[0], S.y = i.translate(p, !1, !0, !1, !0), f.isSum ? (S.y = i.translate(M[1], !1, !0, !1, !0), S.height = Math.min(i.translate(M[0], !1, !0, !1, !0), i.len) - S.y, f.below = M[1] <= a) : f.isIntermediateSum ? (L >= 0 ? (m = M[1] + l, y = l) : (m = l, y = M[1] + l), i.reversed && (m ^= y, y ^= m, m ^= y), S.y = i.translate(m, !1, !0, !1, !0), S.height = Math.abs(S.y - Math.min(i.translate(y, !1, !0, !1, !0), i.len)), l += M[1], f.below = m <= a) : (S.height = x > 0 ? i.translate(h, !1, !0, !1, !0) - S.y : i.translate(h, !1, !0, !1, !0) - i.translate(h - x, !1, !0, !1, !0), h += x, f.below = h < a), S.height < 0 && (S.y += S.height, S.height *= -1);
	        f.plotY = S.y = Math.round(S.y || 0) - this.borderWidth % 2 / 2, S.height = Math.max(Math.round(S.height || 0), .001), f.yBottom = S.y + S.height, S.height <= s && !f.isNull ? (S.height = s, S.y -= o, f.plotY = S.y, L < 0 ? f.minPointLengthOffset = -o : f.minPointLengthOffset = o) : (f.isNull && (S.width = 0), f.minPointLengthOffset = 0);
	        let k = f.plotY + (f.negative ? S.height : 0);
	        f.below && (f.plotY += S.height), f.tooltipPos && (this.chart.inverted ? f.tooltipPos[0] = i.len - k : f.tooltipPos[1] = k), f.isInside = this.isPointInside(f), u(!0, f.shapeArgs, S);
	      }
	    }, {
	      order: 2
	    }), t.registerSeriesType("waterfall", m), m;
	  }), i(e, "masters/highcharts-more.src.js", [e["Core/Globals.js"], e["Core/Series/SeriesRegistry.js"], e["Extensions/Pane/Pane.js"], e["Series/Bubble/BubbleSeries.js"], e["Series/PackedBubble/PackedBubbleSeries.js"], e["Series/PolarComposition.js"], e["Series/Waterfall/WaterfallSeries.js"]], function (t, e, i, s, o, a, r) {
	    s.compose(t.Axis, t.Chart, t.Legend, t.Series), o.compose(t.Axis, t.Chart, t.Legend, t.Series), i.compose(t.Chart, t.Pointer), a.compose(t.Axis, t.Chart, t.Pointer, t.Series, t.Tick, t.Point, e.seriesTypes.areasplinerange, e.seriesTypes.column, e.seriesTypes.line, e.seriesTypes.spline), r.compose(t.Axis, t.Chart);
	  });
	}); 
} (highchartsMore));

var highchartsMoreExports = highchartsMore.exports;
var More = /*@__PURE__*/getDefaultExportFromCjs(highchartsMoreExports);

// NB: importing Highcharts rather than the Chart module as could not quite get
// highcharts-more working using Chart or when both Chart + Highcharts loaded.
var $$3 = window.$;
More(Highcharts$1);
var _default$r = /*#__PURE__*/function (_Controller) {
  function _default() {
    _classCallCheck$1(this, _default);
    return _callSuper(this, _default, arguments);
  }
  _inherits$1(_default, _Controller);
  return _createClass$1(_default, [{
    key: "connect",
    value: function connect() {
      var _this = this;
      $$3.getJSON(this.data.get("url"), function (data) {
        Highcharts$1.chart(_this.element, {
          chart: {
            scrollablePlotArea: {
              minWidth: 600,
              scrollPositionX: 1
            }
          },
          title: {
            //text: "Peritoneal Equilibration Test",
            text: "",
            align: "left"
          },
          subtitle: {
            text: "",
            align: "left"
          },
          xAxis: {
            title: {
              text: "D/P creatinine (4hrs)"
            },
            type: "linear",
            labels: {
              overflow: "justify"
            },
            plotBands: [{
              from: 0.3,
              to: 0.5,
              color: "rgba(68, 170, 213, 0.1)",
              label: {
                text: "Low",
                style: {
                  color: "#606060"
                }
              }
            }, {
              from: 0.5,
              to: 0.65,
              color: "rgba(0, 0, 0, 0)",
              label: {
                text: "Low average",
                style: {
                  color: "#606060"
                }
              }
            }, {
              from: 0.65,
              to: 0.82,
              color: "rgba(68, 170, 213, 0.1)",
              label: {
                text: "High average",
                style: {
                  color: "#606060"
                }
              }
            }, {
              from: 0.82,
              to: 1.0,
              color: "rgba(0, 0, 0, 0)",
              label: {
                text: "High",
                style: {
                  color: "#606060"
                }
              }
            }]
          },
          yAxis: {
            title: {
              text: "Net Ultrafiltration (mls)"
            },
            tickInterval: 200,
            minorGridLineWidth: 0,
            gridLineWidth: 0,
            alternateGridColor: null,
            floor: -600,
            plotLines: [{
              color: "#BBB",
              width: 1,
              value: 0
            }]
          },
          tooltip: {
            formatter: function formatter() {
              return "<br>D_Pcr <b>" + this.x + "</b><br>" + "netUF <b>" + this.y + "</b>";
            }
          },
          plotOptions: {
            pointStart: 0.3,
            line: {
              dataLabels: {
                enabled: true,
                format: "{point.index}",
                style: {
                  fontSize: "15px"
                }
              }
            },
            series: {
              enableMouseTracking: false
            },
            dataLabels: {
              enabled: true,
              style: {
                fontWeight: "bold"
              }
            }
          },
          series: [{
            name: "Expected",
            color: "#00a499",
            //"#D970D9",
            showInLegend: true,
            type: "polygon",
            data: [[0.36, 400], [0.36, 1000], [0.5, 1000], [0.9, 600], [0.9, 300], [0.6, 100], [0.36, 400]]
          }, {
            name: "Warning",
            color: "#fff495",
            showInLegend: true,
            type: "polygon",
            data: [[0.6, 100], [0.9, 300], [1.0, 200], [1.0, -600], [0.75, -600], [0.6, 100]]
          }, {
            // patient data
            color: "#040481",
            showInLegend: false,
            enableMouseTracking: true,
            data: data
          }],
          navigation: {
            menuItemStyle: {
              fontSize: "10px"
            }
          }
        });
        _this.element.style.overflow = "unset";
      });
    }
  }]);
}(Controller);

var _default$q = /*#__PURE__*/function (_Controller) {
  function _default() {
    _classCallCheck$1(this, _default);
    return _callSuper(this, _default, arguments);
  }
  _inherits$1(_default, _Controller);
  return _createClass$1(_default, [{
    key: "connect",
    value: function connect() {
      // let data = this.data.get("chartData")
      // let chartId = this.chartTarget.id

      // console.log(chartId)
      // let json = [
      //     {
      //       name: "",
      //       data: data
      //     }
      //   ]
      console.log("Not implemented");
      //Highcharts.SparkLine(this.chartTarget, {})
      //     series: [{
      //         name: '',
      //         data: data
      //    }]
      // })
      //new Chartkick.LineChart(chartId, json, this.chartOptions)
    }

    // get chartOptions() {
    //   return {
    //     library: {
    //       chart: {
    //         type: "area",
    //         margin: [0, 0, 0, 0],
    //         height: 20,
    //         width: 80,
    //         skipClone: true,
    //         style: {
    //           overflow: "visible"
    //         }
    //       },
    //       credits: {
    //         enabled: false
    //       },
    //       title: "",
    //       xAxis: {
    //         type: "datetime",
    //         tickPositions: [],
    //         labels: {
    //           enabled: false
    //         },
    //         startOnTick: false,
    //         endOnTick: false,
    //         title: {
    //           text: null
    //         }
    //       },
    //       legend: {
    //         enabled: false
    //       },
    //       yAxis: {
    //         tickPositions: [0],
    //         endOnTick: false,
    //         startOnTick: false,
    //         title: {
    //           text: null
    //         },
    //         min: 0,
    //         labels: {
    //           enabled: false
    //         }
    //       },
    //       tooltip: {
    //         hideDelay: 0,
    //         outside: true,
    //         shared: true,
    //         xDateFormat: '%d-%b-%Y'
    //       },
    //       plotOptions: {
    //         series: {
    //           animation: false,
    //           lineWidth: 1,
    //           shadow: false,
    //           states: {
    //             hover: {
    //               lineWidth: 1
    //             }
    //           },
    //           marker: {
    //             radius: 1,
    //             states: {
    //               hover: {
    //                 radius: 2
    //               }
    //             }
    //           },
    //           fillOpacity: 0.25
    //         },
    //         column: {
    //           negativeColor: "#910000",
    //           borderColor: "silver"
    //         }
    //       }
    //     }
    //   }
    // }
  }]);
}(Controller);
/**
* Create a constructor for sparklines that takes some sensible defaults and merges in the individual
* chart options.
*/
/*
window.Highcharts.SparkLine = function (a, b, c) {
console.log("defining1");
var hasRenderToArg = typeof a === 'string' || a.nodeName,
    options = arguments[hasRenderToArg ? 1 : 0],
    defaultOptions = {
        chart: {
            renderTo: (options.chart && options.chart.renderTo) || this,
            backgroundColor: null,
            borderWidth: 0,
            type: 'area',
            margin: [2, 0, 2, 0],
            width: 120,
            height: 20,
            style: {
                overflow: 'visible'
            },
             // small optimization, saves 1-2 ms each sparkline
            skipClone: true
        },
        title: {
            text: ''
        },
        credits: {
            enabled: false
        },
        xAxis: {
            labels: {
                enabled: false
            },
            title: {
                text: null
            },
            startOnTick: false,
            endOnTick: false,
            tickPositions: []
        },
        yAxis: {
            endOnTick: false,
            startOnTick: false,
            labels: {
                enabled: false
            },
            title: {
                text: null
            },
            tickPositions: [0]
        },
        legend: {
            enabled: false
        },
        tooltip: {
            hideDelay: 0,
            outside: true,
            shared: true
        },
        plotOptions: {
            series: {
                animation: false,
                lineWidth: 1,
                shadow: false,
                states: {
                    hover: {
                        lineWidth: 1
                    }
                },
                marker: {
                    radius: 1,
                    states: {
                        hover: {
                            radius: 2
                        }
                    }
                },
                fillOpacity: 0.25
            },
            column: {
                negativeColor: '#910000',
                borderColor: 'silver'
            }
        }
    };
 options = Highcharts.merge(defaultOptions, options);
 return hasRenderToArg ?
    new Highcharts.Chart(a, options, c) :
    new Highcharts.Chart(options, b)
}
 */
_defineProperty$2(_default$q, "targets", ["chart"]);

// Controller to enable collapsing elements of a nav/menu to for example
// allow a more dense menu that can simplifies by hiding/collapsing sections.
//
// Example slim markup:
//
// div(data-controller="collapsible" data-collapsible-open-class="open")
//   a(data-action="collapsible#open" data-collapsible-target="link" href="#") X
//   div.collapsible(data-collapsible-target="section")
//     p XXX
//   a(data-action="collapsible#open" data-collapsible-target="link" href="#") Y
//   div.collapsible(data-collapsible-target="section")
//     p YYY
var _default$p = /*#__PURE__*/function (_Controller) {
  function _default() {
    _classCallCheck$1(this, _default);
    return _callSuper(this, _default, arguments);
  }
  _inherits$1(_default, _Controller);
  return _createClass$1(_default, [{
    key: "connect",
    value: function connect() {
      // TODO: We could support an initial open section here for example.
    }

    // When a user clicks on a link with the target of "link", we determine its index,
    // hide all "section" targets initially, then just show the section with the
    // current index. This is a similar approach to the one we take with the tabs controller.
  }, {
    key: "open",
    value: function open(event) {
      var _this = this;
      var index = this.linkTargets.indexOf(event.currentTarget);
      this.sectionTargets.forEach(function (elem, idx) {
        elem.classList.remove(_this.openClass);
        if (idx == index) {
          elem.classList.add(_this.openClass);
        }
      });
    }
  }]);
}(Controller);
_defineProperty$2(_default$p, "targets", ["section", "link"]);
_defineProperty$2(_default$p, "classes", ["open"]);

var _default$o = /*#__PURE__*/function (_Controller) {
  function _default() {
    _classCallCheck$1(this, _default);
    return _callSuper(this, _default, arguments);
  }
  _inherits$1(_default, _Controller);
  return _createClass$1(_default, [{
    key: "handleSelectChange",
    value: function handleSelectChange() {
      this.populateSelect(this.sourceTarget.value);
    }
  }, {
    key: "populateSelect",
    value: function populateSelect(sourceId) {
      var _this = this;
      var targetId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      fetch("/".concat(this.data.get("sourceRoutePart"), "/").concat(sourceId, "/").concat(this.data.get("targetRoutePart"), ".json"), {
        credentials: "same-origin"
      }).then(function (response) {
        return response.json();
      }).then(function (data) {
        var selectBox = _this.targetTarget;
        selectBox.innerHTML = "";
        selectBox.appendChild(document.createElement("option")); // blank option
        data.forEach(function (item) {
          var opt = document.createElement("option");
          opt.value = item.id;
          opt.innerHTML = item[_this.data.get("displayAttribute")];
          opt.selected = parseInt(targetId) === item.id;
          selectBox.appendChild(opt);
        });
      });
    }
  }]);
}(Controller);
_defineProperty$2(_default$o, "targets", ["source", "target"]);

// Used with patient attachments aka linked files.
var _default$n = /*#__PURE__*/function (_Controller) {
  function _default() {
    _classCallCheck$1(this, _default);
    return _callSuper(this, _default, arguments);
  }
  _inherits$1(_default, _Controller);
  return _createClass$1(_default, [{
    key: "toggleFileInputs",
    value:
    // When the attachment type changes we examine a data attribute on the selected option
    // and show/hide the relevant file input (a text input if its an external stored, otherwise
    // a conventional file input).
    function toggleFileInputs(event) {
      var selectedOption = event.target.querySelector("option:checked");
      var storeFileExternally = "true" == selectedOption.getAttribute("data-store-file-externally");
      this.fileBrowserTarget.style.display = storeFileExternally ? "none" : "block";
      this.externalLocationTarget.style.display = storeFileExternally ? "block" : "none";
    }
  }]);
}(Controller);
_defineProperty$2(_default$n, "targets", ["fileBrowser", "externalLocation"]);

var _default$m = /*#__PURE__*/function (_Controller) {
  function _default() {
    _classCallCheck$1(this, _default);
    return _callSuper(this, _default, arguments);
  }
  _inherits$1(_default, _Controller);
  return _createClass$1(_default, [{
    key: "connect",
    value: function connect() {
      Renalware.PatientSearch.init();
    }
  }]);
}(Controller);

/**!
 * Sortable 1.15.2
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _typeof$1(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1 = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof$1 = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }
  return _typeof$1(obj);
}
function _defineProperty$1(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
var version = "1.15.2";
function userAgent(pattern) {
  if (typeof window !== 'undefined' && window.navigator) {
    return !! /*@__PURE__*/navigator.userAgent.match(pattern);
  }
}
var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
var Edge = userAgent(/Edge/i);
var FireFox = userAgent(/firefox/i);
var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
var IOS = userAgent(/iP(ad|od|hone)/i);
var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);
var captureMode = {
  capture: false,
  passive: false
};
function on(el, event, fn) {
  el.addEventListener(event, fn, !IE11OrLess && captureMode);
}
function off(el, event, fn) {
  el.removeEventListener(event, fn, !IE11OrLess && captureMode);
}
function matches( /**HTMLElement*/el, /**String*/selector) {
  if (!selector) return;
  selector[0] === '>' && (selector = selector.substring(1));
  if (el) {
    try {
      if (el.matches) {
        return el.matches(selector);
      } else if (el.msMatchesSelector) {
        return el.msMatchesSelector(selector);
      } else if (el.webkitMatchesSelector) {
        return el.webkitMatchesSelector(selector);
      }
    } catch (_) {
      return false;
    }
  }
  return false;
}
function getParentOrHost(el) {
  return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
}
function closest( /**HTMLElement*/el, /**String*/selector, /**HTMLElement*/ctx, includeCTX) {
  if (el) {
    ctx = ctx || document;
    do {
      if (selector != null && (selector[0] === '>' ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {
        return el;
      }
      if (el === ctx) break;
      /* jshint boss:true */
    } while (el = getParentOrHost(el));
  }
  return null;
}
var R_SPACE = /\s+/g;
function toggleClass$1(el, name, state) {
  if (el && name) {
    if (el.classList) {
      el.classList[state ? 'add' : 'remove'](name);
    } else {
      var className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');
      el.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');
    }
  }
}
function css(el, prop, val) {
  var style = el && el.style;
  if (style) {
    if (val === void 0) {
      if (document.defaultView && document.defaultView.getComputedStyle) {
        val = document.defaultView.getComputedStyle(el, '');
      } else if (el.currentStyle) {
        val = el.currentStyle;
      }
      return prop === void 0 ? val : val[prop];
    } else {
      if (!(prop in style) && prop.indexOf('webkit') === -1) {
        prop = '-webkit-' + prop;
      }
      style[prop] = val + (typeof val === 'string' ? '' : 'px');
    }
  }
}
function matrix(el, selfOnly) {
  var appliedTransforms = '';
  if (typeof el === 'string') {
    appliedTransforms = el;
  } else {
    do {
      var transform = css(el, 'transform');
      if (transform && transform !== 'none') {
        appliedTransforms = transform + ' ' + appliedTransforms;
      }
      /* jshint boss:true */
    } while (!selfOnly && (el = el.parentNode));
  }
  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  /*jshint -W056 */
  return matrixFn && new matrixFn(appliedTransforms);
}
function find(ctx, tagName, iterator) {
  if (ctx) {
    var list = ctx.getElementsByTagName(tagName),
      i = 0,
      n = list.length;
    if (iterator) {
      for (; i < n; i++) {
        iterator(list[i], i);
      }
    }
    return list;
  }
  return [];
}
function getWindowScrollingElement() {
  var scrollingElement = document.scrollingElement;
  if (scrollingElement) {
    return scrollingElement;
  } else {
    return document.documentElement;
  }
}

/**
 * Returns the "bounding client rect" of given element
 * @param  {HTMLElement} el                       The element whose boundingClientRect is wanted
 * @param  {[Boolean]} relativeToContainingBlock  Whether the rect should be relative to the containing block of (including) the container
 * @param  {[Boolean]} relativeToNonStaticParent  Whether the rect should be relative to the relative parent of (including) the contaienr
 * @param  {[Boolean]} undoScale                  Whether the container's scale() should be undone
 * @param  {[HTMLElement]} container              The parent the element will be placed in
 * @return {Object}                               The boundingClientRect of el, with specified adjustments
 */
function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
  if (!el.getBoundingClientRect && el !== window) return;
  var elRect, top, left, bottom, right, height, width;
  if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {
    elRect = el.getBoundingClientRect();
    top = elRect.top;
    left = elRect.left;
    bottom = elRect.bottom;
    right = elRect.right;
    height = elRect.height;
    width = elRect.width;
  } else {
    top = 0;
    left = 0;
    bottom = window.innerHeight;
    right = window.innerWidth;
    height = window.innerHeight;
    width = window.innerWidth;
  }
  if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
    // Adjust for translate()
    container = container || el.parentNode;

    // solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)
    // Not needed on <= IE11
    if (!IE11OrLess) {
      do {
        if (container && container.getBoundingClientRect && (css(container, 'transform') !== 'none' || relativeToNonStaticParent && css(container, 'position') !== 'static')) {
          var containerRect = container.getBoundingClientRect();

          // Set relative to edges of padding box of container
          top -= containerRect.top + parseInt(css(container, 'border-top-width'));
          left -= containerRect.left + parseInt(css(container, 'border-left-width'));
          bottom = top + elRect.height;
          right = left + elRect.width;
          break;
        }
        /* jshint boss:true */
      } while (container = container.parentNode);
    }
  }
  if (undoScale && el !== window) {
    // Adjust for scale()
    var elMatrix = matrix(container || el),
      scaleX = elMatrix && elMatrix.a,
      scaleY = elMatrix && elMatrix.d;
    if (elMatrix) {
      top /= scaleY;
      left /= scaleX;
      width /= scaleX;
      height /= scaleY;
      bottom = top + height;
      right = left + width;
    }
  }
  return {
    top: top,
    left: left,
    bottom: bottom,
    right: right,
    width: width,
    height: height
  };
}

/**
 * Checks if a side of an element is scrolled past a side of its parents
 * @param  {HTMLElement}  el           The element who's side being scrolled out of view is in question
 * @param  {String}       elSide       Side of the element in question ('top', 'left', 'right', 'bottom')
 * @param  {String}       parentSide   Side of the parent in question ('top', 'left', 'right', 'bottom')
 * @return {HTMLElement}               The parent scroll element that the el's side is scrolled past, or null if there is no such element
 */
function isScrolledPast(el, elSide, parentSide) {
  var parent = getParentAutoScrollElement(el, true),
    elSideVal = getRect(el)[elSide];

  /* jshint boss:true */
  while (parent) {
    var parentSideVal = getRect(parent)[parentSide],
      visible = void 0;
    {
      visible = elSideVal >= parentSideVal;
    }
    if (!visible) return parent;
    if (parent === getWindowScrollingElement()) break;
    parent = getParentAutoScrollElement(parent, false);
  }
  return false;
}

/**
 * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)
 * and non-draggable elements
 * @param  {HTMLElement} el       The parent element
 * @param  {Number} childNum      The index of the child
 * @param  {Object} options       Parent Sortable's options
 * @return {HTMLElement}          The child at index childNum, or null if not found
 */
function getChild(el, childNum, options, includeDragEl) {
  var currentChild = 0,
    i = 0,
    children = el.children;
  while (i < children.length) {
    if (children[i].style.display !== 'none' && children[i] !== Sortable.ghost && (includeDragEl || children[i] !== Sortable.dragged) && closest(children[i], options.draggable, el, false)) {
      if (currentChild === childNum) {
        return children[i];
      }
      currentChild++;
    }
    i++;
  }
  return null;
}

/**
 * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)
 * @param  {HTMLElement} el       Parent element
 * @param  {selector} selector    Any other elements that should be ignored
 * @return {HTMLElement}          The last child, ignoring ghostEl
 */
function lastChild(el, selector) {
  var last = el.lastElementChild;
  while (last && (last === Sortable.ghost || css(last, 'display') === 'none' || selector && !matches(last, selector))) {
    last = last.previousElementSibling;
  }
  return last || null;
}

/**
 * Returns the index of an element within its parent for a selected set of
 * elements
 * @param  {HTMLElement} el
 * @param  {selector} selector
 * @return {number}
 */
function index$1(el, selector) {
  var index = 0;
  if (!el || !el.parentNode) {
    return -1;
  }

  /* jshint boss:true */
  while (el = el.previousElementSibling) {
    if (el.nodeName.toUpperCase() !== 'TEMPLATE' && el !== Sortable.clone && (!selector || matches(el, selector))) {
      index++;
    }
  }
  return index;
}

/**
 * Returns the scroll offset of the given element, added with all the scroll offsets of parent elements.
 * The value is returned in real pixels.
 * @param  {HTMLElement} el
 * @return {Array}             Offsets in the format of [left, top]
 */
function getRelativeScrollOffset(el) {
  var offsetLeft = 0,
    offsetTop = 0,
    winScroller = getWindowScrollingElement();
  if (el) {
    do {
      var elMatrix = matrix(el),
        scaleX = elMatrix.a,
        scaleY = elMatrix.d;
      offsetLeft += el.scrollLeft * scaleX;
      offsetTop += el.scrollTop * scaleY;
    } while (el !== winScroller && (el = el.parentNode));
  }
  return [offsetLeft, offsetTop];
}

/**
 * Returns the index of the object within the given array
 * @param  {Array} arr   Array that may or may not hold the object
 * @param  {Object} obj  An object that has a key-value pair unique to and identical to a key-value pair in the object you want to find
 * @return {Number}      The index of the object in the array, or -1
 */
function indexOfObject(arr, obj) {
  for (var i in arr) {
    if (!arr.hasOwnProperty(i)) continue;
    for (var key in obj) {
      if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);
    }
  }
  return -1;
}
function getParentAutoScrollElement(el, includeSelf) {
  // skip to window
  if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();
  var elem = el;
  var gotSelf = false;
  do {
    // we don't need to get elem css if it isn't even overflowing in the first place (performance)
    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
      var elemCSS = css(elem);
      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == 'auto' || elemCSS.overflowX == 'scroll') || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == 'auto' || elemCSS.overflowY == 'scroll')) {
        if (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();
        if (gotSelf || includeSelf) return elem;
        gotSelf = true;
      }
    }
    /* jshint boss:true */
  } while (elem = elem.parentNode);
  return getWindowScrollingElement();
}
function extend$1(dst, src) {
  if (dst && src) {
    for (var key in src) {
      if (src.hasOwnProperty(key)) {
        dst[key] = src[key];
      }
    }
  }
  return dst;
}
function isRectEqual(rect1, rect2) {
  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
}
var _throttleTimeout;
function throttle(callback, ms) {
  return function () {
    if (!_throttleTimeout) {
      var args = arguments,
        _this = this;
      if (args.length === 1) {
        callback.call(_this, args[0]);
      } else {
        callback.apply(_this, args);
      }
      _throttleTimeout = setTimeout(function () {
        _throttleTimeout = void 0;
      }, ms);
    }
  };
}
function cancelThrottle() {
  clearTimeout(_throttleTimeout);
  _throttleTimeout = void 0;
}
function scrollBy(el, x, y) {
  el.scrollLeft += x;
  el.scrollTop += y;
}
function clone(el) {
  var Polymer = window.Polymer;
  var $ = window.jQuery || window.Zepto;
  if (Polymer && Polymer.dom) {
    return Polymer.dom(el).cloneNode(true);
  } else if ($) {
    return $(el).clone(true)[0];
  } else {
    return el.cloneNode(true);
  }
}
function getChildContainingRectFromElement(container, options, ghostEl) {
  var rect = {};
  Array.from(container.children).forEach(function (child) {
    var _rect$left, _rect$top, _rect$right, _rect$bottom;
    if (!closest(child, options.draggable, container, false) || child.animated || child === ghostEl) return;
    var childRect = getRect(child);
    rect.left = Math.min((_rect$left = rect.left) !== null && _rect$left !== void 0 ? _rect$left : Infinity, childRect.left);
    rect.top = Math.min((_rect$top = rect.top) !== null && _rect$top !== void 0 ? _rect$top : Infinity, childRect.top);
    rect.right = Math.max((_rect$right = rect.right) !== null && _rect$right !== void 0 ? _rect$right : -Infinity, childRect.right);
    rect.bottom = Math.max((_rect$bottom = rect.bottom) !== null && _rect$bottom !== void 0 ? _rect$bottom : -Infinity, childRect.bottom);
  });
  rect.width = rect.right - rect.left;
  rect.height = rect.bottom - rect.top;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
var expando = 'Sortable' + new Date().getTime();
function AnimationStateManager() {
  var animationStates = [],
    animationCallbackId;
  return {
    captureAnimationState: function captureAnimationState() {
      animationStates = [];
      if (!this.options.animation) return;
      var children = [].slice.call(this.el.children);
      children.forEach(function (child) {
        if (css(child, 'display') === 'none' || child === Sortable.ghost) return;
        animationStates.push({
          target: child,
          rect: getRect(child)
        });
        var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect);

        // If animating: compensate for current animation
        if (child.thisAnimationDuration) {
          var childMatrix = matrix(child, true);
          if (childMatrix) {
            fromRect.top -= childMatrix.f;
            fromRect.left -= childMatrix.e;
          }
        }
        child.fromRect = fromRect;
      });
    },
    addAnimationState: function addAnimationState(state) {
      animationStates.push(state);
    },
    removeAnimationState: function removeAnimationState(target) {
      animationStates.splice(indexOfObject(animationStates, {
        target: target
      }), 1);
    },
    animateAll: function animateAll(callback) {
      var _this = this;
      if (!this.options.animation) {
        clearTimeout(animationCallbackId);
        if (typeof callback === 'function') callback();
        return;
      }
      var animating = false,
        animationTime = 0;
      animationStates.forEach(function (state) {
        var time = 0,
          target = state.target,
          fromRect = target.fromRect,
          toRect = getRect(target),
          prevFromRect = target.prevFromRect,
          prevToRect = target.prevToRect,
          animatingRect = state.rect,
          targetMatrix = matrix(target, true);
        if (targetMatrix) {
          // Compensate for current animation
          toRect.top -= targetMatrix.f;
          toRect.left -= targetMatrix.e;
        }
        target.toRect = toRect;
        if (target.thisAnimationDuration) {
          // Could also check if animatingRect is between fromRect and toRect
          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) &&
          // Make sure animatingRect is on line between toRect & fromRect
          (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
            // If returning to same place as started from animation and on same axis
            time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
          }
        }

        // if fromRect != toRect: animate
        if (!isRectEqual(toRect, fromRect)) {
          target.prevFromRect = fromRect;
          target.prevToRect = toRect;
          if (!time) {
            time = _this.options.animation;
          }
          _this.animate(target, animatingRect, toRect, time);
        }
        if (time) {
          animating = true;
          animationTime = Math.max(animationTime, time);
          clearTimeout(target.animationResetTimer);
          target.animationResetTimer = setTimeout(function () {
            target.animationTime = 0;
            target.prevFromRect = null;
            target.fromRect = null;
            target.prevToRect = null;
            target.thisAnimationDuration = null;
          }, time);
          target.thisAnimationDuration = time;
        }
      });
      clearTimeout(animationCallbackId);
      if (!animating) {
        if (typeof callback === 'function') callback();
      } else {
        animationCallbackId = setTimeout(function () {
          if (typeof callback === 'function') callback();
        }, animationTime);
      }
      animationStates = [];
    },
    animate: function animate(target, currentRect, toRect, duration) {
      if (duration) {
        css(target, 'transition', '');
        css(target, 'transform', '');
        var elMatrix = matrix(this.el),
          scaleX = elMatrix && elMatrix.a,
          scaleY = elMatrix && elMatrix.d,
          translateX = (currentRect.left - toRect.left) / (scaleX || 1),
          translateY = (currentRect.top - toRect.top) / (scaleY || 1);
        target.animatingX = !!translateX;
        target.animatingY = !!translateY;
        css(target, 'transform', 'translate3d(' + translateX + 'px,' + translateY + 'px,0)');
        this.forRepaintDummy = repaint(target); // repaint

        css(target, 'transition', 'transform ' + duration + 'ms' + (this.options.easing ? ' ' + this.options.easing : ''));
        css(target, 'transform', 'translate3d(0,0,0)');
        typeof target.animated === 'number' && clearTimeout(target.animated);
        target.animated = setTimeout(function () {
          css(target, 'transition', '');
          css(target, 'transform', '');
          target.animated = false;
          target.animatingX = false;
          target.animatingY = false;
        }, duration);
      }
    }
  };
}
function repaint(target) {
  return target.offsetWidth;
}
function calculateRealTime(animatingRect, fromRect, toRect, options) {
  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
}
var plugins = [];
var defaults$1 = {
  initializeByDefault: true
};
var PluginManager = {
  mount: function mount(plugin) {
    // Set default static properties
    for (var option in defaults$1) {
      if (defaults$1.hasOwnProperty(option) && !(option in plugin)) {
        plugin[option] = defaults$1[option];
      }
    }
    plugins.forEach(function (p) {
      if (p.pluginName === plugin.pluginName) {
        throw "Sortable: Cannot mount plugin ".concat(plugin.pluginName, " more than once");
      }
    });
    plugins.push(plugin);
  },
  pluginEvent: function pluginEvent(eventName, sortable, evt) {
    var _this = this;
    this.eventCanceled = false;
    evt.cancel = function () {
      _this.eventCanceled = true;
    };
    var eventNameGlobal = eventName + 'Global';
    plugins.forEach(function (plugin) {
      if (!sortable[plugin.pluginName]) return;
      // Fire global events if it exists in this sortable
      if (sortable[plugin.pluginName][eventNameGlobal]) {
        sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({
          sortable: sortable
        }, evt));
      }

      // Only fire plugin event if plugin is enabled in this sortable,
      // and plugin has event defined
      if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
        sortable[plugin.pluginName][eventName](_objectSpread2({
          sortable: sortable
        }, evt));
      }
    });
  },
  initializePlugins: function initializePlugins(sortable, el, defaults, options) {
    plugins.forEach(function (plugin) {
      var pluginName = plugin.pluginName;
      if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;
      var initialized = new plugin(sortable, el, sortable.options);
      initialized.sortable = sortable;
      initialized.options = sortable.options;
      sortable[pluginName] = initialized;

      // Add default options from plugin
      _extends(defaults, initialized.defaults);
    });
    for (var option in sortable.options) {
      if (!sortable.options.hasOwnProperty(option)) continue;
      var modified = this.modifyOption(sortable, option, sortable.options[option]);
      if (typeof modified !== 'undefined') {
        sortable.options[option] = modified;
      }
    }
  },
  getEventProperties: function getEventProperties(name, sortable) {
    var eventProperties = {};
    plugins.forEach(function (plugin) {
      if (typeof plugin.eventProperties !== 'function') return;
      _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));
    });
    return eventProperties;
  },
  modifyOption: function modifyOption(sortable, name, value) {
    var modifiedValue;
    plugins.forEach(function (plugin) {
      // Plugin must exist on the Sortable
      if (!sortable[plugin.pluginName]) return;

      // If static option listener exists for this option, call in the context of the Sortable's instance of this plugin
      if (plugin.optionListeners && typeof plugin.optionListeners[name] === 'function') {
        modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);
      }
    });
    return modifiedValue;
  }
};
function dispatchEvent$1(_ref) {
  var sortable = _ref.sortable,
    rootEl = _ref.rootEl,
    name = _ref.name,
    targetEl = _ref.targetEl,
    cloneEl = _ref.cloneEl,
    toEl = _ref.toEl,
    fromEl = _ref.fromEl,
    oldIndex = _ref.oldIndex,
    newIndex = _ref.newIndex,
    oldDraggableIndex = _ref.oldDraggableIndex,
    newDraggableIndex = _ref.newDraggableIndex,
    originalEvent = _ref.originalEvent,
    putSortable = _ref.putSortable,
    extraEventProperties = _ref.extraEventProperties;
  sortable = sortable || rootEl && rootEl[expando];
  if (!sortable) return;
  var evt,
    options = sortable.options,
    onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1);
  // Support for new CustomEvent feature
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent(name, {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent('Event');
    evt.initEvent(name, true, true);
  }
  evt.to = toEl || rootEl;
  evt.from = fromEl || rootEl;
  evt.item = targetEl || rootEl;
  evt.clone = cloneEl;
  evt.oldIndex = oldIndex;
  evt.newIndex = newIndex;
  evt.oldDraggableIndex = oldDraggableIndex;
  evt.newDraggableIndex = newDraggableIndex;
  evt.originalEvent = originalEvent;
  evt.pullMode = putSortable ? putSortable.lastPutMode : undefined;
  var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));
  for (var option in allEventProperties) {
    evt[option] = allEventProperties[option];
  }
  if (rootEl) {
    rootEl.dispatchEvent(evt);
  }
  if (options[onName]) {
    options[onName].call(sortable, evt);
  }
}
var _excluded = ["evt"];
var pluginEvent = function pluginEvent(eventName, sortable) {
  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
    originalEvent = _ref.evt,
    data = _objectWithoutProperties(_ref, _excluded);
  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
    dragEl: dragEl,
    parentEl: parentEl,
    ghostEl: ghostEl,
    rootEl: rootEl,
    nextEl: nextEl,
    lastDownEl: lastDownEl,
    cloneEl: cloneEl,
    cloneHidden: cloneHidden,
    dragStarted: moved,
    putSortable: putSortable,
    activeSortable: Sortable.active,
    originalEvent: originalEvent,
    oldIndex: oldIndex,
    oldDraggableIndex: oldDraggableIndex,
    newIndex: newIndex,
    newDraggableIndex: newDraggableIndex,
    hideGhostForTarget: _hideGhostForTarget,
    unhideGhostForTarget: _unhideGhostForTarget,
    cloneNowHidden: function cloneNowHidden() {
      cloneHidden = true;
    },
    cloneNowShown: function cloneNowShown() {
      cloneHidden = false;
    },
    dispatchSortableEvent: function dispatchSortableEvent(name) {
      _dispatchEvent({
        sortable: sortable,
        name: name,
        originalEvent: originalEvent
      });
    }
  }, data));
};
function _dispatchEvent(info) {
  dispatchEvent$1(_objectSpread2({
    putSortable: putSortable,
    cloneEl: cloneEl,
    targetEl: dragEl,
    rootEl: rootEl,
    oldIndex: oldIndex,
    oldDraggableIndex: oldDraggableIndex,
    newIndex: newIndex,
    newDraggableIndex: newDraggableIndex
  }, info));
}
var dragEl,
  parentEl,
  ghostEl,
  rootEl,
  nextEl,
  lastDownEl,
  cloneEl,
  cloneHidden,
  oldIndex,
  newIndex,
  oldDraggableIndex,
  newDraggableIndex,
  activeGroup,
  putSortable,
  awaitingDragStarted = false,
  ignoreNextClick = false,
  sortables = [],
  tapEvt,
  touchEvt,
  lastDx,
  lastDy,
  tapDistanceLeft,
  tapDistanceTop,
  moved,
  lastTarget,
  lastDirection,
  pastFirstInvertThresh = false,
  isCircumstantialInvert = false,
  targetMoveDistance,
  // For positioning ghost absolutely
  ghostRelativeParent,
  ghostRelativeParentInitialScroll = [],
  // (left, top)

  _silent = false,
  savedInputChecked = [];

/** @const */
var documentExists = typeof document !== 'undefined',
  PositionGhostAbsolutely = IOS,
  CSSFloatProperty = Edge || IE11OrLess ? 'cssFloat' : 'float',
  // This will not pass for IE9, because IE9 DnD only works on anchors
  supportDraggable = documentExists && !ChromeForAndroid && !IOS && 'draggable' in document.createElement('div'),
  supportCssPointerEvents = function () {
    if (!documentExists) return;
    // false when <= IE11
    if (IE11OrLess) {
      return false;
    }
    var el = document.createElement('x');
    el.style.cssText = 'pointer-events:auto';
    return el.style.pointerEvents === 'auto';
  }(),
  _detectDirection = function _detectDirection(el, options) {
    var elCSS = css(el),
      elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth),
      child1 = getChild(el, 0, options),
      child2 = getChild(el, 1, options),
      firstChildCSS = child1 && css(child1),
      secondChildCSS = child2 && css(child2),
      firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width,
      secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;
    if (elCSS.display === 'flex') {
      return elCSS.flexDirection === 'column' || elCSS.flexDirection === 'column-reverse' ? 'vertical' : 'horizontal';
    }
    if (elCSS.display === 'grid') {
      return elCSS.gridTemplateColumns.split(' ').length <= 1 ? 'vertical' : 'horizontal';
    }
    if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== 'none') {
      var touchingSideChild2 = firstChildCSS["float"] === 'left' ? 'left' : 'right';
      return child2 && (secondChildCSS.clear === 'both' || secondChildCSS.clear === touchingSideChild2) ? 'vertical' : 'horizontal';
    }
    return child1 && (firstChildCSS.display === 'block' || firstChildCSS.display === 'flex' || firstChildCSS.display === 'table' || firstChildCSS.display === 'grid' || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === 'none' || child2 && elCSS[CSSFloatProperty] === 'none' && firstChildWidth + secondChildWidth > elWidth) ? 'vertical' : 'horizontal';
  },
  _dragElInRowColumn = function _dragElInRowColumn(dragRect, targetRect, vertical) {
    var dragElS1Opp = vertical ? dragRect.left : dragRect.top,
      dragElS2Opp = vertical ? dragRect.right : dragRect.bottom,
      dragElOppLength = vertical ? dragRect.width : dragRect.height,
      targetS1Opp = vertical ? targetRect.left : targetRect.top,
      targetS2Opp = vertical ? targetRect.right : targetRect.bottom,
      targetOppLength = vertical ? targetRect.width : targetRect.height;
    return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
  },
  /**
   * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.
   * @param  {Number} x      X position
   * @param  {Number} y      Y position
   * @return {HTMLElement}   Element of the first found nearest Sortable
   */
  _detectNearestEmptySortable = function _detectNearestEmptySortable(x, y) {
    var ret;
    sortables.some(function (sortable) {
      var threshold = sortable[expando].options.emptyInsertThreshold;
      if (!threshold || lastChild(sortable)) return;
      var rect = getRect(sortable),
        insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold,
        insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;
      if (insideHorizontally && insideVertically) {
        return ret = sortable;
      }
    });
    return ret;
  },
  _prepareGroup = function _prepareGroup(options) {
    function toFn(value, pull) {
      return function (to, from, dragEl, evt) {
        var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;
        if (value == null && (pull || sameGroup)) {
          // Default pull value
          // Default pull and put value if same group
          return true;
        } else if (value == null || value === false) {
          return false;
        } else if (pull && value === 'clone') {
          return value;
        } else if (typeof value === 'function') {
          return toFn(value(to, from, dragEl, evt), pull)(to, from, dragEl, evt);
        } else {
          var otherGroup = (pull ? to : from).options.group.name;
          return value === true || typeof value === 'string' && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
        }
      };
    }
    var group = {};
    var originalGroup = options.group;
    if (!originalGroup || _typeof$1(originalGroup) != 'object') {
      originalGroup = {
        name: originalGroup
      };
    }
    group.name = originalGroup.name;
    group.checkPull = toFn(originalGroup.pull, true);
    group.checkPut = toFn(originalGroup.put);
    group.revertClone = originalGroup.revertClone;
    options.group = group;
  },
  _hideGhostForTarget = function _hideGhostForTarget() {
    if (!supportCssPointerEvents && ghostEl) {
      css(ghostEl, 'display', 'none');
    }
  },
  _unhideGhostForTarget = function _unhideGhostForTarget() {
    if (!supportCssPointerEvents && ghostEl) {
      css(ghostEl, 'display', '');
    }
  };

// #1184 fix - Prevent click event on fallback if dragged but item not changed position
if (documentExists && !ChromeForAndroid) {
  document.addEventListener('click', function (evt) {
    if (ignoreNextClick) {
      evt.preventDefault();
      evt.stopPropagation && evt.stopPropagation();
      evt.stopImmediatePropagation && evt.stopImmediatePropagation();
      ignoreNextClick = false;
      return false;
    }
  }, true);
}
var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent(evt) {
  if (dragEl) {
    evt = evt.touches ? evt.touches[0] : evt;
    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);
    if (nearest) {
      // Create imitation event
      var event = {};
      for (var i in evt) {
        if (evt.hasOwnProperty(i)) {
          event[i] = evt[i];
        }
      }
      event.target = event.rootEl = nearest;
      event.preventDefault = void 0;
      event.stopPropagation = void 0;
      nearest[expando]._onDragOver(event);
    }
  }
};
var _checkOutsideTargetEl = function _checkOutsideTargetEl(evt) {
  if (dragEl) {
    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
  }
};

/**
 * @class  Sortable
 * @param  {HTMLElement}  el
 * @param  {Object}       [options]
 */
function Sortable(el, options) {
  if (!(el && el.nodeType && el.nodeType === 1)) {
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
  }
  this.el = el; // root element
  this.options = options = _extends({}, options);

  // Export instance
  el[expando] = this;
  var defaults = {
    group: null,
    sort: true,
    disabled: false,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(el.nodeName) ? '>li' : '>*',
    swapThreshold: 1,
    // percentage; 0 <= x <= 1
    invertSwap: false,
    // invert always
    invertedSwapThreshold: null,
    // will be set to same as swapThreshold if default
    removeCloneOnHide: true,
    direction: function direction() {
      return _detectDirection(el, this.options);
    },
    ghostClass: 'sortable-ghost',
    chosenClass: 'sortable-chosen',
    dragClass: 'sortable-drag',
    ignore: 'a, img',
    filter: null,
    preventOnFilter: true,
    animation: 0,
    easing: null,
    setData: function setData(dataTransfer, dragEl) {
      dataTransfer.setData('Text', dragEl.textContent);
    },
    dropBubble: false,
    dragoverBubble: false,
    dataIdAttr: 'data-id',
    delay: 0,
    delayOnTouchOnly: false,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: false,
    fallbackClass: 'sortable-fallback',
    fallbackOnBody: false,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    supportPointer: Sortable.supportPointer !== false && 'PointerEvent' in window && !Safari,
    emptyInsertThreshold: 5
  };
  PluginManager.initializePlugins(this, el, defaults);

  // Set default options
  for (var name in defaults) {
    !(name in options) && (options[name] = defaults[name]);
  }
  _prepareGroup(options);

  // Bind all private methods
  for (var fn in this) {
    if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
      this[fn] = this[fn].bind(this);
    }
  }

  // Setup drag mode
  this.nativeDraggable = options.forceFallback ? false : supportDraggable;
  if (this.nativeDraggable) {
    // Touch start threshold cannot be greater than the native dragstart threshold
    this.options.touchStartThreshold = 1;
  }

  // Bind events
  if (options.supportPointer) {
    on(el, 'pointerdown', this._onTapStart);
  } else {
    on(el, 'mousedown', this._onTapStart);
    on(el, 'touchstart', this._onTapStart);
  }
  if (this.nativeDraggable) {
    on(el, 'dragover', this);
    on(el, 'dragenter', this);
  }
  sortables.push(this.el);

  // Restore sorting
  options.store && options.store.get && this.sort(options.store.get(this) || []);

  // Add animation state manager
  _extends(this, AnimationStateManager());
}
Sortable.prototype = /** @lends Sortable.prototype */{
  constructor: Sortable,
  _isOutsideThisEl: function _isOutsideThisEl(target) {
    if (!this.el.contains(target) && target !== this.el) {
      lastTarget = null;
    }
  },
  _getDirection: function _getDirection(evt, target) {
    return typeof this.options.direction === 'function' ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
  },
  _onTapStart: function _onTapStart( /** Event|TouchEvent */evt) {
    if (!evt.cancelable) return;
    var _this = this,
      el = this.el,
      options = this.options,
      preventOnFilter = options.preventOnFilter,
      type = evt.type,
      touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === 'touch' && evt,
      target = (touch || evt).target,
      originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target,
      filter = options.filter;
    _saveInputCheckedState(el);

    // Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.
    if (dragEl) {
      return;
    }
    if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
      return; // only left button and enabled
    }

    // cancel dnd if original target is content editable
    if (originalTarget.isContentEditable) {
      return;
    }

    // Safari ignores further event handling after mousedown
    if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === 'SELECT') {
      return;
    }
    target = closest(target, options.draggable, el, false);
    if (target && target.animated) {
      return;
    }
    if (lastDownEl === target) {
      // Ignoring duplicate `down`
      return;
    }

    // Get the index of the dragged element within its parent
    oldIndex = index$1(target);
    oldDraggableIndex = index$1(target, options.draggable);

    // Check filter
    if (typeof filter === 'function') {
      if (filter.call(this, evt, target, this)) {
        _dispatchEvent({
          sortable: _this,
          rootEl: originalTarget,
          name: 'filter',
          targetEl: target,
          toEl: el,
          fromEl: el
        });
        pluginEvent('filter', _this, {
          evt: evt
        });
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return; // cancel dnd
      }
    } else if (filter) {
      filter = filter.split(',').some(function (criteria) {
        criteria = closest(originalTarget, criteria.trim(), el, false);
        if (criteria) {
          _dispatchEvent({
            sortable: _this,
            rootEl: criteria,
            name: 'filter',
            targetEl: target,
            fromEl: el,
            toEl: el
          });
          pluginEvent('filter', _this, {
            evt: evt
          });
          return true;
        }
      });
      if (filter) {
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return; // cancel dnd
      }
    }
    if (options.handle && !closest(originalTarget, options.handle, el, false)) {
      return;
    }

    // Prepare `dragstart`
    this._prepareDragStart(evt, touch, target);
  },
  _prepareDragStart: function _prepareDragStart( /** Event */evt, /** Touch */touch, /** HTMLElement */target) {
    var _this = this,
      el = _this.el,
      options = _this.options,
      ownerDocument = el.ownerDocument,
      dragStartFn;
    if (target && !dragEl && target.parentNode === el) {
      var dragRect = getRect(target);
      rootEl = el;
      dragEl = target;
      parentEl = dragEl.parentNode;
      nextEl = dragEl.nextSibling;
      lastDownEl = target;
      activeGroup = options.group;
      Sortable.dragged = dragEl;
      tapEvt = {
        target: dragEl,
        clientX: (touch || evt).clientX,
        clientY: (touch || evt).clientY
      };
      tapDistanceLeft = tapEvt.clientX - dragRect.left;
      tapDistanceTop = tapEvt.clientY - dragRect.top;
      this._lastX = (touch || evt).clientX;
      this._lastY = (touch || evt).clientY;
      dragEl.style['will-change'] = 'all';
      dragStartFn = function dragStartFn() {
        pluginEvent('delayEnded', _this, {
          evt: evt
        });
        if (Sortable.eventCanceled) {
          _this._onDrop();
          return;
        }
        // Delayed drag has been triggered
        // we can re-enable the events: touchmove/mousemove
        _this._disableDelayedDragEvents();
        if (!FireFox && _this.nativeDraggable) {
          dragEl.draggable = true;
        }

        // Bind the events: dragstart/dragend
        _this._triggerDragStart(evt, touch);

        // Drag start event
        _dispatchEvent({
          sortable: _this,
          name: 'choose',
          originalEvent: evt
        });

        // Chosen item
        toggleClass$1(dragEl, options.chosenClass, true);
      };

      // Disable "draggable"
      options.ignore.split(',').forEach(function (criteria) {
        find(dragEl, criteria.trim(), _disableDraggable);
      });
      on(ownerDocument, 'dragover', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'mousemove', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'touchmove', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'mouseup', _this._onDrop);
      on(ownerDocument, 'touchend', _this._onDrop);
      on(ownerDocument, 'touchcancel', _this._onDrop);

      // Make dragEl draggable (must be before delay for FireFox)
      if (FireFox && this.nativeDraggable) {
        this.options.touchStartThreshold = 4;
        dragEl.draggable = true;
      }
      pluginEvent('delayStart', this, {
        evt: evt
      });

      // Delay is impossible for native DnD in Edge or IE
      if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
        if (Sortable.eventCanceled) {
          this._onDrop();
          return;
        }
        // If the user moves the pointer or let go the click or touch
        // before the delay has been reached:
        // disable the delayed drag
        on(ownerDocument, 'mouseup', _this._disableDelayedDrag);
        on(ownerDocument, 'touchend', _this._disableDelayedDrag);
        on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);
        on(ownerDocument, 'mousemove', _this._delayedDragTouchMoveHandler);
        on(ownerDocument, 'touchmove', _this._delayedDragTouchMoveHandler);
        options.supportPointer && on(ownerDocument, 'pointermove', _this._delayedDragTouchMoveHandler);
        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
      } else {
        dragStartFn();
      }
    }
  },
  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler( /** TouchEvent|PointerEvent **/e) {
    var touch = e.touches ? e.touches[0] : e;
    if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
      this._disableDelayedDrag();
    }
  },
  _disableDelayedDrag: function _disableDelayedDrag() {
    dragEl && _disableDraggable(dragEl);
    clearTimeout(this._dragStartTimer);
    this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function _disableDelayedDragEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, 'mouseup', this._disableDelayedDrag);
    off(ownerDocument, 'touchend', this._disableDelayedDrag);
    off(ownerDocument, 'touchcancel', this._disableDelayedDrag);
    off(ownerDocument, 'mousemove', this._delayedDragTouchMoveHandler);
    off(ownerDocument, 'touchmove', this._delayedDragTouchMoveHandler);
    off(ownerDocument, 'pointermove', this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function _triggerDragStart( /** Event */evt, /** Touch */touch) {
    touch = touch || evt.pointerType == 'touch' && evt;
    if (!this.nativeDraggable || touch) {
      if (this.options.supportPointer) {
        on(document, 'pointermove', this._onTouchMove);
      } else if (touch) {
        on(document, 'touchmove', this._onTouchMove);
      } else {
        on(document, 'mousemove', this._onTouchMove);
      }
    } else {
      on(dragEl, 'dragend', this);
      on(rootEl, 'dragstart', this._onDragStart);
    }
    try {
      if (document.selection) {
        // Timeout neccessary for IE9
        _nextTick(function () {
          document.selection.empty();
        });
      } else {
        window.getSelection().removeAllRanges();
      }
    } catch (err) {}
  },
  _dragStarted: function _dragStarted(fallback, evt) {
    awaitingDragStarted = false;
    if (rootEl && dragEl) {
      pluginEvent('dragStarted', this, {
        evt: evt
      });
      if (this.nativeDraggable) {
        on(document, 'dragover', _checkOutsideTargetEl);
      }
      var options = this.options;

      // Apply effect
      !fallback && toggleClass$1(dragEl, options.dragClass, false);
      toggleClass$1(dragEl, options.ghostClass, true);
      Sortable.active = this;
      fallback && this._appendGhost();

      // Drag start event
      _dispatchEvent({
        sortable: this,
        name: 'start',
        originalEvent: evt
      });
    } else {
      this._nulling();
    }
  },
  _emulateDragOver: function _emulateDragOver() {
    if (touchEvt) {
      this._lastX = touchEvt.clientX;
      this._lastY = touchEvt.clientY;
      _hideGhostForTarget();
      var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
      var parent = target;
      while (target && target.shadowRoot) {
        target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        if (target === parent) break;
        parent = target;
      }
      dragEl.parentNode[expando]._isOutsideThisEl(target);
      if (parent) {
        do {
          if (parent[expando]) {
            var inserted = void 0;
            inserted = parent[expando]._onDragOver({
              clientX: touchEvt.clientX,
              clientY: touchEvt.clientY,
              target: target,
              rootEl: parent
            });
            if (inserted && !this.options.dragoverBubble) {
              break;
            }
          }
          target = parent; // store last element
        }
        /* jshint boss:true */ while (parent = parent.parentNode);
      }
      _unhideGhostForTarget();
    }
  },
  _onTouchMove: function _onTouchMove( /**TouchEvent*/evt) {
    if (tapEvt) {
      var options = this.options,
        fallbackTolerance = options.fallbackTolerance,
        fallbackOffset = options.fallbackOffset,
        touch = evt.touches ? evt.touches[0] : evt,
        ghostMatrix = ghostEl && matrix(ghostEl, true),
        scaleX = ghostEl && ghostMatrix && ghostMatrix.a,
        scaleY = ghostEl && ghostMatrix && ghostMatrix.d,
        relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent),
        dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1),
        dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1);

      // only set the status to dragging, when we are actually dragging
      if (!Sortable.active && !awaitingDragStarted) {
        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
          return;
        }
        this._onDragStart(evt, true);
      }
      if (ghostEl) {
        if (ghostMatrix) {
          ghostMatrix.e += dx - (lastDx || 0);
          ghostMatrix.f += dy - (lastDy || 0);
        } else {
          ghostMatrix = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: dx,
            f: dy
          };
        }
        var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
        css(ghostEl, 'webkitTransform', cssMatrix);
        css(ghostEl, 'mozTransform', cssMatrix);
        css(ghostEl, 'msTransform', cssMatrix);
        css(ghostEl, 'transform', cssMatrix);
        lastDx = dx;
        lastDy = dy;
        touchEvt = touch;
      }
      evt.cancelable && evt.preventDefault();
    }
  },
  _appendGhost: function _appendGhost() {
    // Bug if using scale(): https://stackoverflow.com/questions/2637058
    // Not being adjusted for
    if (!ghostEl) {
      var container = this.options.fallbackOnBody ? document.body : rootEl,
        rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container),
        options = this.options;

      // Position absolutely
      if (PositionGhostAbsolutely) {
        // Get relatively positioned parent
        ghostRelativeParent = container;
        while (css(ghostRelativeParent, 'position') === 'static' && css(ghostRelativeParent, 'transform') === 'none' && ghostRelativeParent !== document) {
          ghostRelativeParent = ghostRelativeParent.parentNode;
        }
        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
          if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();
          rect.top += ghostRelativeParent.scrollTop;
          rect.left += ghostRelativeParent.scrollLeft;
        } else {
          ghostRelativeParent = getWindowScrollingElement();
        }
        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
      }
      ghostEl = dragEl.cloneNode(true);
      toggleClass$1(ghostEl, options.ghostClass, false);
      toggleClass$1(ghostEl, options.fallbackClass, true);
      toggleClass$1(ghostEl, options.dragClass, true);
      css(ghostEl, 'transition', '');
      css(ghostEl, 'transform', '');
      css(ghostEl, 'box-sizing', 'border-box');
      css(ghostEl, 'margin', 0);
      css(ghostEl, 'top', rect.top);
      css(ghostEl, 'left', rect.left);
      css(ghostEl, 'width', rect.width);
      css(ghostEl, 'height', rect.height);
      css(ghostEl, 'opacity', '0.8');
      css(ghostEl, 'position', PositionGhostAbsolutely ? 'absolute' : 'fixed');
      css(ghostEl, 'zIndex', '100000');
      css(ghostEl, 'pointerEvents', 'none');
      Sortable.ghost = ghostEl;
      container.appendChild(ghostEl);

      // Set transform-origin
      css(ghostEl, 'transform-origin', tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + '% ' + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + '%');
    }
  },
  _onDragStart: function _onDragStart( /**Event*/evt, /**boolean*/fallback) {
    var _this = this;
    var dataTransfer = evt.dataTransfer;
    var options = _this.options;
    pluginEvent('dragStart', this, {
      evt: evt
    });
    if (Sortable.eventCanceled) {
      this._onDrop();
      return;
    }
    pluginEvent('setupClone', this);
    if (!Sortable.eventCanceled) {
      cloneEl = clone(dragEl);
      cloneEl.removeAttribute("id");
      cloneEl.draggable = false;
      cloneEl.style['will-change'] = '';
      this._hideClone();
      toggleClass$1(cloneEl, this.options.chosenClass, false);
      Sortable.clone = cloneEl;
    }

    // #1143: IFrame support workaround
    _this.cloneId = _nextTick(function () {
      pluginEvent('clone', _this);
      if (Sortable.eventCanceled) return;
      if (!_this.options.removeCloneOnHide) {
        rootEl.insertBefore(cloneEl, dragEl);
      }
      _this._hideClone();
      _dispatchEvent({
        sortable: _this,
        name: 'clone'
      });
    });
    !fallback && toggleClass$1(dragEl, options.dragClass, true);

    // Set proper drop events
    if (fallback) {
      ignoreNextClick = true;
      _this._loopId = setInterval(_this._emulateDragOver, 50);
    } else {
      // Undo what was set in _prepareDragStart before drag started
      off(document, 'mouseup', _this._onDrop);
      off(document, 'touchend', _this._onDrop);
      off(document, 'touchcancel', _this._onDrop);
      if (dataTransfer) {
        dataTransfer.effectAllowed = 'move';
        options.setData && options.setData.call(_this, dataTransfer, dragEl);
      }
      on(document, 'drop', _this);

      // #1276 fix:
      css(dragEl, 'transform', 'translateZ(0)');
    }
    awaitingDragStarted = true;
    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
    on(document, 'selectstart', _this);
    moved = true;
    if (Safari) {
      css(document.body, 'user-select', 'none');
    }
  },
  // Returns true - if no further action is needed (either inserted or another condition)
  _onDragOver: function _onDragOver( /**Event*/evt) {
    var el = this.el,
      target = evt.target,
      dragRect,
      targetRect,
      revert,
      options = this.options,
      group = options.group,
      activeSortable = Sortable.active,
      isOwner = activeGroup === group,
      canSort = options.sort,
      fromSortable = putSortable || activeSortable,
      vertical,
      _this = this,
      completedFired = false;
    if (_silent) return;
    function dragOverEvent(name, extra) {
      pluginEvent(name, _this, _objectSpread2({
        evt: evt,
        isOwner: isOwner,
        axis: vertical ? 'vertical' : 'horizontal',
        revert: revert,
        dragRect: dragRect,
        targetRect: targetRect,
        canSort: canSort,
        fromSortable: fromSortable,
        target: target,
        completed: completed,
        onMove: function onMove(target, after) {
          return _onMove(rootEl, el, dragEl, dragRect, target, getRect(target), evt, after);
        },
        changed: changed
      }, extra));
    }

    // Capture animation state
    function capture() {
      dragOverEvent('dragOverAnimationCapture');
      _this.captureAnimationState();
      if (_this !== fromSortable) {
        fromSortable.captureAnimationState();
      }
    }

    // Return invocation when dragEl is inserted (or completed)
    function completed(insertion) {
      dragOverEvent('dragOverCompleted', {
        insertion: insertion
      });
      if (insertion) {
        // Clones must be hidden before folding animation to capture dragRectAbsolute properly
        if (isOwner) {
          activeSortable._hideClone();
        } else {
          activeSortable._showClone(_this);
        }
        if (_this !== fromSortable) {
          // Set ghost class to new sortable's ghost class
          toggleClass$1(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
          toggleClass$1(dragEl, options.ghostClass, true);
        }
        if (putSortable !== _this && _this !== Sortable.active) {
          putSortable = _this;
        } else if (_this === Sortable.active && putSortable) {
          putSortable = null;
        }

        // Animation
        if (fromSortable === _this) {
          _this._ignoreWhileAnimating = target;
        }
        _this.animateAll(function () {
          dragOverEvent('dragOverAnimationComplete');
          _this._ignoreWhileAnimating = null;
        });
        if (_this !== fromSortable) {
          fromSortable.animateAll();
          fromSortable._ignoreWhileAnimating = null;
        }
      }

      // Null lastTarget if it is not inside a previously swapped element
      if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
        lastTarget = null;
      }

      // no bubbling and not fallback
      if (!options.dragoverBubble && !evt.rootEl && target !== document) {
        dragEl.parentNode[expando]._isOutsideThisEl(evt.target);

        // Do not detect for empty insert if already inserted
        !insertion && nearestEmptyInsertDetectEvent(evt);
      }
      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
      return completedFired = true;
    }

    // Call when dragEl has been inserted
    function changed() {
      newIndex = index$1(dragEl);
      newDraggableIndex = index$1(dragEl, options.draggable);
      _dispatchEvent({
        sortable: _this,
        name: 'change',
        toEl: el,
        newIndex: newIndex,
        newDraggableIndex: newDraggableIndex,
        originalEvent: evt
      });
    }
    if (evt.preventDefault !== void 0) {
      evt.cancelable && evt.preventDefault();
    }
    target = closest(target, options.draggable, el, true);
    dragOverEvent('dragOver');
    if (Sortable.eventCanceled) return completedFired;
    if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
      return completed(false);
    }
    ignoreNextClick = false;
    if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) // Reverting item into the original list
    : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
      vertical = this._getDirection(evt, target) === 'vertical';
      dragRect = getRect(dragEl);
      dragOverEvent('dragOverValid');
      if (Sortable.eventCanceled) return completedFired;
      if (revert) {
        parentEl = rootEl; // actualization
        capture();
        this._hideClone();
        dragOverEvent('revert');
        if (!Sortable.eventCanceled) {
          if (nextEl) {
            rootEl.insertBefore(dragEl, nextEl);
          } else {
            rootEl.appendChild(dragEl);
          }
        }
        return completed(true);
      }
      var elLastChild = lastChild(el, options.draggable);
      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
        // Insert to end of list

        // If already at end of list: Do not insert
        if (elLastChild === dragEl) {
          return completed(false);
        }

        // if there is a last element, it is the target
        if (elLastChild && el === evt.target) {
          target = elLastChild;
        }
        if (target) {
          targetRect = getRect(target);
        }
        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
          capture();
          if (elLastChild && elLastChild.nextSibling) {
            // the last draggable element is not the last node
            el.insertBefore(dragEl, elLastChild.nextSibling);
          } else {
            el.appendChild(dragEl);
          }
          parentEl = el; // actualization

          changed();
          return completed(true);
        }
      } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
        // Insert to start of list
        var firstChild = getChild(el, 0, options, true);
        if (firstChild === dragEl) {
          return completed(false);
        }
        target = firstChild;
        targetRect = getRect(target);
        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {
          capture();
          el.insertBefore(dragEl, firstChild);
          parentEl = el; // actualization

          changed();
          return completed(true);
        }
      } else if (target.parentNode === el) {
        targetRect = getRect(target);
        var direction = 0,
          targetBeforeFirstSwap,
          differentLevel = dragEl.parentNode !== el,
          differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical),
          side1 = vertical ? 'top' : 'left',
          scrolledPastTop = isScrolledPast(target, 'top', 'top') || isScrolledPast(dragEl, 'top', 'top'),
          scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;
        if (lastTarget !== target) {
          targetBeforeFirstSwap = targetRect[side1];
          pastFirstInvertThresh = false;
          isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
        }
        direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
        var sibling;
        if (direction !== 0) {
          // Check if target is beside dragEl in respective direction (ignoring hidden elements)
          var dragIndex = index$1(dragEl);
          do {
            dragIndex -= direction;
            sibling = parentEl.children[dragIndex];
          } while (sibling && (css(sibling, 'display') === 'none' || sibling === ghostEl));
        }
        // If dragEl is already beside target: Do not insert
        if (direction === 0 || sibling === target) {
          return completed(false);
        }
        lastTarget = target;
        lastDirection = direction;
        var nextSibling = target.nextElementSibling,
          after = false;
        after = direction === 1;
        var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);
        if (moveVector !== false) {
          if (moveVector === 1 || moveVector === -1) {
            after = moveVector === 1;
          }
          _silent = true;
          setTimeout(_unsilent, 30);
          capture();
          if (after && !nextSibling) {
            el.appendChild(dragEl);
          } else {
            target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
          }

          // Undo chrome's scroll adjustment (has no effect on other browsers)
          if (scrolledPastTop) {
            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
          }
          parentEl = dragEl.parentNode; // actualization

          // must be done before animation
          if (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {
            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
          }
          changed();
          return completed(true);
        }
      }
      if (el.contains(dragEl)) {
        return completed(false);
      }
    }
    return false;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function _offMoveEvents() {
    off(document, 'mousemove', this._onTouchMove);
    off(document, 'touchmove', this._onTouchMove);
    off(document, 'pointermove', this._onTouchMove);
    off(document, 'dragover', nearestEmptyInsertDetectEvent);
    off(document, 'mousemove', nearestEmptyInsertDetectEvent);
    off(document, 'touchmove', nearestEmptyInsertDetectEvent);
  },
  _offUpEvents: function _offUpEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, 'mouseup', this._onDrop);
    off(ownerDocument, 'touchend', this._onDrop);
    off(ownerDocument, 'pointerup', this._onDrop);
    off(ownerDocument, 'touchcancel', this._onDrop);
    off(document, 'selectstart', this);
  },
  _onDrop: function _onDrop( /**Event*/evt) {
    var el = this.el,
      options = this.options;

    // Get the index of the dragged element within its parent
    newIndex = index$1(dragEl);
    newDraggableIndex = index$1(dragEl, options.draggable);
    pluginEvent('drop', this, {
      evt: evt
    });
    parentEl = dragEl && dragEl.parentNode;

    // Get again after plugin event
    newIndex = index$1(dragEl);
    newDraggableIndex = index$1(dragEl, options.draggable);
    if (Sortable.eventCanceled) {
      this._nulling();
      return;
    }
    awaitingDragStarted = false;
    isCircumstantialInvert = false;
    pastFirstInvertThresh = false;
    clearInterval(this._loopId);
    clearTimeout(this._dragStartTimer);
    _cancelNextTick(this.cloneId);
    _cancelNextTick(this._dragStartId);

    // Unbind events
    if (this.nativeDraggable) {
      off(document, 'drop', this);
      off(el, 'dragstart', this._onDragStart);
    }
    this._offMoveEvents();
    this._offUpEvents();
    if (Safari) {
      css(document.body, 'user-select', '');
    }
    css(dragEl, 'transform', '');
    if (evt) {
      if (moved) {
        evt.cancelable && evt.preventDefault();
        !options.dropBubble && evt.stopPropagation();
      }
      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);
      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {
        // Remove clone(s)
        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
      }
      if (dragEl) {
        if (this.nativeDraggable) {
          off(dragEl, 'dragend', this);
        }
        _disableDraggable(dragEl);
        dragEl.style['will-change'] = '';

        // Remove classes
        // ghostClass is added in dragStarted
        if (moved && !awaitingDragStarted) {
          toggleClass$1(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
        }
        toggleClass$1(dragEl, this.options.chosenClass, false);

        // Drag stop event
        _dispatchEvent({
          sortable: this,
          name: 'unchoose',
          toEl: parentEl,
          newIndex: null,
          newDraggableIndex: null,
          originalEvent: evt
        });
        if (rootEl !== parentEl) {
          if (newIndex >= 0) {
            // Add event
            _dispatchEvent({
              rootEl: parentEl,
              name: 'add',
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });

            // Remove event
            _dispatchEvent({
              sortable: this,
              name: 'remove',
              toEl: parentEl,
              originalEvent: evt
            });

            // drag from one list and drop into another
            _dispatchEvent({
              rootEl: parentEl,
              name: 'sort',
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: 'sort',
              toEl: parentEl,
              originalEvent: evt
            });
          }
          putSortable && putSortable.save();
        } else {
          if (newIndex !== oldIndex) {
            if (newIndex >= 0) {
              // drag & drop within the same list
              _dispatchEvent({
                sortable: this,
                name: 'update',
                toEl: parentEl,
                originalEvent: evt
              });
              _dispatchEvent({
                sortable: this,
                name: 'sort',
                toEl: parentEl,
                originalEvent: evt
              });
            }
          }
        }
        if (Sortable.active) {
          /* jshint eqnull:true */
          if (newIndex == null || newIndex === -1) {
            newIndex = oldIndex;
            newDraggableIndex = oldDraggableIndex;
          }
          _dispatchEvent({
            sortable: this,
            name: 'end',
            toEl: parentEl,
            originalEvent: evt
          });

          // Save sorting
          this.save();
        }
      }
    }
    this._nulling();
  },
  _nulling: function _nulling() {
    pluginEvent('nulling', this);
    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
    savedInputChecked.forEach(function (el) {
      el.checked = true;
    });
    savedInputChecked.length = lastDx = lastDy = 0;
  },
  handleEvent: function handleEvent( /**Event*/evt) {
    switch (evt.type) {
      case 'drop':
      case 'dragend':
        this._onDrop(evt);
        break;
      case 'dragenter':
      case 'dragover':
        if (dragEl) {
          this._onDragOver(evt);
          _globalDragOver(evt);
        }
        break;
      case 'selectstart':
        evt.preventDefault();
        break;
    }
  },
  /**
   * Serializes the item into an array of string.
   * @returns {String[]}
   */
  toArray: function toArray() {
    var order = [],
      el,
      children = this.el.children,
      i = 0,
      n = children.length,
      options = this.options;
    for (; i < n; i++) {
      el = children[i];
      if (closest(el, options.draggable, this.el, false)) {
        order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
      }
    }
    return order;
  },
  /**
   * Sorts the elements according to the array.
   * @param  {String[]}  order  order of the items
   */
  sort: function sort(order, useAnimation) {
    var items = {},
      rootEl = this.el;
    this.toArray().forEach(function (id, i) {
      var el = rootEl.children[i];
      if (closest(el, this.options.draggable, rootEl, false)) {
        items[id] = el;
      }
    }, this);
    useAnimation && this.captureAnimationState();
    order.forEach(function (id) {
      if (items[id]) {
        rootEl.removeChild(items[id]);
        rootEl.appendChild(items[id]);
      }
    });
    useAnimation && this.animateAll();
  },
  /**
   * Save the current sorting
   */
  save: function save() {
    var store = this.options.store;
    store && store.set && store.set(this);
  },
  /**
   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
   * @param   {HTMLElement}  el
   * @param   {String}       [selector]  default: `options.draggable`
   * @returns {HTMLElement|null}
   */
  closest: function closest$1(el, selector) {
    return closest(el, selector || this.options.draggable, this.el, false);
  },
  /**
   * Set/get option
   * @param   {string} name
   * @param   {*}      [value]
   * @returns {*}
   */
  option: function option(name, value) {
    var options = this.options;
    if (value === void 0) {
      return options[name];
    } else {
      var modifiedValue = PluginManager.modifyOption(this, name, value);
      if (typeof modifiedValue !== 'undefined') {
        options[name] = modifiedValue;
      } else {
        options[name] = value;
      }
      if (name === 'group') {
        _prepareGroup(options);
      }
    }
  },
  /**
   * Destroy
   */
  destroy: function destroy() {
    pluginEvent('destroy', this);
    var el = this.el;
    el[expando] = null;
    off(el, 'mousedown', this._onTapStart);
    off(el, 'touchstart', this._onTapStart);
    off(el, 'pointerdown', this._onTapStart);
    if (this.nativeDraggable) {
      off(el, 'dragover', this);
      off(el, 'dragenter', this);
    }
    // Remove draggable attributes
    Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {
      el.removeAttribute('draggable');
    });
    this._onDrop();
    this._disableDelayedDragEvents();
    sortables.splice(sortables.indexOf(this.el), 1);
    this.el = el = null;
  },
  _hideClone: function _hideClone() {
    if (!cloneHidden) {
      pluginEvent('hideClone', this);
      if (Sortable.eventCanceled) return;
      css(cloneEl, 'display', 'none');
      if (this.options.removeCloneOnHide && cloneEl.parentNode) {
        cloneEl.parentNode.removeChild(cloneEl);
      }
      cloneHidden = true;
    }
  },
  _showClone: function _showClone(putSortable) {
    if (putSortable.lastPutMode !== 'clone') {
      this._hideClone();
      return;
    }
    if (cloneHidden) {
      pluginEvent('showClone', this);
      if (Sortable.eventCanceled) return;

      // show clone at dragEl or original position
      if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
        rootEl.insertBefore(cloneEl, dragEl);
      } else if (nextEl) {
        rootEl.insertBefore(cloneEl, nextEl);
      } else {
        rootEl.appendChild(cloneEl);
      }
      if (this.options.group.revertClone) {
        this.animate(dragEl, cloneEl);
      }
      css(cloneEl, 'display', '');
      cloneHidden = false;
    }
  }
};
function _globalDragOver( /**Event*/evt) {
  if (evt.dataTransfer) {
    evt.dataTransfer.dropEffect = 'move';
  }
  evt.cancelable && evt.preventDefault();
}
function _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
  var evt,
    sortable = fromEl[expando],
    onMoveFn = sortable.options.onMove,
    retVal;
  // Support for new CustomEvent feature
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent('move', {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent('Event');
    evt.initEvent('move', true, true);
  }
  evt.to = toEl;
  evt.from = fromEl;
  evt.dragged = dragEl;
  evt.draggedRect = dragRect;
  evt.related = targetEl || toEl;
  evt.relatedRect = targetRect || getRect(toEl);
  evt.willInsertAfter = willInsertAfter;
  evt.originalEvent = originalEvent;
  fromEl.dispatchEvent(evt);
  if (onMoveFn) {
    retVal = onMoveFn.call(sortable, evt, originalEvent);
  }
  return retVal;
}
function _disableDraggable(el) {
  el.draggable = false;
}
function _unsilent() {
  _silent = false;
}
function _ghostIsFirst(evt, vertical, sortable) {
  var firstElRect = getRect(getChild(sortable.el, 0, sortable.options, true));
  var childContainingRect = getChildContainingRectFromElement(sortable.el, sortable.options, ghostEl);
  var spacer = 10;
  return vertical ? evt.clientX < childContainingRect.left - spacer || evt.clientY < firstElRect.top && evt.clientX < firstElRect.right : evt.clientY < childContainingRect.top - spacer || evt.clientY < firstElRect.bottom && evt.clientX < firstElRect.left;
}
function _ghostIsLast(evt, vertical, sortable) {
  var lastElRect = getRect(lastChild(sortable.el, sortable.options.draggable));
  var childContainingRect = getChildContainingRectFromElement(sortable.el, sortable.options, ghostEl);
  var spacer = 10;
  return vertical ? evt.clientX > childContainingRect.right + spacer || evt.clientY > lastElRect.bottom && evt.clientX > lastElRect.left : evt.clientY > childContainingRect.bottom + spacer || evt.clientX > lastElRect.right && evt.clientY > lastElRect.top;
}
function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
  var mouseOnAxis = vertical ? evt.clientY : evt.clientX,
    targetLength = vertical ? targetRect.height : targetRect.width,
    targetS1 = vertical ? targetRect.top : targetRect.left,
    targetS2 = vertical ? targetRect.bottom : targetRect.right,
    invert = false;
  if (!invertSwap) {
    // Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold
    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
      // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2
      // check if past first invert threshold on side opposite of lastDirection
      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
        // past first invert threshold, do not restrict inverted threshold to dragEl shadow
        pastFirstInvertThresh = true;
      }
      if (!pastFirstInvertThresh) {
        // dragEl shadow (target move distance shadow)
        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow
        : mouseOnAxis > targetS2 - targetMoveDistance) {
          return -lastDirection;
        }
      } else {
        invert = true;
      }
    } else {
      // Regular
      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
        return _getInsertDirection(target);
      }
    }
  }
  invert = invert || invertSwap;
  if (invert) {
    // Invert of regular
    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
    }
  }
  return 0;
}

/**
 * Gets the direction dragEl must be swapped relative to target in order to make it
 * seem that dragEl has been "inserted" into that element's position
 * @param  {HTMLElement} target       The target whose position dragEl is being inserted at
 * @return {Number}                   Direction dragEl must be swapped
 */
function _getInsertDirection(target) {
  if (index$1(dragEl) < index$1(target)) {
    return 1;
  } else {
    return -1;
  }
}

/**
 * Generate id
 * @param   {HTMLElement} el
 * @returns {String}
 * @private
 */
function _generateId(el) {
  var str = el.tagName + el.className + el.src + el.href + el.textContent,
    i = str.length,
    sum = 0;
  while (i--) {
    sum += str.charCodeAt(i);
  }
  return sum.toString(36);
}
function _saveInputCheckedState(root) {
  savedInputChecked.length = 0;
  var inputs = root.getElementsByTagName('input');
  var idx = inputs.length;
  while (idx--) {
    var el = inputs[idx];
    el.checked && savedInputChecked.push(el);
  }
}
function _nextTick(fn) {
  return setTimeout(fn, 0);
}
function _cancelNextTick(id) {
  return clearTimeout(id);
}

// Fixed #973:
if (documentExists) {
  on(document, 'touchmove', function (evt) {
    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
      evt.preventDefault();
    }
  });
}

// Export utils
Sortable.utils = {
  on: on,
  off: off,
  css: css,
  find: find,
  is: function is(el, selector) {
    return !!closest(el, selector, el, false);
  },
  extend: extend$1,
  throttle: throttle,
  closest: closest,
  toggleClass: toggleClass$1,
  clone: clone,
  index: index$1,
  nextTick: _nextTick,
  cancelNextTick: _cancelNextTick,
  detectDirection: _detectDirection,
  getChild: getChild
};

/**
 * Get the Sortable instance of an element
 * @param  {HTMLElement} element The element
 * @return {Sortable|undefined}         The instance of Sortable
 */
Sortable.get = function (element) {
  return element[expando];
};

/**
 * Mount a plugin to Sortable
 * @param  {...SortablePlugin|SortablePlugin[]} plugins       Plugins being mounted
 */
Sortable.mount = function () {
  for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
    plugins[_key] = arguments[_key];
  }
  if (plugins[0].constructor === Array) plugins = plugins[0];
  plugins.forEach(function (plugin) {
    if (!plugin.prototype || !plugin.prototype.constructor) {
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
    }
    if (plugin.utils) Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);
    PluginManager.mount(plugin);
  });
};

/**
 * Create sortable instance
 * @param {HTMLElement}  el
 * @param {Object}      [options]
 */
Sortable.create = function (el, options) {
  return new Sortable(el, options);
};

// Export
Sortable.version = version;
var autoScrolls = [],
  scrollEl,
  scrollRootEl,
  scrolling = false,
  lastAutoScrollX,
  lastAutoScrollY,
  touchEvt$1,
  pointerElemChangedInterval;
function AutoScrollPlugin() {
  function AutoScroll() {
    this.defaults = {
      scroll: true,
      forceAutoScrollFallback: false,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: true
    };

    // Bind all private methods
    for (var fn in this) {
      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
        this[fn] = this[fn].bind(this);
      }
    }
  }
  AutoScroll.prototype = {
    dragStarted: function dragStarted(_ref) {
      var originalEvent = _ref.originalEvent;
      if (this.sortable.nativeDraggable) {
        on(document, 'dragover', this._handleAutoScroll);
      } else {
        if (this.options.supportPointer) {
          on(document, 'pointermove', this._handleFallbackAutoScroll);
        } else if (originalEvent.touches) {
          on(document, 'touchmove', this._handleFallbackAutoScroll);
        } else {
          on(document, 'mousemove', this._handleFallbackAutoScroll);
        }
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref2) {
      var originalEvent = _ref2.originalEvent;
      // For when bubbling is canceled and using fallback (fallback 'touchmove' always reached)
      if (!this.options.dragOverBubble && !originalEvent.rootEl) {
        this._handleAutoScroll(originalEvent);
      }
    },
    drop: function drop() {
      if (this.sortable.nativeDraggable) {
        off(document, 'dragover', this._handleAutoScroll);
      } else {
        off(document, 'pointermove', this._handleFallbackAutoScroll);
        off(document, 'touchmove', this._handleFallbackAutoScroll);
        off(document, 'mousemove', this._handleFallbackAutoScroll);
      }
      clearPointerElemChangedInterval();
      clearAutoScrolls();
      cancelThrottle();
    },
    nulling: function nulling() {
      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
      autoScrolls.length = 0;
    },
    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
      this._handleAutoScroll(evt, true);
    },
    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
      var _this = this;
      var x = (evt.touches ? evt.touches[0] : evt).clientX,
        y = (evt.touches ? evt.touches[0] : evt).clientY,
        elem = document.elementFromPoint(x, y);
      touchEvt$1 = evt;

      // IE does not seem to have native autoscroll,
      // Edge's autoscroll seems too conditional,
      // MACOS Safari does not have autoscroll,
      // Firefox and Chrome are good
      if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
        autoScroll(evt, this.options, elem, fallback);

        // Listener for pointer element change
        var ogElemScroller = getParentAutoScrollElement(elem, true);
        if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {
          pointerElemChangedInterval && clearPointerElemChangedInterval();
          // Detect for pointer elem change, emulating native DnD behaviour
          pointerElemChangedInterval = setInterval(function () {
            var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);
            if (newElem !== ogElemScroller) {
              ogElemScroller = newElem;
              clearAutoScrolls();
            }
            autoScroll(evt, _this.options, newElem, fallback);
          }, 10);
          lastAutoScrollX = x;
          lastAutoScrollY = y;
        }
      } else {
        // if DnD is enabled (and browser has good autoscrolling), first autoscroll will already scroll, so get parent autoscroll of first autoscroll
        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
          clearAutoScrolls();
          return;
        }
        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
      }
    }
  };
  return _extends(AutoScroll, {
    pluginName: 'scroll',
    initializeByDefault: true
  });
}
function clearAutoScrolls() {
  autoScrolls.forEach(function (autoScroll) {
    clearInterval(autoScroll.pid);
  });
  autoScrolls = [];
}
function clearPointerElemChangedInterval() {
  clearInterval(pointerElemChangedInterval);
}
var autoScroll = throttle(function (evt, options, rootEl, isFallback) {
  // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521
  if (!options.scroll) return;
  var x = (evt.touches ? evt.touches[0] : evt).clientX,
    y = (evt.touches ? evt.touches[0] : evt).clientY,
    sens = options.scrollSensitivity,
    speed = options.scrollSpeed,
    winScroller = getWindowScrollingElement();
  var scrollThisInstance = false,
    scrollCustomFn;

  // New scroll root, set scrollEl
  if (scrollRootEl !== rootEl) {
    scrollRootEl = rootEl;
    clearAutoScrolls();
    scrollEl = options.scroll;
    scrollCustomFn = options.scrollFn;
    if (scrollEl === true) {
      scrollEl = getParentAutoScrollElement(rootEl, true);
    }
  }
  var layersOut = 0;
  var currentParent = scrollEl;
  do {
    var el = currentParent,
      rect = getRect(el),
      top = rect.top,
      bottom = rect.bottom,
      left = rect.left,
      right = rect.right,
      width = rect.width,
      height = rect.height,
      canScrollX = void 0,
      canScrollY = void 0,
      scrollWidth = el.scrollWidth,
      scrollHeight = el.scrollHeight,
      elCSS = css(el),
      scrollPosX = el.scrollLeft,
      scrollPosY = el.scrollTop;
    if (el === winScroller) {
      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll' || elCSS.overflowX === 'visible');
      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll' || elCSS.overflowY === 'visible');
    } else {
      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll');
      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll');
    }
    var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);
    var vy = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);
    if (!autoScrolls[layersOut]) {
      for (var i = 0; i <= layersOut; i++) {
        if (!autoScrolls[i]) {
          autoScrolls[i] = {};
        }
      }
    }
    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
      autoScrolls[layersOut].el = el;
      autoScrolls[layersOut].vx = vx;
      autoScrolls[layersOut].vy = vy;
      clearInterval(autoScrolls[layersOut].pid);
      if (vx != 0 || vy != 0) {
        scrollThisInstance = true;
        /* jshint loopfunc:true */
        autoScrolls[layersOut].pid = setInterval(function () {
          // emulate drag over during autoscroll (fallback), emulating native DnD behaviour
          if (isFallback && this.layer === 0) {
            Sortable.active._onTouchMove(touchEvt$1); // To move ghost if it is positioned absolutely
          }
          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;
          if (typeof scrollCustomFn === 'function') {
            if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== 'continue') {
              return;
            }
          }
          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
        }.bind({
          layer: layersOut
        }), 24);
      }
    }
    layersOut++;
  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));
  scrolling = scrollThisInstance; // in case another function catches scrolling as false in between when it is not
}, 30);
var drop = function drop(_ref) {
  var originalEvent = _ref.originalEvent,
    putSortable = _ref.putSortable,
    dragEl = _ref.dragEl,
    activeSortable = _ref.activeSortable,
    dispatchSortableEvent = _ref.dispatchSortableEvent,
    hideGhostForTarget = _ref.hideGhostForTarget,
    unhideGhostForTarget = _ref.unhideGhostForTarget;
  if (!originalEvent) return;
  var toSortable = putSortable || activeSortable;
  hideGhostForTarget();
  var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
  var target = document.elementFromPoint(touch.clientX, touch.clientY);
  unhideGhostForTarget();
  if (toSortable && !toSortable.el.contains(target)) {
    dispatchSortableEvent('spill');
    this.onSpill({
      dragEl: dragEl,
      putSortable: putSortable
    });
  }
};
function Revert() {}
Revert.prototype = {
  startIndex: null,
  dragStart: function dragStart(_ref2) {
    var oldDraggableIndex = _ref2.oldDraggableIndex;
    this.startIndex = oldDraggableIndex;
  },
  onSpill: function onSpill(_ref3) {
    var dragEl = _ref3.dragEl,
      putSortable = _ref3.putSortable;
    this.sortable.captureAnimationState();
    if (putSortable) {
      putSortable.captureAnimationState();
    }
    var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);
    if (nextSibling) {
      this.sortable.el.insertBefore(dragEl, nextSibling);
    } else {
      this.sortable.el.appendChild(dragEl);
    }
    this.sortable.animateAll();
    if (putSortable) {
      putSortable.animateAll();
    }
  },
  drop: drop
};
_extends(Revert, {
  pluginName: 'revertOnSpill'
});
function Remove() {}
Remove.prototype = {
  onSpill: function onSpill(_ref4) {
    var dragEl = _ref4.dragEl,
      putSortable = _ref4.putSortable;
    var parentSortable = putSortable || this.sortable;
    parentSortable.captureAnimationState();
    dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);
    parentSortable.animateAll();
  },
  drop: drop
};
_extends(Remove, {
  pluginName: 'removeOnSpill'
});
Sortable.mount(new AutoScrollPlugin());
Sortable.mount(Remove, Revert);

//
// Inspired by https://gorails.com/episodes/rails-drag-and-drop-sortable
//
// Annotate html as follows:
//
// <div data-controller="sortable" data-sortable-url=move_some_resource_path(id: ":id")>
//   <% items.each do |item| %>
//     <div data-id=item.id>...</div>
//   <% end %>
// </div>
var _default$l = /*#__PURE__*/function (_Controller) {
  function _default() {
    _classCallCheck$1(this, _default);
    return _callSuper(this, _default, arguments);
  }
  _inherits$1(_default, _Controller);
  return _createClass$1(_default, [{
    key: "connect",
    value: function connect() {
      this.sortable = Sortable.create(this.element, {
        handle: ".handle",
        animation: 150,
        onEnd: this.end.bind(this)
      });
    }
  }, {
    key: "end",
    value: function end(event) {
      var url = this.data.get("url");

      // No direct server persistence
      if (!url) return;
      var id = event.item.dataset.id;
      var data = new FormData();
      data.append("position", event.newIndex + 1);
      Rails.ajax({
        url: url.replace(":id", id),
        type: "PATCH",
        data: data
      });
    }
  }]);
}(Controller);

var Rails$1 = window.Rails;
var _default$k = /*#__PURE__*/function (_Controller) {
  function _default() {
    _classCallCheck$1(this, _default);
    return _callSuper(this, _default, arguments);
  }
  _inherits$1(_default, _Controller);
  return _createClass$1(_default, [{
    key: "refresh",
    value: function refresh(event) {
      event.preventDefault();
      var selectedOption = this.element.options[this.element.selectedIndex];
      var url = selectedOption.dataset.source;
      Rails$1.ajax({
        type: "GET",
        url: url,
        dataType: "application/js"
      });
    }

    /*
    When each option in a select has data-show and/or data-hide attributes
    specifying the ids (currently only one id supported) of elements to show or
    hide. Used for example when selecting an option should show a certain UI element
    and other options should hide it. Used e.g. on the AKI alerts filter form for the
    specific data option.
    */
  }, {
    key: "showhide",
    value: function showhide(event) {
      var _document$querySelect, _document$querySelect2;
      var selectedOption = this.element.options[this.element.selectedIndex];
      var idsToShow = selectedOption.dataset.show;
      var idsToHide = selectedOption.dataset.hide;
      (_document$querySelect = document.querySelector("#" + idsToShow)) === null || _document$querySelect === void 0 || _document$querySelect.classList.remove("hidden");
      (_document$querySelect2 = document.querySelector("#" + idsToHide)) === null || _document$querySelect2 === void 0 || _document$querySelect2.classList.add("hidden");
    }
  }]);
}(Controller);

// Set all radio inputs within the controller's element to checked if their
// value = matchValue (eg "no" in the case of tristate Yes No Unknown radio
// groups).
// Example usage:
// div(data-controller="radio-reset" data-radio-reset-match-value="no")
//   input(type="radio" value="yes" ..)
//   input(type="radio" value="no" ..)
//   ...
var _default$j = /*#__PURE__*/function (_Controller) {
  function _default() {
    _classCallCheck$1(this, _default);
    return _callSuper(this, _default, arguments);
  }
  _inherits$1(_default, _Controller);
  return _createClass$1(_default, [{
    key: "reset_all",
    value: function reset_all(event) {
      var that = this;
      var radioInputs = Array.prototype.slice.call(this.element.querySelectorAll("input[type='radio']"));
      radioInputs.forEach(function (a) {
        if (a.value == that.matchValue) {
          a.checked = true;
        }
      });
    }
  }]);
}(Controller);
_defineProperty$2(_default$j, "values", {
  match: String
});

var _default$i = /*#__PURE__*/function (_Controller) {
  function _default() {
    _classCallCheck$1(this, _default);
    return _callSuper(this, _default, arguments);
  }
  _inherits$1(_default, _Controller);
  return _createClass$1(_default, [{
    key: "showhide",
    value:
    /*
    For a SELECT, find the chosen option, and the data attribute we need (a boolean eg "true" whose
    name is in the attributeToTest value).  Hide or show the target element according to the boolean
    'test' attribute.
    */
    function showhide(event) {
      console.log("H");
      event.preventDefault();
      if (event.target.tagName.toUpperCase() == "SELECT") {
        var selectedOption = event.target.options[event.target.selectedIndex];
        var display = selectedOption.dataset[this.attributeToTestValue] == "true" ? "block" : "none";
        this.displayableTarget.style.display = display;
      }
    }
  }]);
}(Controller);
_defineProperty$2(_default$i, "targets", ["displayable"]);
// element we are going to show/hide
// attributeToTest: Name of the boolean data attribute on the selected option that determines if
//                  the displayable target should be visible or not
_defineProperty$2(_default$i, "values", {
  attributeToTest: String
});

var slimselect = {exports: {}};

(function (module, exports) {
	(function (global, factory) {
	  module.exports = factory() ;
	})(commonjsGlobal, function () {

	  function generateID() {
	    return Math.random().toString(36).substring(2, 10);
	  }
	  function hasClassInTree(element, className) {
	    function hasClass(e, c) {
	      if (c && e && e.classList && e.classList.contains(c)) {
	        return e;
	      }
	      if (c && e && e.dataset && e.dataset.id && e.dataset.id === className) {
	        return e;
	      }
	      return null;
	    }
	    function parentByClass(e, c) {
	      if (!e || e === document) {
	        return null;
	      } else if (hasClass(e, c)) {
	        return e;
	      } else {
	        return parentByClass(e.parentNode, c);
	      }
	    }
	    return hasClass(element, className) || parentByClass(element, className);
	  }
	  function debounce(func, wait = 50, immediate = false) {
	    let timeout;
	    return function (...args) {
	      const context = self;
	      const later = () => {
	        timeout = null;
	        if (!immediate) {
	          func.apply(context, args);
	        }
	      };
	      const callNow = immediate && !timeout;
	      clearTimeout(timeout);
	      timeout = setTimeout(later, wait);
	      if (callNow) {
	        func.apply(context, args);
	      }
	    };
	  }
	  function isEqual(a, b) {
	    return JSON.stringify(a) === JSON.stringify(b);
	  }
	  function kebabCase(str) {
	    const result = str.replace(/[A-Z\u00C0-\u00D6\u00D8-\u00DE]/g, match => '-' + match.toLowerCase());
	    return str[0] === str[0].toUpperCase() ? result.substring(1) : result;
	  }
	  class Optgroup {
	    constructor(optgroup) {
	      this.id = !optgroup.id || optgroup.id === '' ? generateID() : optgroup.id;
	      this.label = optgroup.label || '';
	      this.selectAll = optgroup.selectAll === undefined ? false : optgroup.selectAll;
	      this.selectAllText = optgroup.selectAllText || 'Select All';
	      this.closable = optgroup.closable || 'off';
	      this.options = [];
	      if (optgroup.options) {
	        for (const o of optgroup.options) {
	          this.options.push(new Option(o));
	        }
	      }
	    }
	  }
	  class Option {
	    constructor(option) {
	      this.id = !option.id || option.id === '' ? generateID() : option.id;
	      this.value = option.value === undefined ? option.text : option.value;
	      this.text = option.text || '';
	      this.html = option.html || '';
	      this.selected = option.selected !== undefined ? option.selected : false;
	      this.display = option.display !== undefined ? option.display : true;
	      this.disabled = option.disabled !== undefined ? option.disabled : false;
	      this.mandatory = option.mandatory !== undefined ? option.mandatory : false;
	      this.placeholder = option.placeholder !== undefined ? option.placeholder : false;
	      this.class = option.class || '';
	      this.style = option.style || '';
	      this.data = option.data || {};
	    }
	  }
	  class Store {
	    constructor(type, data) {
	      this.selectType = 'single';
	      this.data = [];
	      this.selectType = type;
	      this.setData(data);
	    }
	    validateDataArray(data) {
	      if (!Array.isArray(data)) {
	        return new Error('Data must be an array');
	      }
	      for (let dataObj of data) {
	        if (dataObj instanceof Optgroup || 'label' in dataObj) {
	          if (!('label' in dataObj)) {
	            return new Error('Optgroup must have a label');
	          }
	          if ('options' in dataObj && dataObj.options) {
	            for (let option of dataObj.options) {
	              return this.validateOption(option);
	            }
	          }
	        } else if (dataObj instanceof Option || 'text' in dataObj) {
	          return this.validateOption(dataObj);
	        } else {
	          return new Error('Data object must be a valid optgroup or option');
	        }
	      }
	      return null;
	    }
	    validateOption(option) {
	      if (!('text' in option)) {
	        return new Error('Option must have a text');
	      }
	      return null;
	    }
	    partialToFullData(data) {
	      let dataFinal = [];
	      data.forEach(dataObj => {
	        if (dataObj instanceof Optgroup || 'label' in dataObj) {
	          let optOptions = [];
	          if ('options' in dataObj && dataObj.options) {
	            dataObj.options.forEach(option => {
	              optOptions.push(new Option(option));
	            });
	          }
	          if (optOptions.length > 0) {
	            dataFinal.push(new Optgroup(dataObj));
	          }
	        }
	        if (dataObj instanceof Option || 'text' in dataObj) {
	          dataFinal.push(new Option(dataObj));
	        }
	      });
	      return dataFinal;
	    }
	    setData(data) {
	      this.data = this.partialToFullData(data);
	      if (this.selectType === 'single') {
	        this.setSelectedBy('value', this.getSelected());
	      }
	    }
	    getData() {
	      return this.filter(null, true);
	    }
	    getDataOptions() {
	      return this.filter(null, false);
	    }
	    addOption(option) {
	      this.setData(this.getData().concat(new Option(option)));
	    }
	    setSelectedBy(selectedType, selectedValues) {
	      let firstOption = null;
	      let hasSelected = false;
	      for (let dataObj of this.data) {
	        if (dataObj instanceof Optgroup) {
	          for (let option of dataObj.options) {
	            if (!firstOption) {
	              firstOption = option;
	            }
	            option.selected = hasSelected ? false : selectedValues.includes(option[selectedType]);
	            if (option.selected && this.selectType === 'single') {
	              hasSelected = true;
	            }
	          }
	        }
	        if (dataObj instanceof Option) {
	          if (!firstOption) {
	            firstOption = dataObj;
	          }
	          dataObj.selected = hasSelected ? false : selectedValues.includes(dataObj[selectedType]);
	          if (dataObj.selected && this.selectType === 'single') {
	            hasSelected = true;
	          }
	        }
	      }
	      if (this.selectType === 'single' && firstOption && !hasSelected) {
	        firstOption.selected = true;
	      }
	    }
	    getSelected() {
	      let selectedOptions = this.getSelectedOptions();
	      let selectedValues = [];
	      selectedOptions.forEach(option => {
	        selectedValues.push(option.value);
	      });
	      return selectedValues;
	    }
	    getSelectedOptions() {
	      return this.filter(opt => {
	        return opt.selected;
	      }, false);
	    }
	    getSelectedIDs() {
	      let selectedOptions = this.getSelectedOptions();
	      let selectedIDs = [];
	      selectedOptions.forEach(op => {
	        selectedIDs.push(op.id);
	      });
	      return selectedIDs;
	    }
	    getOptgroupByID(id) {
	      for (let dataObj of this.data) {
	        if (dataObj instanceof Optgroup && dataObj.id === id) {
	          return dataObj;
	        }
	      }
	      return null;
	    }
	    getOptionByID(id) {
	      let options = this.filter(opt => {
	        return opt.id === id;
	      }, false);
	      return options.length ? options[0] : null;
	    }
	    getSelectType() {
	      return this.selectType;
	    }
	    getFirstOption() {
	      let option = null;
	      for (let dataObj of this.data) {
	        if (dataObj instanceof Optgroup) {
	          option = dataObj.options[0];
	        } else if (dataObj instanceof Option) {
	          option = dataObj;
	        }
	        if (option) {
	          break;
	        }
	      }
	      return option;
	    }
	    search(search, searchFilter) {
	      search = search.trim();
	      if (search === '') {
	        return this.getData();
	      }
	      return this.filter(opt => {
	        return searchFilter(opt, search);
	      }, true);
	    }
	    filter(filter, includeOptgroup) {
	      const dataSearch = [];
	      this.data.forEach(dataObj => {
	        if (dataObj instanceof Optgroup) {
	          let optOptions = [];
	          dataObj.options.forEach(option => {
	            if (!filter || filter(option)) {
	              if (!includeOptgroup) {
	                dataSearch.push(new Option(option));
	              } else {
	                optOptions.push(new Option(option));
	              }
	            }
	          });
	          if (optOptions.length > 0) {
	            let optgroup = new Optgroup(dataObj);
	            optgroup.options = optOptions;
	            dataSearch.push(optgroup);
	          }
	        }
	        if (dataObj instanceof Option) {
	          if (!filter || filter(dataObj)) {
	            dataSearch.push(new Option(dataObj));
	          }
	        }
	      });
	      return dataSearch;
	    }
	  }
	  class Render {
	    constructor(settings, store, callbacks) {
	      this.classes = {
	        main: 'ss-main',
	        placeholder: 'ss-placeholder',
	        values: 'ss-values',
	        single: 'ss-single',
	        max: 'ss-max',
	        value: 'ss-value',
	        valueText: 'ss-value-text',
	        valueDelete: 'ss-value-delete',
	        valueOut: 'ss-value-out',
	        deselect: 'ss-deselect',
	        deselectPath: 'M10,10 L90,90 M10,90 L90,10',
	        arrow: 'ss-arrow',
	        arrowClose: 'M10,30 L50,70 L90,30',
	        arrowOpen: 'M10,70 L50,30 L90,70',
	        content: 'ss-content',
	        openAbove: 'ss-open-above',
	        openBelow: 'ss-open-below',
	        search: 'ss-search',
	        searchHighlighter: 'ss-search-highlight',
	        searching: 'ss-searching',
	        addable: 'ss-addable',
	        addablePath: 'M50,10 L50,90 M10,50 L90,50',
	        list: 'ss-list',
	        optgroup: 'ss-optgroup',
	        optgroupLabel: 'ss-optgroup-label',
	        optgroupLabelText: 'ss-optgroup-label-text',
	        optgroupActions: 'ss-optgroup-actions',
	        optgroupSelectAll: 'ss-selectall',
	        optgroupSelectAllBox: 'M60,10 L10,10 L10,90 L90,90 L90,50',
	        optgroupSelectAllCheck: 'M30,45 L50,70 L90,10',
	        optgroupClosable: 'ss-closable',
	        option: 'ss-option',
	        optionDelete: 'M10,10 L90,90 M10,90 L90,10',
	        highlighted: 'ss-highlighted',
	        open: 'ss-open',
	        close: 'ss-close',
	        selected: 'ss-selected',
	        error: 'ss-error',
	        disabled: 'ss-disabled',
	        hide: 'ss-hide'
	      };
	      this.store = store;
	      this.settings = settings;
	      this.callbacks = callbacks;
	      this.main = this.mainDiv();
	      this.content = this.contentDiv();
	      this.updateClassStyles();
	      this.updateAriaAttributes();
	      this.settings.contentLocation.appendChild(this.content.main);
	    }
	    enable() {
	      this.main.main.classList.remove(this.classes.disabled);
	      this.content.search.input.disabled = false;
	    }
	    disable() {
	      this.main.main.classList.add(this.classes.disabled);
	      this.content.search.input.disabled = true;
	    }
	    open() {
	      this.main.arrow.path.setAttribute('d', this.classes.arrowOpen);
	      this.main.main.classList.add(this.settings.openPosition === 'up' ? this.classes.openAbove : this.classes.openBelow);
	      this.main.main.setAttribute('aria-expanded', 'true');
	      this.moveContent();
	      const selectedOptions = this.store.getSelectedOptions();
	      if (selectedOptions.length) {
	        const selectedId = selectedOptions[selectedOptions.length - 1].id;
	        const selectedOption = this.content.list.querySelector('[data-id="' + selectedId + '"]');
	        if (selectedOption) {
	          this.ensureElementInView(this.content.list, selectedOption);
	        }
	      }
	    }
	    close() {
	      this.main.main.classList.remove(this.classes.openAbove);
	      this.main.main.classList.remove(this.classes.openBelow);
	      this.main.main.setAttribute('aria-expanded', 'false');
	      this.content.main.classList.remove(this.classes.openAbove);
	      this.content.main.classList.remove(this.classes.openBelow);
	      this.main.arrow.path.setAttribute('d', this.classes.arrowClose);
	    }
	    updateClassStyles() {
	      this.main.main.className = '';
	      this.main.main.removeAttribute('style');
	      this.content.main.className = '';
	      this.content.main.removeAttribute('style');
	      this.main.main.classList.add(this.classes.main);
	      this.content.main.classList.add(this.classes.content);
	      if (this.settings.style !== '') {
	        this.main.main.style.cssText = this.settings.style;
	        this.content.main.style.cssText = this.settings.style;
	      }
	      if (this.settings.class.length) {
	        for (const c of this.settings.class) {
	          if (c.trim() !== '') {
	            this.main.main.classList.add(c.trim());
	            this.content.main.classList.add(c.trim());
	          }
	        }
	      }
	      if (this.settings.contentPosition === 'relative') {
	        this.content.main.classList.add('ss-' + this.settings.contentPosition);
	      }
	    }
	    updateAriaAttributes() {
	      this.main.main.role = 'combobox';
	      this.main.main.setAttribute('aria-haspopup', 'listbox');
	      this.main.main.setAttribute('aria-controls', this.content.main.id);
	      this.main.main.setAttribute('aria-expanded', 'false');
	      this.content.main.setAttribute('role', 'listbox');
	    }
	    mainDiv() {
	      var _a;
	      const main = document.createElement('div');
	      main.dataset.id = this.settings.id;
	      main.setAttribute('aria-label', this.settings.ariaLabel);
	      main.tabIndex = 0;
	      main.onkeydown = e => {
	        switch (e.key) {
	          case 'ArrowUp':
	          case 'ArrowDown':
	            this.callbacks.open();
	            e.key === 'ArrowDown' ? this.highlight('down') : this.highlight('up');
	            return false;
	          case 'Tab':
	            this.callbacks.close();
	            return true;
	          case 'Enter':
	          case ' ':
	            this.callbacks.open();
	            const highlighted = this.content.list.querySelector('.' + this.classes.highlighted);
	            if (highlighted) {
	              highlighted.click();
	            }
	            return false;
	          case 'Escape':
	            this.callbacks.close();
	            return false;
	        }
	        return false;
	      };
	      main.onclick = e => {
	        if (this.settings.disabled) {
	          return;
	        }
	        this.settings.isOpen ? this.callbacks.close() : this.callbacks.open();
	      };
	      const values = document.createElement('div');
	      values.classList.add(this.classes.values);
	      main.appendChild(values);
	      const deselect = document.createElement('div');
	      deselect.classList.add(this.classes.deselect);
	      const selectedOptions = (_a = this.store) === null || _a === void 0 ? void 0 : _a.getSelectedOptions();
	      if (!this.settings.allowDeselect || this.settings.isMultiple && selectedOptions && selectedOptions.length <= 0) {
	        deselect.classList.add(this.classes.hide);
	      } else {
	        deselect.classList.remove(this.classes.hide);
	      }
	      deselect.onclick = e => {
	        e.stopPropagation();
	        if (this.settings.disabled) {
	          return;
	        }
	        let shouldDelete = true;
	        const before = this.store.getSelectedOptions();
	        const after = [];
	        if (this.callbacks.beforeChange) {
	          shouldDelete = this.callbacks.beforeChange(after, before) === true;
	        }
	        if (shouldDelete) {
	          if (this.settings.isMultiple) {
	            this.callbacks.setSelected([], false);
	            this.updateDeselectAll();
	          } else {
	            const firstOption = this.store.getFirstOption();
	            const value = firstOption ? firstOption.value : '';
	            this.callbacks.setSelected(value, false);
	          }
	          if (this.settings.closeOnSelect) {
	            this.callbacks.close();
	          }
	          if (this.callbacks.afterChange) {
	            this.callbacks.afterChange(this.store.getSelectedOptions());
	          }
	        }
	      };
	      const deselectSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
	      deselectSvg.setAttribute('viewBox', '0 0 100 100');
	      const deselectPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
	      deselectPath.setAttribute('d', this.classes.deselectPath);
	      deselectSvg.appendChild(deselectPath);
	      deselect.appendChild(deselectSvg);
	      main.appendChild(deselect);
	      const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
	      arrow.classList.add(this.classes.arrow);
	      arrow.setAttribute('viewBox', '0 0 100 100');
	      const arrowPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
	      arrowPath.setAttribute('d', this.classes.arrowClose);
	      if (this.settings.alwaysOpen) {
	        arrow.classList.add(this.classes.hide);
	      }
	      arrow.appendChild(arrowPath);
	      main.appendChild(arrow);
	      return {
	        main: main,
	        values: values,
	        deselect: {
	          main: deselect,
	          svg: deselectSvg,
	          path: deselectPath
	        },
	        arrow: {
	          main: arrow,
	          path: arrowPath
	        }
	      };
	    }
	    mainFocus(eventType) {
	      if (eventType !== 'click') {
	        this.main.main.focus({
	          preventScroll: true
	        });
	      }
	    }
	    placeholder() {
	      const placeholderOption = this.store.filter(o => o.placeholder, false);
	      let placeholderText = this.settings.placeholderText;
	      if (placeholderOption.length) {
	        if (placeholderOption[0].html !== '') {
	          placeholderText = placeholderOption[0].html;
	        } else if (placeholderOption[0].text !== '') {
	          placeholderText = placeholderOption[0].text;
	        }
	      }
	      const placeholder = document.createElement('div');
	      placeholder.classList.add(this.classes.placeholder);
	      placeholder.innerHTML = placeholderText;
	      return placeholder;
	    }
	    renderValues() {
	      if (!this.settings.isMultiple) {
	        this.renderSingleValue();
	        return;
	      }
	      this.renderMultipleValues();
	      this.updateDeselectAll();
	    }
	    renderSingleValue() {
	      const selected = this.store.filter(o => {
	        return o.selected && !o.placeholder;
	      }, false);
	      const selectedSingle = selected.length > 0 ? selected[0] : null;
	      if (!selectedSingle) {
	        this.main.values.innerHTML = this.placeholder().outerHTML;
	      } else {
	        const singleValue = document.createElement('div');
	        singleValue.classList.add(this.classes.single);
	        if (selectedSingle.html) {
	          singleValue.innerHTML = selectedSingle.html;
	        } else {
	          singleValue.innerText = selectedSingle.text;
	        }
	        this.main.values.innerHTML = singleValue.outerHTML;
	      }
	      if (!this.settings.allowDeselect || !selected.length) {
	        this.main.deselect.main.classList.add(this.classes.hide);
	      } else {
	        this.main.deselect.main.classList.remove(this.classes.hide);
	      }
	    }
	    renderMultipleValues() {
	      let currentNodes = this.main.values.childNodes;
	      let selectedOptions = this.store.filter(opt => {
	        return opt.selected && opt.display;
	      }, false);
	      if (selectedOptions.length === 0) {
	        this.main.values.innerHTML = this.placeholder().outerHTML;
	        return;
	      } else {
	        const placeholder = this.main.values.querySelector('.' + this.classes.placeholder);
	        if (placeholder) {
	          placeholder.remove();
	        }
	      }
	      if (selectedOptions.length > this.settings.maxValuesShown) {
	        const singleValue = document.createElement('div');
	        singleValue.classList.add(this.classes.max);
	        singleValue.textContent = this.settings.maxValuesMessage.replace('{number}', selectedOptions.length.toString());
	        this.main.values.innerHTML = singleValue.outerHTML;
	        return;
	      } else {
	        const maxValuesMessage = this.main.values.querySelector('.' + this.classes.max);
	        if (maxValuesMessage) {
	          maxValuesMessage.remove();
	        }
	      }
	      let removeNodes = [];
	      for (let i = 0; i < currentNodes.length; i++) {
	        const node = currentNodes[i];
	        const id = node.getAttribute('data-id');
	        if (id) {
	          const found = selectedOptions.filter(opt => {
	            return opt.id === id;
	          }, false);
	          if (!found.length) {
	            removeNodes.push(node);
	          }
	        }
	      }
	      for (const n of removeNodes) {
	        n.classList.add(this.classes.valueOut);
	        setTimeout(() => {
	          if (this.main.values.hasChildNodes() && this.main.values.contains(n)) {
	            this.main.values.removeChild(n);
	          }
	        }, 100);
	      }
	      currentNodes = this.main.values.childNodes;
	      for (let d = 0; d < selectedOptions.length; d++) {
	        let shouldAdd = true;
	        for (let i = 0; i < currentNodes.length; i++) {
	          if (selectedOptions[d].id === String(currentNodes[i].dataset.id)) {
	            shouldAdd = false;
	          }
	        }
	        if (shouldAdd) {
	          if (this.settings.keepOrder) {
	            this.main.values.appendChild(this.multipleValue(selectedOptions[d]));
	          } else {
	            if (currentNodes.length === 0) {
	              this.main.values.appendChild(this.multipleValue(selectedOptions[d]));
	            } else if (d === 0) {
	              this.main.values.insertBefore(this.multipleValue(selectedOptions[d]), currentNodes[d]);
	            } else {
	              currentNodes[d - 1].insertAdjacentElement('afterend', this.multipleValue(selectedOptions[d]));
	            }
	          }
	        }
	      }
	    }
	    multipleValue(option) {
	      const value = document.createElement('div');
	      value.classList.add(this.classes.value);
	      value.dataset.id = option.id;
	      const text = document.createElement('div');
	      text.classList.add(this.classes.valueText);
	      text.innerText = option.text;
	      value.appendChild(text);
	      if (!option.mandatory) {
	        const deleteDiv = document.createElement('div');
	        deleteDiv.classList.add(this.classes.valueDelete);
	        deleteDiv.onclick = e => {
	          e.preventDefault();
	          e.stopPropagation();
	          if (this.settings.disabled) {
	            return;
	          }
	          let shouldDelete = true;
	          const before = this.store.getSelectedOptions();
	          const after = before.filter(o => {
	            return o.selected && o.id !== option.id;
	          }, true);
	          if (this.settings.minSelected && after.length < this.settings.minSelected) {
	            return;
	          }
	          if (this.callbacks.beforeChange) {
	            shouldDelete = this.callbacks.beforeChange(after, before) === true;
	          }
	          if (shouldDelete) {
	            let selectedValues = [];
	            for (const o of after) {
	              if (o instanceof Optgroup) {
	                for (const c of o.options) {
	                  selectedValues.push(c.value);
	                }
	              }
	              if (o instanceof Option) {
	                selectedValues.push(o.value);
	              }
	            }
	            this.callbacks.setSelected(selectedValues, false);
	            if (this.settings.closeOnSelect) {
	              this.callbacks.close();
	            }
	            if (this.callbacks.afterChange) {
	              this.callbacks.afterChange(after);
	            }
	            this.updateDeselectAll();
	          }
	        };
	        const deleteSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
	        deleteSvg.setAttribute('viewBox', '0 0 100 100');
	        const deletePath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
	        deletePath.setAttribute('d', this.classes.optionDelete);
	        deleteSvg.appendChild(deletePath);
	        deleteDiv.appendChild(deleteSvg);
	        value.appendChild(deleteDiv);
	      }
	      return value;
	    }
	    contentDiv() {
	      const main = document.createElement('div');
	      main.dataset.id = this.settings.id;
	      const search = this.searchDiv();
	      main.appendChild(search.main);
	      const list = this.listDiv();
	      main.appendChild(list);
	      return {
	        main: main,
	        search: search,
	        list: list
	      };
	    }
	    moveContent() {
	      if (this.settings.contentPosition === 'relative') {
	        this.moveContentBelow();
	        return;
	      }
	      if (this.settings.openPosition === 'down') {
	        this.moveContentBelow();
	        return;
	      } else if (this.settings.openPosition === 'up') {
	        this.moveContentAbove();
	        return;
	      }
	      if (this.putContent() === 'up') {
	        this.moveContentAbove();
	      } else {
	        this.moveContentBelow();
	      }
	    }
	    searchDiv() {
	      const main = document.createElement('div');
	      const input = document.createElement('input');
	      const addable = document.createElement('div');
	      main.classList.add(this.classes.search);
	      const searchReturn = {
	        main,
	        input
	      };
	      if (!this.settings.showSearch) {
	        main.classList.add(this.classes.hide);
	        input.readOnly = true;
	      }
	      input.type = 'search';
	      input.placeholder = this.settings.searchPlaceholder;
	      input.tabIndex = -1;
	      input.setAttribute('aria-label', this.settings.searchPlaceholder);
	      input.setAttribute('autocapitalize', 'off');
	      input.setAttribute('autocomplete', 'off');
	      input.setAttribute('autocorrect', 'off');
	      input.oninput = debounce(e => {
	        this.callbacks.search(e.target.value);
	      }, 100);
	      input.onkeydown = e => {
	        switch (e.key) {
	          case 'ArrowUp':
	          case 'ArrowDown':
	            e.key === 'ArrowDown' ? this.highlight('down') : this.highlight('up');
	            return false;
	          case 'Tab':
	            this.callbacks.close();
	            return true;
	          case 'Escape':
	            this.callbacks.close();
	            return false;
	          case 'Enter':
	          case ' ':
	            if (this.callbacks.addable && e.ctrlKey) {
	              addable.click();
	              return false;
	            } else {
	              const highlighted = this.content.list.querySelector('.' + this.classes.highlighted);
	              if (highlighted) {
	                highlighted.click();
	                return false;
	              }
	            }
	            return true;
	        }
	        return true;
	      };
	      main.appendChild(input);
	      if (this.callbacks.addable) {
	        addable.classList.add(this.classes.addable);
	        const plus = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
	        plus.setAttribute('viewBox', '0 0 100 100');
	        const plusPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
	        plusPath.setAttribute('d', this.classes.addablePath);
	        plus.appendChild(plusPath);
	        addable.appendChild(plus);
	        addable.onclick = e => {
	          e.preventDefault();
	          e.stopPropagation();
	          if (!this.callbacks.addable) {
	            return;
	          }
	          const inputValue = this.content.search.input.value.trim();
	          if (inputValue === '') {
	            this.content.search.input.focus();
	            return;
	          }
	          const runFinish = oo => {
	            let newOption = new Option(oo);
	            this.callbacks.addOption(newOption);
	            if (this.settings.isMultiple) {
	              let values = this.store.getSelected();
	              values.push(newOption.value);
	              this.callbacks.setSelected(values, true);
	            } else {
	              this.callbacks.setSelected([newOption.value], true);
	            }
	            this.callbacks.search('');
	            if (this.settings.closeOnSelect) {
	              setTimeout(() => {
	                this.callbacks.close();
	              }, 100);
	            }
	          };
	          const addableValue = this.callbacks.addable(inputValue);
	          if (addableValue === false || addableValue === undefined || addableValue === null) {
	            return;
	          }
	          if (addableValue instanceof Promise) {
	            addableValue.then(value => {
	              if (typeof value === 'string') {
	                runFinish({
	                  text: value,
	                  value: value
	                });
	              } else {
	                runFinish(value);
	              }
	            });
	          } else if (typeof addableValue === 'string') {
	            runFinish({
	              text: addableValue,
	              value: addableValue
	            });
	          } else {
	            runFinish(addableValue);
	          }
	          return;
	        };
	        main.appendChild(addable);
	        searchReturn.addable = {
	          main: addable,
	          svg: plus,
	          path: plusPath
	        };
	      }
	      return searchReturn;
	    }
	    searchFocus() {
	      this.content.search.input.focus();
	    }
	    getOptions(notPlaceholder = false, notDisabled = false, notHidden = false) {
	      let query = '.' + this.classes.option;
	      if (notPlaceholder) {
	        query += ':not(.' + this.classes.placeholder + ')';
	      }
	      if (notDisabled) {
	        query += ':not(.' + this.classes.disabled + ')';
	      }
	      if (notHidden) {
	        query += ':not(.' + this.classes.hide + ')';
	      }
	      return Array.from(this.content.list.querySelectorAll(query));
	    }
	    highlight(dir) {
	      const options = this.getOptions(true, true, true);
	      if (options.length === 0) {
	        return;
	      }
	      if (options.length === 1) {
	        if (!options[0].classList.contains(this.classes.highlighted)) {
	          options[0].classList.add(this.classes.highlighted);
	          return;
	        }
	      }
	      let highlighted = false;
	      for (const o of options) {
	        if (o.classList.contains(this.classes.highlighted)) {
	          highlighted = true;
	        }
	      }
	      if (!highlighted) {
	        for (const o of options) {
	          if (o.classList.contains(this.classes.selected)) {
	            o.classList.add(this.classes.highlighted);
	            break;
	          }
	        }
	      }
	      for (let i = 0; i < options.length; i++) {
	        if (options[i].classList.contains(this.classes.highlighted)) {
	          const prevOption = options[i];
	          prevOption.classList.remove(this.classes.highlighted);
	          const prevParent = prevOption.parentElement;
	          if (prevParent && prevParent.classList.contains(this.classes.open)) {
	            const optgroupLabel = prevParent.querySelector('.' + this.classes.optgroupLabel);
	            if (optgroupLabel) {
	              optgroupLabel.click();
	            }
	          }
	          let selectOption = options[dir === 'down' ? i + 1 < options.length ? i + 1 : 0 : i - 1 >= 0 ? i - 1 : options.length - 1];
	          selectOption.classList.add(this.classes.highlighted);
	          this.ensureElementInView(this.content.list, selectOption);
	          const selectParent = selectOption.parentElement;
	          if (selectParent && selectParent.classList.contains(this.classes.close)) {
	            const optgroupLabel = selectParent.querySelector('.' + this.classes.optgroupLabel);
	            if (optgroupLabel) {
	              optgroupLabel.click();
	            }
	          }
	          return;
	        }
	      }
	      options[dir === 'down' ? 0 : options.length - 1].classList.add(this.classes.highlighted);
	      this.ensureElementInView(this.content.list, options[dir === 'down' ? 0 : options.length - 1]);
	    }
	    listDiv() {
	      const options = document.createElement('div');
	      options.classList.add(this.classes.list);
	      return options;
	    }
	    renderError(error) {
	      this.content.list.innerHTML = '';
	      const errorDiv = document.createElement('div');
	      errorDiv.classList.add(this.classes.error);
	      errorDiv.textContent = error;
	      this.content.list.appendChild(errorDiv);
	    }
	    renderSearching() {
	      this.content.list.innerHTML = '';
	      const searchingDiv = document.createElement('div');
	      searchingDiv.classList.add(this.classes.searching);
	      searchingDiv.textContent = this.settings.searchingText;
	      this.content.list.appendChild(searchingDiv);
	    }
	    renderOptions(data) {
	      this.content.list.innerHTML = '';
	      if (data.length === 0) {
	        const noResults = document.createElement('div');
	        noResults.classList.add(this.classes.search);
	        noResults.innerHTML = this.settings.searchText;
	        this.content.list.appendChild(noResults);
	        return;
	      }
	      for (const d of data) {
	        if (d instanceof Optgroup) {
	          const optgroupEl = document.createElement('div');
	          optgroupEl.classList.add(this.classes.optgroup);
	          const optgroupLabel = document.createElement('div');
	          optgroupLabel.classList.add(this.classes.optgroupLabel);
	          optgroupEl.appendChild(optgroupLabel);
	          const optgroupLabelText = document.createElement('div');
	          optgroupLabelText.classList.add(this.classes.optgroupLabelText);
	          optgroupLabelText.textContent = d.label;
	          optgroupLabel.appendChild(optgroupLabelText);
	          const optgroupActions = document.createElement('div');
	          optgroupActions.classList.add(this.classes.optgroupActions);
	          optgroupLabel.appendChild(optgroupActions);
	          if (this.settings.isMultiple && d.selectAll) {
	            const selectAll = document.createElement('div');
	            selectAll.classList.add(this.classes.optgroupSelectAll);
	            let allSelected = true;
	            for (const o of d.options) {
	              if (!o.selected) {
	                allSelected = false;
	                break;
	              }
	            }
	            if (allSelected) {
	              selectAll.classList.add(this.classes.selected);
	            }
	            const selectAllText = document.createElement('span');
	            selectAllText.textContent = d.selectAllText;
	            selectAll.appendChild(selectAllText);
	            const selectAllSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
	            selectAllSvg.setAttribute('viewBox', '0 0 100 100');
	            selectAll.appendChild(selectAllSvg);
	            const selectAllBox = document.createElementNS('http://www.w3.org/2000/svg', 'path');
	            selectAllBox.setAttribute('d', this.classes.optgroupSelectAllBox);
	            selectAllSvg.appendChild(selectAllBox);
	            const selectAllCheck = document.createElementNS('http://www.w3.org/2000/svg', 'path');
	            selectAllCheck.setAttribute('d', this.classes.optgroupSelectAllCheck);
	            selectAllSvg.appendChild(selectAllCheck);
	            selectAll.addEventListener('click', e => {
	              e.preventDefault();
	              e.stopPropagation();
	              const currentSelected = this.store.getSelected();
	              if (allSelected) {
	                const newSelected = currentSelected.filter(s => {
	                  for (const o of d.options) {
	                    if (s === o.value) {
	                      return false;
	                    }
	                  }
	                  return true;
	                });
	                this.callbacks.setSelected(newSelected, true);
	                return;
	              } else {
	                const newSelected = currentSelected.concat(d.options.map(o => o.value));
	                for (const o of d.options) {
	                  if (!this.store.getOptionByID(o.id)) {
	                    this.callbacks.addOption(o);
	                  }
	                }
	                this.callbacks.setSelected(newSelected, true);
	                return;
	              }
	            });
	            optgroupActions.appendChild(selectAll);
	          }
	          if (d.closable !== 'off') {
	            const optgroupClosable = document.createElement('div');
	            optgroupClosable.classList.add(this.classes.optgroupClosable);
	            const optgroupClosableSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
	            optgroupClosableSvg.setAttribute('viewBox', '0 0 100 100');
	            optgroupClosableSvg.classList.add(this.classes.arrow);
	            optgroupClosable.appendChild(optgroupClosableSvg);
	            const optgroupClosableArrow = document.createElementNS('http://www.w3.org/2000/svg', 'path');
	            optgroupClosableSvg.appendChild(optgroupClosableArrow);
	            if (d.options.some(o => o.selected) || this.content.search.input.value.trim() !== '') {
	              optgroupClosable.classList.add(this.classes.open);
	              optgroupClosableArrow.setAttribute('d', this.classes.arrowOpen);
	            } else if (d.closable === 'open') {
	              optgroupEl.classList.add(this.classes.open);
	              optgroupClosableArrow.setAttribute('d', this.classes.arrowOpen);
	            } else if (d.closable === 'close') {
	              optgroupEl.classList.add(this.classes.close);
	              optgroupClosableArrow.setAttribute('d', this.classes.arrowClose);
	            }
	            optgroupLabel.addEventListener('click', e => {
	              e.preventDefault();
	              e.stopPropagation();
	              if (optgroupEl.classList.contains(this.classes.close)) {
	                optgroupEl.classList.remove(this.classes.close);
	                optgroupEl.classList.add(this.classes.open);
	                optgroupClosableArrow.setAttribute('d', this.classes.arrowOpen);
	              } else {
	                optgroupEl.classList.remove(this.classes.open);
	                optgroupEl.classList.add(this.classes.close);
	                optgroupClosableArrow.setAttribute('d', this.classes.arrowClose);
	              }
	            });
	            optgroupActions.appendChild(optgroupClosable);
	          }
	          optgroupEl.appendChild(optgroupLabel);
	          for (const o of d.options) {
	            optgroupEl.appendChild(this.option(o));
	          }
	          this.content.list.appendChild(optgroupEl);
	        }
	        if (d instanceof Option) {
	          this.content.list.appendChild(this.option(d));
	        }
	      }
	    }
	    option(option) {
	      if (option.placeholder) {
	        const placeholder = document.createElement('div');
	        placeholder.classList.add(this.classes.option);
	        placeholder.classList.add(this.classes.hide);
	        return placeholder;
	      }
	      const optionEl = document.createElement('div');
	      optionEl.dataset.id = option.id;
	      optionEl.id = option.id;
	      optionEl.classList.add(this.classes.option);
	      optionEl.setAttribute('role', 'option');
	      if (option.class) {
	        option.class.split(' ').forEach(dataClass => {
	          optionEl.classList.add(dataClass);
	        });
	      }
	      if (option.style) {
	        optionEl.style.cssText = option.style;
	      }
	      if (this.settings.searchHighlight && this.content.search.input.value.trim() !== '') {
	        optionEl.innerHTML = this.highlightText(option.html !== '' ? option.html : option.text, this.content.search.input.value, this.classes.searchHighlighter);
	      } else if (option.html !== '') {
	        optionEl.innerHTML = option.html;
	      } else {
	        optionEl.textContent = option.text;
	      }
	      if (this.settings.showOptionTooltips && optionEl.textContent) {
	        optionEl.setAttribute('title', optionEl.textContent);
	      }
	      if (!option.display) {
	        optionEl.classList.add(this.classes.hide);
	      }
	      if (option.disabled) {
	        optionEl.classList.add(this.classes.disabled);
	      }
	      if (option.selected && this.settings.hideSelected) {
	        optionEl.classList.add(this.classes.hide);
	      }
	      if (option.selected) {
	        optionEl.classList.add(this.classes.selected);
	        optionEl.setAttribute('aria-selected', 'true');
	        this.main.main.setAttribute('aria-activedescendant', optionEl.id);
	      } else {
	        optionEl.classList.remove(this.classes.selected);
	        optionEl.setAttribute('aria-selected', 'false');
	      }
	      optionEl.addEventListener('click', e => {
	        e.preventDefault();
	        e.stopPropagation();
	        const selectedOptions = this.store.getSelected();
	        const element = e.currentTarget;
	        const elementID = String(element.dataset.id);
	        if (option.disabled || option.selected && !this.settings.allowDeselect) {
	          return;
	        }
	        if (this.settings.isMultiple && this.settings.maxSelected <= selectedOptions.length && !option.selected || this.settings.isMultiple && this.settings.minSelected >= selectedOptions.length && option.selected) {
	          return;
	        }
	        let shouldUpdate = false;
	        const before = this.store.getSelectedOptions();
	        let after = [];
	        if (this.settings.isMultiple) {
	          if (option.selected) {
	            after = before.filter(o => o.id !== elementID);
	          } else {
	            after = before.concat(option);
	          }
	        }
	        if (!this.settings.isMultiple) {
	          if (option.selected) {
	            after = [];
	          } else {
	            after = [option];
	          }
	        }
	        if (!this.callbacks.beforeChange) {
	          shouldUpdate = true;
	        }
	        if (this.callbacks.beforeChange) {
	          if (this.callbacks.beforeChange(after, before) === false) {
	            shouldUpdate = false;
	          } else {
	            shouldUpdate = true;
	          }
	        }
	        if (shouldUpdate) {
	          if (!this.store.getOptionByID(elementID)) {
	            this.callbacks.addOption(option);
	          }
	          this.callbacks.setSelected(after.map(o => o.value), false);
	          if (this.settings.closeOnSelect) {
	            this.callbacks.close();
	          }
	          if (this.callbacks.afterChange) {
	            this.callbacks.afterChange(after);
	          }
	        }
	      });
	      return optionEl;
	    }
	    destroy() {
	      this.main.main.remove();
	      this.content.main.remove();
	    }
	    highlightText(str, search, className) {
	      let completedString = str;
	      const regex = new RegExp('(' + search.trim() + ')(?![^<]*>[^<>]*</)', 'i');
	      if (!str.match(regex)) {
	        return str;
	      }
	      const matchStartPosition = str.match(regex).index;
	      const matchEndPosition = matchStartPosition + str.match(regex)[0].toString().length;
	      const originalTextFoundByRegex = str.substring(matchStartPosition, matchEndPosition);
	      completedString = completedString.replace(regex, `<mark class="${className}">${originalTextFoundByRegex}</mark>`);
	      return completedString;
	    }
	    moveContentAbove() {
	      const mainHeight = this.main.main.offsetHeight;
	      const contentHeight = this.content.main.offsetHeight;
	      this.main.main.classList.remove(this.classes.openBelow);
	      this.main.main.classList.add(this.classes.openAbove);
	      this.content.main.classList.remove(this.classes.openBelow);
	      this.content.main.classList.add(this.classes.openAbove);
	      const containerRect = this.main.main.getBoundingClientRect();
	      this.content.main.style.margin = '-' + (mainHeight + contentHeight - 1) + 'px 0px 0px 0px';
	      this.content.main.style.top = containerRect.top + containerRect.height + window.scrollY + 'px';
	      this.content.main.style.left = containerRect.left + window.scrollX + 'px';
	      this.content.main.style.width = containerRect.width + 'px';
	    }
	    moveContentBelow() {
	      this.main.main.classList.remove(this.classes.openAbove);
	      this.main.main.classList.add(this.classes.openBelow);
	      this.content.main.classList.remove(this.classes.openAbove);
	      this.content.main.classList.add(this.classes.openBelow);
	      const containerRect = this.main.main.getBoundingClientRect();
	      this.content.main.style.margin = '-1px 0px 0px 0px';
	      if (this.settings.contentPosition !== 'relative') {
	        this.content.main.style.top = containerRect.top + containerRect.height + window.scrollY + 'px';
	        this.content.main.style.left = containerRect.left + window.scrollX + 'px';
	        this.content.main.style.width = containerRect.width + 'px';
	      }
	    }
	    ensureElementInView(container, element) {
	      const cTop = container.scrollTop + container.offsetTop;
	      const cBottom = cTop + container.clientHeight;
	      const eTop = element.offsetTop;
	      const eBottom = eTop + element.clientHeight;
	      if (eTop < cTop) {
	        container.scrollTop -= cTop - eTop;
	      } else if (eBottom > cBottom) {
	        container.scrollTop += eBottom - cBottom;
	      }
	    }
	    putContent() {
	      const mainHeight = this.main.main.offsetHeight;
	      const mainRect = this.main.main.getBoundingClientRect();
	      const contentHeight = this.content.main.offsetHeight;
	      const spaceBelow = window.innerHeight - (mainRect.top + mainHeight);
	      if (spaceBelow <= contentHeight) {
	        if (mainRect.top > contentHeight) {
	          return 'up';
	        } else {
	          return 'down';
	        }
	      }
	      return 'down';
	    }
	    updateDeselectAll() {
	      if (!this.store || !this.settings) {
	        return;
	      }
	      const selected = this.store.getSelectedOptions();
	      const hasSelectedItems = selected && selected.length > 0;
	      const isMultiple = this.settings.isMultiple;
	      const allowDeselect = this.settings.allowDeselect;
	      const deselectButton = this.main.deselect.main;
	      const hideClass = this.classes.hide;
	      if (allowDeselect && !(isMultiple && !hasSelectedItems)) {
	        deselectButton.classList.remove(hideClass);
	      } else {
	        deselectButton.classList.add(hideClass);
	      }
	    }
	  }
	  class Select {
	    constructor(select) {
	      this.listen = false;
	      this.observer = null;
	      this.select = select;
	      this.valueChange = this.valueChange.bind(this);
	      this.select.addEventListener('change', this.valueChange, {
	        passive: true
	      });
	      this.observer = new MutationObserver(this.observeCall.bind(this));
	      this.changeListen(true);
	    }
	    enable() {
	      this.select.disabled = false;
	    }
	    disable() {
	      this.select.disabled = true;
	    }
	    hideUI() {
	      this.select.tabIndex = -1;
	      this.select.style.display = 'none';
	      this.select.setAttribute('aria-hidden', 'true');
	    }
	    showUI() {
	      this.select.removeAttribute('tabindex');
	      this.select.style.display = '';
	      this.select.removeAttribute('aria-hidden');
	    }
	    changeListen(listen) {
	      this.listen = listen;
	      if (listen) {
	        if (this.observer) {
	          this.observer.observe(this.select, {
	            subtree: true,
	            childList: true,
	            attributes: true
	          });
	        }
	      }
	      if (!listen) {
	        if (this.observer) {
	          this.observer.disconnect();
	        }
	      }
	    }
	    valueChange(ev) {
	      if (this.listen && this.onValueChange) {
	        this.onValueChange(this.getSelectedValues());
	      }
	      return true;
	    }
	    observeCall(mutations) {
	      if (!this.listen) {
	        return;
	      }
	      let classChanged = false;
	      let disabledChanged = false;
	      let optgroupOptionChanged = false;
	      for (const m of mutations) {
	        if (m.target === this.select) {
	          if (m.attributeName === 'disabled') {
	            disabledChanged = true;
	          }
	          if (m.attributeName === 'class') {
	            classChanged = true;
	          }
	        }
	        if (m.target.nodeName === 'OPTGROUP' || m.target.nodeName === 'OPTION') {
	          optgroupOptionChanged = true;
	        }
	      }
	      if (classChanged && this.onClassChange) {
	        this.onClassChange(this.select.className.split(' '));
	      }
	      if (disabledChanged && this.onDisabledChange) {
	        this.changeListen(false);
	        this.onDisabledChange(this.select.disabled);
	        this.changeListen(true);
	      }
	      if (optgroupOptionChanged && this.onOptionsChange) {
	        this.changeListen(false);
	        this.onOptionsChange(this.getData());
	        this.changeListen(true);
	      }
	    }
	    getData() {
	      let data = [];
	      const nodes = this.select.childNodes;
	      for (const n of nodes) {
	        if (n.nodeName === 'OPTGROUP') {
	          data.push(this.getDataFromOptgroup(n));
	        }
	        if (n.nodeName === 'OPTION') {
	          data.push(this.getDataFromOption(n));
	        }
	      }
	      return data;
	    }
	    getDataFromOptgroup(optgroup) {
	      let data = {
	        id: optgroup.id,
	        label: optgroup.label,
	        selectAll: optgroup.dataset ? optgroup.dataset.selectall === 'true' : false,
	        selectAllText: optgroup.dataset ? optgroup.dataset.selectalltext : 'Select all',
	        closable: optgroup.dataset ? optgroup.dataset.closable : 'off',
	        options: []
	      };
	      const options = optgroup.childNodes;
	      for (const o of options) {
	        if (o.nodeName === 'OPTION') {
	          data.options.push(this.getDataFromOption(o));
	        }
	      }
	      return data;
	    }
	    getDataFromOption(option) {
	      return {
	        id: option.id,
	        value: option.value,
	        text: option.text,
	        html: option.dataset && option.dataset.html ? option.dataset.html : '',
	        selected: option.selected,
	        display: option.style.display === 'none' ? false : true,
	        disabled: option.disabled,
	        mandatory: option.dataset ? option.dataset.mandatory === 'true' : false,
	        placeholder: option.dataset.placeholder === 'true',
	        class: option.className,
	        style: option.style.cssText,
	        data: option.dataset
	      };
	    }
	    getSelectedValues() {
	      let values = [];
	      const options = this.select.childNodes;
	      for (const o of options) {
	        if (o.nodeName === 'OPTGROUP') {
	          const optgroupOptions = o.childNodes;
	          for (const oo of optgroupOptions) {
	            if (oo.nodeName === 'OPTION') {
	              const option = oo;
	              if (option.selected) {
	                values.push(option.value);
	              }
	            }
	          }
	        }
	        if (o.nodeName === 'OPTION') {
	          const option = o;
	          if (option.selected) {
	            values.push(option.value);
	          }
	        }
	      }
	      return values;
	    }
	    setSelected(value) {
	      this.changeListen(false);
	      const options = this.select.childNodes;
	      for (const o of options) {
	        if (o.nodeName === 'OPTGROUP') {
	          const optgroup = o;
	          const optgroupOptions = optgroup.childNodes;
	          for (const oo of optgroupOptions) {
	            if (oo.nodeName === 'OPTION') {
	              const option = oo;
	              option.selected = value.includes(option.value);
	            }
	          }
	        }
	        if (o.nodeName === 'OPTION') {
	          const option = o;
	          option.selected = value.includes(option.value);
	        }
	      }
	      this.changeListen(true);
	    }
	    updateSelect(id, style, classes) {
	      this.changeListen(false);
	      if (id) {
	        this.select.dataset.id = id;
	      }
	      if (style) {
	        this.select.style.cssText = style;
	      }
	      if (classes) {
	        this.select.className = '';
	        classes.forEach(c => {
	          if (c.trim() !== '') {
	            this.select.classList.add(c.trim());
	          }
	        });
	      }
	      this.changeListen(true);
	    }
	    updateOptions(data) {
	      this.changeListen(false);
	      this.select.innerHTML = '';
	      for (const d of data) {
	        if (d instanceof Optgroup) {
	          this.select.appendChild(this.createOptgroup(d));
	        }
	        if (d instanceof Option) {
	          this.select.appendChild(this.createOption(d));
	        }
	      }
	      this.select.dispatchEvent(new Event('change'));
	      this.changeListen(true);
	    }
	    createOptgroup(optgroup) {
	      const optgroupEl = document.createElement('optgroup');
	      optgroupEl.id = optgroup.id;
	      optgroupEl.label = optgroup.label;
	      if (optgroup.selectAll) {
	        optgroupEl.dataset.selectAll = 'true';
	      }
	      if (optgroup.closable !== 'off') {
	        optgroupEl.dataset.closable = optgroup.closable;
	      }
	      if (optgroup.options) {
	        for (const o of optgroup.options) {
	          optgroupEl.appendChild(this.createOption(o));
	        }
	      }
	      return optgroupEl;
	    }
	    createOption(info) {
	      const optionEl = document.createElement('option');
	      optionEl.id = info.id;
	      optionEl.value = info.value;
	      optionEl.innerHTML = info.text;
	      if (info.html !== '') {
	        optionEl.setAttribute('data-html', info.html);
	      }
	      if (info.selected) {
	        optionEl.selected = info.selected;
	      }
	      if (info.disabled) {
	        optionEl.disabled = true;
	      }
	      if (info.display === false) {
	        optionEl.style.display = 'none';
	      }
	      if (info.placeholder) {
	        optionEl.setAttribute('data-placeholder', 'true');
	      }
	      if (info.mandatory) {
	        optionEl.setAttribute('data-mandatory', 'true');
	      }
	      if (info.class) {
	        info.class.split(' ').forEach(optionClass => {
	          optionEl.classList.add(optionClass);
	        });
	      }
	      if (info.data && typeof info.data === 'object') {
	        Object.keys(info.data).forEach(key => {
	          optionEl.setAttribute('data-' + kebabCase(key), info.data[key]);
	        });
	      }
	      return optionEl;
	    }
	    destroy() {
	      this.changeListen(false);
	      this.select.removeEventListener('change', this.valueChange);
	      if (this.observer) {
	        this.observer.disconnect();
	        this.observer = null;
	      }
	      delete this.select.dataset.id;
	      this.showUI();
	    }
	  }
	  class Settings {
	    constructor(settings) {
	      this.id = '';
	      this.style = '';
	      this.class = [];
	      this.isMultiple = false;
	      this.isOpen = false;
	      this.isFullOpen = false;
	      this.intervalMove = null;
	      if (!settings) {
	        settings = {};
	      }
	      this.id = 'ss-' + generateID();
	      this.style = settings.style || '';
	      this.class = settings.class || [];
	      this.disabled = settings.disabled !== undefined ? settings.disabled : false;
	      this.alwaysOpen = settings.alwaysOpen !== undefined ? settings.alwaysOpen : false;
	      this.showSearch = settings.showSearch !== undefined ? settings.showSearch : true;
	      this.ariaLabel = settings.ariaLabel || 'Combobox';
	      this.searchPlaceholder = settings.searchPlaceholder || 'Search';
	      this.searchText = settings.searchText || 'No Results';
	      this.searchingText = settings.searchingText || 'Searching...';
	      this.searchHighlight = settings.searchHighlight !== undefined ? settings.searchHighlight : false;
	      this.closeOnSelect = settings.closeOnSelect !== undefined ? settings.closeOnSelect : true;
	      this.contentLocation = settings.contentLocation || document.body;
	      this.contentPosition = settings.contentPosition || 'absolute';
	      this.openPosition = settings.openPosition || 'auto';
	      this.placeholderText = settings.placeholderText !== undefined ? settings.placeholderText : 'Select Value';
	      this.allowDeselect = settings.allowDeselect !== undefined ? settings.allowDeselect : false;
	      this.hideSelected = settings.hideSelected !== undefined ? settings.hideSelected : false;
	      this.keepOrder = settings.keepOrder !== undefined ? settings.keepOrder : false;
	      this.showOptionTooltips = settings.showOptionTooltips !== undefined ? settings.showOptionTooltips : false;
	      this.minSelected = settings.minSelected || 0;
	      this.maxSelected = settings.maxSelected || 1000;
	      this.timeoutDelay = settings.timeoutDelay || 200;
	      this.maxValuesShown = settings.maxValuesShown || 20;
	      this.maxValuesMessage = settings.maxValuesMessage || '{number} selected';
	    }
	  }
	  class SlimSelect {
	    constructor(config) {
	      var _a;
	      this.events = {
	        search: undefined,
	        searchFilter: (opt, search) => {
	          return opt.text.toLowerCase().indexOf(search.toLowerCase()) !== -1;
	        },
	        addable: undefined,
	        beforeChange: undefined,
	        afterChange: undefined,
	        beforeOpen: undefined,
	        afterOpen: undefined,
	        beforeClose: undefined,
	        afterClose: undefined
	      };
	      this.windowResize = debounce(() => {
	        if (!this.settings.isOpen && !this.settings.isFullOpen) {
	          return;
	        }
	        this.render.moveContent();
	      });
	      this.windowScroll = debounce(() => {
	        if (!this.settings.isOpen && !this.settings.isFullOpen) {
	          return;
	        }
	        this.render.moveContent();
	      });
	      this.documentClick = e => {
	        if (!this.settings.isOpen) {
	          return;
	        }
	        if (e.target && !hasClassInTree(e.target, this.settings.id)) {
	          this.close(e.type);
	        }
	      };
	      this.windowVisibilityChange = () => {
	        if (document.hidden) {
	          this.close();
	        }
	      };
	      this.selectEl = typeof config.select === 'string' ? document.querySelector(config.select) : config.select;
	      if (!this.selectEl) {
	        if (config.events && config.events.error) {
	          config.events.error(new Error('Could not find select element'));
	        }
	        return;
	      }
	      if (this.selectEl.tagName !== 'SELECT') {
	        if (config.events && config.events.error) {
	          config.events.error(new Error('Element isnt of type select'));
	        }
	        return;
	      }
	      if (this.selectEl.dataset.ssid) {
	        this.destroy();
	      }
	      this.settings = new Settings(config.settings);
	      const debounceEvents = ['afterChange', 'beforeOpen', 'afterOpen', 'beforeClose', 'afterClose'];
	      for (const key in config.events) {
	        if (!config.events.hasOwnProperty(key)) {
	          continue;
	        }
	        if (debounceEvents.indexOf(key) !== -1) {
	          this.events[key] = debounce(config.events[key], 100);
	        } else {
	          this.events[key] = config.events[key];
	        }
	      }
	      this.settings.disabled = ((_a = config.settings) === null || _a === void 0 ? void 0 : _a.disabled) ? config.settings.disabled : this.selectEl.disabled;
	      this.settings.isMultiple = this.selectEl.multiple;
	      this.settings.style = this.selectEl.style.cssText;
	      this.settings.class = this.selectEl.className.split(' ');
	      this.select = new Select(this.selectEl);
	      this.select.updateSelect(this.settings.id, this.settings.style, this.settings.class);
	      this.select.hideUI();
	      this.select.onValueChange = values => {
	        this.setSelected(values);
	      };
	      this.select.onClassChange = classes => {
	        this.settings.class = classes;
	        this.render.updateClassStyles();
	      };
	      this.select.onDisabledChange = disabled => {
	        if (disabled) {
	          this.disable();
	        } else {
	          this.enable();
	        }
	      };
	      this.select.onOptionsChange = data => {
	        this.setData(data);
	      };
	      this.store = new Store(this.settings.isMultiple ? 'multiple' : 'single', config.data ? config.data : this.select.getData());
	      if (config.data) {
	        this.select.updateOptions(this.store.getData());
	      }
	      const renderCallbacks = {
	        open: this.open.bind(this),
	        close: this.close.bind(this),
	        addable: this.events.addable ? this.events.addable : undefined,
	        setSelected: this.setSelected.bind(this),
	        addOption: this.addOption.bind(this),
	        search: this.search.bind(this),
	        beforeChange: this.events.beforeChange,
	        afterChange: this.events.afterChange
	      };
	      this.render = new Render(this.settings, this.store, renderCallbacks);
	      this.render.renderValues();
	      this.render.renderOptions(this.store.getData());
	      const selectAriaLabel = this.selectEl.getAttribute('aria-label');
	      const selectAriaLabelledBy = this.selectEl.getAttribute('aria-labelledby');
	      if (selectAriaLabel) {
	        this.render.main.main.setAttribute('aria-label', selectAriaLabel);
	      } else if (selectAriaLabelledBy) {
	        this.render.main.main.setAttribute('aria-labelledby', selectAriaLabelledBy);
	      }
	      if (this.selectEl.parentNode) {
	        this.selectEl.parentNode.insertBefore(this.render.main.main, this.selectEl.nextSibling);
	      }
	      window.addEventListener('resize', this.windowResize, false);
	      if (this.settings.openPosition === 'auto') {
	        window.addEventListener('scroll', this.windowScroll, false);
	      }
	      document.addEventListener('visibilitychange', this.windowVisibilityChange);
	      if (this.settings.disabled) {
	        this.disable();
	      }
	      if (this.settings.alwaysOpen) {
	        this.open();
	      }
	      this.selectEl.slim = this;
	    }
	    enable() {
	      this.settings.disabled = false;
	      this.select.enable();
	      this.render.enable();
	    }
	    disable() {
	      this.settings.disabled = true;
	      this.select.disable();
	      this.render.disable();
	    }
	    getData() {
	      return this.store.getData();
	    }
	    setData(data) {
	      const selected = this.store.getSelected();
	      const err = this.store.validateDataArray(data);
	      if (err) {
	        if (this.events.error) {
	          this.events.error(err);
	        }
	        return;
	      }
	      this.store.setData(data);
	      const dataClean = this.store.getData();
	      this.select.updateOptions(dataClean);
	      this.render.renderValues();
	      this.render.renderOptions(dataClean);
	      if (this.events.afterChange && !isEqual(selected, this.store.getSelected())) {
	        this.events.afterChange(this.store.getSelectedOptions());
	      }
	    }
	    getSelected() {
	      return this.store.getSelected();
	    }
	    setSelected(value, runAfterChange = true) {
	      const selected = this.store.getSelected();
	      this.store.setSelectedBy('value', Array.isArray(value) ? value : [value]);
	      const data = this.store.getData();
	      this.select.updateOptions(data);
	      this.render.renderValues();
	      if (this.render.content.search.input.value !== '') {
	        this.search(this.render.content.search.input.value);
	      } else {
	        this.render.renderOptions(data);
	      }
	      if (runAfterChange && this.events.afterChange && !isEqual(selected, this.store.getSelected())) {
	        this.events.afterChange(this.store.getSelectedOptions());
	      }
	    }
	    addOption(option) {
	      const selected = this.store.getSelected();
	      if (!this.store.getDataOptions().some(o => {
	        var _a;
	        return o.value === ((_a = option.value) !== null && _a !== void 0 ? _a : option.text);
	      })) {
	        this.store.addOption(option);
	      }
	      const data = this.store.getData();
	      this.select.updateOptions(data);
	      this.render.renderValues();
	      this.render.renderOptions(data);
	      if (this.events.afterChange && !isEqual(selected, this.store.getSelected())) {
	        this.events.afterChange(this.store.getSelectedOptions());
	      }
	    }
	    open() {
	      if (this.settings.disabled || this.settings.isOpen) {
	        return;
	      }
	      if (this.events.beforeOpen) {
	        this.events.beforeOpen();
	      }
	      this.render.open();
	      if (this.settings.showSearch) {
	        this.render.searchFocus();
	      }
	      this.settings.isOpen = true;
	      setTimeout(() => {
	        if (this.events.afterOpen) {
	          this.events.afterOpen();
	        }
	        if (this.settings.isOpen) {
	          this.settings.isFullOpen = true;
	        }
	        document.addEventListener('click', this.documentClick);
	      }, this.settings.timeoutDelay);
	      if (this.settings.contentPosition === 'absolute') {
	        if (this.settings.intervalMove) {
	          clearInterval(this.settings.intervalMove);
	        }
	        this.settings.intervalMove = setInterval(this.render.moveContent.bind(this.render), 500);
	      }
	    }
	    close(eventType = null) {
	      if (!this.settings.isOpen || this.settings.alwaysOpen) {
	        return;
	      }
	      if (this.events.beforeClose) {
	        this.events.beforeClose();
	      }
	      this.render.close();
	      if (this.render.content.search.input.value !== '') {
	        this.search('');
	      }
	      this.render.mainFocus(eventType);
	      this.settings.isOpen = false;
	      this.settings.isFullOpen = false;
	      setTimeout(() => {
	        if (this.events.afterClose) {
	          this.events.afterClose();
	        }
	        document.removeEventListener('click', this.documentClick);
	      }, this.settings.timeoutDelay);
	      if (this.settings.intervalMove) {
	        clearInterval(this.settings.intervalMove);
	      }
	    }
	    search(value) {
	      if (this.render.content.search.input.value !== value) {
	        this.render.content.search.input.value = value;
	      }
	      if (!this.events.search) {
	        this.render.renderOptions(value === '' ? this.store.getData() : this.store.search(value, this.events.searchFilter));
	        return;
	      }
	      this.render.renderSearching();
	      const searchResp = this.events.search(value, this.store.getSelectedOptions());
	      if (searchResp instanceof Promise) {
	        searchResp.then(data => {
	          this.render.renderOptions(this.store.partialToFullData(data));
	        }).catch(err => {
	          this.render.renderError(typeof err === 'string' ? err : err.message);
	        });
	        return;
	      } else if (Array.isArray(searchResp)) {
	        this.render.renderOptions(this.store.partialToFullData(searchResp));
	      } else {
	        this.render.renderError('Search event must return a promise or an array of data');
	      }
	    }
	    destroy() {
	      document.removeEventListener('click', this.documentClick);
	      window.removeEventListener('resize', this.windowResize, false);
	      if (this.settings.openPosition === 'auto') {
	        window.removeEventListener('scroll', this.windowScroll, false);
	      }
	      document.removeEventListener('visibilitychange', this.windowVisibilityChange);
	      this.store.setData([]);
	      this.render.destroy();
	      this.select.destroy();
	    }
	  }
	  return SlimSelect;
	}); 
} (slimselect));

var slimselectExports = slimselect.exports;
var SlimSelect = /*@__PURE__*/getDefaultExportFromCjs(slimselectExports);

var _default$h = /*#__PURE__*/function (_Controller) {
  function _default() {
    _classCallCheck$1(this, _default);
    return _callSuper(this, _default, arguments);
  }
  _inherits$1(_default, _Controller);
  return _createClass$1(_default, [{
    key: "connect",
    value:
    // See also e.g. https://slimselectjs.com/settings
    // maxValuesShown: 100
    // placeholderText: this.placeholder
    function connect() {
      this.slimselect = new SlimSelect(_objectSpread2$1({
        select: this.element,
        settings: {
          searchHighlight: true,
          allowDeselect: true
        }
      }, this.optionsValue));
    }
  }, {
    key: "disconnect",
    value: function disconnect() {
      this.slimselect.destroy();
    }
  }]);
}(Controller);
_defineProperty$2(_default$h, "values", {
  options: Object
});

var _default$g = /*#__PURE__*/function (_Controller) {
  function _default() {
    _classCallCheck$1(this, _default);
    return _callSuper(this, _default, arguments);
  }
  _inherits$1(_default, _Controller);
  return _createClass$1(_default, [{
    key: "connect",
    value: function connect() {
      // The class we should toggle on the container
      this.toggleClass = this.data.get("class") || "hidden";

      // The ID of the background to hide/remove
      this.backgroundId = this.data.get("backgroundId") || "modal-background";

      // The HTML for the background element
      this.backgroundHtml = this.data.get("backgroundHtml") || this._backgroundHTML();

      // Let the user close the modal by clicking on the background
      this.allowBackgroundClose = (this.data.get("allowBackgroundClose") || "true") === "true";

      // Prevent the default action of the clicked element (following a link for example) when opening the modal
      this.preventDefaultActionOpening = (this.data.get("preventDefaultActionOpening") || "true") === "true";

      // Prevent the default action of the clicked element (following a link for example) when closing the modal
      this.preventDefaultActionClosing = (this.data.get("preventDefaultActionClosing") || "true") === "true";
    }
  }, {
    key: "disconnect",
    value: function disconnect() {
      this.close();
    }
  }, {
    key: "open",
    value: function open(e) {
      if (this.hasTurboFrameTarget) {
        this.turboFrameTarget.src = e.target.href;
      }
      if (this.preventDefaultActionOpening) {
        e.preventDefault();
      }
      if (e.target.blur) {
        e.target.blur();
      }

      // Lock the scroll and save current scroll position
      this.lockScroll();

      // Unhide the modal
      this.containerTarget.classList.remove(this.toggleClass);

      // Insert the background
      if (!this.data.get("disable-backdrop")) {
        document.body.insertAdjacentHTML("beforeend", this.backgroundHtml);
        this.background = document.querySelector("#".concat(this.backgroundId));
      }
    }
  }, {
    key: "close",
    value: function close(e) {
      if (e && this.preventDefaultActionClosing) {
        e.preventDefault();
      }

      // Unlock the scroll and restore previous scroll position
      this.unlockScroll();

      // Hide the modal
      this.containerTarget.classList.add(this.toggleClass);

      // Remove the background
      if (this.background) {
        this.background.remove();
      }
    }
  }, {
    key: "closeBackground",
    value: function closeBackground(e) {
      if (this.allowBackgroundClose && e.target === this.containerTarget) {
        this.close(e);
      }
    }
  }, {
    key: "closeWithKeyboard",
    value: function closeWithKeyboard(e) {
      if (e.keyCode === 27 && !this.containerTarget.classList.contains(this.toggleClass)) {
        this.close(e);
      }
    }
  }, {
    key: "_backgroundHTML",
    value: function _backgroundHTML() {
      return "<div id=\"".concat(this.backgroundId, "\" class=\"fixed top-0 left-0 w-full h-full\" style=\"background-color: ").concat(this.backdropColorValue, "; z-index: 9998;\"></div>");
    }
  }, {
    key: "lockScroll",
    value: function lockScroll() {
      // Add right padding to the body so the page doesn't shift
      // when we disable scrolling
      var scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
      document.body.style.paddingRight = "".concat(scrollbarWidth, "px");

      // Add classes to body to fix its position
      document.body.classList.add("fixed", "inset-x-0", "overflow-hidden");
      if (this.restoreScrollValue) {
        // Save the scroll position
        this.saveScrollPosition();

        // Add negative top position in order for body to stay in place
        document.body.style.top = "-".concat(this.scrollPosition, "px");
      }
    }
  }, {
    key: "unlockScroll",
    value: function unlockScroll() {
      // Remove tweaks for scrollbar
      document.body.style.paddingRight = null;

      // Remove classes from body to unfix position
      document.body.classList.remove("fixed", "inset-x-0", "overflow-hidden");

      // Restore the scroll position of the body before it got locked
      if (this.restoreScrollValue) {
        this.restoreScrollPosition();

        // Remove the negative top inline style from body
        document.body.style.top = null;
      }
    }
  }, {
    key: "saveScrollPosition",
    value: function saveScrollPosition() {
      this.scrollPosition = window.pageYOffset || document.body.scrollTop;
    }
  }, {
    key: "restoreScrollPosition",
    value: function restoreScrollPosition() {
      if (this.scrollPosition === undefined) return;
      document.documentElement.scrollTop = this.scrollPosition;
    }
  }]);
}(Controller);
_defineProperty$2(_default$g, "targets", ["container", "turboFrame"]);
_defineProperty$2(_default$g, "values", {
  backdropColor: {
    type: String,
    default: "rgba(0, 0, 0, 0.8)"
  },
  restoreScroll: {
    type: Boolean,
    default: true
  }
});

/**
 * Returns a function, that, as long as it continues to be invoked, will not
 * be triggered. The function will be called after it stops being called for
 * N milliseconds. If `immediate` is passed, trigger the function on the
 * leading edge, instead of the trailing. The function also has a property 'clear' 
 * that is a function which will clear the timer to prevent previously scheduled executions. 
 *
 * @source underscore.js
 * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/
 * @param {Function} function to wrap
 * @param {Number} timeout in ms (`100`)
 * @param {Boolean} whether to execute at the beginning (`false`)
 * @api public
 */

function debounce$2(func, wait, immediate) {
  var timeout, args, context, timestamp, result;
  if (null == wait) wait = 100;
  function later() {
    var last = Date.now() - timestamp;
    if (last < wait && last >= 0) {
      timeout = setTimeout(later, wait - last);
    } else {
      timeout = null;
      if (!immediate) {
        result = func.apply(context, args);
        context = args = null;
      }
    }
  }
  var debounced = function () {
    context = this;
    args = arguments;
    timestamp = Date.now();
    var callNow = immediate && !timeout;
    if (!timeout) timeout = setTimeout(later, wait);
    if (callNow) {
      result = func.apply(context, args);
      context = args = null;
    }
    return result;
  };
  debounced.clear = function () {
    if (timeout) {
      clearTimeout(timeout);
      timeout = null;
    }
  };
  debounced.flush = function () {
    if (timeout) {
      result = func.apply(context, args);
      context = args = null;
      clearTimeout(timeout);
      timeout = null;
    }
  };
  return debounced;
}

// Adds compatibility for ES modules
debounce$2.debounce = debounce$2;
var debounce_1 = debounce$2;

var debounce$3 = /*@__PURE__*/getDefaultExportFromCjs(debounce_1);

/*  Adds auto-submit to a form using @hotwired turbo
    Submits the form associated with the input
    Debounces changes to prevent chatter when typing into a textfield.

    Example usage:
      form_for ..
        data: {
        turbo: true,
        turbo_frame: "drugs",
        turbo_advance: true,
        controller: "form"
        action: "input->form#submit"
      }

    - turbo_frame is id the turbo_frame_tag name to replace eg a paginated table
    - turbo_advance: true will add to history as they search
    - action: "input->form#submit" will need to change depending on input type eg
      select, radio, but will cause the form to submit
*/
var _default$f = /*#__PURE__*/function (_Controller) {
  function _default() {
    _classCallCheck$1(this, _default);
    return _callSuper(this, _default, arguments);
  }
  _inherits$1(_default, _Controller);
  return _createClass$1(_default, [{
    key: "initialize",
    value: function initialize() {
      this.submit = debounce$3(this.submit.bind(this), 300);
    }
  }, {
    key: "submit",
    value: function submit(event) {
      event.target.form.requestSubmit();
    }
  }]);
}(Controller);

/*  Allows to submit an form that's different to the
   form the input is attached to. All fields that are
   part of the main form at submitted to the alternative
   form.

   Example:

   Define an empty form outside of the current form:

  = form_with url: search_url, id: "inner_drug_select_form", data: { turbo_frame: "inner_drug_select_form_frame" }, method: :get do |select_form|

  Then, specify an action that will trigger the submit of the "empty" form:

  = simple_form_for prescription, url: update_url do |f|
    = f.input_field :field,
      as: :toggle,
      data: { "action": "change->alternative-form-submitter#submit" }
*/
var _default$e = /*#__PURE__*/function (_Controller) {
  function _default() {
    _classCallCheck$1(this, _default);
    return _callSuper(this, _default, arguments);
  }
  _inherits$1(_default, _Controller);
  return _createClass$1(_default, [{
    key: "submit",
    value: function submit(event) {
      var targetForm = document.getElementById(event.target.dataset.alternativeForm) || this.formTarget;
      Array.from(event.target.form.elements).forEach(function (element) {
        element.setAttribute("form", targetForm.id);
      });
      targetForm.requestSubmit();
      Array.from(event.target.form.elements).forEach(function (element) {
        element.removeAttribute("form");
      });
    }
  }]);
}(Controller);
_defineProperty$2(_default$e, "targets", ["form"]);

// Inspired by https://www.youtube.com/watch?v=gk_qDsKMIrM&t=528s
var _default$d = /*#__PURE__*/function (_Controller) {
  function _default() {
    _classCallCheck$1(this, _default);
    return _callSuper(this, _default, arguments);
  }
  _inherits$1(_default, _Controller);
  return _createClass$1(_default, [{
    key: "connect",
    value: function connect() {
      var _this = this;
      setTimeout(function () {
        _this.dismiss();
      }, 5000);
    }
  }, {
    key: "dismiss",
    value: function dismiss() {
      this.element.remove();
    }
  }]);
}(Controller);

var HOOKS = ["onChange", "onClose", "onDayCreate", "onDestroy", "onKeyDown", "onMonthChange", "onOpen", "onParseConfig", "onReady", "onValueUpdate", "onYearChange", "onPreCalendarPosition"];
var defaults = {
  _disable: [],
  allowInput: false,
  allowInvalidPreload: false,
  altFormat: "F j, Y",
  altInput: false,
  altInputClass: "form-control input",
  animate: typeof window === "object" && window.navigator.userAgent.indexOf("MSIE") === -1,
  ariaDateFormat: "F j, Y",
  autoFillDefaultTime: true,
  clickOpens: true,
  closeOnSelect: true,
  conjunction: ", ",
  dateFormat: "Y-m-d",
  defaultHour: 12,
  defaultMinute: 0,
  defaultSeconds: 0,
  disable: [],
  disableMobile: false,
  enableSeconds: false,
  enableTime: false,
  errorHandler: function (err) {
    return typeof console !== "undefined" && console.warn(err);
  },
  getWeek: function (givenDate) {
    var date = new Date(givenDate.getTime());
    date.setHours(0, 0, 0, 0);
    date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7);
    var week1 = new Date(date.getFullYear(), 0, 4);
    return 1 + Math.round(((date.getTime() - week1.getTime()) / 86400000 - 3 + (week1.getDay() + 6) % 7) / 7);
  },
  hourIncrement: 1,
  ignoredFocusElements: [],
  inline: false,
  locale: "default",
  minuteIncrement: 5,
  mode: "single",
  monthSelectorType: "dropdown",
  nextArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>",
  noCalendar: false,
  now: new Date(),
  onChange: [],
  onClose: [],
  onDayCreate: [],
  onDestroy: [],
  onKeyDown: [],
  onMonthChange: [],
  onOpen: [],
  onParseConfig: [],
  onReady: [],
  onValueUpdate: [],
  onYearChange: [],
  onPreCalendarPosition: [],
  plugins: [],
  position: "auto",
  positionElement: undefined,
  prevArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>",
  shorthandCurrentMonth: false,
  showMonths: 1,
  static: false,
  time_24hr: false,
  weekNumbers: false,
  wrap: false
};

var english = {
  weekdays: {
    shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    longhand: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
  },
  months: {
    shorthand: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    longhand: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
  },
  daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
  firstDayOfWeek: 0,
  ordinal: function (nth) {
    var s = nth % 100;
    if (s > 3 && s < 21) return "th";
    switch (s % 10) {
      case 1:
        return "st";
      case 2:
        return "nd";
      case 3:
        return "rd";
      default:
        return "th";
    }
  },
  rangeSeparator: " to ",
  weekAbbreviation: "Wk",
  scrollTitle: "Scroll to increment",
  toggleTitle: "Click to toggle",
  amPM: ["AM", "PM"],
  yearAriaLabel: "Year",
  monthAriaLabel: "Month",
  hourAriaLabel: "Hour",
  minuteAriaLabel: "Minute",
  time_24hr: false
};

var pad = function (number, length) {
  if (length === void 0) {
    length = 2;
  }
  return ("000" + number).slice(length * -1);
};
var int = function (bool) {
  return bool === true ? 1 : 0;
};
function debounce$1(fn, wait) {
  var t;
  return function () {
    var _this = this;
    var args = arguments;
    clearTimeout(t);
    t = setTimeout(function () {
      return fn.apply(_this, args);
    }, wait);
  };
}
var arrayify = function (obj) {
  return obj instanceof Array ? obj : [obj];
};

function toggleClass(elem, className, bool) {
  if (bool === true) return elem.classList.add(className);
  elem.classList.remove(className);
}
function createElement(tag, className, content) {
  var e = window.document.createElement(tag);
  className = className || "";
  content = content || "";
  e.className = className;
  if (content !== undefined) e.textContent = content;
  return e;
}
function clearNode(node) {
  while (node.firstChild) node.removeChild(node.firstChild);
}
function findParent(node, condition) {
  if (condition(node)) return node;else if (node.parentNode) return findParent(node.parentNode, condition);
  return undefined;
}
function createNumberInput(inputClassName, opts) {
  var wrapper = createElement("div", "numInputWrapper"),
    numInput = createElement("input", "numInput " + inputClassName),
    arrowUp = createElement("span", "arrowUp"),
    arrowDown = createElement("span", "arrowDown");
  if (navigator.userAgent.indexOf("MSIE 9.0") === -1) {
    numInput.type = "number";
  } else {
    numInput.type = "text";
    numInput.pattern = "\\d*";
  }
  if (opts !== undefined) for (var key in opts) numInput.setAttribute(key, opts[key]);
  wrapper.appendChild(numInput);
  wrapper.appendChild(arrowUp);
  wrapper.appendChild(arrowDown);
  return wrapper;
}
function getEventTarget(event) {
  try {
    if (typeof event.composedPath === "function") {
      var path = event.composedPath();
      return path[0];
    }
    return event.target;
  } catch (error) {
    return event.target;
  }
}

var doNothing = function () {
  return undefined;
};
var monthToStr = function (monthNumber, shorthand, locale) {
  return locale.months[shorthand ? "shorthand" : "longhand"][monthNumber];
};
var revFormat = {
  D: doNothing,
  F: function (dateObj, monthName, locale) {
    dateObj.setMonth(locale.months.longhand.indexOf(monthName));
  },
  G: function (dateObj, hour) {
    dateObj.setHours((dateObj.getHours() >= 12 ? 12 : 0) + parseFloat(hour));
  },
  H: function (dateObj, hour) {
    dateObj.setHours(parseFloat(hour));
  },
  J: function (dateObj, day) {
    dateObj.setDate(parseFloat(day));
  },
  K: function (dateObj, amPM, locale) {
    dateObj.setHours(dateObj.getHours() % 12 + 12 * int(new RegExp(locale.amPM[1], "i").test(amPM)));
  },
  M: function (dateObj, shortMonth, locale) {
    dateObj.setMonth(locale.months.shorthand.indexOf(shortMonth));
  },
  S: function (dateObj, seconds) {
    dateObj.setSeconds(parseFloat(seconds));
  },
  U: function (_, unixSeconds) {
    return new Date(parseFloat(unixSeconds) * 1000);
  },
  W: function (dateObj, weekNum, locale) {
    var weekNumber = parseInt(weekNum);
    var date = new Date(dateObj.getFullYear(), 0, 2 + (weekNumber - 1) * 7, 0, 0, 0, 0);
    date.setDate(date.getDate() - date.getDay() + locale.firstDayOfWeek);
    return date;
  },
  Y: function (dateObj, year) {
    dateObj.setFullYear(parseFloat(year));
  },
  Z: function (_, ISODate) {
    return new Date(ISODate);
  },
  d: function (dateObj, day) {
    dateObj.setDate(parseFloat(day));
  },
  h: function (dateObj, hour) {
    dateObj.setHours((dateObj.getHours() >= 12 ? 12 : 0) + parseFloat(hour));
  },
  i: function (dateObj, minutes) {
    dateObj.setMinutes(parseFloat(minutes));
  },
  j: function (dateObj, day) {
    dateObj.setDate(parseFloat(day));
  },
  l: doNothing,
  m: function (dateObj, month) {
    dateObj.setMonth(parseFloat(month) - 1);
  },
  n: function (dateObj, month) {
    dateObj.setMonth(parseFloat(month) - 1);
  },
  s: function (dateObj, seconds) {
    dateObj.setSeconds(parseFloat(seconds));
  },
  u: function (_, unixMillSeconds) {
    return new Date(parseFloat(unixMillSeconds));
  },
  w: doNothing,
  y: function (dateObj, year) {
    dateObj.setFullYear(2000 + parseFloat(year));
  }
};
var tokenRegex = {
  D: "",
  F: "",
  G: "(\\d\\d|\\d)",
  H: "(\\d\\d|\\d)",
  J: "(\\d\\d|\\d)\\w+",
  K: "",
  M: "",
  S: "(\\d\\d|\\d)",
  U: "(.+)",
  W: "(\\d\\d|\\d)",
  Y: "(\\d{4})",
  Z: "(.+)",
  d: "(\\d\\d|\\d)",
  h: "(\\d\\d|\\d)",
  i: "(\\d\\d|\\d)",
  j: "(\\d\\d|\\d)",
  l: "",
  m: "(\\d\\d|\\d)",
  n: "(\\d\\d|\\d)",
  s: "(\\d\\d|\\d)",
  u: "(.+)",
  w: "(\\d\\d|\\d)",
  y: "(\\d{2})"
};
var formats = {
  Z: function (date) {
    return date.toISOString();
  },
  D: function (date, locale, options) {
    return locale.weekdays.shorthand[formats.w(date, locale, options)];
  },
  F: function (date, locale, options) {
    return monthToStr(formats.n(date, locale, options) - 1, false, locale);
  },
  G: function (date, locale, options) {
    return pad(formats.h(date, locale, options));
  },
  H: function (date) {
    return pad(date.getHours());
  },
  J: function (date, locale) {
    return locale.ordinal !== undefined ? date.getDate() + locale.ordinal(date.getDate()) : date.getDate();
  },
  K: function (date, locale) {
    return locale.amPM[int(date.getHours() > 11)];
  },
  M: function (date, locale) {
    return monthToStr(date.getMonth(), true, locale);
  },
  S: function (date) {
    return pad(date.getSeconds());
  },
  U: function (date) {
    return date.getTime() / 1000;
  },
  W: function (date, _, options) {
    return options.getWeek(date);
  },
  Y: function (date) {
    return pad(date.getFullYear(), 4);
  },
  d: function (date) {
    return pad(date.getDate());
  },
  h: function (date) {
    return date.getHours() % 12 ? date.getHours() % 12 : 12;
  },
  i: function (date) {
    return pad(date.getMinutes());
  },
  j: function (date) {
    return date.getDate();
  },
  l: function (date, locale) {
    return locale.weekdays.longhand[date.getDay()];
  },
  m: function (date) {
    return pad(date.getMonth() + 1);
  },
  n: function (date) {
    return date.getMonth() + 1;
  },
  s: function (date) {
    return date.getSeconds();
  },
  u: function (date) {
    return date.getTime();
  },
  w: function (date) {
    return date.getDay();
  },
  y: function (date) {
    return String(date.getFullYear()).substring(2);
  }
};

var createDateFormatter = function (_a) {
  var _b = _a.config,
    config = _b === void 0 ? defaults : _b,
    _c = _a.l10n,
    l10n = _c === void 0 ? english : _c,
    _d = _a.isMobile,
    isMobile = _d === void 0 ? false : _d;
  return function (dateObj, frmt, overrideLocale) {
    var locale = overrideLocale || l10n;
    if (config.formatDate !== undefined && !isMobile) {
      return config.formatDate(dateObj, frmt, locale);
    }
    return frmt.split("").map(function (c, i, arr) {
      return formats[c] && arr[i - 1] !== "\\" ? formats[c](dateObj, locale, config) : c !== "\\" ? c : "";
    }).join("");
  };
};
var createDateParser = function (_a) {
  var _b = _a.config,
    config = _b === void 0 ? defaults : _b,
    _c = _a.l10n,
    l10n = _c === void 0 ? english : _c;
  return function (date, givenFormat, timeless, customLocale) {
    if (date !== 0 && !date) return undefined;
    var locale = customLocale || l10n;
    var parsedDate;
    var dateOrig = date;
    if (date instanceof Date) parsedDate = new Date(date.getTime());else if (typeof date !== "string" && date.toFixed !== undefined) parsedDate = new Date(date);else if (typeof date === "string") {
      var format = givenFormat || (config || defaults).dateFormat;
      var datestr = String(date).trim();
      if (datestr === "today") {
        parsedDate = new Date();
        timeless = true;
      } else if (config && config.parseDate) {
        parsedDate = config.parseDate(date, format);
      } else if (/Z$/.test(datestr) || /GMT$/.test(datestr)) {
        parsedDate = new Date(date);
      } else {
        var matched = void 0,
          ops = [];
        for (var i = 0, matchIndex = 0, regexStr = ""; i < format.length; i++) {
          var token = format[i];
          var isBackSlash = token === "\\";
          var escaped = format[i - 1] === "\\" || isBackSlash;
          if (tokenRegex[token] && !escaped) {
            regexStr += tokenRegex[token];
            var match = new RegExp(regexStr).exec(date);
            if (match && (matched = true)) {
              ops[token !== "Y" ? "push" : "unshift"]({
                fn: revFormat[token],
                val: match[++matchIndex]
              });
            }
          } else if (!isBackSlash) regexStr += ".";
        }
        parsedDate = !config || !config.noCalendar ? new Date(new Date().getFullYear(), 0, 1, 0, 0, 0, 0) : new Date(new Date().setHours(0, 0, 0, 0));
        ops.forEach(function (_a) {
          var fn = _a.fn,
            val = _a.val;
          return parsedDate = fn(parsedDate, val, locale) || parsedDate;
        });
        parsedDate = matched ? parsedDate : undefined;
      }
    }
    if (!(parsedDate instanceof Date && !isNaN(parsedDate.getTime()))) {
      config.errorHandler(new Error("Invalid date provided: " + dateOrig));
      return undefined;
    }
    if (timeless === true) parsedDate.setHours(0, 0, 0, 0);
    return parsedDate;
  };
};
function compareDates(date1, date2, timeless) {
  if (timeless === void 0) {
    timeless = true;
  }
  if (timeless !== false) {
    return new Date(date1.getTime()).setHours(0, 0, 0, 0) - new Date(date2.getTime()).setHours(0, 0, 0, 0);
  }
  return date1.getTime() - date2.getTime();
}
var isBetween = function (ts, ts1, ts2) {
  return ts > Math.min(ts1, ts2) && ts < Math.max(ts1, ts2);
};
var calculateSecondsSinceMidnight = function (hours, minutes, seconds) {
  return hours * 3600 + minutes * 60 + seconds;
};
var parseSeconds = function (secondsSinceMidnight) {
  var hours = Math.floor(secondsSinceMidnight / 3600),
    minutes = (secondsSinceMidnight - hours * 3600) / 60;
  return [hours, minutes, secondsSinceMidnight - hours * 3600 - minutes * 60];
};
var duration = {
  DAY: 86400000
};
function getDefaultHours(config) {
  var hours = config.defaultHour;
  var minutes = config.defaultMinute;
  var seconds = config.defaultSeconds;
  if (config.minDate !== undefined) {
    var minHour = config.minDate.getHours();
    var minMinutes = config.minDate.getMinutes();
    var minSeconds = config.minDate.getSeconds();
    if (hours < minHour) {
      hours = minHour;
    }
    if (hours === minHour && minutes < minMinutes) {
      minutes = minMinutes;
    }
    if (hours === minHour && minutes === minMinutes && seconds < minSeconds) seconds = config.minDate.getSeconds();
  }
  if (config.maxDate !== undefined) {
    var maxHr = config.maxDate.getHours();
    var maxMinutes = config.maxDate.getMinutes();
    hours = Math.min(hours, maxHr);
    if (hours === maxHr) minutes = Math.min(maxMinutes, minutes);
    if (hours === maxHr && minutes === maxMinutes) seconds = config.maxDate.getSeconds();
  }
  return {
    hours: hours,
    minutes: minutes,
    seconds: seconds
  };
}

if (typeof Object.assign !== "function") {
  Object.assign = function (target) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    if (!target) {
      throw TypeError("Cannot convert undefined or null to object");
    }
    var _loop_1 = function (source) {
      if (source) {
        Object.keys(source).forEach(function (key) {
          return target[key] = source[key];
        });
      }
    };
    for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
      var source = args_1[_a];
      _loop_1(source);
    }
    return target;
  };
}

var __assign = window && window.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var __spreadArrays = window && window.__spreadArrays || function () {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];
  return r;
};
var DEBOUNCED_CHANGE_MS = 300;
function FlatpickrInstance(element, instanceConfig) {
  var self = {
    config: __assign(__assign({}, defaults), flatpickr.defaultConfig),
    l10n: english
  };
  self.parseDate = createDateParser({
    config: self.config,
    l10n: self.l10n
  });
  self._handlers = [];
  self.pluginElements = [];
  self.loadedPlugins = [];
  self._bind = bind;
  self._setHoursFromDate = setHoursFromDate;
  self._positionCalendar = positionCalendar;
  self.changeMonth = changeMonth;
  self.changeYear = changeYear;
  self.clear = clear;
  self.close = close;
  self.onMouseOver = onMouseOver;
  self._createElement = createElement;
  self.createDay = createDay;
  self.destroy = destroy;
  self.isEnabled = isEnabled;
  self.jumpToDate = jumpToDate;
  self.updateValue = updateValue;
  self.open = open;
  self.redraw = redraw;
  self.set = set;
  self.setDate = setDate;
  self.toggle = toggle;
  function setupHelperFunctions() {
    self.utils = {
      getDaysInMonth: function (month, yr) {
        if (month === void 0) {
          month = self.currentMonth;
        }
        if (yr === void 0) {
          yr = self.currentYear;
        }
        if (month === 1 && (yr % 4 === 0 && yr % 100 !== 0 || yr % 400 === 0)) return 29;
        return self.l10n.daysInMonth[month];
      }
    };
  }
  function init() {
    self.element = self.input = element;
    self.isOpen = false;
    parseConfig();
    setupLocale();
    setupInputs();
    setupDates();
    setupHelperFunctions();
    if (!self.isMobile) build();
    bindEvents();
    if (self.selectedDates.length || self.config.noCalendar) {
      if (self.config.enableTime) {
        setHoursFromDate(self.config.noCalendar ? self.latestSelectedDateObj : undefined);
      }
      updateValue(false);
    }
    setCalendarWidth();
    var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    if (!self.isMobile && isSafari) {
      positionCalendar();
    }
    triggerEvent("onReady");
  }
  function getClosestActiveElement() {
    var _a;
    return ((_a = self.calendarContainer) === null || _a === void 0 ? void 0 : _a.getRootNode()).activeElement || document.activeElement;
  }
  function bindToInstance(fn) {
    return fn.bind(self);
  }
  function setCalendarWidth() {
    var config = self.config;
    if (config.weekNumbers === false && config.showMonths === 1) {
      return;
    } else if (config.noCalendar !== true) {
      window.requestAnimationFrame(function () {
        if (self.calendarContainer !== undefined) {
          self.calendarContainer.style.visibility = "hidden";
          self.calendarContainer.style.display = "block";
        }
        if (self.daysContainer !== undefined) {
          var daysWidth = (self.days.offsetWidth + 1) * config.showMonths;
          self.daysContainer.style.width = daysWidth + "px";
          self.calendarContainer.style.width = daysWidth + (self.weekWrapper !== undefined ? self.weekWrapper.offsetWidth : 0) + "px";
          self.calendarContainer.style.removeProperty("visibility");
          self.calendarContainer.style.removeProperty("display");
        }
      });
    }
  }
  function updateTime(e) {
    if (self.selectedDates.length === 0) {
      var defaultDate = self.config.minDate === undefined || compareDates(new Date(), self.config.minDate) >= 0 ? new Date() : new Date(self.config.minDate.getTime());
      var defaults = getDefaultHours(self.config);
      defaultDate.setHours(defaults.hours, defaults.minutes, defaults.seconds, defaultDate.getMilliseconds());
      self.selectedDates = [defaultDate];
      self.latestSelectedDateObj = defaultDate;
    }
    if (e !== undefined && e.type !== "blur") {
      timeWrapper(e);
    }
    var prevValue = self._input.value;
    setHoursFromInputs();
    updateValue();
    if (self._input.value !== prevValue) {
      self._debouncedChange();
    }
  }
  function ampm2military(hour, amPM) {
    return hour % 12 + 12 * int(amPM === self.l10n.amPM[1]);
  }
  function military2ampm(hour) {
    switch (hour % 24) {
      case 0:
      case 12:
        return 12;
      default:
        return hour % 12;
    }
  }
  function setHoursFromInputs() {
    if (self.hourElement === undefined || self.minuteElement === undefined) return;
    var hours = (parseInt(self.hourElement.value.slice(-2), 10) || 0) % 24,
      minutes = (parseInt(self.minuteElement.value, 10) || 0) % 60,
      seconds = self.secondElement !== undefined ? (parseInt(self.secondElement.value, 10) || 0) % 60 : 0;
    if (self.amPM !== undefined) {
      hours = ampm2military(hours, self.amPM.textContent);
    }
    var limitMinHours = self.config.minTime !== undefined || self.config.minDate && self.minDateHasTime && self.latestSelectedDateObj && compareDates(self.latestSelectedDateObj, self.config.minDate, true) === 0;
    var limitMaxHours = self.config.maxTime !== undefined || self.config.maxDate && self.maxDateHasTime && self.latestSelectedDateObj && compareDates(self.latestSelectedDateObj, self.config.maxDate, true) === 0;
    if (self.config.maxTime !== undefined && self.config.minTime !== undefined && self.config.minTime > self.config.maxTime) {
      var minBound = calculateSecondsSinceMidnight(self.config.minTime.getHours(), self.config.minTime.getMinutes(), self.config.minTime.getSeconds());
      var maxBound = calculateSecondsSinceMidnight(self.config.maxTime.getHours(), self.config.maxTime.getMinutes(), self.config.maxTime.getSeconds());
      var currentTime = calculateSecondsSinceMidnight(hours, minutes, seconds);
      if (currentTime > maxBound && currentTime < minBound) {
        var result = parseSeconds(minBound);
        hours = result[0];
        minutes = result[1];
        seconds = result[2];
      }
    } else {
      if (limitMaxHours) {
        var maxTime = self.config.maxTime !== undefined ? self.config.maxTime : self.config.maxDate;
        hours = Math.min(hours, maxTime.getHours());
        if (hours === maxTime.getHours()) minutes = Math.min(minutes, maxTime.getMinutes());
        if (minutes === maxTime.getMinutes()) seconds = Math.min(seconds, maxTime.getSeconds());
      }
      if (limitMinHours) {
        var minTime = self.config.minTime !== undefined ? self.config.minTime : self.config.minDate;
        hours = Math.max(hours, minTime.getHours());
        if (hours === minTime.getHours() && minutes < minTime.getMinutes()) minutes = minTime.getMinutes();
        if (minutes === minTime.getMinutes()) seconds = Math.max(seconds, minTime.getSeconds());
      }
    }
    setHours(hours, minutes, seconds);
  }
  function setHoursFromDate(dateObj) {
    var date = dateObj || self.latestSelectedDateObj;
    if (date && date instanceof Date) {
      setHours(date.getHours(), date.getMinutes(), date.getSeconds());
    }
  }
  function setHours(hours, minutes, seconds) {
    if (self.latestSelectedDateObj !== undefined) {
      self.latestSelectedDateObj.setHours(hours % 24, minutes, seconds || 0, 0);
    }
    if (!self.hourElement || !self.minuteElement || self.isMobile) return;
    self.hourElement.value = pad(!self.config.time_24hr ? (12 + hours) % 12 + 12 * int(hours % 12 === 0) : hours);
    self.minuteElement.value = pad(minutes);
    if (self.amPM !== undefined) self.amPM.textContent = self.l10n.amPM[int(hours >= 12)];
    if (self.secondElement !== undefined) self.secondElement.value = pad(seconds);
  }
  function onYearInput(event) {
    var eventTarget = getEventTarget(event);
    var year = parseInt(eventTarget.value) + (event.delta || 0);
    if (year / 1000 > 1 || event.key === "Enter" && !/[^\d]/.test(year.toString())) {
      changeYear(year);
    }
  }
  function bind(element, event, handler, options) {
    if (event instanceof Array) return event.forEach(function (ev) {
      return bind(element, ev, handler, options);
    });
    if (element instanceof Array) return element.forEach(function (el) {
      return bind(el, event, handler, options);
    });
    element.addEventListener(event, handler, options);
    self._handlers.push({
      remove: function () {
        return element.removeEventListener(event, handler, options);
      }
    });
  }
  function triggerChange() {
    triggerEvent("onChange");
  }
  function bindEvents() {
    if (self.config.wrap) {
      ["open", "close", "toggle", "clear"].forEach(function (evt) {
        Array.prototype.forEach.call(self.element.querySelectorAll("[data-" + evt + "]"), function (el) {
          return bind(el, "click", self[evt]);
        });
      });
    }
    if (self.isMobile) {
      setupMobile();
      return;
    }
    var debouncedResize = debounce$1(onResize, 50);
    self._debouncedChange = debounce$1(triggerChange, DEBOUNCED_CHANGE_MS);
    if (self.daysContainer && !/iPhone|iPad|iPod/i.test(navigator.userAgent)) bind(self.daysContainer, "mouseover", function (e) {
      if (self.config.mode === "range") onMouseOver(getEventTarget(e));
    });
    bind(self._input, "keydown", onKeyDown);
    if (self.calendarContainer !== undefined) {
      bind(self.calendarContainer, "keydown", onKeyDown);
    }
    if (!self.config.inline && !self.config.static) bind(window, "resize", debouncedResize);
    if (window.ontouchstart !== undefined) bind(window.document, "touchstart", documentClick);else bind(window.document, "mousedown", documentClick);
    bind(window.document, "focus", documentClick, {
      capture: true
    });
    if (self.config.clickOpens === true) {
      bind(self._input, "focus", self.open);
      bind(self._input, "click", self.open);
    }
    if (self.daysContainer !== undefined) {
      bind(self.monthNav, "click", onMonthNavClick);
      bind(self.monthNav, ["keyup", "increment"], onYearInput);
      bind(self.daysContainer, "click", selectDate);
    }
    if (self.timeContainer !== undefined && self.minuteElement !== undefined && self.hourElement !== undefined) {
      var selText = function (e) {
        return getEventTarget(e).select();
      };
      bind(self.timeContainer, ["increment"], updateTime);
      bind(self.timeContainer, "blur", updateTime, {
        capture: true
      });
      bind(self.timeContainer, "click", timeIncrement);
      bind([self.hourElement, self.minuteElement], ["focus", "click"], selText);
      if (self.secondElement !== undefined) bind(self.secondElement, "focus", function () {
        return self.secondElement && self.secondElement.select();
      });
      if (self.amPM !== undefined) {
        bind(self.amPM, "click", function (e) {
          updateTime(e);
        });
      }
    }
    if (self.config.allowInput) {
      bind(self._input, "blur", onBlur);
    }
  }
  function jumpToDate(jumpDate, triggerChange) {
    var jumpTo = jumpDate !== undefined ? self.parseDate(jumpDate) : self.latestSelectedDateObj || (self.config.minDate && self.config.minDate > self.now ? self.config.minDate : self.config.maxDate && self.config.maxDate < self.now ? self.config.maxDate : self.now);
    var oldYear = self.currentYear;
    var oldMonth = self.currentMonth;
    try {
      if (jumpTo !== undefined) {
        self.currentYear = jumpTo.getFullYear();
        self.currentMonth = jumpTo.getMonth();
      }
    } catch (e) {
      e.message = "Invalid date supplied: " + jumpTo;
      self.config.errorHandler(e);
    }
    if (triggerChange && self.currentYear !== oldYear) {
      triggerEvent("onYearChange");
      buildMonthSwitch();
    }
    if (triggerChange && (self.currentYear !== oldYear || self.currentMonth !== oldMonth)) {
      triggerEvent("onMonthChange");
    }
    self.redraw();
  }
  function timeIncrement(e) {
    var eventTarget = getEventTarget(e);
    if (~eventTarget.className.indexOf("arrow")) incrementNumInput(e, eventTarget.classList.contains("arrowUp") ? 1 : -1);
  }
  function incrementNumInput(e, delta, inputElem) {
    var target = e && getEventTarget(e);
    var input = inputElem || target && target.parentNode && target.parentNode.firstChild;
    var event = createEvent("increment");
    event.delta = delta;
    input && input.dispatchEvent(event);
  }
  function build() {
    var fragment = window.document.createDocumentFragment();
    self.calendarContainer = createElement("div", "flatpickr-calendar");
    self.calendarContainer.tabIndex = -1;
    if (!self.config.noCalendar) {
      fragment.appendChild(buildMonthNav());
      self.innerContainer = createElement("div", "flatpickr-innerContainer");
      if (self.config.weekNumbers) {
        var _a = buildWeeks(),
          weekWrapper = _a.weekWrapper,
          weekNumbers = _a.weekNumbers;
        self.innerContainer.appendChild(weekWrapper);
        self.weekNumbers = weekNumbers;
        self.weekWrapper = weekWrapper;
      }
      self.rContainer = createElement("div", "flatpickr-rContainer");
      self.rContainer.appendChild(buildWeekdays());
      if (!self.daysContainer) {
        self.daysContainer = createElement("div", "flatpickr-days");
        self.daysContainer.tabIndex = -1;
      }
      buildDays();
      self.rContainer.appendChild(self.daysContainer);
      self.innerContainer.appendChild(self.rContainer);
      fragment.appendChild(self.innerContainer);
    }
    if (self.config.enableTime) {
      fragment.appendChild(buildTime());
    }
    toggleClass(self.calendarContainer, "rangeMode", self.config.mode === "range");
    toggleClass(self.calendarContainer, "animate", self.config.animate === true);
    toggleClass(self.calendarContainer, "multiMonth", self.config.showMonths > 1);
    self.calendarContainer.appendChild(fragment);
    var customAppend = self.config.appendTo !== undefined && self.config.appendTo.nodeType !== undefined;
    if (self.config.inline || self.config.static) {
      self.calendarContainer.classList.add(self.config.inline ? "inline" : "static");
      if (self.config.inline) {
        if (!customAppend && self.element.parentNode) self.element.parentNode.insertBefore(self.calendarContainer, self._input.nextSibling);else if (self.config.appendTo !== undefined) self.config.appendTo.appendChild(self.calendarContainer);
      }
      if (self.config.static) {
        var wrapper = createElement("div", "flatpickr-wrapper");
        if (self.element.parentNode) self.element.parentNode.insertBefore(wrapper, self.element);
        wrapper.appendChild(self.element);
        if (self.altInput) wrapper.appendChild(self.altInput);
        wrapper.appendChild(self.calendarContainer);
      }
    }
    if (!self.config.static && !self.config.inline) (self.config.appendTo !== undefined ? self.config.appendTo : window.document.body).appendChild(self.calendarContainer);
  }
  function createDay(className, date, _dayNumber, i) {
    var dateIsEnabled = isEnabled(date, true),
      dayElement = createElement("span", className, date.getDate().toString());
    dayElement.dateObj = date;
    dayElement.$i = i;
    dayElement.setAttribute("aria-label", self.formatDate(date, self.config.ariaDateFormat));
    if (className.indexOf("hidden") === -1 && compareDates(date, self.now) === 0) {
      self.todayDateElem = dayElement;
      dayElement.classList.add("today");
      dayElement.setAttribute("aria-current", "date");
    }
    if (dateIsEnabled) {
      dayElement.tabIndex = -1;
      if (isDateSelected(date)) {
        dayElement.classList.add("selected");
        self.selectedDateElem = dayElement;
        if (self.config.mode === "range") {
          toggleClass(dayElement, "startRange", self.selectedDates[0] && compareDates(date, self.selectedDates[0], true) === 0);
          toggleClass(dayElement, "endRange", self.selectedDates[1] && compareDates(date, self.selectedDates[1], true) === 0);
          if (className === "nextMonthDay") dayElement.classList.add("inRange");
        }
      }
    } else {
      dayElement.classList.add("flatpickr-disabled");
    }
    if (self.config.mode === "range") {
      if (isDateInRange(date) && !isDateSelected(date)) dayElement.classList.add("inRange");
    }
    if (self.weekNumbers && self.config.showMonths === 1 && className !== "prevMonthDay" && i % 7 === 6) {
      self.weekNumbers.insertAdjacentHTML("beforeend", "<span class='flatpickr-day'>" + self.config.getWeek(date) + "</span>");
    }
    triggerEvent("onDayCreate", dayElement);
    return dayElement;
  }
  function focusOnDayElem(targetNode) {
    targetNode.focus();
    if (self.config.mode === "range") onMouseOver(targetNode);
  }
  function getFirstAvailableDay(delta) {
    var startMonth = delta > 0 ? 0 : self.config.showMonths - 1;
    var endMonth = delta > 0 ? self.config.showMonths : -1;
    for (var m = startMonth; m != endMonth; m += delta) {
      var month = self.daysContainer.children[m];
      var startIndex = delta > 0 ? 0 : month.children.length - 1;
      var endIndex = delta > 0 ? month.children.length : -1;
      for (var i = startIndex; i != endIndex; i += delta) {
        var c = month.children[i];
        if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj)) return c;
      }
    }
    return undefined;
  }
  function getNextAvailableDay(current, delta) {
    var givenMonth = current.className.indexOf("Month") === -1 ? current.dateObj.getMonth() : self.currentMonth;
    var endMonth = delta > 0 ? self.config.showMonths : -1;
    var loopDelta = delta > 0 ? 1 : -1;
    for (var m = givenMonth - self.currentMonth; m != endMonth; m += loopDelta) {
      var month = self.daysContainer.children[m];
      var startIndex = givenMonth - self.currentMonth === m ? current.$i + delta : delta < 0 ? month.children.length - 1 : 0;
      var numMonthDays = month.children.length;
      for (var i = startIndex; i >= 0 && i < numMonthDays && i != (delta > 0 ? numMonthDays : -1); i += loopDelta) {
        var c = month.children[i];
        if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj) && Math.abs(current.$i - i) >= Math.abs(delta)) return focusOnDayElem(c);
      }
    }
    self.changeMonth(loopDelta);
    focusOnDay(getFirstAvailableDay(loopDelta), 0);
    return undefined;
  }
  function focusOnDay(current, offset) {
    var activeElement = getClosestActiveElement();
    var dayFocused = isInView(activeElement || document.body);
    var startElem = current !== undefined ? current : dayFocused ? activeElement : self.selectedDateElem !== undefined && isInView(self.selectedDateElem) ? self.selectedDateElem : self.todayDateElem !== undefined && isInView(self.todayDateElem) ? self.todayDateElem : getFirstAvailableDay(offset > 0 ? 1 : -1);
    if (startElem === undefined) {
      self._input.focus();
    } else if (!dayFocused) {
      focusOnDayElem(startElem);
    } else {
      getNextAvailableDay(startElem, offset);
    }
  }
  function buildMonthDays(year, month) {
    var firstOfMonth = (new Date(year, month, 1).getDay() - self.l10n.firstDayOfWeek + 7) % 7;
    var prevMonthDays = self.utils.getDaysInMonth((month - 1 + 12) % 12, year);
    var daysInMonth = self.utils.getDaysInMonth(month, year),
      days = window.document.createDocumentFragment(),
      isMultiMonth = self.config.showMonths > 1,
      prevMonthDayClass = isMultiMonth ? "prevMonthDay hidden" : "prevMonthDay",
      nextMonthDayClass = isMultiMonth ? "nextMonthDay hidden" : "nextMonthDay";
    var dayNumber = prevMonthDays + 1 - firstOfMonth,
      dayIndex = 0;
    for (; dayNumber <= prevMonthDays; dayNumber++, dayIndex++) {
      days.appendChild(createDay("flatpickr-day " + prevMonthDayClass, new Date(year, month - 1, dayNumber), dayNumber, dayIndex));
    }
    for (dayNumber = 1; dayNumber <= daysInMonth; dayNumber++, dayIndex++) {
      days.appendChild(createDay("flatpickr-day", new Date(year, month, dayNumber), dayNumber, dayIndex));
    }
    for (var dayNum = daysInMonth + 1; dayNum <= 42 - firstOfMonth && (self.config.showMonths === 1 || dayIndex % 7 !== 0); dayNum++, dayIndex++) {
      days.appendChild(createDay("flatpickr-day " + nextMonthDayClass, new Date(year, month + 1, dayNum % daysInMonth), dayNum, dayIndex));
    }
    var dayContainer = createElement("div", "dayContainer");
    dayContainer.appendChild(days);
    return dayContainer;
  }
  function buildDays() {
    if (self.daysContainer === undefined) {
      return;
    }
    clearNode(self.daysContainer);
    if (self.weekNumbers) clearNode(self.weekNumbers);
    var frag = document.createDocumentFragment();
    for (var i = 0; i < self.config.showMonths; i++) {
      var d = new Date(self.currentYear, self.currentMonth, 1);
      d.setMonth(self.currentMonth + i);
      frag.appendChild(buildMonthDays(d.getFullYear(), d.getMonth()));
    }
    self.daysContainer.appendChild(frag);
    self.days = self.daysContainer.firstChild;
    if (self.config.mode === "range" && self.selectedDates.length === 1) {
      onMouseOver();
    }
  }
  function buildMonthSwitch() {
    if (self.config.showMonths > 1 || self.config.monthSelectorType !== "dropdown") return;
    var shouldBuildMonth = function (month) {
      if (self.config.minDate !== undefined && self.currentYear === self.config.minDate.getFullYear() && month < self.config.minDate.getMonth()) {
        return false;
      }
      return !(self.config.maxDate !== undefined && self.currentYear === self.config.maxDate.getFullYear() && month > self.config.maxDate.getMonth());
    };
    self.monthsDropdownContainer.tabIndex = -1;
    self.monthsDropdownContainer.innerHTML = "";
    for (var i = 0; i < 12; i++) {
      if (!shouldBuildMonth(i)) continue;
      var month = createElement("option", "flatpickr-monthDropdown-month");
      month.value = new Date(self.currentYear, i).getMonth().toString();
      month.textContent = monthToStr(i, self.config.shorthandCurrentMonth, self.l10n);
      month.tabIndex = -1;
      if (self.currentMonth === i) {
        month.selected = true;
      }
      self.monthsDropdownContainer.appendChild(month);
    }
  }
  function buildMonth() {
    var container = createElement("div", "flatpickr-month");
    var monthNavFragment = window.document.createDocumentFragment();
    var monthElement;
    if (self.config.showMonths > 1 || self.config.monthSelectorType === "static") {
      monthElement = createElement("span", "cur-month");
    } else {
      self.monthsDropdownContainer = createElement("select", "flatpickr-monthDropdown-months");
      self.monthsDropdownContainer.setAttribute("aria-label", self.l10n.monthAriaLabel);
      bind(self.monthsDropdownContainer, "change", function (e) {
        var target = getEventTarget(e);
        var selectedMonth = parseInt(target.value, 10);
        self.changeMonth(selectedMonth - self.currentMonth);
        triggerEvent("onMonthChange");
      });
      buildMonthSwitch();
      monthElement = self.monthsDropdownContainer;
    }
    var yearInput = createNumberInput("cur-year", {
      tabindex: "-1"
    });
    var yearElement = yearInput.getElementsByTagName("input")[0];
    yearElement.setAttribute("aria-label", self.l10n.yearAriaLabel);
    if (self.config.minDate) {
      yearElement.setAttribute("min", self.config.minDate.getFullYear().toString());
    }
    if (self.config.maxDate) {
      yearElement.setAttribute("max", self.config.maxDate.getFullYear().toString());
      yearElement.disabled = !!self.config.minDate && self.config.minDate.getFullYear() === self.config.maxDate.getFullYear();
    }
    var currentMonth = createElement("div", "flatpickr-current-month");
    currentMonth.appendChild(monthElement);
    currentMonth.appendChild(yearInput);
    monthNavFragment.appendChild(currentMonth);
    container.appendChild(monthNavFragment);
    return {
      container: container,
      yearElement: yearElement,
      monthElement: monthElement
    };
  }
  function buildMonths() {
    clearNode(self.monthNav);
    self.monthNav.appendChild(self.prevMonthNav);
    if (self.config.showMonths) {
      self.yearElements = [];
      self.monthElements = [];
    }
    for (var m = self.config.showMonths; m--;) {
      var month = buildMonth();
      self.yearElements.push(month.yearElement);
      self.monthElements.push(month.monthElement);
      self.monthNav.appendChild(month.container);
    }
    self.monthNav.appendChild(self.nextMonthNav);
  }
  function buildMonthNav() {
    self.monthNav = createElement("div", "flatpickr-months");
    self.yearElements = [];
    self.monthElements = [];
    self.prevMonthNav = createElement("span", "flatpickr-prev-month");
    self.prevMonthNav.innerHTML = self.config.prevArrow;
    self.nextMonthNav = createElement("span", "flatpickr-next-month");
    self.nextMonthNav.innerHTML = self.config.nextArrow;
    buildMonths();
    Object.defineProperty(self, "_hidePrevMonthArrow", {
      get: function () {
        return self.__hidePrevMonthArrow;
      },
      set: function (bool) {
        if (self.__hidePrevMonthArrow !== bool) {
          toggleClass(self.prevMonthNav, "flatpickr-disabled", bool);
          self.__hidePrevMonthArrow = bool;
        }
      }
    });
    Object.defineProperty(self, "_hideNextMonthArrow", {
      get: function () {
        return self.__hideNextMonthArrow;
      },
      set: function (bool) {
        if (self.__hideNextMonthArrow !== bool) {
          toggleClass(self.nextMonthNav, "flatpickr-disabled", bool);
          self.__hideNextMonthArrow = bool;
        }
      }
    });
    self.currentYearElement = self.yearElements[0];
    updateNavigationCurrentMonth();
    return self.monthNav;
  }
  function buildTime() {
    self.calendarContainer.classList.add("hasTime");
    if (self.config.noCalendar) self.calendarContainer.classList.add("noCalendar");
    var defaults = getDefaultHours(self.config);
    self.timeContainer = createElement("div", "flatpickr-time");
    self.timeContainer.tabIndex = -1;
    var separator = createElement("span", "flatpickr-time-separator", ":");
    var hourInput = createNumberInput("flatpickr-hour", {
      "aria-label": self.l10n.hourAriaLabel
    });
    self.hourElement = hourInput.getElementsByTagName("input")[0];
    var minuteInput = createNumberInput("flatpickr-minute", {
      "aria-label": self.l10n.minuteAriaLabel
    });
    self.minuteElement = minuteInput.getElementsByTagName("input")[0];
    self.hourElement.tabIndex = self.minuteElement.tabIndex = -1;
    self.hourElement.value = pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getHours() : self.config.time_24hr ? defaults.hours : military2ampm(defaults.hours));
    self.minuteElement.value = pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getMinutes() : defaults.minutes);
    self.hourElement.setAttribute("step", self.config.hourIncrement.toString());
    self.minuteElement.setAttribute("step", self.config.minuteIncrement.toString());
    self.hourElement.setAttribute("min", self.config.time_24hr ? "0" : "1");
    self.hourElement.setAttribute("max", self.config.time_24hr ? "23" : "12");
    self.hourElement.setAttribute("maxlength", "2");
    self.minuteElement.setAttribute("min", "0");
    self.minuteElement.setAttribute("max", "59");
    self.minuteElement.setAttribute("maxlength", "2");
    self.timeContainer.appendChild(hourInput);
    self.timeContainer.appendChild(separator);
    self.timeContainer.appendChild(minuteInput);
    if (self.config.time_24hr) self.timeContainer.classList.add("time24hr");
    if (self.config.enableSeconds) {
      self.timeContainer.classList.add("hasSeconds");
      var secondInput = createNumberInput("flatpickr-second");
      self.secondElement = secondInput.getElementsByTagName("input")[0];
      self.secondElement.value = pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getSeconds() : defaults.seconds);
      self.secondElement.setAttribute("step", self.minuteElement.getAttribute("step"));
      self.secondElement.setAttribute("min", "0");
      self.secondElement.setAttribute("max", "59");
      self.secondElement.setAttribute("maxlength", "2");
      self.timeContainer.appendChild(createElement("span", "flatpickr-time-separator", ":"));
      self.timeContainer.appendChild(secondInput);
    }
    if (!self.config.time_24hr) {
      self.amPM = createElement("span", "flatpickr-am-pm", self.l10n.amPM[int((self.latestSelectedDateObj ? self.hourElement.value : self.config.defaultHour) > 11)]);
      self.amPM.title = self.l10n.toggleTitle;
      self.amPM.tabIndex = -1;
      self.timeContainer.appendChild(self.amPM);
    }
    return self.timeContainer;
  }
  function buildWeekdays() {
    if (!self.weekdayContainer) self.weekdayContainer = createElement("div", "flatpickr-weekdays");else clearNode(self.weekdayContainer);
    for (var i = self.config.showMonths; i--;) {
      var container = createElement("div", "flatpickr-weekdaycontainer");
      self.weekdayContainer.appendChild(container);
    }
    updateWeekdays();
    return self.weekdayContainer;
  }
  function updateWeekdays() {
    if (!self.weekdayContainer) {
      return;
    }
    var firstDayOfWeek = self.l10n.firstDayOfWeek;
    var weekdays = __spreadArrays(self.l10n.weekdays.shorthand);
    if (firstDayOfWeek > 0 && firstDayOfWeek < weekdays.length) {
      weekdays = __spreadArrays(weekdays.splice(firstDayOfWeek, weekdays.length), weekdays.splice(0, firstDayOfWeek));
    }
    for (var i = self.config.showMonths; i--;) {
      self.weekdayContainer.children[i].innerHTML = "\n      <span class='flatpickr-weekday'>\n        " + weekdays.join("</span><span class='flatpickr-weekday'>") + "\n      </span>\n      ";
    }
  }
  function buildWeeks() {
    self.calendarContainer.classList.add("hasWeeks");
    var weekWrapper = createElement("div", "flatpickr-weekwrapper");
    weekWrapper.appendChild(createElement("span", "flatpickr-weekday", self.l10n.weekAbbreviation));
    var weekNumbers = createElement("div", "flatpickr-weeks");
    weekWrapper.appendChild(weekNumbers);
    return {
      weekWrapper: weekWrapper,
      weekNumbers: weekNumbers
    };
  }
  function changeMonth(value, isOffset) {
    if (isOffset === void 0) {
      isOffset = true;
    }
    var delta = isOffset ? value : value - self.currentMonth;
    if (delta < 0 && self._hidePrevMonthArrow === true || delta > 0 && self._hideNextMonthArrow === true) return;
    self.currentMonth += delta;
    if (self.currentMonth < 0 || self.currentMonth > 11) {
      self.currentYear += self.currentMonth > 11 ? 1 : -1;
      self.currentMonth = (self.currentMonth + 12) % 12;
      triggerEvent("onYearChange");
      buildMonthSwitch();
    }
    buildDays();
    triggerEvent("onMonthChange");
    updateNavigationCurrentMonth();
  }
  function clear(triggerChangeEvent, toInitial) {
    if (triggerChangeEvent === void 0) {
      triggerChangeEvent = true;
    }
    if (toInitial === void 0) {
      toInitial = true;
    }
    self.input.value = "";
    if (self.altInput !== undefined) self.altInput.value = "";
    if (self.mobileInput !== undefined) self.mobileInput.value = "";
    self.selectedDates = [];
    self.latestSelectedDateObj = undefined;
    if (toInitial === true) {
      self.currentYear = self._initialDate.getFullYear();
      self.currentMonth = self._initialDate.getMonth();
    }
    if (self.config.enableTime === true) {
      var _a = getDefaultHours(self.config),
        hours = _a.hours,
        minutes = _a.minutes,
        seconds = _a.seconds;
      setHours(hours, minutes, seconds);
    }
    self.redraw();
    if (triggerChangeEvent) triggerEvent("onChange");
  }
  function close() {
    self.isOpen = false;
    if (!self.isMobile) {
      if (self.calendarContainer !== undefined) {
        self.calendarContainer.classList.remove("open");
      }
      if (self._input !== undefined) {
        self._input.classList.remove("active");
      }
    }
    triggerEvent("onClose");
  }
  function destroy() {
    if (self.config !== undefined) triggerEvent("onDestroy");
    for (var i = self._handlers.length; i--;) {
      self._handlers[i].remove();
    }
    self._handlers = [];
    if (self.mobileInput) {
      if (self.mobileInput.parentNode) self.mobileInput.parentNode.removeChild(self.mobileInput);
      self.mobileInput = undefined;
    } else if (self.calendarContainer && self.calendarContainer.parentNode) {
      if (self.config.static && self.calendarContainer.parentNode) {
        var wrapper = self.calendarContainer.parentNode;
        wrapper.lastChild && wrapper.removeChild(wrapper.lastChild);
        if (wrapper.parentNode) {
          while (wrapper.firstChild) wrapper.parentNode.insertBefore(wrapper.firstChild, wrapper);
          wrapper.parentNode.removeChild(wrapper);
        }
      } else self.calendarContainer.parentNode.removeChild(self.calendarContainer);
    }
    if (self.altInput) {
      self.input.type = "text";
      if (self.altInput.parentNode) self.altInput.parentNode.removeChild(self.altInput);
      delete self.altInput;
    }
    if (self.input) {
      self.input.type = self.input._type;
      self.input.classList.remove("flatpickr-input");
      self.input.removeAttribute("readonly");
    }
    ["_showTimeInput", "latestSelectedDateObj", "_hideNextMonthArrow", "_hidePrevMonthArrow", "__hideNextMonthArrow", "__hidePrevMonthArrow", "isMobile", "isOpen", "selectedDateElem", "minDateHasTime", "maxDateHasTime", "days", "daysContainer", "_input", "_positionElement", "innerContainer", "rContainer", "monthNav", "todayDateElem", "calendarContainer", "weekdayContainer", "prevMonthNav", "nextMonthNav", "monthsDropdownContainer", "currentMonthElement", "currentYearElement", "navigationCurrentMonth", "selectedDateElem", "config"].forEach(function (k) {
      try {
        delete self[k];
      } catch (_) {}
    });
  }
  function isCalendarElem(elem) {
    return self.calendarContainer.contains(elem);
  }
  function documentClick(e) {
    if (self.isOpen && !self.config.inline) {
      var eventTarget_1 = getEventTarget(e);
      var isCalendarElement = isCalendarElem(eventTarget_1);
      var isInput = eventTarget_1 === self.input || eventTarget_1 === self.altInput || self.element.contains(eventTarget_1) || e.path && e.path.indexOf && (~e.path.indexOf(self.input) || ~e.path.indexOf(self.altInput));
      var lostFocus = !isInput && !isCalendarElement && !isCalendarElem(e.relatedTarget);
      var isIgnored = !self.config.ignoredFocusElements.some(function (elem) {
        return elem.contains(eventTarget_1);
      });
      if (lostFocus && isIgnored) {
        if (self.config.allowInput) {
          self.setDate(self._input.value, false, self.config.altInput ? self.config.altFormat : self.config.dateFormat);
        }
        if (self.timeContainer !== undefined && self.minuteElement !== undefined && self.hourElement !== undefined && self.input.value !== "" && self.input.value !== undefined) {
          updateTime();
        }
        self.close();
        if (self.config && self.config.mode === "range" && self.selectedDates.length === 1) self.clear(false);
      }
    }
  }
  function changeYear(newYear) {
    if (!newYear || self.config.minDate && newYear < self.config.minDate.getFullYear() || self.config.maxDate && newYear > self.config.maxDate.getFullYear()) return;
    var newYearNum = newYear,
      isNewYear = self.currentYear !== newYearNum;
    self.currentYear = newYearNum || self.currentYear;
    if (self.config.maxDate && self.currentYear === self.config.maxDate.getFullYear()) {
      self.currentMonth = Math.min(self.config.maxDate.getMonth(), self.currentMonth);
    } else if (self.config.minDate && self.currentYear === self.config.minDate.getFullYear()) {
      self.currentMonth = Math.max(self.config.minDate.getMonth(), self.currentMonth);
    }
    if (isNewYear) {
      self.redraw();
      triggerEvent("onYearChange");
      buildMonthSwitch();
    }
  }
  function isEnabled(date, timeless) {
    var _a;
    if (timeless === void 0) {
      timeless = true;
    }
    var dateToCheck = self.parseDate(date, undefined, timeless);
    if (self.config.minDate && dateToCheck && compareDates(dateToCheck, self.config.minDate, timeless !== undefined ? timeless : !self.minDateHasTime) < 0 || self.config.maxDate && dateToCheck && compareDates(dateToCheck, self.config.maxDate, timeless !== undefined ? timeless : !self.maxDateHasTime) > 0) return false;
    if (!self.config.enable && self.config.disable.length === 0) return true;
    if (dateToCheck === undefined) return false;
    var bool = !!self.config.enable,
      array = (_a = self.config.enable) !== null && _a !== void 0 ? _a : self.config.disable;
    for (var i = 0, d = void 0; i < array.length; i++) {
      d = array[i];
      if (typeof d === "function" && d(dateToCheck)) return bool;else if (d instanceof Date && dateToCheck !== undefined && d.getTime() === dateToCheck.getTime()) return bool;else if (typeof d === "string") {
        var parsed = self.parseDate(d, undefined, true);
        return parsed && parsed.getTime() === dateToCheck.getTime() ? bool : !bool;
      } else if (typeof d === "object" && dateToCheck !== undefined && d.from && d.to && dateToCheck.getTime() >= d.from.getTime() && dateToCheck.getTime() <= d.to.getTime()) return bool;
    }
    return !bool;
  }
  function isInView(elem) {
    if (self.daysContainer !== undefined) return elem.className.indexOf("hidden") === -1 && elem.className.indexOf("flatpickr-disabled") === -1 && self.daysContainer.contains(elem);
    return false;
  }
  function onBlur(e) {
    var isInput = e.target === self._input;
    var valueChanged = self._input.value.trimEnd() !== getDateStr();
    if (isInput && valueChanged && !(e.relatedTarget && isCalendarElem(e.relatedTarget))) {
      self.setDate(self._input.value, true, e.target === self.altInput ? self.config.altFormat : self.config.dateFormat);
    }
  }
  function onKeyDown(e) {
    var eventTarget = getEventTarget(e);
    var isInput = self.config.wrap ? element.contains(eventTarget) : eventTarget === self._input;
    var allowInput = self.config.allowInput;
    var allowKeydown = self.isOpen && (!allowInput || !isInput);
    var allowInlineKeydown = self.config.inline && isInput && !allowInput;
    if (e.keyCode === 13 && isInput) {
      if (allowInput) {
        self.setDate(self._input.value, true, eventTarget === self.altInput ? self.config.altFormat : self.config.dateFormat);
        self.close();
        return eventTarget.blur();
      } else {
        self.open();
      }
    } else if (isCalendarElem(eventTarget) || allowKeydown || allowInlineKeydown) {
      var isTimeObj = !!self.timeContainer && self.timeContainer.contains(eventTarget);
      switch (e.keyCode) {
        case 13:
          if (isTimeObj) {
            e.preventDefault();
            updateTime();
            focusAndClose();
          } else selectDate(e);
          break;
        case 27:
          e.preventDefault();
          focusAndClose();
          break;
        case 8:
        case 46:
          if (isInput && !self.config.allowInput) {
            e.preventDefault();
            self.clear();
          }
          break;
        case 37:
        case 39:
          if (!isTimeObj && !isInput) {
            e.preventDefault();
            var activeElement = getClosestActiveElement();
            if (self.daysContainer !== undefined && (allowInput === false || activeElement && isInView(activeElement))) {
              var delta_1 = e.keyCode === 39 ? 1 : -1;
              if (!e.ctrlKey) focusOnDay(undefined, delta_1);else {
                e.stopPropagation();
                changeMonth(delta_1);
                focusOnDay(getFirstAvailableDay(1), 0);
              }
            }
          } else if (self.hourElement) self.hourElement.focus();
          break;
        case 38:
        case 40:
          e.preventDefault();
          var delta = e.keyCode === 40 ? 1 : -1;
          if (self.daysContainer && eventTarget.$i !== undefined || eventTarget === self.input || eventTarget === self.altInput) {
            if (e.ctrlKey) {
              e.stopPropagation();
              changeYear(self.currentYear - delta);
              focusOnDay(getFirstAvailableDay(1), 0);
            } else if (!isTimeObj) focusOnDay(undefined, delta * 7);
          } else if (eventTarget === self.currentYearElement) {
            changeYear(self.currentYear - delta);
          } else if (self.config.enableTime) {
            if (!isTimeObj && self.hourElement) self.hourElement.focus();
            updateTime(e);
            self._debouncedChange();
          }
          break;
        case 9:
          if (isTimeObj) {
            var elems = [self.hourElement, self.minuteElement, self.secondElement, self.amPM].concat(self.pluginElements).filter(function (x) {
              return x;
            });
            var i = elems.indexOf(eventTarget);
            if (i !== -1) {
              var target = elems[i + (e.shiftKey ? -1 : 1)];
              e.preventDefault();
              (target || self._input).focus();
            }
          } else if (!self.config.noCalendar && self.daysContainer && self.daysContainer.contains(eventTarget) && e.shiftKey) {
            e.preventDefault();
            self._input.focus();
          }
          break;
      }
    }
    if (self.amPM !== undefined && eventTarget === self.amPM) {
      switch (e.key) {
        case self.l10n.amPM[0].charAt(0):
        case self.l10n.amPM[0].charAt(0).toLowerCase():
          self.amPM.textContent = self.l10n.amPM[0];
          setHoursFromInputs();
          updateValue();
          break;
        case self.l10n.amPM[1].charAt(0):
        case self.l10n.amPM[1].charAt(0).toLowerCase():
          self.amPM.textContent = self.l10n.amPM[1];
          setHoursFromInputs();
          updateValue();
          break;
      }
    }
    if (isInput || isCalendarElem(eventTarget)) {
      triggerEvent("onKeyDown", e);
    }
  }
  function onMouseOver(elem, cellClass) {
    if (cellClass === void 0) {
      cellClass = "flatpickr-day";
    }
    if (self.selectedDates.length !== 1 || elem && (!elem.classList.contains(cellClass) || elem.classList.contains("flatpickr-disabled"))) return;
    var hoverDate = elem ? elem.dateObj.getTime() : self.days.firstElementChild.dateObj.getTime(),
      initialDate = self.parseDate(self.selectedDates[0], undefined, true).getTime(),
      rangeStartDate = Math.min(hoverDate, self.selectedDates[0].getTime()),
      rangeEndDate = Math.max(hoverDate, self.selectedDates[0].getTime());
    var containsDisabled = false;
    var minRange = 0,
      maxRange = 0;
    for (var t = rangeStartDate; t < rangeEndDate; t += duration.DAY) {
      if (!isEnabled(new Date(t), true)) {
        containsDisabled = containsDisabled || t > rangeStartDate && t < rangeEndDate;
        if (t < initialDate && (!minRange || t > minRange)) minRange = t;else if (t > initialDate && (!maxRange || t < maxRange)) maxRange = t;
      }
    }
    var hoverableCells = Array.from(self.rContainer.querySelectorAll("*:nth-child(-n+" + self.config.showMonths + ") > ." + cellClass));
    hoverableCells.forEach(function (dayElem) {
      var date = dayElem.dateObj;
      var timestamp = date.getTime();
      var outOfRange = minRange > 0 && timestamp < minRange || maxRange > 0 && timestamp > maxRange;
      if (outOfRange) {
        dayElem.classList.add("notAllowed");
        ["inRange", "startRange", "endRange"].forEach(function (c) {
          dayElem.classList.remove(c);
        });
        return;
      } else if (containsDisabled && !outOfRange) return;
      ["startRange", "inRange", "endRange", "notAllowed"].forEach(function (c) {
        dayElem.classList.remove(c);
      });
      if (elem !== undefined) {
        elem.classList.add(hoverDate <= self.selectedDates[0].getTime() ? "startRange" : "endRange");
        if (initialDate < hoverDate && timestamp === initialDate) dayElem.classList.add("startRange");else if (initialDate > hoverDate && timestamp === initialDate) dayElem.classList.add("endRange");
        if (timestamp >= minRange && (maxRange === 0 || timestamp <= maxRange) && isBetween(timestamp, initialDate, hoverDate)) dayElem.classList.add("inRange");
      }
    });
  }
  function onResize() {
    if (self.isOpen && !self.config.static && !self.config.inline) positionCalendar();
  }
  function open(e, positionElement) {
    if (positionElement === void 0) {
      positionElement = self._positionElement;
    }
    if (self.isMobile === true) {
      if (e) {
        e.preventDefault();
        var eventTarget = getEventTarget(e);
        if (eventTarget) {
          eventTarget.blur();
        }
      }
      if (self.mobileInput !== undefined) {
        self.mobileInput.focus();
        self.mobileInput.click();
      }
      triggerEvent("onOpen");
      return;
    } else if (self._input.disabled || self.config.inline) {
      return;
    }
    var wasOpen = self.isOpen;
    self.isOpen = true;
    if (!wasOpen) {
      self.calendarContainer.classList.add("open");
      self._input.classList.add("active");
      triggerEvent("onOpen");
      positionCalendar(positionElement);
    }
    if (self.config.enableTime === true && self.config.noCalendar === true) {
      if (self.config.allowInput === false && (e === undefined || !self.timeContainer.contains(e.relatedTarget))) {
        setTimeout(function () {
          return self.hourElement.select();
        }, 50);
      }
    }
  }
  function minMaxDateSetter(type) {
    return function (date) {
      var dateObj = self.config["_" + type + "Date"] = self.parseDate(date, self.config.dateFormat);
      var inverseDateObj = self.config["_" + (type === "min" ? "max" : "min") + "Date"];
      if (dateObj !== undefined) {
        self[type === "min" ? "minDateHasTime" : "maxDateHasTime"] = dateObj.getHours() > 0 || dateObj.getMinutes() > 0 || dateObj.getSeconds() > 0;
      }
      if (self.selectedDates) {
        self.selectedDates = self.selectedDates.filter(function (d) {
          return isEnabled(d);
        });
        if (!self.selectedDates.length && type === "min") setHoursFromDate(dateObj);
        updateValue();
      }
      if (self.daysContainer) {
        redraw();
        if (dateObj !== undefined) self.currentYearElement[type] = dateObj.getFullYear().toString();else self.currentYearElement.removeAttribute(type);
        self.currentYearElement.disabled = !!inverseDateObj && dateObj !== undefined && inverseDateObj.getFullYear() === dateObj.getFullYear();
      }
    };
  }
  function parseConfig() {
    var boolOpts = ["wrap", "weekNumbers", "allowInput", "allowInvalidPreload", "clickOpens", "time_24hr", "enableTime", "noCalendar", "altInput", "shorthandCurrentMonth", "inline", "static", "enableSeconds", "disableMobile"];
    var userConfig = __assign(__assign({}, JSON.parse(JSON.stringify(element.dataset || {}))), instanceConfig);
    var formats = {};
    self.config.parseDate = userConfig.parseDate;
    self.config.formatDate = userConfig.formatDate;
    Object.defineProperty(self.config, "enable", {
      get: function () {
        return self.config._enable;
      },
      set: function (dates) {
        self.config._enable = parseDateRules(dates);
      }
    });
    Object.defineProperty(self.config, "disable", {
      get: function () {
        return self.config._disable;
      },
      set: function (dates) {
        self.config._disable = parseDateRules(dates);
      }
    });
    var timeMode = userConfig.mode === "time";
    if (!userConfig.dateFormat && (userConfig.enableTime || timeMode)) {
      var defaultDateFormat = flatpickr.defaultConfig.dateFormat || defaults.dateFormat;
      formats.dateFormat = userConfig.noCalendar || timeMode ? "H:i" + (userConfig.enableSeconds ? ":S" : "") : defaultDateFormat + " H:i" + (userConfig.enableSeconds ? ":S" : "");
    }
    if (userConfig.altInput && (userConfig.enableTime || timeMode) && !userConfig.altFormat) {
      var defaultAltFormat = flatpickr.defaultConfig.altFormat || defaults.altFormat;
      formats.altFormat = userConfig.noCalendar || timeMode ? "h:i" + (userConfig.enableSeconds ? ":S K" : " K") : defaultAltFormat + (" h:i" + (userConfig.enableSeconds ? ":S" : "") + " K");
    }
    Object.defineProperty(self.config, "minDate", {
      get: function () {
        return self.config._minDate;
      },
      set: minMaxDateSetter("min")
    });
    Object.defineProperty(self.config, "maxDate", {
      get: function () {
        return self.config._maxDate;
      },
      set: minMaxDateSetter("max")
    });
    var minMaxTimeSetter = function (type) {
      return function (val) {
        self.config[type === "min" ? "_minTime" : "_maxTime"] = self.parseDate(val, "H:i:S");
      };
    };
    Object.defineProperty(self.config, "minTime", {
      get: function () {
        return self.config._minTime;
      },
      set: minMaxTimeSetter("min")
    });
    Object.defineProperty(self.config, "maxTime", {
      get: function () {
        return self.config._maxTime;
      },
      set: minMaxTimeSetter("max")
    });
    if (userConfig.mode === "time") {
      self.config.noCalendar = true;
      self.config.enableTime = true;
    }
    Object.assign(self.config, formats, userConfig);
    for (var i = 0; i < boolOpts.length; i++) self.config[boolOpts[i]] = self.config[boolOpts[i]] === true || self.config[boolOpts[i]] === "true";
    HOOKS.filter(function (hook) {
      return self.config[hook] !== undefined;
    }).forEach(function (hook) {
      self.config[hook] = arrayify(self.config[hook] || []).map(bindToInstance);
    });
    self.isMobile = !self.config.disableMobile && !self.config.inline && self.config.mode === "single" && !self.config.disable.length && !self.config.enable && !self.config.weekNumbers && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    for (var i = 0; i < self.config.plugins.length; i++) {
      var pluginConf = self.config.plugins[i](self) || {};
      for (var key in pluginConf) {
        if (HOOKS.indexOf(key) > -1) {
          self.config[key] = arrayify(pluginConf[key]).map(bindToInstance).concat(self.config[key]);
        } else if (typeof userConfig[key] === "undefined") self.config[key] = pluginConf[key];
      }
    }
    if (!userConfig.altInputClass) {
      self.config.altInputClass = getInputElem().className + " " + self.config.altInputClass;
    }
    triggerEvent("onParseConfig");
  }
  function getInputElem() {
    return self.config.wrap ? element.querySelector("[data-input]") : element;
  }
  function setupLocale() {
    if (typeof self.config.locale !== "object" && typeof flatpickr.l10ns[self.config.locale] === "undefined") self.config.errorHandler(new Error("flatpickr: invalid locale " + self.config.locale));
    self.l10n = __assign(__assign({}, flatpickr.l10ns.default), typeof self.config.locale === "object" ? self.config.locale : self.config.locale !== "default" ? flatpickr.l10ns[self.config.locale] : undefined);
    tokenRegex.D = "(" + self.l10n.weekdays.shorthand.join("|") + ")";
    tokenRegex.l = "(" + self.l10n.weekdays.longhand.join("|") + ")";
    tokenRegex.M = "(" + self.l10n.months.shorthand.join("|") + ")";
    tokenRegex.F = "(" + self.l10n.months.longhand.join("|") + ")";
    tokenRegex.K = "(" + self.l10n.amPM[0] + "|" + self.l10n.amPM[1] + "|" + self.l10n.amPM[0].toLowerCase() + "|" + self.l10n.amPM[1].toLowerCase() + ")";
    var userConfig = __assign(__assign({}, instanceConfig), JSON.parse(JSON.stringify(element.dataset || {})));
    if (userConfig.time_24hr === undefined && flatpickr.defaultConfig.time_24hr === undefined) {
      self.config.time_24hr = self.l10n.time_24hr;
    }
    self.formatDate = createDateFormatter(self);
    self.parseDate = createDateParser({
      config: self.config,
      l10n: self.l10n
    });
  }
  function positionCalendar(customPositionElement) {
    if (typeof self.config.position === "function") {
      return void self.config.position(self, customPositionElement);
    }
    if (self.calendarContainer === undefined) return;
    triggerEvent("onPreCalendarPosition");
    var positionElement = customPositionElement || self._positionElement;
    var calendarHeight = Array.prototype.reduce.call(self.calendarContainer.children, function (acc, child) {
        return acc + child.offsetHeight;
      }, 0),
      calendarWidth = self.calendarContainer.offsetWidth,
      configPos = self.config.position.split(" "),
      configPosVertical = configPos[0],
      configPosHorizontal = configPos.length > 1 ? configPos[1] : null,
      inputBounds = positionElement.getBoundingClientRect(),
      distanceFromBottom = window.innerHeight - inputBounds.bottom,
      showOnTop = configPosVertical === "above" || configPosVertical !== "below" && distanceFromBottom < calendarHeight && inputBounds.top > calendarHeight;
    var top = window.pageYOffset + inputBounds.top + (!showOnTop ? positionElement.offsetHeight + 2 : -calendarHeight - 2);
    toggleClass(self.calendarContainer, "arrowTop", !showOnTop);
    toggleClass(self.calendarContainer, "arrowBottom", showOnTop);
    if (self.config.inline) return;
    var left = window.pageXOffset + inputBounds.left;
    var isCenter = false;
    var isRight = false;
    if (configPosHorizontal === "center") {
      left -= (calendarWidth - inputBounds.width) / 2;
      isCenter = true;
    } else if (configPosHorizontal === "right") {
      left -= calendarWidth - inputBounds.width;
      isRight = true;
    }
    toggleClass(self.calendarContainer, "arrowLeft", !isCenter && !isRight);
    toggleClass(self.calendarContainer, "arrowCenter", isCenter);
    toggleClass(self.calendarContainer, "arrowRight", isRight);
    var right = window.document.body.offsetWidth - (window.pageXOffset + inputBounds.right);
    var rightMost = left + calendarWidth > window.document.body.offsetWidth;
    var centerMost = right + calendarWidth > window.document.body.offsetWidth;
    toggleClass(self.calendarContainer, "rightMost", rightMost);
    if (self.config.static) return;
    self.calendarContainer.style.top = top + "px";
    if (!rightMost) {
      self.calendarContainer.style.left = left + "px";
      self.calendarContainer.style.right = "auto";
    } else if (!centerMost) {
      self.calendarContainer.style.left = "auto";
      self.calendarContainer.style.right = right + "px";
    } else {
      var doc = getDocumentStyleSheet();
      if (doc === undefined) return;
      var bodyWidth = window.document.body.offsetWidth;
      var centerLeft = Math.max(0, bodyWidth / 2 - calendarWidth / 2);
      var centerBefore = ".flatpickr-calendar.centerMost:before";
      var centerAfter = ".flatpickr-calendar.centerMost:after";
      var centerIndex = doc.cssRules.length;
      var centerStyle = "{left:" + inputBounds.left + "px;right:auto;}";
      toggleClass(self.calendarContainer, "rightMost", false);
      toggleClass(self.calendarContainer, "centerMost", true);
      doc.insertRule(centerBefore + "," + centerAfter + centerStyle, centerIndex);
      self.calendarContainer.style.left = centerLeft + "px";
      self.calendarContainer.style.right = "auto";
    }
  }
  function getDocumentStyleSheet() {
    var editableSheet = null;
    for (var i = 0; i < document.styleSheets.length; i++) {
      var sheet = document.styleSheets[i];
      if (!sheet.cssRules) continue;
      try {
        sheet.cssRules;
      } catch (err) {
        continue;
      }
      editableSheet = sheet;
      break;
    }
    return editableSheet != null ? editableSheet : createStyleSheet();
  }
  function createStyleSheet() {
    var style = document.createElement("style");
    document.head.appendChild(style);
    return style.sheet;
  }
  function redraw() {
    if (self.config.noCalendar || self.isMobile) return;
    buildMonthSwitch();
    updateNavigationCurrentMonth();
    buildDays();
  }
  function focusAndClose() {
    self._input.focus();
    if (window.navigator.userAgent.indexOf("MSIE") !== -1 || navigator.msMaxTouchPoints !== undefined) {
      setTimeout(self.close, 0);
    } else {
      self.close();
    }
  }
  function selectDate(e) {
    e.preventDefault();
    e.stopPropagation();
    var isSelectable = function (day) {
      return day.classList && day.classList.contains("flatpickr-day") && !day.classList.contains("flatpickr-disabled") && !day.classList.contains("notAllowed");
    };
    var t = findParent(getEventTarget(e), isSelectable);
    if (t === undefined) return;
    var target = t;
    var selectedDate = self.latestSelectedDateObj = new Date(target.dateObj.getTime());
    var shouldChangeMonth = (selectedDate.getMonth() < self.currentMonth || selectedDate.getMonth() > self.currentMonth + self.config.showMonths - 1) && self.config.mode !== "range";
    self.selectedDateElem = target;
    if (self.config.mode === "single") self.selectedDates = [selectedDate];else if (self.config.mode === "multiple") {
      var selectedIndex = isDateSelected(selectedDate);
      if (selectedIndex) self.selectedDates.splice(parseInt(selectedIndex), 1);else self.selectedDates.push(selectedDate);
    } else if (self.config.mode === "range") {
      if (self.selectedDates.length === 2) {
        self.clear(false, false);
      }
      self.latestSelectedDateObj = selectedDate;
      self.selectedDates.push(selectedDate);
      if (compareDates(selectedDate, self.selectedDates[0], true) !== 0) self.selectedDates.sort(function (a, b) {
        return a.getTime() - b.getTime();
      });
    }
    setHoursFromInputs();
    if (shouldChangeMonth) {
      var isNewYear = self.currentYear !== selectedDate.getFullYear();
      self.currentYear = selectedDate.getFullYear();
      self.currentMonth = selectedDate.getMonth();
      if (isNewYear) {
        triggerEvent("onYearChange");
        buildMonthSwitch();
      }
      triggerEvent("onMonthChange");
    }
    updateNavigationCurrentMonth();
    buildDays();
    updateValue();
    if (!shouldChangeMonth && self.config.mode !== "range" && self.config.showMonths === 1) focusOnDayElem(target);else if (self.selectedDateElem !== undefined && self.hourElement === undefined) {
      self.selectedDateElem && self.selectedDateElem.focus();
    }
    if (self.hourElement !== undefined) self.hourElement !== undefined && self.hourElement.focus();
    if (self.config.closeOnSelect) {
      var single = self.config.mode === "single" && !self.config.enableTime;
      var range = self.config.mode === "range" && self.selectedDates.length === 2 && !self.config.enableTime;
      if (single || range) {
        focusAndClose();
      }
    }
    triggerChange();
  }
  var CALLBACKS = {
    locale: [setupLocale, updateWeekdays],
    showMonths: [buildMonths, setCalendarWidth, buildWeekdays],
    minDate: [jumpToDate],
    maxDate: [jumpToDate],
    positionElement: [updatePositionElement],
    clickOpens: [function () {
      if (self.config.clickOpens === true) {
        bind(self._input, "focus", self.open);
        bind(self._input, "click", self.open);
      } else {
        self._input.removeEventListener("focus", self.open);
        self._input.removeEventListener("click", self.open);
      }
    }]
  };
  function set(option, value) {
    if (option !== null && typeof option === "object") {
      Object.assign(self.config, option);
      for (var key in option) {
        if (CALLBACKS[key] !== undefined) CALLBACKS[key].forEach(function (x) {
          return x();
        });
      }
    } else {
      self.config[option] = value;
      if (CALLBACKS[option] !== undefined) CALLBACKS[option].forEach(function (x) {
        return x();
      });else if (HOOKS.indexOf(option) > -1) self.config[option] = arrayify(value);
    }
    self.redraw();
    updateValue(true);
  }
  function setSelectedDate(inputDate, format) {
    var dates = [];
    if (inputDate instanceof Array) dates = inputDate.map(function (d) {
      return self.parseDate(d, format);
    });else if (inputDate instanceof Date || typeof inputDate === "number") dates = [self.parseDate(inputDate, format)];else if (typeof inputDate === "string") {
      switch (self.config.mode) {
        case "single":
        case "time":
          dates = [self.parseDate(inputDate, format)];
          break;
        case "multiple":
          dates = inputDate.split(self.config.conjunction).map(function (date) {
            return self.parseDate(date, format);
          });
          break;
        case "range":
          dates = inputDate.split(self.l10n.rangeSeparator).map(function (date) {
            return self.parseDate(date, format);
          });
          break;
      }
    } else self.config.errorHandler(new Error("Invalid date supplied: " + JSON.stringify(inputDate)));
    self.selectedDates = self.config.allowInvalidPreload ? dates : dates.filter(function (d) {
      return d instanceof Date && isEnabled(d, false);
    });
    if (self.config.mode === "range") self.selectedDates.sort(function (a, b) {
      return a.getTime() - b.getTime();
    });
  }
  function setDate(date, triggerChange, format) {
    if (triggerChange === void 0) {
      triggerChange = false;
    }
    if (format === void 0) {
      format = self.config.dateFormat;
    }
    if (date !== 0 && !date || date instanceof Array && date.length === 0) return self.clear(triggerChange);
    setSelectedDate(date, format);
    self.latestSelectedDateObj = self.selectedDates[self.selectedDates.length - 1];
    self.redraw();
    jumpToDate(undefined, triggerChange);
    setHoursFromDate();
    if (self.selectedDates.length === 0) {
      self.clear(false);
    }
    updateValue(triggerChange);
    if (triggerChange) triggerEvent("onChange");
  }
  function parseDateRules(arr) {
    return arr.slice().map(function (rule) {
      if (typeof rule === "string" || typeof rule === "number" || rule instanceof Date) {
        return self.parseDate(rule, undefined, true);
      } else if (rule && typeof rule === "object" && rule.from && rule.to) return {
        from: self.parseDate(rule.from, undefined),
        to: self.parseDate(rule.to, undefined)
      };
      return rule;
    }).filter(function (x) {
      return x;
    });
  }
  function setupDates() {
    self.selectedDates = [];
    self.now = self.parseDate(self.config.now) || new Date();
    var preloadedDate = self.config.defaultDate || ((self.input.nodeName === "INPUT" || self.input.nodeName === "TEXTAREA") && self.input.placeholder && self.input.value === self.input.placeholder ? null : self.input.value);
    if (preloadedDate) setSelectedDate(preloadedDate, self.config.dateFormat);
    self._initialDate = self.selectedDates.length > 0 ? self.selectedDates[0] : self.config.minDate && self.config.minDate.getTime() > self.now.getTime() ? self.config.minDate : self.config.maxDate && self.config.maxDate.getTime() < self.now.getTime() ? self.config.maxDate : self.now;
    self.currentYear = self._initialDate.getFullYear();
    self.currentMonth = self._initialDate.getMonth();
    if (self.selectedDates.length > 0) self.latestSelectedDateObj = self.selectedDates[0];
    if (self.config.minTime !== undefined) self.config.minTime = self.parseDate(self.config.minTime, "H:i");
    if (self.config.maxTime !== undefined) self.config.maxTime = self.parseDate(self.config.maxTime, "H:i");
    self.minDateHasTime = !!self.config.minDate && (self.config.minDate.getHours() > 0 || self.config.minDate.getMinutes() > 0 || self.config.minDate.getSeconds() > 0);
    self.maxDateHasTime = !!self.config.maxDate && (self.config.maxDate.getHours() > 0 || self.config.maxDate.getMinutes() > 0 || self.config.maxDate.getSeconds() > 0);
  }
  function setupInputs() {
    self.input = getInputElem();
    if (!self.input) {
      self.config.errorHandler(new Error("Invalid input element specified"));
      return;
    }
    self.input._type = self.input.type;
    self.input.type = "text";
    self.input.classList.add("flatpickr-input");
    self._input = self.input;
    if (self.config.altInput) {
      self.altInput = createElement(self.input.nodeName, self.config.altInputClass);
      self._input = self.altInput;
      self.altInput.placeholder = self.input.placeholder;
      self.altInput.disabled = self.input.disabled;
      self.altInput.required = self.input.required;
      self.altInput.tabIndex = self.input.tabIndex;
      self.altInput.type = "text";
      self.input.setAttribute("type", "hidden");
      if (!self.config.static && self.input.parentNode) self.input.parentNode.insertBefore(self.altInput, self.input.nextSibling);
    }
    if (!self.config.allowInput) self._input.setAttribute("readonly", "readonly");
    updatePositionElement();
  }
  function updatePositionElement() {
    self._positionElement = self.config.positionElement || self._input;
  }
  function setupMobile() {
    var inputType = self.config.enableTime ? self.config.noCalendar ? "time" : "datetime-local" : "date";
    self.mobileInput = createElement("input", self.input.className + " flatpickr-mobile");
    self.mobileInput.tabIndex = 1;
    self.mobileInput.type = inputType;
    self.mobileInput.disabled = self.input.disabled;
    self.mobileInput.required = self.input.required;
    self.mobileInput.placeholder = self.input.placeholder;
    self.mobileFormatStr = inputType === "datetime-local" ? "Y-m-d\\TH:i:S" : inputType === "date" ? "Y-m-d" : "H:i:S";
    if (self.selectedDates.length > 0) {
      self.mobileInput.defaultValue = self.mobileInput.value = self.formatDate(self.selectedDates[0], self.mobileFormatStr);
    }
    if (self.config.minDate) self.mobileInput.min = self.formatDate(self.config.minDate, "Y-m-d");
    if (self.config.maxDate) self.mobileInput.max = self.formatDate(self.config.maxDate, "Y-m-d");
    if (self.input.getAttribute("step")) self.mobileInput.step = String(self.input.getAttribute("step"));
    self.input.type = "hidden";
    if (self.altInput !== undefined) self.altInput.type = "hidden";
    try {
      if (self.input.parentNode) self.input.parentNode.insertBefore(self.mobileInput, self.input.nextSibling);
    } catch (_a) {}
    bind(self.mobileInput, "change", function (e) {
      self.setDate(getEventTarget(e).value, false, self.mobileFormatStr);
      triggerEvent("onChange");
      triggerEvent("onClose");
    });
  }
  function toggle(e) {
    if (self.isOpen === true) return self.close();
    self.open(e);
  }
  function triggerEvent(event, data) {
    if (self.config === undefined) return;
    var hooks = self.config[event];
    if (hooks !== undefined && hooks.length > 0) {
      for (var i = 0; hooks[i] && i < hooks.length; i++) hooks[i](self.selectedDates, self.input.value, self, data);
    }
    if (event === "onChange") {
      self.input.dispatchEvent(createEvent("change"));
      self.input.dispatchEvent(createEvent("input"));
    }
  }
  function createEvent(name) {
    var e = document.createEvent("Event");
    e.initEvent(name, true, true);
    return e;
  }
  function isDateSelected(date) {
    for (var i = 0; i < self.selectedDates.length; i++) {
      var selectedDate = self.selectedDates[i];
      if (selectedDate instanceof Date && compareDates(selectedDate, date) === 0) return "" + i;
    }
    return false;
  }
  function isDateInRange(date) {
    if (self.config.mode !== "range" || self.selectedDates.length < 2) return false;
    return compareDates(date, self.selectedDates[0]) >= 0 && compareDates(date, self.selectedDates[1]) <= 0;
  }
  function updateNavigationCurrentMonth() {
    if (self.config.noCalendar || self.isMobile || !self.monthNav) return;
    self.yearElements.forEach(function (yearElement, i) {
      var d = new Date(self.currentYear, self.currentMonth, 1);
      d.setMonth(self.currentMonth + i);
      if (self.config.showMonths > 1 || self.config.monthSelectorType === "static") {
        self.monthElements[i].textContent = monthToStr(d.getMonth(), self.config.shorthandCurrentMonth, self.l10n) + " ";
      } else {
        self.monthsDropdownContainer.value = d.getMonth().toString();
      }
      yearElement.value = d.getFullYear().toString();
    });
    self._hidePrevMonthArrow = self.config.minDate !== undefined && (self.currentYear === self.config.minDate.getFullYear() ? self.currentMonth <= self.config.minDate.getMonth() : self.currentYear < self.config.minDate.getFullYear());
    self._hideNextMonthArrow = self.config.maxDate !== undefined && (self.currentYear === self.config.maxDate.getFullYear() ? self.currentMonth + 1 > self.config.maxDate.getMonth() : self.currentYear > self.config.maxDate.getFullYear());
  }
  function getDateStr(specificFormat) {
    var format = specificFormat || (self.config.altInput ? self.config.altFormat : self.config.dateFormat);
    return self.selectedDates.map(function (dObj) {
      return self.formatDate(dObj, format);
    }).filter(function (d, i, arr) {
      return self.config.mode !== "range" || self.config.enableTime || arr.indexOf(d) === i;
    }).join(self.config.mode !== "range" ? self.config.conjunction : self.l10n.rangeSeparator);
  }
  function updateValue(triggerChange) {
    if (triggerChange === void 0) {
      triggerChange = true;
    }
    if (self.mobileInput !== undefined && self.mobileFormatStr) {
      self.mobileInput.value = self.latestSelectedDateObj !== undefined ? self.formatDate(self.latestSelectedDateObj, self.mobileFormatStr) : "";
    }
    self.input.value = getDateStr(self.config.dateFormat);
    if (self.altInput !== undefined) {
      self.altInput.value = getDateStr(self.config.altFormat);
    }
    if (triggerChange !== false) triggerEvent("onValueUpdate");
  }
  function onMonthNavClick(e) {
    var eventTarget = getEventTarget(e);
    var isPrevMonth = self.prevMonthNav.contains(eventTarget);
    var isNextMonth = self.nextMonthNav.contains(eventTarget);
    if (isPrevMonth || isNextMonth) {
      changeMonth(isPrevMonth ? -1 : 1);
    } else if (self.yearElements.indexOf(eventTarget) >= 0) {
      eventTarget.select();
    } else if (eventTarget.classList.contains("arrowUp")) {
      self.changeYear(self.currentYear + 1);
    } else if (eventTarget.classList.contains("arrowDown")) {
      self.changeYear(self.currentYear - 1);
    }
  }
  function timeWrapper(e) {
    e.preventDefault();
    var isKeyDown = e.type === "keydown",
      eventTarget = getEventTarget(e),
      input = eventTarget;
    if (self.amPM !== undefined && eventTarget === self.amPM) {
      self.amPM.textContent = self.l10n.amPM[int(self.amPM.textContent === self.l10n.amPM[0])];
    }
    var min = parseFloat(input.getAttribute("min")),
      max = parseFloat(input.getAttribute("max")),
      step = parseFloat(input.getAttribute("step")),
      curValue = parseInt(input.value, 10),
      delta = e.delta || (isKeyDown ? e.which === 38 ? 1 : -1 : 0);
    var newValue = curValue + step * delta;
    if (typeof input.value !== "undefined" && input.value.length === 2) {
      var isHourElem = input === self.hourElement,
        isMinuteElem = input === self.minuteElement;
      if (newValue < min) {
        newValue = max + newValue + int(!isHourElem) + (int(isHourElem) && int(!self.amPM));
        if (isMinuteElem) incrementNumInput(undefined, -1, self.hourElement);
      } else if (newValue > max) {
        newValue = input === self.hourElement ? newValue - max - int(!self.amPM) : min;
        if (isMinuteElem) incrementNumInput(undefined, 1, self.hourElement);
      }
      if (self.amPM && isHourElem && (step === 1 ? newValue + curValue === 23 : Math.abs(newValue - curValue) > step)) {
        self.amPM.textContent = self.l10n.amPM[int(self.amPM.textContent === self.l10n.amPM[0])];
      }
      input.value = pad(newValue);
    }
  }
  init();
  return self;
}
function _flatpickr(nodeList, config) {
  var nodes = Array.prototype.slice.call(nodeList).filter(function (x) {
    return x instanceof HTMLElement;
  });
  var instances = [];
  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    try {
      if (node.getAttribute("data-fp-omit") !== null) continue;
      if (node._flatpickr !== undefined) {
        node._flatpickr.destroy();
        node._flatpickr = undefined;
      }
      node._flatpickr = FlatpickrInstance(node, config || {});
      instances.push(node._flatpickr);
    } catch (e) {
      console.error(e);
    }
  }
  return instances.length === 1 ? instances[0] : instances;
}
if (typeof HTMLElement !== "undefined" && typeof HTMLCollection !== "undefined" && typeof NodeList !== "undefined") {
  HTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function (config) {
    return _flatpickr(this, config);
  };
  HTMLElement.prototype.flatpickr = function (config) {
    return _flatpickr([this], config);
  };
}
var flatpickr = function (selector, config) {
  if (typeof selector === "string") {
    return _flatpickr(window.document.querySelectorAll(selector), config);
  } else if (selector instanceof Node) {
    return _flatpickr([selector], config);
  } else {
    return _flatpickr(selector, config);
  }
};
flatpickr.defaultConfig = {};
flatpickr.l10ns = {
  en: __assign({}, english),
  default: __assign({}, english)
};
flatpickr.localize = function (l10n) {
  flatpickr.l10ns.default = __assign(__assign({}, flatpickr.l10ns.default), l10n);
};
flatpickr.setDefaults = function (config) {
  flatpickr.defaultConfig = __assign(__assign({}, flatpickr.defaultConfig), config);
};
flatpickr.parseDate = createDateParser({});
flatpickr.formatDate = createDateFormatter({});
flatpickr.compareDates = compareDates;
if (typeof jQuery !== "undefined" && typeof jQuery.fn !== "undefined") {
  jQuery.fn.flatpickr = function (config) {
    return _flatpickr(this, config);
  };
}
Date.prototype.fp_incr = function (days) {
  return new Date(this.getFullYear(), this.getMonth(), this.getDate() + (typeof days === "string" ? parseInt(days, 10) : days));
};
if (typeof window !== "undefined") {
  window.flatpickr = flatpickr;
}

var _default$c = {exports: {}};

(function (module, exports) {
	(function (global, factory) {
	  factory(exports) ;
	})(commonjsGlobal, function (exports) {

	  var english = {
	    weekdays: {
	      shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
	      longhand: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
	    },
	    months: {
	      shorthand: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
	      longhand: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
	    },
	    daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
	    firstDayOfWeek: 0,
	    ordinal: function (nth) {
	      var s = nth % 100;
	      if (s > 3 && s < 21) return "th";
	      switch (s % 10) {
	        case 1:
	          return "st";
	        case 2:
	          return "nd";
	        case 3:
	          return "rd";
	        default:
	          return "th";
	      }
	    },
	    rangeSeparator: " to ",
	    weekAbbreviation: "Wk",
	    scrollTitle: "Scroll to increment",
	    toggleTitle: "Click to toggle",
	    amPM: ["AM", "PM"],
	    yearAriaLabel: "Year",
	    monthAriaLabel: "Month",
	    hourAriaLabel: "Hour",
	    minuteAriaLabel: "Minute",
	    time_24hr: false
	  };
	  exports.default = english;
	  exports.english = english;
	  Object.defineProperty(exports, '__esModule', {
	    value: true
	  });
	}); 
} (_default$c, _default$c.exports));

var _defaultExports = _default$c.exports;

function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

function toInteger(dirtyNumber) {
  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    return NaN;
  }
  var number = Number(dirtyNumber);
  if (isNaN(number)) {
    return number;
  }
  return number < 0 ? Math.ceil(number) : Math.floor(number);
}

function requiredArgs(required, args) {
  if (args.length < required) {
    throw new TypeError(required + ' argument' + (required > 1 ? 's' : '') + ' required, but only ' + args.length + ' present');
  }
}

/**
 * @name toDate
 * @category Common Helpers
 * @summary Convert the given argument to an instance of Date.
 *
 * @description
 * Convert the given argument to an instance of Date.
 *
 * If the argument is an instance of Date, the function returns its clone.
 *
 * If the argument is a number, it is treated as a timestamp.
 *
 * If the argument is none of the above, the function returns Invalid Date.
 *
 * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
 *
 * @param {Date|Number} argument - the value to convert
 * @returns {Date} the parsed date in the local time zone
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Clone the date:
 * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
 * //=> Tue Feb 11 2014 11:30:30
 *
 * @example
 * // Convert the timestamp to date:
 * const result = toDate(1392098430000)
 * //=> Tue Feb 11 2014 11:30:30
 */
function toDate(argument) {
  requiredArgs(1, arguments);
  var argStr = Object.prototype.toString.call(argument);

  // Clone the date
  if (argument instanceof Date || _typeof(argument) === 'object' && argStr === '[object Date]') {
    // Prevent the date to lose the milliseconds when passed to new Date() in IE10
    return new Date(argument.getTime());
  } else if (typeof argument === 'number' || argStr === '[object Number]') {
    return new Date(argument);
  } else {
    if ((typeof argument === 'string' || argStr === '[object String]') && typeof console !== 'undefined') {
      // eslint-disable-next-line no-console
      console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments");
      // eslint-disable-next-line no-console
      console.warn(new Error().stack);
    }
    return new Date(NaN);
  }
}

/**
 * @name addMilliseconds
 * @category Millisecond Helpers
 * @summary Add the specified number of milliseconds to the given date.
 *
 * @description
 * Add the specified number of milliseconds to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of milliseconds to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the milliseconds added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add 750 milliseconds to 10 July 2014 12:45:30.000:
 * const result = addMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
 * //=> Thu Jul 10 2014 12:45:30.750
 */
function addMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var timestamp = toDate(dirtyDate).getTime();
  var amount = toInteger(dirtyAmount);
  return new Date(timestamp + amount);
}

var defaultOptions$1 = {};
function getDefaultOptions() {
  return defaultOptions$1;
}

/**
 * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.
 * They usually appear for dates that denote time before the timezones were introduced
 * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891
 * and GMT+01:00:00 after that date)
 *
 * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,
 * which would lead to incorrect calculations.
 *
 * This function returns the timezone offset in milliseconds that takes seconds in account.
 */
function getTimezoneOffsetInMilliseconds(date) {
  var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
  utcDate.setUTCFullYear(date.getFullYear());
  return date.getTime() - utcDate.getTime();
}

/**
 * Days in 1 week.
 *
 * @name daysInWeek
 * @constant
 * @type {number}
 * @default
 */

/**
 * Milliseconds in 1 minute
 *
 * @name millisecondsInMinute
 * @constant
 * @type {number}
 * @default
 */
var millisecondsInMinute = 60000;

/**
 * Milliseconds in 1 hour
 *
 * @name millisecondsInHour
 * @constant
 * @type {number}
 * @default
 */
var millisecondsInHour = 3600000;

/**
 * Milliseconds in 1 second
 *
 * @name millisecondsInSecond
 * @constant
 * @type {number}
 * @default
 */
var millisecondsInSecond = 1000;

/**
 * @name isDate
 * @category Common Helpers
 * @summary Is the given value a date?
 *
 * @description
 * Returns true if the given value is an instance of Date. The function works for dates transferred across iframes.
 *
 * @param {*} value - the value to check
 * @returns {boolean} true if the given value is a date
 * @throws {TypeError} 1 arguments required
 *
 * @example
 * // For a valid date:
 * const result = isDate(new Date())
 * //=> true
 *
 * @example
 * // For an invalid date:
 * const result = isDate(new Date(NaN))
 * //=> true
 *
 * @example
 * // For some value:
 * const result = isDate('2014-02-31')
 * //=> false
 *
 * @example
 * // For an object:
 * const result = isDate({})
 * //=> false
 */
function isDate(value) {
  requiredArgs(1, arguments);
  return value instanceof Date || _typeof(value) === 'object' && Object.prototype.toString.call(value) === '[object Date]';
}

/**
 * @name isValid
 * @category Common Helpers
 * @summary Is the given date valid?
 *
 * @description
 * Returns false if argument is Invalid Date and true otherwise.
 * Argument is converted to Date using `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
 * Invalid Date is a Date, whose time value is NaN.
 *
 * Time value of Date: http://es5.github.io/#x15.9.1.1
 *
 * @param {*} date - the date to check
 * @returns {Boolean} the date is valid
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // For the valid date:
 * const result = isValid(new Date(2014, 1, 31))
 * //=> true
 *
 * @example
 * // For the value, convertable into a date:
 * const result = isValid(1393804800000)
 * //=> true
 *
 * @example
 * // For the invalid date:
 * const result = isValid(new Date(''))
 * //=> false
 */
function isValid(dirtyDate) {
  requiredArgs(1, arguments);
  if (!isDate(dirtyDate) && typeof dirtyDate !== 'number') {
    return false;
  }
  var date = toDate(dirtyDate);
  return !isNaN(Number(date));
}

/**
 * @name subMilliseconds
 * @category Millisecond Helpers
 * @summary Subtract the specified number of milliseconds from the given date.
 *
 * @description
 * Subtract the specified number of milliseconds from the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of milliseconds to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the milliseconds subtracted
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Subtract 750 milliseconds from 10 July 2014 12:45:30.000:
 * const result = subMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
 * //=> Thu Jul 10 2014 12:45:29.250
 */
function subMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, -amount);
}

function startOfUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}

function getUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var fourthOfJanuaryOfNextYear = new Date(0);
  fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = new Date(0);
  fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

function startOfUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var year = getUTCISOWeekYear(dirtyDate);
  var fourthOfJanuary = new Date(0);
  fourthOfJanuary.setUTCFullYear(year, 0, 4);
  fourthOfJanuary.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCISOWeek(fourthOfJanuary);
  return date;
}

var MILLISECONDS_IN_WEEK$1 = 604800000;
function getUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCISOWeek(date).getTime() - startOfUTCISOWeekYear(date).getTime();

  // Round the number of days to the nearest integer
  // because the number of milliseconds in a week is not constant
  // (e.g. it's different in the week of the daylight saving time clock shift)
  return Math.round(diff / MILLISECONDS_IN_WEEK$1) + 1;
}

function startOfUTCWeek(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions = getDefaultOptions();
  var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);

  // Test if weekStartsOn is between 0 and 6 _and_ is not NaN
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}

function getUTCWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var defaultOptions = getDefaultOptions();
  var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);

  // Test if weekStartsOn is between 1 and 7 _and_ is not NaN
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
  }
  var firstWeekOfNextYear = new Date(0);
  firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, options);
  var firstWeekOfThisYear = new Date(0);
  firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, options);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

function startOfUTCWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions = getDefaultOptions();
  var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
  var year = getUTCWeekYear(dirtyDate, options);
  var firstWeek = new Date(0);
  firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCWeek(firstWeek, options);
  return date;
}

var MILLISECONDS_IN_WEEK = 604800000;
function getUTCWeek(dirtyDate, options) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCWeek(date, options).getTime() - startOfUTCWeekYear(date, options).getTime();

  // Round the number of days to the nearest integer
  // because the number of milliseconds in a week is not constant
  // (e.g. it's different in the week of the daylight saving time clock shift)
  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
}

var dateLongFormatter = function dateLongFormatter(pattern, formatLong) {
  switch (pattern) {
    case 'P':
      return formatLong.date({
        width: 'short'
      });
    case 'PP':
      return formatLong.date({
        width: 'medium'
      });
    case 'PPP':
      return formatLong.date({
        width: 'long'
      });
    case 'PPPP':
    default:
      return formatLong.date({
        width: 'full'
      });
  }
};
var timeLongFormatter = function timeLongFormatter(pattern, formatLong) {
  switch (pattern) {
    case 'p':
      return formatLong.time({
        width: 'short'
      });
    case 'pp':
      return formatLong.time({
        width: 'medium'
      });
    case 'ppp':
      return formatLong.time({
        width: 'long'
      });
    case 'pppp':
    default:
      return formatLong.time({
        width: 'full'
      });
  }
};
var dateTimeLongFormatter = function dateTimeLongFormatter(pattern, formatLong) {
  var matchResult = pattern.match(/(P+)(p+)?/) || [];
  var datePattern = matchResult[1];
  var timePattern = matchResult[2];
  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong);
  }
  var dateTimeFormat;
  switch (datePattern) {
    case 'P':
      dateTimeFormat = formatLong.dateTime({
        width: 'short'
      });
      break;
    case 'PP':
      dateTimeFormat = formatLong.dateTime({
        width: 'medium'
      });
      break;
    case 'PPP':
      dateTimeFormat = formatLong.dateTime({
        width: 'long'
      });
      break;
    case 'PPPP':
    default:
      dateTimeFormat = formatLong.dateTime({
        width: 'full'
      });
      break;
  }
  return dateTimeFormat.replace('{{date}}', dateLongFormatter(datePattern, formatLong)).replace('{{time}}', timeLongFormatter(timePattern, formatLong));
};
var longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};

var protectedDayOfYearTokens = ['D', 'DD'];
var protectedWeekYearTokens = ['YY', 'YYYY'];
function isProtectedDayOfYearToken(token) {
  return protectedDayOfYearTokens.indexOf(token) !== -1;
}
function isProtectedWeekYearToken(token) {
  return protectedWeekYearTokens.indexOf(token) !== -1;
}
function throwProtectedError(token, format, input) {
  if (token === 'YYYY') {
    throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === 'YY') {
    throw new RangeError("Use `yy` instead of `YY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === 'D') {
    throw new RangeError("Use `d` instead of `D` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === 'DD') {
    throw new RangeError("Use `dd` instead of `DD` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  }
}

var formatDistanceLocale = {
  lessThanXSeconds: {
    one: 'less than a second',
    other: 'less than {{count}} seconds'
  },
  xSeconds: {
    one: '1 second',
    other: '{{count}} seconds'
  },
  halfAMinute: 'half a minute',
  lessThanXMinutes: {
    one: 'less than a minute',
    other: 'less than {{count}} minutes'
  },
  xMinutes: {
    one: '1 minute',
    other: '{{count}} minutes'
  },
  aboutXHours: {
    one: 'about 1 hour',
    other: 'about {{count}} hours'
  },
  xHours: {
    one: '1 hour',
    other: '{{count}} hours'
  },
  xDays: {
    one: '1 day',
    other: '{{count}} days'
  },
  aboutXWeeks: {
    one: 'about 1 week',
    other: 'about {{count}} weeks'
  },
  xWeeks: {
    one: '1 week',
    other: '{{count}} weeks'
  },
  aboutXMonths: {
    one: 'about 1 month',
    other: 'about {{count}} months'
  },
  xMonths: {
    one: '1 month',
    other: '{{count}} months'
  },
  aboutXYears: {
    one: 'about 1 year',
    other: 'about {{count}} years'
  },
  xYears: {
    one: '1 year',
    other: '{{count}} years'
  },
  overXYears: {
    one: 'over 1 year',
    other: 'over {{count}} years'
  },
  almostXYears: {
    one: 'almost 1 year',
    other: 'almost {{count}} years'
  }
};
var formatDistance = function formatDistance(token, count, options) {
  var result;
  var tokenValue = formatDistanceLocale[token];
  if (typeof tokenValue === 'string') {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace('{{count}}', count.toString());
  }
  if (options !== null && options !== void 0 && options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return 'in ' + result;
    } else {
      return result + ' ago';
    }
  }
  return result;
};

function buildFormatLongFn(args) {
  return function () {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    // TODO: Remove String()
    var width = options.width ? String(options.width) : args.defaultWidth;
    var format = args.formats[width] || args.formats[args.defaultWidth];
    return format;
  };
}

var dateFormats = {
  full: 'EEEE, MMMM do, y',
  long: 'MMMM do, y',
  medium: 'MMM d, y',
  short: 'MM/dd/yyyy'
};
var timeFormats = {
  full: 'h:mm:ss a zzzz',
  long: 'h:mm:ss a z',
  medium: 'h:mm:ss a',
  short: 'h:mm a'
};
var dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: '{{date}}, {{time}}',
  short: '{{date}}, {{time}}'
};
var formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: 'full'
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: 'full'
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: 'full'
  })
};

var formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: 'P'
};
var formatRelative = function formatRelative(token, _date, _baseDate, _options) {
  return formatRelativeLocale[token];
};

function buildLocalizeFn(args) {
  return function (dirtyIndex, options) {
    var context = options !== null && options !== void 0 && options.context ? String(options.context) : 'standalone';
    var valuesArray;
    if (context === 'formatting' && args.formattingValues) {
      var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      var width = options !== null && options !== void 0 && options.width ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      var _defaultWidth = args.defaultWidth;
      var _width = options !== null && options !== void 0 && options.width ? String(options.width) : args.defaultWidth;
      valuesArray = args.values[_width] || args.values[_defaultWidth];
    }
    var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
    // @ts-ignore: For some reason TypeScript just don't want to match it, no matter how hard we try. I challenge you to try to remove it!
    return valuesArray[index];
  };
}

var eraValues = {
  narrow: ['B', 'A'],
  abbreviated: ['BC', 'AD'],
  wide: ['Before Christ', 'Anno Domini']
};
var quarterValues = {
  narrow: ['1', '2', '3', '4'],
  abbreviated: ['Q1', 'Q2', 'Q3', 'Q4'],
  wide: ['1st quarter', '2nd quarter', '3rd quarter', '4th quarter']
};

// Note: in English, the names of days of the week and months are capitalized.
// If you are making a new locale based on this one, check if the same is true for the language you're working on.
// Generally, formatted dates should look like they are in the middle of a sentence,
// e.g. in Spanish language the weekdays and months should be in the lowercase.
var monthValues = {
  narrow: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
  abbreviated: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
  wide: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
};
var dayValues = {
  narrow: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
  short: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
  abbreviated: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
  wide: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
};
var dayPeriodValues = {
  narrow: {
    am: 'a',
    pm: 'p',
    midnight: 'mi',
    noon: 'n',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  },
  abbreviated: {
    am: 'AM',
    pm: 'PM',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  },
  wide: {
    am: 'a.m.',
    pm: 'p.m.',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: 'a',
    pm: 'p',
    midnight: 'mi',
    noon: 'n',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  },
  abbreviated: {
    am: 'AM',
    pm: 'PM',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  },
  wide: {
    am: 'a.m.',
    pm: 'p.m.',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  }
};
var ordinalNumber = function ordinalNumber(dirtyNumber, _options) {
  var number = Number(dirtyNumber);

  // If ordinal numbers depend on context, for example,
  // if they are different for different grammatical genders,
  // use `options.unit`.
  //
  // `unit` can be 'year', 'quarter', 'month', 'week', 'date', 'dayOfYear',
  // 'day', 'hour', 'minute', 'second'.

  var rem100 = number % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + 'st';
      case 2:
        return number + 'nd';
      case 3:
        return number + 'rd';
    }
  }
  return number + 'th';
};
var localize = {
  ordinalNumber: ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: 'wide'
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: 'wide',
    argumentCallback: function argumentCallback(quarter) {
      return quarter - 1;
    }
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: 'wide'
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: 'wide'
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: 'wide',
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: 'wide'
  })
};

function buildMatchFn(args) {
  return function (string) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var width = options.width;
    var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    var matchResult = string.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    var matchedString = matchResult[0];
    var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    var key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function (pattern) {
      return pattern.test(matchedString);
    }) : findKey(parsePatterns, function (pattern) {
      return pattern.test(matchedString);
    });
    var value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value: value,
      rest: rest
    };
  };
}
function findKey(object, predicate) {
  for (var key in object) {
    if (object.hasOwnProperty(key) && predicate(object[key])) {
      return key;
    }
  }
  return undefined;
}
function findIndex(array, predicate) {
  for (var key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }
  return undefined;
}

function buildMatchPatternFn(args) {
  return function (string) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var matchResult = string.match(args.matchPattern);
    if (!matchResult) return null;
    var matchedString = matchResult[0];
    var parseResult = string.match(args.parsePattern);
    if (!parseResult) return null;
    var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value: value,
      rest: rest
    };
  };
}

var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
};
var matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: function valueCallback(value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseEraPatterns,
    defaultParseWidth: 'any'
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: 'any',
    valueCallback: function valueCallback(index) {
      return index + 1;
    }
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: 'any'
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseDayPatterns,
    defaultParseWidth: 'any'
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: 'any',
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: 'any'
  })
};

/**
 * @type {Locale}
 * @category Locales
 * @summary English locale (United States).
 * @language English
 * @iso-639-2 eng
 * @author Sasha Koss [@kossnocorp]{@link https://github.com/kossnocorp}
 * @author Lesha Koss [@leshakoss]{@link https://github.com/leshakoss}
 */
var locale = {
  code: 'en-US',
  formatDistance: formatDistance,
  formatLong: formatLong,
  formatRelative: formatRelative,
  localize: localize,
  match: match,
  options: {
    weekStartsOn: 0 /* Sunday */,
    firstWeekContainsDate: 1
  }
};

function assign(target, object) {
  if (target == null) {
    throw new TypeError('assign requires that input parameter not be null or undefined');
  }
  for (var property in object) {
    if (Object.prototype.hasOwnProperty.call(object, property)) {
      target[property] = object[property];
    }
  }
  return target;
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike  ) {
      if (it) o = it;
      var i = 0;
      var F = function F() {};
      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true,
    didErr = false,
    err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}

function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

var TIMEZONE_UNIT_PRIORITY = 10;
var Setter = /*#__PURE__*/function () {
  function Setter() {
    _classCallCheck(this, Setter);
    _defineProperty(this, "priority", void 0);
    _defineProperty(this, "subPriority", 0);
  }
  _createClass(Setter, [{
    key: "validate",
    value: function validate(_utcDate, _options) {
      return true;
    }
  }]);
  return Setter;
}();
var ValueSetter = /*#__PURE__*/function (_Setter) {
  _inherits(ValueSetter, _Setter);
  var _super = _createSuper(ValueSetter);
  function ValueSetter(value, validateValue, setValue, priority, subPriority) {
    var _this;
    _classCallCheck(this, ValueSetter);
    _this = _super.call(this);
    _this.value = value;
    _this.validateValue = validateValue;
    _this.setValue = setValue;
    _this.priority = priority;
    if (subPriority) {
      _this.subPriority = subPriority;
    }
    return _this;
  }
  _createClass(ValueSetter, [{
    key: "validate",
    value: function validate(utcDate, options) {
      return this.validateValue(utcDate, this.value, options);
    }
  }, {
    key: "set",
    value: function set(utcDate, flags, options) {
      return this.setValue(utcDate, flags, this.value, options);
    }
  }]);
  return ValueSetter;
}(Setter);
var DateToSystemTimezoneSetter = /*#__PURE__*/function (_Setter2) {
  _inherits(DateToSystemTimezoneSetter, _Setter2);
  var _super2 = _createSuper(DateToSystemTimezoneSetter);
  function DateToSystemTimezoneSetter() {
    var _this2;
    _classCallCheck(this, DateToSystemTimezoneSetter);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _super2.call.apply(_super2, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this2), "priority", TIMEZONE_UNIT_PRIORITY);
    _defineProperty(_assertThisInitialized(_this2), "subPriority", -1);
    return _this2;
  }
  _createClass(DateToSystemTimezoneSetter, [{
    key: "set",
    value: function set(date, flags) {
      if (flags.timestampIsSet) {
        return date;
      }
      var convertedDate = new Date(0);
      convertedDate.setFullYear(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
      convertedDate.setHours(date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
      return convertedDate;
    }
  }]);
  return DateToSystemTimezoneSetter;
}(Setter);

var Parser = /*#__PURE__*/function () {
  function Parser() {
    _classCallCheck(this, Parser);
    _defineProperty(this, "incompatibleTokens", void 0);
    _defineProperty(this, "priority", void 0);
    _defineProperty(this, "subPriority", void 0);
  }
  _createClass(Parser, [{
    key: "run",
    value: function run(dateString, token, match, options) {
      var result = this.parse(dateString, token, match, options);
      if (!result) {
        return null;
      }
      return {
        setter: new ValueSetter(result.value, this.validate, this.set, this.priority, this.subPriority),
        rest: result.rest
      };
    }
  }, {
    key: "validate",
    value: function validate(_utcDate, _value, _options) {
      return true;
    }
  }]);
  return Parser;
}();

var EraParser = /*#__PURE__*/function (_Parser) {
  _inherits(EraParser, _Parser);
  var _super = _createSuper(EraParser);
  function EraParser() {
    var _this;
    _classCallCheck(this, EraParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 140);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['R', 'u', 't', 'T']);
    return _this;
  }
  _createClass(EraParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        // AD, BC
        case 'G':
        case 'GG':
        case 'GGG':
          return match.era(dateString, {
            width: 'abbreviated'
          }) || match.era(dateString, {
            width: 'narrow'
          });
        // A, B
        case 'GGGGG':
          return match.era(dateString, {
            width: 'narrow'
          });
        // Anno Domini, Before Christ
        case 'GGGG':
        default:
          return match.era(dateString, {
            width: 'wide'
          }) || match.era(dateString, {
            width: 'abbreviated'
          }) || match.era(dateString, {
            width: 'narrow'
          });
      }
    }
  }, {
    key: "set",
    value: function set(date, flags, value) {
      flags.era = value;
      date.setUTCFullYear(value, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return EraParser;
}(Parser);

var numericPatterns = {
  month: /^(1[0-2]|0?\d)/,
  // 0 to 12
  date: /^(3[0-1]|[0-2]?\d)/,
  // 0 to 31
  dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
  // 0 to 366
  week: /^(5[0-3]|[0-4]?\d)/,
  // 0 to 53
  hour23h: /^(2[0-3]|[0-1]?\d)/,
  // 0 to 23
  hour24h: /^(2[0-4]|[0-1]?\d)/,
  // 0 to 24
  hour11h: /^(1[0-1]|0?\d)/,
  // 0 to 11
  hour12h: /^(1[0-2]|0?\d)/,
  // 0 to 12
  minute: /^[0-5]?\d/,
  // 0 to 59
  second: /^[0-5]?\d/,
  // 0 to 59

  singleDigit: /^\d/,
  // 0 to 9
  twoDigits: /^\d{1,2}/,
  // 0 to 99
  threeDigits: /^\d{1,3}/,
  // 0 to 999
  fourDigits: /^\d{1,4}/,
  // 0 to 9999

  anyDigitsSigned: /^-?\d+/,
  singleDigitSigned: /^-?\d/,
  // 0 to 9, -0 to -9
  twoDigitsSigned: /^-?\d{1,2}/,
  // 0 to 99, -0 to -99
  threeDigitsSigned: /^-?\d{1,3}/,
  // 0 to 999, -0 to -999
  fourDigitsSigned: /^-?\d{1,4}/ // 0 to 9999, -0 to -9999
};
var timezonePatterns = {
  basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
  basic: /^([+-])(\d{2})(\d{2})|Z/,
  basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
  extended: /^([+-])(\d{2}):(\d{2})|Z/,
  extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};

function mapValue(parseFnResult, mapFn) {
  if (!parseFnResult) {
    return parseFnResult;
  }
  return {
    value: mapFn(parseFnResult.value),
    rest: parseFnResult.rest
  };
}
function parseNumericPattern(pattern, dateString) {
  var matchResult = dateString.match(pattern);
  if (!matchResult) {
    return null;
  }
  return {
    value: parseInt(matchResult[0], 10),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseTimezonePattern(pattern, dateString) {
  var matchResult = dateString.match(pattern);
  if (!matchResult) {
    return null;
  }

  // Input is 'Z'
  if (matchResult[0] === 'Z') {
    return {
      value: 0,
      rest: dateString.slice(1)
    };
  }
  var sign = matchResult[1] === '+' ? 1 : -1;
  var hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
  var minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
  var seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
  return {
    value: sign * (hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * millisecondsInSecond),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseAnyDigitsSigned(dateString) {
  return parseNumericPattern(numericPatterns.anyDigitsSigned, dateString);
}
function parseNDigits(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigit, dateString);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigits, dateString);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigits, dateString);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigits, dateString);
    default:
      return parseNumericPattern(new RegExp('^\\d{1,' + n + '}'), dateString);
  }
}
function parseNDigitsSigned(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigitSigned, dateString);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigitsSigned, dateString);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigitsSigned, dateString);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigitsSigned, dateString);
    default:
      return parseNumericPattern(new RegExp('^-?\\d{1,' + n + '}'), dateString);
  }
}
function dayPeriodEnumToHours(dayPeriod) {
  switch (dayPeriod) {
    case 'morning':
      return 4;
    case 'evening':
      return 17;
    case 'pm':
    case 'noon':
    case 'afternoon':
      return 12;
    case 'am':
    case 'midnight':
    case 'night':
    default:
      return 0;
  }
}
function normalizeTwoDigitYear(twoDigitYear, currentYear) {
  var isCommonEra = currentYear > 0;
  // Absolute number of the current year:
  // 1 -> 1 AC
  // 0 -> 1 BC
  // -1 -> 2 BC
  var absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
  var result;
  if (absCurrentYear <= 50) {
    result = twoDigitYear || 100;
  } else {
    var rangeEnd = absCurrentYear + 50;
    var rangeEndCentury = Math.floor(rangeEnd / 100) * 100;
    var isPreviousCentury = twoDigitYear >= rangeEnd % 100;
    result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
  }
  return isCommonEra ? result : 1 - result;
}
function isLeapYearIndex(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}

// From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_Patterns
// | Year     |     y | yy |   yyy |  yyyy | yyyyy |
// |----------|-------|----|-------|-------|-------|
// | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
// | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
// | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
// | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
// | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |
var YearParser = /*#__PURE__*/function (_Parser) {
  _inherits(YearParser, _Parser);
  var _super = _createSuper(YearParser);
  function YearParser() {
    var _this;
    _classCallCheck(this, YearParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 130);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['Y', 'R', 'u', 'w', 'I', 'i', 'e', 'c', 't', 'T']);
    return _this;
  }
  _createClass(YearParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      var valueCallback = function valueCallback(year) {
        return {
          year: year,
          isTwoDigitYear: token === 'yy'
        };
      };
      switch (token) {
        case 'y':
          return mapValue(parseNDigits(4, dateString), valueCallback);
        case 'yo':
          return mapValue(match.ordinalNumber(dateString, {
            unit: 'year'
          }), valueCallback);
        default:
          return mapValue(parseNDigits(token.length, dateString), valueCallback);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value.isTwoDigitYear || value.year > 0;
    }
  }, {
    key: "set",
    value: function set(date, flags, value) {
      var currentYear = date.getUTCFullYear();
      if (value.isTwoDigitYear) {
        var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
        date.setUTCFullYear(normalizedTwoDigitYear, 0, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }
      var year = !('era' in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date.setUTCFullYear(year, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return YearParser;
}(Parser);

// Local week-numbering year
var LocalWeekYearParser = /*#__PURE__*/function (_Parser) {
  _inherits(LocalWeekYearParser, _Parser);
  var _super = _createSuper(LocalWeekYearParser);
  function LocalWeekYearParser() {
    var _this;
    _classCallCheck(this, LocalWeekYearParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 130);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['y', 'R', 'u', 'Q', 'q', 'M', 'L', 'I', 'd', 'D', 'i', 't', 'T']);
    return _this;
  }
  _createClass(LocalWeekYearParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      var valueCallback = function valueCallback(year) {
        return {
          year: year,
          isTwoDigitYear: token === 'YY'
        };
      };
      switch (token) {
        case 'Y':
          return mapValue(parseNDigits(4, dateString), valueCallback);
        case 'Yo':
          return mapValue(match.ordinalNumber(dateString, {
            unit: 'year'
          }), valueCallback);
        default:
          return mapValue(parseNDigits(token.length, dateString), valueCallback);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value.isTwoDigitYear || value.year > 0;
    }
  }, {
    key: "set",
    value: function set(date, flags, value, options) {
      var currentYear = getUTCWeekYear(date, options);
      if (value.isTwoDigitYear) {
        var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
        date.setUTCFullYear(normalizedTwoDigitYear, 0, options.firstWeekContainsDate);
        date.setUTCHours(0, 0, 0, 0);
        return startOfUTCWeek(date, options);
      }
      var year = !('era' in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date.setUTCFullYear(year, 0, options.firstWeekContainsDate);
      date.setUTCHours(0, 0, 0, 0);
      return startOfUTCWeek(date, options);
    }
  }]);
  return LocalWeekYearParser;
}(Parser);

var ISOWeekYearParser = /*#__PURE__*/function (_Parser) {
  _inherits(ISOWeekYearParser, _Parser);
  var _super = _createSuper(ISOWeekYearParser);
  function ISOWeekYearParser() {
    var _this;
    _classCallCheck(this, ISOWeekYearParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 130);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['G', 'y', 'Y', 'u', 'Q', 'q', 'M', 'L', 'w', 'd', 'D', 'e', 'c', 't', 'T']);
    return _this;
  }
  _createClass(ISOWeekYearParser, [{
    key: "parse",
    value: function parse(dateString, token) {
      if (token === 'R') {
        return parseNDigitsSigned(4, dateString);
      }
      return parseNDigitsSigned(token.length, dateString);
    }
  }, {
    key: "set",
    value: function set(_date, _flags, value) {
      var firstWeekOfYear = new Date(0);
      firstWeekOfYear.setUTCFullYear(value, 0, 4);
      firstWeekOfYear.setUTCHours(0, 0, 0, 0);
      return startOfUTCISOWeek(firstWeekOfYear);
    }
  }]);
  return ISOWeekYearParser;
}(Parser);

var ExtendedYearParser = /*#__PURE__*/function (_Parser) {
  _inherits(ExtendedYearParser, _Parser);
  var _super = _createSuper(ExtendedYearParser);
  function ExtendedYearParser() {
    var _this;
    _classCallCheck(this, ExtendedYearParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 130);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['G', 'y', 'Y', 'R', 'w', 'I', 'i', 'e', 'c', 't', 'T']);
    return _this;
  }
  _createClass(ExtendedYearParser, [{
    key: "parse",
    value: function parse(dateString, token) {
      if (token === 'u') {
        return parseNDigitsSigned(4, dateString);
      }
      return parseNDigitsSigned(token.length, dateString);
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCFullYear(value, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return ExtendedYearParser;
}(Parser);

var QuarterParser = /*#__PURE__*/function (_Parser) {
  _inherits(QuarterParser, _Parser);
  var _super = _createSuper(QuarterParser);
  function QuarterParser() {
    var _this;
    _classCallCheck(this, QuarterParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 120);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['Y', 'R', 'q', 'M', 'L', 'w', 'I', 'd', 'D', 'i', 'e', 'c', 't', 'T']);
    return _this;
  }
  _createClass(QuarterParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        // 1, 2, 3, 4
        case 'Q':
        case 'QQ':
          // 01, 02, 03, 04
          return parseNDigits(token.length, dateString);
        // 1st, 2nd, 3rd, 4th
        case 'Qo':
          return match.ordinalNumber(dateString, {
            unit: 'quarter'
          });
        // Q1, Q2, Q3, Q4
        case 'QQQ':
          return match.quarter(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.quarter(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // 1, 2, 3, 4 (narrow quarter; could be not numerical)
        case 'QQQQQ':
          return match.quarter(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // 1st quarter, 2nd quarter, ...
        case 'QQQQ':
        default:
          return match.quarter(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.quarter(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.quarter(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 4;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMonth((value - 1) * 3, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return QuarterParser;
}(Parser);

var StandAloneQuarterParser = /*#__PURE__*/function (_Parser) {
  _inherits(StandAloneQuarterParser, _Parser);
  var _super = _createSuper(StandAloneQuarterParser);
  function StandAloneQuarterParser() {
    var _this;
    _classCallCheck(this, StandAloneQuarterParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 120);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['Y', 'R', 'Q', 'M', 'L', 'w', 'I', 'd', 'D', 'i', 'e', 'c', 't', 'T']);
    return _this;
  }
  _createClass(StandAloneQuarterParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        // 1, 2, 3, 4
        case 'q':
        case 'qq':
          // 01, 02, 03, 04
          return parseNDigits(token.length, dateString);
        // 1st, 2nd, 3rd, 4th
        case 'qo':
          return match.ordinalNumber(dateString, {
            unit: 'quarter'
          });
        // Q1, Q2, Q3, Q4
        case 'qqq':
          return match.quarter(dateString, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.quarter(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
        // 1, 2, 3, 4 (narrow quarter; could be not numerical)
        case 'qqqqq':
          return match.quarter(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
        // 1st quarter, 2nd quarter, ...
        case 'qqqq':
        default:
          return match.quarter(dateString, {
            width: 'wide',
            context: 'standalone'
          }) || match.quarter(dateString, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.quarter(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 4;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMonth((value - 1) * 3, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return StandAloneQuarterParser;
}(Parser);

var MonthParser = /*#__PURE__*/function (_Parser) {
  _inherits(MonthParser, _Parser);
  var _super = _createSuper(MonthParser);
  function MonthParser() {
    var _this;
    _classCallCheck(this, MonthParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['Y', 'R', 'q', 'Q', 'L', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']);
    _defineProperty(_assertThisInitialized(_this), "priority", 110);
    return _this;
  }
  _createClass(MonthParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      var valueCallback = function valueCallback(value) {
        return value - 1;
      };
      switch (token) {
        // 1, 2, ..., 12
        case 'M':
          return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback);
        // 01, 02, ..., 12
        case 'MM':
          return mapValue(parseNDigits(2, dateString), valueCallback);
        // 1st, 2nd, ..., 12th
        case 'Mo':
          return mapValue(match.ordinalNumber(dateString, {
            unit: 'month'
          }), valueCallback);
        // Jan, Feb, ..., Dec
        case 'MMM':
          return match.month(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.month(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // J, F, ..., D
        case 'MMMMM':
          return match.month(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // January, February, ..., December
        case 'MMMM':
        default:
          return match.month(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.month(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.month(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 11;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMonth(value, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return MonthParser;
}(Parser);

var StandAloneMonthParser = /*#__PURE__*/function (_Parser) {
  _inherits(StandAloneMonthParser, _Parser);
  var _super = _createSuper(StandAloneMonthParser);
  function StandAloneMonthParser() {
    var _this;
    _classCallCheck(this, StandAloneMonthParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 110);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['Y', 'R', 'q', 'Q', 'M', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']);
    return _this;
  }
  _createClass(StandAloneMonthParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      var valueCallback = function valueCallback(value) {
        return value - 1;
      };
      switch (token) {
        // 1, 2, ..., 12
        case 'L':
          return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback);
        // 01, 02, ..., 12
        case 'LL':
          return mapValue(parseNDigits(2, dateString), valueCallback);
        // 1st, 2nd, ..., 12th
        case 'Lo':
          return mapValue(match.ordinalNumber(dateString, {
            unit: 'month'
          }), valueCallback);
        // Jan, Feb, ..., Dec
        case 'LLL':
          return match.month(dateString, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.month(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
        // J, F, ..., D
        case 'LLLLL':
          return match.month(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
        // January, February, ..., December
        case 'LLLL':
        default:
          return match.month(dateString, {
            width: 'wide',
            context: 'standalone'
          }) || match.month(dateString, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.month(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 11;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMonth(value, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return StandAloneMonthParser;
}(Parser);

function setUTCWeek(dirtyDate, dirtyWeek, options) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var week = toInteger(dirtyWeek);
  var diff = getUTCWeek(date, options) - week;
  date.setUTCDate(date.getUTCDate() - diff * 7);
  return date;
}

var LocalWeekParser = /*#__PURE__*/function (_Parser) {
  _inherits(LocalWeekParser, _Parser);
  var _super = _createSuper(LocalWeekParser);
  function LocalWeekParser() {
    var _this;
    _classCallCheck(this, LocalWeekParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 100);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'i', 't', 'T']);
    return _this;
  }
  _createClass(LocalWeekParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'w':
          return parseNumericPattern(numericPatterns.week, dateString);
        case 'wo':
          return match.ordinalNumber(dateString, {
            unit: 'week'
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 53;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value, options) {
      return startOfUTCWeek(setUTCWeek(date, value, options), options);
    }
  }]);
  return LocalWeekParser;
}(Parser);

function setUTCISOWeek(dirtyDate, dirtyISOWeek) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var isoWeek = toInteger(dirtyISOWeek);
  var diff = getUTCISOWeek(date) - isoWeek;
  date.setUTCDate(date.getUTCDate() - diff * 7);
  return date;
}

var ISOWeekParser = /*#__PURE__*/function (_Parser) {
  _inherits(ISOWeekParser, _Parser);
  var _super = _createSuper(ISOWeekParser);
  function ISOWeekParser() {
    var _this;
    _classCallCheck(this, ISOWeekParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 100);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['y', 'Y', 'u', 'q', 'Q', 'M', 'L', 'w', 'd', 'D', 'e', 'c', 't', 'T']);
    return _this;
  }
  _createClass(ISOWeekParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'I':
          return parseNumericPattern(numericPatterns.week, dateString);
        case 'Io':
          return match.ordinalNumber(dateString, {
            unit: 'week'
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 53;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      return startOfUTCISOWeek(setUTCISOWeek(date, value));
    }
  }]);
  return ISOWeekParser;
}(Parser);

var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

// Day of the month
var DateParser = /*#__PURE__*/function (_Parser) {
  _inherits(DateParser, _Parser);
  var _super = _createSuper(DateParser);
  function DateParser() {
    var _this;
    _classCallCheck(this, DateParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 90);
    _defineProperty(_assertThisInitialized(_this), "subPriority", 1);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['Y', 'R', 'q', 'Q', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']);
    return _this;
  }
  _createClass(DateParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'd':
          return parseNumericPattern(numericPatterns.date, dateString);
        case 'do':
          return match.ordinalNumber(dateString, {
            unit: 'date'
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(date, value) {
      var year = date.getUTCFullYear();
      var isLeapYear = isLeapYearIndex(year);
      var month = date.getUTCMonth();
      if (isLeapYear) {
        return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
      } else {
        return value >= 1 && value <= DAYS_IN_MONTH[month];
      }
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCDate(value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return DateParser;
}(Parser);

var DayOfYearParser = /*#__PURE__*/function (_Parser) {
  _inherits(DayOfYearParser, _Parser);
  var _super = _createSuper(DayOfYearParser);
  function DayOfYearParser() {
    var _this;
    _classCallCheck(this, DayOfYearParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 90);
    _defineProperty(_assertThisInitialized(_this), "subpriority", 1);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['Y', 'R', 'q', 'Q', 'M', 'L', 'w', 'I', 'd', 'E', 'i', 'e', 'c', 't', 'T']);
    return _this;
  }
  _createClass(DayOfYearParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'D':
        case 'DD':
          return parseNumericPattern(numericPatterns.dayOfYear, dateString);
        case 'Do':
          return match.ordinalNumber(dateString, {
            unit: 'date'
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(date, value) {
      var year = date.getUTCFullYear();
      var isLeapYear = isLeapYearIndex(year);
      if (isLeapYear) {
        return value >= 1 && value <= 366;
      } else {
        return value >= 1 && value <= 365;
      }
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMonth(0, value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return DayOfYearParser;
}(Parser);

function setUTCDay(dirtyDate, dirtyDay, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(2, arguments);
  var defaultOptions = getDefaultOptions();
  var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);

  // Test if weekStartsOn is between 0 and 6 _and_ is not NaN
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }
  var date = toDate(dirtyDate);
  var day = toInteger(dirtyDay);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}

var DayParser = /*#__PURE__*/function (_Parser) {
  _inherits(DayParser, _Parser);
  var _super = _createSuper(DayParser);
  function DayParser() {
    var _this;
    _classCallCheck(this, DayParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 90);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['D', 'i', 'e', 'c', 't', 'T']);
    return _this;
  }
  _createClass(DayParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        // Tue
        case 'E':
        case 'EE':
        case 'EEE':
          return match.day(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // T
        case 'EEEEE':
          return match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tu
        case 'EEEEEE':
          return match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tuesday
        case 'EEEE':
        default:
          return match.day(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 6;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return DayParser;
}(Parser);

var LocalDayParser = /*#__PURE__*/function (_Parser) {
  _inherits(LocalDayParser, _Parser);
  var _super = _createSuper(LocalDayParser);
  function LocalDayParser() {
    var _this;
    _classCallCheck(this, LocalDayParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 90);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'E', 'i', 'c', 't', 'T']);
    return _this;
  }
  _createClass(LocalDayParser, [{
    key: "parse",
    value: function parse(dateString, token, match, options) {
      var valueCallback = function valueCallback(value) {
        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
      };
      switch (token) {
        // 3
        case 'e':
        case 'ee':
          // 03
          return mapValue(parseNDigits(token.length, dateString), valueCallback);
        // 3rd
        case 'eo':
          return mapValue(match.ordinalNumber(dateString, {
            unit: 'day'
          }), valueCallback);
        // Tue
        case 'eee':
          return match.day(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // T
        case 'eeeee':
          return match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tu
        case 'eeeeee':
          return match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tuesday
        case 'eeee':
        default:
          return match.day(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 6;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return LocalDayParser;
}(Parser);

var StandAloneLocalDayParser = /*#__PURE__*/function (_Parser) {
  _inherits(StandAloneLocalDayParser, _Parser);
  var _super = _createSuper(StandAloneLocalDayParser);
  function StandAloneLocalDayParser() {
    var _this;
    _classCallCheck(this, StandAloneLocalDayParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 90);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'E', 'i', 'e', 't', 'T']);
    return _this;
  }
  _createClass(StandAloneLocalDayParser, [{
    key: "parse",
    value: function parse(dateString, token, match, options) {
      var valueCallback = function valueCallback(value) {
        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
      };
      switch (token) {
        // 3
        case 'c':
        case 'cc':
          // 03
          return mapValue(parseNDigits(token.length, dateString), valueCallback);
        // 3rd
        case 'co':
          return mapValue(match.ordinalNumber(dateString, {
            unit: 'day'
          }), valueCallback);
        // Tue
        case 'ccc':
          return match.day(dateString, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.day(dateString, {
            width: 'short',
            context: 'standalone'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
        // T
        case 'ccccc':
          return match.day(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
        // Tu
        case 'cccccc':
          return match.day(dateString, {
            width: 'short',
            context: 'standalone'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
        // Tuesday
        case 'cccc':
        default:
          return match.day(dateString, {
            width: 'wide',
            context: 'standalone'
          }) || match.day(dateString, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.day(dateString, {
            width: 'short',
            context: 'standalone'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 6;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return StandAloneLocalDayParser;
}(Parser);

function setUTCISODay(dirtyDate, dirtyDay) {
  requiredArgs(2, arguments);
  var day = toInteger(dirtyDay);
  if (day % 7 === 0) {
    day = day - 7;
  }
  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}

var ISODayParser = /*#__PURE__*/function (_Parser) {
  _inherits(ISODayParser, _Parser);
  var _super = _createSuper(ISODayParser);
  function ISODayParser() {
    var _this;
    _classCallCheck(this, ISODayParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 90);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['y', 'Y', 'u', 'q', 'Q', 'M', 'L', 'w', 'd', 'D', 'E', 'e', 'c', 't', 'T']);
    return _this;
  }
  _createClass(ISODayParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      var valueCallback = function valueCallback(value) {
        if (value === 0) {
          return 7;
        }
        return value;
      };
      switch (token) {
        // 2
        case 'i':
        case 'ii':
          // 02
          return parseNDigits(token.length, dateString);
        // 2nd
        case 'io':
          return match.ordinalNumber(dateString, {
            unit: 'day'
          });
        // Tue
        case 'iii':
          return mapValue(match.day(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          }), valueCallback);
        // T
        case 'iiiii':
          return mapValue(match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          }), valueCallback);
        // Tu
        case 'iiiiii':
          return mapValue(match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          }), valueCallback);
        // Tuesday
        case 'iiii':
        default:
          return mapValue(match.day(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          }), valueCallback);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 7;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date = setUTCISODay(date, value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return ISODayParser;
}(Parser);

var AMPMParser = /*#__PURE__*/function (_Parser) {
  _inherits(AMPMParser, _Parser);
  var _super = _createSuper(AMPMParser);
  function AMPMParser() {
    var _this;
    _classCallCheck(this, AMPMParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 80);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['b', 'B', 'H', 'k', 't', 'T']);
    return _this;
  }
  _createClass(AMPMParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'a':
        case 'aa':
        case 'aaa':
          return match.dayPeriod(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        case 'aaaaa':
          return match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        case 'aaaa':
        default:
          return match.dayPeriod(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    }
  }]);
  return AMPMParser;
}(Parser);

var AMPMMidnightParser = /*#__PURE__*/function (_Parser) {
  _inherits(AMPMMidnightParser, _Parser);
  var _super = _createSuper(AMPMMidnightParser);
  function AMPMMidnightParser() {
    var _this;
    _classCallCheck(this, AMPMMidnightParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 80);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['a', 'B', 'H', 'k', 't', 'T']);
    return _this;
  }
  _createClass(AMPMMidnightParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'b':
        case 'bb':
        case 'bbb':
          return match.dayPeriod(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        case 'bbbbb':
          return match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        case 'bbbb':
        default:
          return match.dayPeriod(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    }
  }]);
  return AMPMMidnightParser;
}(Parser);

var DayPeriodParser = /*#__PURE__*/function (_Parser) {
  _inherits(DayPeriodParser, _Parser);
  var _super = _createSuper(DayPeriodParser);
  function DayPeriodParser() {
    var _this;
    _classCallCheck(this, DayPeriodParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 80);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['a', 'b', 't', 'T']);
    return _this;
  }
  _createClass(DayPeriodParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'B':
        case 'BB':
        case 'BBB':
          return match.dayPeriod(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        case 'BBBBB':
          return match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        case 'BBBB':
        default:
          return match.dayPeriod(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    }
  }]);
  return DayPeriodParser;
}(Parser);

var Hour1to12Parser = /*#__PURE__*/function (_Parser) {
  _inherits(Hour1to12Parser, _Parser);
  var _super = _createSuper(Hour1to12Parser);
  function Hour1to12Parser() {
    var _this;
    _classCallCheck(this, Hour1to12Parser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 70);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['H', 'K', 'k', 't', 'T']);
    return _this;
  }
  _createClass(Hour1to12Parser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'h':
          return parseNumericPattern(numericPatterns.hour12h, dateString);
        case 'ho':
          return match.ordinalNumber(dateString, {
            unit: 'hour'
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 12;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      var isPM = date.getUTCHours() >= 12;
      if (isPM && value < 12) {
        date.setUTCHours(value + 12, 0, 0, 0);
      } else if (!isPM && value === 12) {
        date.setUTCHours(0, 0, 0, 0);
      } else {
        date.setUTCHours(value, 0, 0, 0);
      }
      return date;
    }
  }]);
  return Hour1to12Parser;
}(Parser);

var Hour0to23Parser = /*#__PURE__*/function (_Parser) {
  _inherits(Hour0to23Parser, _Parser);
  var _super = _createSuper(Hour0to23Parser);
  function Hour0to23Parser() {
    var _this;
    _classCallCheck(this, Hour0to23Parser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 70);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['a', 'b', 'h', 'K', 'k', 't', 'T']);
    return _this;
  }
  _createClass(Hour0to23Parser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'H':
          return parseNumericPattern(numericPatterns.hour23h, dateString);
        case 'Ho':
          return match.ordinalNumber(dateString, {
            unit: 'hour'
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 23;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCHours(value, 0, 0, 0);
      return date;
    }
  }]);
  return Hour0to23Parser;
}(Parser);

var Hour0To11Parser = /*#__PURE__*/function (_Parser) {
  _inherits(Hour0To11Parser, _Parser);
  var _super = _createSuper(Hour0To11Parser);
  function Hour0To11Parser() {
    var _this;
    _classCallCheck(this, Hour0To11Parser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 70);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['h', 'H', 'k', 't', 'T']);
    return _this;
  }
  _createClass(Hour0To11Parser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'K':
          return parseNumericPattern(numericPatterns.hour11h, dateString);
        case 'Ko':
          return match.ordinalNumber(dateString, {
            unit: 'hour'
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 11;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      var isPM = date.getUTCHours() >= 12;
      if (isPM && value < 12) {
        date.setUTCHours(value + 12, 0, 0, 0);
      } else {
        date.setUTCHours(value, 0, 0, 0);
      }
      return date;
    }
  }]);
  return Hour0To11Parser;
}(Parser);

var Hour1To24Parser = /*#__PURE__*/function (_Parser) {
  _inherits(Hour1To24Parser, _Parser);
  var _super = _createSuper(Hour1To24Parser);
  function Hour1To24Parser() {
    var _this;
    _classCallCheck(this, Hour1To24Parser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 70);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['a', 'b', 'h', 'H', 'K', 't', 'T']);
    return _this;
  }
  _createClass(Hour1To24Parser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'k':
          return parseNumericPattern(numericPatterns.hour24h, dateString);
        case 'ko':
          return match.ordinalNumber(dateString, {
            unit: 'hour'
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 24;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      var hours = value <= 24 ? value % 24 : value;
      date.setUTCHours(hours, 0, 0, 0);
      return date;
    }
  }]);
  return Hour1To24Parser;
}(Parser);

var MinuteParser = /*#__PURE__*/function (_Parser) {
  _inherits(MinuteParser, _Parser);
  var _super = _createSuper(MinuteParser);
  function MinuteParser() {
    var _this;
    _classCallCheck(this, MinuteParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 60);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['t', 'T']);
    return _this;
  }
  _createClass(MinuteParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'm':
          return parseNumericPattern(numericPatterns.minute, dateString);
        case 'mo':
          return match.ordinalNumber(dateString, {
            unit: 'minute'
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 59;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMinutes(value, 0, 0);
      return date;
    }
  }]);
  return MinuteParser;
}(Parser);

var SecondParser = /*#__PURE__*/function (_Parser) {
  _inherits(SecondParser, _Parser);
  var _super = _createSuper(SecondParser);
  function SecondParser() {
    var _this;
    _classCallCheck(this, SecondParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 50);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['t', 'T']);
    return _this;
  }
  _createClass(SecondParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 's':
          return parseNumericPattern(numericPatterns.second, dateString);
        case 'so':
          return match.ordinalNumber(dateString, {
            unit: 'second'
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 59;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCSeconds(value, 0);
      return date;
    }
  }]);
  return SecondParser;
}(Parser);

var FractionOfSecondParser = /*#__PURE__*/function (_Parser) {
  _inherits(FractionOfSecondParser, _Parser);
  var _super = _createSuper(FractionOfSecondParser);
  function FractionOfSecondParser() {
    var _this;
    _classCallCheck(this, FractionOfSecondParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 30);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['t', 'T']);
    return _this;
  }
  _createClass(FractionOfSecondParser, [{
    key: "parse",
    value: function parse(dateString, token) {
      var valueCallback = function valueCallback(value) {
        return Math.floor(value * Math.pow(10, -token.length + 3));
      };
      return mapValue(parseNDigits(token.length, dateString), valueCallback);
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMilliseconds(value);
      return date;
    }
  }]);
  return FractionOfSecondParser;
}(Parser);

var ISOTimezoneWithZParser = /*#__PURE__*/function (_Parser) {
  _inherits(ISOTimezoneWithZParser, _Parser);
  var _super = _createSuper(ISOTimezoneWithZParser);
  function ISOTimezoneWithZParser() {
    var _this;
    _classCallCheck(this, ISOTimezoneWithZParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 10);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['t', 'T', 'x']);
    return _this;
  }
  _createClass(ISOTimezoneWithZParser, [{
    key: "parse",
    value: function parse(dateString, token) {
      switch (token) {
        case 'X':
          return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);
        case 'XX':
          return parseTimezonePattern(timezonePatterns.basic, dateString);
        case 'XXXX':
          return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);
        case 'XXXXX':
          return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);
        case 'XXX':
        default:
          return parseTimezonePattern(timezonePatterns.extended, dateString);
      }
    }
  }, {
    key: "set",
    value: function set(date, flags, value) {
      if (flags.timestampIsSet) {
        return date;
      }
      return new Date(date.getTime() - value);
    }
  }]);
  return ISOTimezoneWithZParser;
}(Parser);

var ISOTimezoneParser = /*#__PURE__*/function (_Parser) {
  _inherits(ISOTimezoneParser, _Parser);
  var _super = _createSuper(ISOTimezoneParser);
  function ISOTimezoneParser() {
    var _this;
    _classCallCheck(this, ISOTimezoneParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 10);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['t', 'T', 'X']);
    return _this;
  }
  _createClass(ISOTimezoneParser, [{
    key: "parse",
    value: function parse(dateString, token) {
      switch (token) {
        case 'x':
          return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);
        case 'xx':
          return parseTimezonePattern(timezonePatterns.basic, dateString);
        case 'xxxx':
          return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);
        case 'xxxxx':
          return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);
        case 'xxx':
        default:
          return parseTimezonePattern(timezonePatterns.extended, dateString);
      }
    }
  }, {
    key: "set",
    value: function set(date, flags, value) {
      if (flags.timestampIsSet) {
        return date;
      }
      return new Date(date.getTime() - value);
    }
  }]);
  return ISOTimezoneParser;
}(Parser);

var TimestampSecondsParser = /*#__PURE__*/function (_Parser) {
  _inherits(TimestampSecondsParser, _Parser);
  var _super = _createSuper(TimestampSecondsParser);
  function TimestampSecondsParser() {
    var _this;
    _classCallCheck(this, TimestampSecondsParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 40);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", '*');
    return _this;
  }
  _createClass(TimestampSecondsParser, [{
    key: "parse",
    value: function parse(dateString) {
      return parseAnyDigitsSigned(dateString);
    }
  }, {
    key: "set",
    value: function set(_date, _flags, value) {
      return [new Date(value * 1000), {
        timestampIsSet: true
      }];
    }
  }]);
  return TimestampSecondsParser;
}(Parser);

var TimestampMillisecondsParser = /*#__PURE__*/function (_Parser) {
  _inherits(TimestampMillisecondsParser, _Parser);
  var _super = _createSuper(TimestampMillisecondsParser);
  function TimestampMillisecondsParser() {
    var _this;
    _classCallCheck(this, TimestampMillisecondsParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 20);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", '*');
    return _this;
  }
  _createClass(TimestampMillisecondsParser, [{
    key: "parse",
    value: function parse(dateString) {
      return parseAnyDigitsSigned(dateString);
    }
  }, {
    key: "set",
    value: function set(_date, _flags, value) {
      return [new Date(value), {
        timestampIsSet: true
      }];
    }
  }]);
  return TimestampMillisecondsParser;
}(Parser);

/*
 * |     | Unit                           |     | Unit                           |
 * |-----|--------------------------------|-----|--------------------------------|
 * |  a  | AM, PM                         |  A* | Milliseconds in day            |
 * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
 * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
 * |  d  | Day of month                   |  D  | Day of year                    |
 * |  e  | Local day of week              |  E  | Day of week                    |
 * |  f  |                                |  F* | Day of week in month           |
 * |  g* | Modified Julian day            |  G  | Era                            |
 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
 * |  i! | ISO day of week                |  I! | ISO week of year               |
 * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
 * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
 * |  l* | (deprecated)                   |  L  | Stand-alone month              |
 * |  m  | Minute                         |  M  | Month                          |
 * |  n  |                                |  N  |                                |
 * |  o! | Ordinal number modifier        |  O* | Timezone (GMT)                 |
 * |  p  |                                |  P  |                                |
 * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
 * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
 * |  s  | Second                         |  S  | Fraction of second             |
 * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
 * |  u  | Extended year                  |  U* | Cyclic year                    |
 * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
 * |  w  | Local week of year             |  W* | Week of month                  |
 * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
 * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
 * |  z* | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
 *
 * Letters marked by * are not implemented but reserved by Unicode standard.
 *
 * Letters marked by ! are non-standard, but implemented by date-fns:
 * - `o` modifies the previous token to turn it into an ordinal (see `parse` docs)
 * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
 *   i.e. 7 for Sunday, 1 for Monday, etc.
 * - `I` is ISO week of year, as opposed to `w` which is local week of year.
 * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
 *   `R` is supposed to be used in conjunction with `I` and `i`
 *   for universal ISO week-numbering date, whereas
 *   `Y` is supposed to be used in conjunction with `w` and `e`
 *   for week-numbering date specific to the locale.
 */
var parsers = {
  G: new EraParser(),
  y: new YearParser(),
  Y: new LocalWeekYearParser(),
  R: new ISOWeekYearParser(),
  u: new ExtendedYearParser(),
  Q: new QuarterParser(),
  q: new StandAloneQuarterParser(),
  M: new MonthParser(),
  L: new StandAloneMonthParser(),
  w: new LocalWeekParser(),
  I: new ISOWeekParser(),
  d: new DateParser(),
  D: new DayOfYearParser(),
  E: new DayParser(),
  e: new LocalDayParser(),
  c: new StandAloneLocalDayParser(),
  i: new ISODayParser(),
  a: new AMPMParser(),
  b: new AMPMMidnightParser(),
  B: new DayPeriodParser(),
  h: new Hour1to12Parser(),
  H: new Hour0to23Parser(),
  K: new Hour0To11Parser(),
  k: new Hour1To24Parser(),
  m: new MinuteParser(),
  s: new SecondParser(),
  S: new FractionOfSecondParser(),
  X: new ISOTimezoneWithZParser(),
  x: new ISOTimezoneParser(),
  t: new TimestampSecondsParser(),
  T: new TimestampMillisecondsParser()
};

// - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
//   (one of the certain letters followed by `o`)
// - (\w)\1* matches any sequences of the same letter
// - '' matches two quote characters in a row
// - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
//   except a single quote symbol, which ends the sequence.
//   Two quote characters do not end the sequence.
//   If there is no matching single quote
//   then the sequence will continue until the end of the string.
// - . matches any single character unmatched by previous parts of the RegExps
var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;

// This RegExp catches symbols escaped by quotes, and also
// sequences of symbols P, p, and the combinations like `PPPPPPPppppp`
var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'([^]*?)'?$/;
var doubleQuoteRegExp = /''/g;
var notWhitespaceRegExp = /\S/;
var unescapedLatinCharacterRegExp = /[a-zA-Z]/;

/**
 * @name parse
 * @category Common Helpers
 * @summary Parse the date.
 *
 * @description
 * Return the date parsed from string using the given format string.
 *
 * > â ï¸ Please note that the `format` tokens differ from Moment.js and other libraries.
 * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * The characters in the format string wrapped between two single quotes characters (') are escaped.
 * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
 *
 * Format of the format string is based on Unicode Technical Standard #35:
 * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
 * with a few additions (see note 5 below the table).
 *
 * Not all tokens are compatible. Combinations that don't make sense or could lead to bugs are prohibited
 * and will throw `RangeError`. For example usage of 24-hour format token with AM/PM token will throw an exception:
 *
 * ```javascript
 * parse('23 AM', 'HH a', new Date())
 * //=> RangeError: The format string mustn't contain `HH` and `a` at the same time
 * ```
 *
 * See the compatibility table: https://docs.google.com/spreadsheets/d/e/2PACX-1vQOPU3xUhplll6dyoMmVUXHKl_8CRDs6_ueLmex3SoqwhuolkuN3O05l4rqx5h1dKX8eb46Ul-CCSrq/pubhtml?gid=0&single=true
 *
 * Accepted format string patterns:
 * | Unit                            |Prior| Pattern | Result examples                   | Notes |
 * |---------------------------------|-----|---------|-----------------------------------|-------|
 * | Era                             | 140 | G..GGG  | AD, BC                            |       |
 * |                                 |     | GGGG    | Anno Domini, Before Christ        | 2     |
 * |                                 |     | GGGGG   | A, B                              |       |
 * | Calendar year                   | 130 | y       | 44, 1, 1900, 2017, 9999           | 4     |
 * |                                 |     | yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
 * |                                 |     | yy      | 44, 01, 00, 17                    | 4     |
 * |                                 |     | yyy     | 044, 001, 123, 999                | 4     |
 * |                                 |     | yyyy    | 0044, 0001, 1900, 2017            | 4     |
 * |                                 |     | yyyyy   | ...                               | 2,4   |
 * | Local week-numbering year       | 130 | Y       | 44, 1, 1900, 2017, 9000           | 4     |
 * |                                 |     | Yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
 * |                                 |     | YY      | 44, 01, 00, 17                    | 4,6   |
 * |                                 |     | YYY     | 044, 001, 123, 999                | 4     |
 * |                                 |     | YYYY    | 0044, 0001, 1900, 2017            | 4,6   |
 * |                                 |     | YYYYY   | ...                               | 2,4   |
 * | ISO week-numbering year         | 130 | R       | -43, 1, 1900, 2017, 9999, -9999   | 4,5   |
 * |                                 |     | RR      | -43, 01, 00, 17                   | 4,5   |
 * |                                 |     | RRR     | -043, 001, 123, 999, -999         | 4,5   |
 * |                                 |     | RRRR    | -0043, 0001, 2017, 9999, -9999    | 4,5   |
 * |                                 |     | RRRRR   | ...                               | 2,4,5 |
 * | Extended year                   | 130 | u       | -43, 1, 1900, 2017, 9999, -999    | 4     |
 * |                                 |     | uu      | -43, 01, 99, -99                  | 4     |
 * |                                 |     | uuu     | -043, 001, 123, 999, -999         | 4     |
 * |                                 |     | uuuu    | -0043, 0001, 2017, 9999, -9999    | 4     |
 * |                                 |     | uuuuu   | ...                               | 2,4   |
 * | Quarter (formatting)            | 120 | Q       | 1, 2, 3, 4                        |       |
 * |                                 |     | Qo      | 1st, 2nd, 3rd, 4th                | 5     |
 * |                                 |     | QQ      | 01, 02, 03, 04                    |       |
 * |                                 |     | QQQ     | Q1, Q2, Q3, Q4                    |       |
 * |                                 |     | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 |     | QQQQQ   | 1, 2, 3, 4                        | 4     |
 * | Quarter (stand-alone)           | 120 | q       | 1, 2, 3, 4                        |       |
 * |                                 |     | qo      | 1st, 2nd, 3rd, 4th                | 5     |
 * |                                 |     | qq      | 01, 02, 03, 04                    |       |
 * |                                 |     | qqq     | Q1, Q2, Q3, Q4                    |       |
 * |                                 |     | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 |     | qqqqq   | 1, 2, 3, 4                        | 3     |
 * | Month (formatting)              | 110 | M       | 1, 2, ..., 12                     |       |
 * |                                 |     | Mo      | 1st, 2nd, ..., 12th               | 5     |
 * |                                 |     | MM      | 01, 02, ..., 12                   |       |
 * |                                 |     | MMM     | Jan, Feb, ..., Dec                |       |
 * |                                 |     | MMMM    | January, February, ..., December  | 2     |
 * |                                 |     | MMMMM   | J, F, ..., D                      |       |
 * | Month (stand-alone)             | 110 | L       | 1, 2, ..., 12                     |       |
 * |                                 |     | Lo      | 1st, 2nd, ..., 12th               | 5     |
 * |                                 |     | LL      | 01, 02, ..., 12                   |       |
 * |                                 |     | LLL     | Jan, Feb, ..., Dec                |       |
 * |                                 |     | LLLL    | January, February, ..., December  | 2     |
 * |                                 |     | LLLLL   | J, F, ..., D                      |       |
 * | Local week of year              | 100 | w       | 1, 2, ..., 53                     |       |
 * |                                 |     | wo      | 1st, 2nd, ..., 53th               | 5     |
 * |                                 |     | ww      | 01, 02, ..., 53                   |       |
 * | ISO week of year                | 100 | I       | 1, 2, ..., 53                     | 5     |
 * |                                 |     | Io      | 1st, 2nd, ..., 53th               | 5     |
 * |                                 |     | II      | 01, 02, ..., 53                   | 5     |
 * | Day of month                    |  90 | d       | 1, 2, ..., 31                     |       |
 * |                                 |     | do      | 1st, 2nd, ..., 31st               | 5     |
 * |                                 |     | dd      | 01, 02, ..., 31                   |       |
 * | Day of year                     |  90 | D       | 1, 2, ..., 365, 366               | 7     |
 * |                                 |     | Do      | 1st, 2nd, ..., 365th, 366th       | 5     |
 * |                                 |     | DD      | 01, 02, ..., 365, 366             | 7     |
 * |                                 |     | DDD     | 001, 002, ..., 365, 366           |       |
 * |                                 |     | DDDD    | ...                               | 2     |
 * | Day of week (formatting)        |  90 | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 |     | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | EEEEE   | M, T, W, T, F, S, S               |       |
 * |                                 |     | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | ISO day of week (formatting)    |  90 | i       | 1, 2, 3, ..., 7                   | 5     |
 * |                                 |     | io      | 1st, 2nd, ..., 7th                | 5     |
 * |                                 |     | ii      | 01, 02, ..., 07                   | 5     |
 * |                                 |     | iii     | Mon, Tue, Wed, ..., Sun           | 5     |
 * |                                 |     | iiii    | Monday, Tuesday, ..., Sunday      | 2,5   |
 * |                                 |     | iiiii   | M, T, W, T, F, S, S               | 5     |
 * |                                 |     | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 5     |
 * | Local day of week (formatting)  |  90 | e       | 2, 3, 4, ..., 1                   |       |
 * |                                 |     | eo      | 2nd, 3rd, ..., 1st                | 5     |
 * |                                 |     | ee      | 02, 03, ..., 01                   |       |
 * |                                 |     | eee     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 |     | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | eeeee   | M, T, W, T, F, S, S               |       |
 * |                                 |     | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | Local day of week (stand-alone) |  90 | c       | 2, 3, 4, ..., 1                   |       |
 * |                                 |     | co      | 2nd, 3rd, ..., 1st                | 5     |
 * |                                 |     | cc      | 02, 03, ..., 01                   |       |
 * |                                 |     | ccc     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 |     | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | ccccc   | M, T, W, T, F, S, S               |       |
 * |                                 |     | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | AM, PM                          |  80 | a..aaa  | AM, PM                            |       |
 * |                                 |     | aaaa    | a.m., p.m.                        | 2     |
 * |                                 |     | aaaaa   | a, p                              |       |
 * | AM, PM, noon, midnight          |  80 | b..bbb  | AM, PM, noon, midnight            |       |
 * |                                 |     | bbbb    | a.m., p.m., noon, midnight        | 2     |
 * |                                 |     | bbbbb   | a, p, n, mi                       |       |
 * | Flexible day period             |  80 | B..BBB  | at night, in the morning, ...     |       |
 * |                                 |     | BBBB    | at night, in the morning, ...     | 2     |
 * |                                 |     | BBBBB   | at night, in the morning, ...     |       |
 * | Hour [1-12]                     |  70 | h       | 1, 2, ..., 11, 12                 |       |
 * |                                 |     | ho      | 1st, 2nd, ..., 11th, 12th         | 5     |
 * |                                 |     | hh      | 01, 02, ..., 11, 12               |       |
 * | Hour [0-23]                     |  70 | H       | 0, 1, 2, ..., 23                  |       |
 * |                                 |     | Ho      | 0th, 1st, 2nd, ..., 23rd          | 5     |
 * |                                 |     | HH      | 00, 01, 02, ..., 23               |       |
 * | Hour [0-11]                     |  70 | K       | 1, 2, ..., 11, 0                  |       |
 * |                                 |     | Ko      | 1st, 2nd, ..., 11th, 0th          | 5     |
 * |                                 |     | KK      | 01, 02, ..., 11, 00               |       |
 * | Hour [1-24]                     |  70 | k       | 24, 1, 2, ..., 23                 |       |
 * |                                 |     | ko      | 24th, 1st, 2nd, ..., 23rd         | 5     |
 * |                                 |     | kk      | 24, 01, 02, ..., 23               |       |
 * | Minute                          |  60 | m       | 0, 1, ..., 59                     |       |
 * |                                 |     | mo      | 0th, 1st, ..., 59th               | 5     |
 * |                                 |     | mm      | 00, 01, ..., 59                   |       |
 * | Second                          |  50 | s       | 0, 1, ..., 59                     |       |
 * |                                 |     | so      | 0th, 1st, ..., 59th               | 5     |
 * |                                 |     | ss      | 00, 01, ..., 59                   |       |
 * | Seconds timestamp               |  40 | t       | 512969520                         |       |
 * |                                 |     | tt      | ...                               | 2     |
 * | Fraction of second              |  30 | S       | 0, 1, ..., 9                      |       |
 * |                                 |     | SS      | 00, 01, ..., 99                   |       |
 * |                                 |     | SSS     | 000, 001, ..., 999                |       |
 * |                                 |     | SSSS    | ...                               | 2     |
 * | Milliseconds timestamp          |  20 | T       | 512969520900                      |       |
 * |                                 |     | TT      | ...                               | 2     |
 * | Timezone (ISO-8601 w/ Z)        |  10 | X       | -08, +0530, Z                     |       |
 * |                                 |     | XX      | -0800, +0530, Z                   |       |
 * |                                 |     | XXX     | -08:00, +05:30, Z                 |       |
 * |                                 |     | XXXX    | -0800, +0530, Z, +123456          | 2     |
 * |                                 |     | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
 * | Timezone (ISO-8601 w/o Z)       |  10 | x       | -08, +0530, +00                   |       |
 * |                                 |     | xx      | -0800, +0530, +0000               |       |
 * |                                 |     | xxx     | -08:00, +05:30, +00:00            | 2     |
 * |                                 |     | xxxx    | -0800, +0530, +0000, +123456      |       |
 * |                                 |     | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
 * | Long localized date             |  NA | P       | 05/29/1453                        | 5,8   |
 * |                                 |     | PP      | May 29, 1453                      |       |
 * |                                 |     | PPP     | May 29th, 1453                    |       |
 * |                                 |     | PPPP    | Sunday, May 29th, 1453            | 2,5,8 |
 * | Long localized time             |  NA | p       | 12:00 AM                          | 5,8   |
 * |                                 |     | pp      | 12:00:00 AM                       |       |
 * | Combination of date and time    |  NA | Pp      | 05/29/1453, 12:00 AM              |       |
 * |                                 |     | PPpp    | May 29, 1453, 12:00:00 AM         |       |
 * |                                 |     | PPPpp   | May 29th, 1453 at ...             |       |
 * |                                 |     | PPPPpp  | Sunday, May 29th, 1453 at ...     | 2,5,8 |
 * Notes:
 * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
 *    are the same as "stand-alone" units, but are different in some languages.
 *    "Formatting" units are declined according to the rules of the language
 *    in the context of a date. "Stand-alone" units are always nominative singular.
 *    In `format` function, they will produce different result:
 *
 *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
 *
 *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
 *
 *    `parse` will try to match both formatting and stand-alone units interchangably.
 *
 * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
 *    the single quote characters (see below).
 *    If the sequence is longer than listed in table:
 *    - for numerical units (`yyyyyyyy`) `parse` will try to match a number
 *      as wide as the sequence
 *    - for text units (`MMMMMMMM`) `parse` will try to match the widest variation of the unit.
 *      These variations are marked with "2" in the last column of the table.
 *
 * 3. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
 *    These tokens represent the shortest form of the quarter.
 *
 * 4. The main difference between `y` and `u` patterns are B.C. years:
 *
 *    | Year | `y` | `u` |
 *    |------|-----|-----|
 *    | AC 1 |   1 |   1 |
 *    | BC 1 |   1 |   0 |
 *    | BC 2 |   2 |  -1 |
 *
 *    Also `yy` will try to guess the century of two digit year by proximity with `referenceDate`:
 *
 *    `parse('50', 'yy', new Date(2018, 0, 1)) //=> Sat Jan 01 2050 00:00:00`
 *
 *    `parse('75', 'yy', new Date(2018, 0, 1)) //=> Wed Jan 01 1975 00:00:00`
 *
 *    while `uu` will just assign the year as is:
 *
 *    `parse('50', 'uu', new Date(2018, 0, 1)) //=> Sat Jan 01 0050 00:00:00`
 *
 *    `parse('75', 'uu', new Date(2018, 0, 1)) //=> Tue Jan 01 0075 00:00:00`
 *
 *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
 *    except local week-numbering years are dependent on `options.weekStartsOn`
 *    and `options.firstWeekContainsDate` (compare [setISOWeekYear]{@link https://date-fns.org/docs/setISOWeekYear}
 *    and [setWeekYear]{@link https://date-fns.org/docs/setWeekYear}).
 *
 * 5. These patterns are not in the Unicode Technical Standard #35:
 *    - `i`: ISO day of week
 *    - `I`: ISO week of year
 *    - `R`: ISO week-numbering year
 *    - `o`: ordinal number modifier
 *    - `P`: long localized date
 *    - `p`: long localized time
 *
 * 6. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
 *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * 7. `D` and `DD` tokens represent days of the year but they are ofthen confused with days of the month.
 *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * 8. `P+` tokens do not have a defined priority since they are merely aliases to other tokens based
 *    on the given locale.
 *
 *    using `en-US` locale: `P` => `MM/dd/yyyy`
 *    using `en-US` locale: `p` => `hh:mm a`
 *    using `pt-BR` locale: `P` => `dd/MM/yyyy`
 *    using `pt-BR` locale: `p` => `HH:mm`
 *
 * Values will be assigned to the date in the descending order of its unit's priority.
 * Units of an equal priority overwrite each other in the order of appearance.
 *
 * If no values of higher priority are parsed (e.g. when parsing string 'January 1st' without a year),
 * the values will be taken from 3rd argument `referenceDate` which works as a context of parsing.
 *
 * `referenceDate` must be passed for correct work of the function.
 * If you're not sure which `referenceDate` to supply, create a new instance of Date:
 * `parse('02/11/2014', 'MM/dd/yyyy', new Date())`
 * In this case parsing will be done in the context of the current date.
 * If `referenceDate` is `Invalid Date` or a value not convertible to valid `Date`,
 * then `Invalid Date` will be returned.
 *
 * The result may vary by locale.
 *
 * If `formatString` matches with `dateString` but does not provides tokens, `referenceDate` will be returned.
 *
 * If parsing failed, `Invalid Date` will be returned.
 * Invalid Date is a Date, whose time value is NaN.
 * Time value of Date: http://es5.github.io/#x15.9.1.1
 *
 * @param {String} dateString - the string to parse
 * @param {String} formatString - the string of tokens
 * @param {Date|Number} referenceDate - defines values missing from the parsed dateString
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @param {1|2|3|4|5|6|7} [options.firstWeekContainsDate=1] - the day of January, which is always in the first week of the year
 * @param {Boolean} [options.useAdditionalWeekYearTokens=false] - if true, allows usage of the week-numbering year tokens `YY` and `YYYY`;
 *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @param {Boolean} [options.useAdditionalDayOfYearTokens=false] - if true, allows usage of the day of year tokens `D` and `DD`;
 *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @returns {Date} the parsed date
 * @throws {TypeError} 3 arguments required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
 * @throws {RangeError} `options.locale` must contain `match` property
 * @throws {RangeError} use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} format string contains an unescaped latin alphabet character
 *
 * @example
 * // Parse 11 February 2014 from middle-endian format:
 * var result = parse('02/11/2014', 'MM/dd/yyyy', new Date())
 * //=> Tue Feb 11 2014 00:00:00
 *
 * @example
 * // Parse 28th of February in Esperanto locale in the context of 2010 year:
 * import eo from 'date-fns/locale/eo'
 * var result = parse('28-a de februaro', "do 'de' MMMM", new Date(2010, 0, 1), {
 *   locale: eo
 * })
 * //=> Sun Feb 28 2010 00:00:00
 */
function parse(dirtyDateString, dirtyFormatString, dirtyReferenceDate, options) {
  var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _defaultOptions$local3, _defaultOptions$local4;
  requiredArgs(3, arguments);
  var dateString = String(dirtyDateString);
  var formatString = String(dirtyFormatString);
  var defaultOptions = getDefaultOptions();
  var locale$1 = (_ref = (_options$locale = void 0 ) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions.locale) !== null && _ref !== void 0 ? _ref : locale;
  if (!locale$1.match) {
    throw new RangeError('locale must contain match property');
  }
  var firstWeekContainsDate = toInteger((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = void 0 ) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : void 0 ) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1);

  // Test if weekStartsOn is between 1 and 7 _and_ is not NaN
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
  }
  var weekStartsOn = toInteger((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = void 0 ) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : void 0 ) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0);

  // Test if weekStartsOn is between 0 and 6 _and_ is not NaN
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }
  if (formatString === '') {
    if (dateString === '') {
      return toDate(dirtyReferenceDate);
    } else {
      return new Date(NaN);
    }
  }
  var subFnOptions = {
    firstWeekContainsDate: firstWeekContainsDate,
    weekStartsOn: weekStartsOn,
    locale: locale$1
  };

  // If timezone isn't specified, it will be set to the system timezone
  var setters = [new DateToSystemTimezoneSetter()];
  var tokens = formatString.match(longFormattingTokensRegExp).map(function (substring) {
    var firstCharacter = substring[0];
    if (firstCharacter in longFormatters) {
      var longFormatter = longFormatters[firstCharacter];
      return longFormatter(substring, locale$1.formatLong);
    }
    return substring;
  }).join('').match(formattingTokensRegExp);
  var usedTokens = [];
  var _iterator = _createForOfIteratorHelper(tokens),
    _step;
  try {
    var _loop = function _loop() {
      var token = _step.value;
      if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(token)) {
        throwProtectedError(token, formatString, dirtyDateString);
      }
      if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(token)) {
        throwProtectedError(token, formatString, dirtyDateString);
      }
      var firstCharacter = token[0];
      var parser = parsers[firstCharacter];
      if (parser) {
        var incompatibleTokens = parser.incompatibleTokens;
        if (Array.isArray(incompatibleTokens)) {
          var incompatibleToken = usedTokens.find(function (usedToken) {
            return incompatibleTokens.includes(usedToken.token) || usedToken.token === firstCharacter;
          });
          if (incompatibleToken) {
            throw new RangeError("The format string mustn't contain `".concat(incompatibleToken.fullToken, "` and `").concat(token, "` at the same time"));
          }
        } else if (parser.incompatibleTokens === '*' && usedTokens.length > 0) {
          throw new RangeError("The format string mustn't contain `".concat(token, "` and any other token at the same time"));
        }
        usedTokens.push({
          token: firstCharacter,
          fullToken: token
        });
        var parseResult = parser.run(dateString, token, locale$1.match, subFnOptions);
        if (!parseResult) {
          return {
            v: new Date(NaN)
          };
        }
        setters.push(parseResult.setter);
        dateString = parseResult.rest;
      } else {
        if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
          throw new RangeError('Format string contains an unescaped latin alphabet character `' + firstCharacter + '`');
        }

        // Replace two single quote characters with one single quote character
        if (token === "''") {
          token = "'";
        } else if (firstCharacter === "'") {
          token = cleanEscapedString(token);
        }

        // Cut token from string, or, if string doesn't match the token, return Invalid Date
        if (dateString.indexOf(token) === 0) {
          dateString = dateString.slice(token.length);
        } else {
          return {
            v: new Date(NaN)
          };
        }
      }
    };
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _ret = _loop();
      if (_typeof(_ret) === "object") return _ret.v;
    }

    // Check if the remaining input contains something other than whitespace
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  if (dateString.length > 0 && notWhitespaceRegExp.test(dateString)) {
    return new Date(NaN);
  }
  var uniquePrioritySetters = setters.map(function (setter) {
    return setter.priority;
  }).sort(function (a, b) {
    return b - a;
  }).filter(function (priority, index, array) {
    return array.indexOf(priority) === index;
  }).map(function (priority) {
    return setters.filter(function (setter) {
      return setter.priority === priority;
    }).sort(function (a, b) {
      return b.subPriority - a.subPriority;
    });
  }).map(function (setterArray) {
    return setterArray[0];
  });
  var date = toDate(dirtyReferenceDate);
  if (isNaN(date.getTime())) {
    return new Date(NaN);
  }

  // Convert the date in system timezone to the same date in UTC+00:00 timezone.
  var utcDate = subMilliseconds(date, getTimezoneOffsetInMilliseconds(date));
  var flags = {};
  var _iterator2 = _createForOfIteratorHelper(uniquePrioritySetters),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var setter = _step2.value;
      if (!setter.validate(utcDate, subFnOptions)) {
        return new Date(NaN);
      }
      var result = setter.set(utcDate, flags, subFnOptions);
      // Result is tuple (date, flags)
      if (Array.isArray(result)) {
        utcDate = result[0];
        assign(flags, result[1]);
        // Result is date
      } else {
        utcDate = result;
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  return utcDate;
}
function cleanEscapedString(input) {
  return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
}

/**
 * @name isMatch
 * @category Common Helpers
 * @summary validates the date string against given formats
 *
 * @description
 * Return the true if given date is string correct against the given format else
 * will return false.
 *
 * > â ï¸ Please note that the `format` tokens differ from Moment.js and other libraries.
 * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * The characters in the format string wrapped between two single quotes characters (') are escaped.
 * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
 *
 * Format of the format string is based on Unicode Technical Standard #35:
 * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
 * with a few additions (see note 5 below the table).
 *
 * Not all tokens are compatible. Combinations that don't make sense or could lead to bugs are prohibited
 * and will throw `RangeError`. For example usage of 24-hour format token with AM/PM token will throw an exception:
 *
 * ```javascript
 * isMatch('23 AM', 'HH a')
 * //=> RangeError: The format string mustn't contain `HH` and `a` at the same time
 * ```
 *
 * See the compatibility table: https://docs.google.com/spreadsheets/d/e/2PACX-1vQOPU3xUhplll6dyoMmVUXHKl_8CRDs6_ueLmex3SoqwhuolkuN3O05l4rqx5h1dKX8eb46Ul-CCSrq/pubhtml?gid=0&single=true
 *
 * Accepted format string patterns:
 * | Unit                            |Prior| Pattern | Result examples                   | Notes |
 * |---------------------------------|-----|---------|-----------------------------------|-------|
 * | Era                             | 140 | G..GGG  | AD, BC                            |       |
 * |                                 |     | GGGG    | Anno Domini, Before Christ        | 2     |
 * |                                 |     | GGGGG   | A, B                              |       |
 * | Calendar year                   | 130 | y       | 44, 1, 1900, 2017, 9999           | 4     |
 * |                                 |     | yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
 * |                                 |     | yy      | 44, 01, 00, 17                    | 4     |
 * |                                 |     | yyy     | 044, 001, 123, 999                | 4     |
 * |                                 |     | yyyy    | 0044, 0001, 1900, 2017            | 4     |
 * |                                 |     | yyyyy   | ...                               | 2,4   |
 * | Local week-numbering year       | 130 | Y       | 44, 1, 1900, 2017, 9000           | 4     |
 * |                                 |     | Yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
 * |                                 |     | YY      | 44, 01, 00, 17                    | 4,6   |
 * |                                 |     | YYY     | 044, 001, 123, 999                | 4     |
 * |                                 |     | YYYY    | 0044, 0001, 1900, 2017            | 4,6   |
 * |                                 |     | YYYYY   | ...                               | 2,4   |
 * | ISO week-numbering year         | 130 | R       | -43, 1, 1900, 2017, 9999, -9999   | 4,5   |
 * |                                 |     | RR      | -43, 01, 00, 17                   | 4,5   |
 * |                                 |     | RRR     | -043, 001, 123, 999, -999         | 4,5   |
 * |                                 |     | RRRR    | -0043, 0001, 2017, 9999, -9999    | 4,5   |
 * |                                 |     | RRRRR   | ...                               | 2,4,5 |
 * | Extended year                   | 130 | u       | -43, 1, 1900, 2017, 9999, -999    | 4     |
 * |                                 |     | uu      | -43, 01, 99, -99                  | 4     |
 * |                                 |     | uuu     | -043, 001, 123, 999, -999         | 4     |
 * |                                 |     | uuuu    | -0043, 0001, 2017, 9999, -9999    | 4     |
 * |                                 |     | uuuuu   | ...                               | 2,4   |
 * | Quarter (formatting)            | 120 | Q       | 1, 2, 3, 4                        |       |
 * |                                 |     | Qo      | 1st, 2nd, 3rd, 4th                | 5     |
 * |                                 |     | QQ      | 01, 02, 03, 04                    |       |
 * |                                 |     | QQQ     | Q1, Q2, Q3, Q4                    |       |
 * |                                 |     | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 |     | QQQQQ   | 1, 2, 3, 4                        | 4     |
 * | Quarter (stand-alone)           | 120 | q       | 1, 2, 3, 4                        |       |
 * |                                 |     | qo      | 1st, 2nd, 3rd, 4th                | 5     |
 * |                                 |     | qq      | 01, 02, 03, 04                    |       |
 * |                                 |     | qqq     | Q1, Q2, Q3, Q4                    |       |
 * |                                 |     | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 |     | qqqqq   | 1, 2, 3, 4                        | 3     |
 * | Month (formatting)              | 110 | M       | 1, 2, ..., 12                     |       |
 * |                                 |     | Mo      | 1st, 2nd, ..., 12th               | 5     |
 * |                                 |     | MM      | 01, 02, ..., 12                   |       |
 * |                                 |     | MMM     | Jan, Feb, ..., Dec                |       |
 * |                                 |     | MMMM    | January, February, ..., December  | 2     |
 * |                                 |     | MMMMM   | J, F, ..., D                      |       |
 * | Month (stand-alone)             | 110 | L       | 1, 2, ..., 12                     |       |
 * |                                 |     | Lo      | 1st, 2nd, ..., 12th               | 5     |
 * |                                 |     | LL      | 01, 02, ..., 12                   |       |
 * |                                 |     | LLL     | Jan, Feb, ..., Dec                |       |
 * |                                 |     | LLLL    | January, February, ..., December  | 2     |
 * |                                 |     | LLLLL   | J, F, ..., D                      |       |
 * | Local week of year              | 100 | w       | 1, 2, ..., 53                     |       |
 * |                                 |     | wo      | 1st, 2nd, ..., 53th               | 5     |
 * |                                 |     | ww      | 01, 02, ..., 53                   |       |
 * | ISO week of year                | 100 | I       | 1, 2, ..., 53                     | 5     |
 * |                                 |     | Io      | 1st, 2nd, ..., 53th               | 5     |
 * |                                 |     | II      | 01, 02, ..., 53                   | 5     |
 * | Day of month                    |  90 | d       | 1, 2, ..., 31                     |       |
 * |                                 |     | do      | 1st, 2nd, ..., 31st               | 5     |
 * |                                 |     | dd      | 01, 02, ..., 31                   |       |
 * | Day of year                     |  90 | D       | 1, 2, ..., 365, 366               | 7     |
 * |                                 |     | Do      | 1st, 2nd, ..., 365th, 366th       | 5     |
 * |                                 |     | DD      | 01, 02, ..., 365, 366             | 7     |
 * |                                 |     | DDD     | 001, 002, ..., 365, 366           |       |
 * |                                 |     | DDDD    | ...                               | 2     |
 * | Day of week (formatting)        |  90 | E..EEE  | Mon, Tue, Wed, ..., Su            |       |
 * |                                 |     | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | EEEEE   | M, T, W, T, F, S, S               |       |
 * |                                 |     | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | ISO day of week (formatting)    |  90 | i       | 1, 2, 3, ..., 7                   | 5     |
 * |                                 |     | io      | 1st, 2nd, ..., 7th                | 5     |
 * |                                 |     | ii      | 01, 02, ..., 07                   | 5     |
 * |                                 |     | iii     | Mon, Tue, Wed, ..., Su            | 5     |
 * |                                 |     | iiii    | Monday, Tuesday, ..., Sunday      | 2,5   |
 * |                                 |     | iiiii   | M, T, W, T, F, S, S               | 5     |
 * |                                 |     | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 5     |
 * | Local day of week (formatting)  |  90 | e       | 2, 3, 4, ..., 1                   |       |
 * |                                 |     | eo      | 2nd, 3rd, ..., 1st                | 5     |
 * |                                 |     | ee      | 02, 03, ..., 01                   |       |
 * |                                 |     | eee     | Mon, Tue, Wed, ..., Su            |       |
 * |                                 |     | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | eeeee   | M, T, W, T, F, S, S               |       |
 * |                                 |     | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | Local day of week (stand-alone) |  90 | c       | 2, 3, 4, ..., 1                   |       |
 * |                                 |     | co      | 2nd, 3rd, ..., 1st                | 5     |
 * |                                 |     | cc      | 02, 03, ..., 01                   |       |
 * |                                 |     | ccc     | Mon, Tue, Wed, ..., Su            |       |
 * |                                 |     | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | ccccc   | M, T, W, T, F, S, S               |       |
 * |                                 |     | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | AM, PM                          |  80 | a..aaa  | AM, PM                            |       |
 * |                                 |     | aaaa    | a.m., p.m.                        | 2     |
 * |                                 |     | aaaaa   | a, p                              |       |
 * | AM, PM, noon, midnight          |  80 | b..bbb  | AM, PM, noon, midnight            |       |
 * |                                 |     | bbbb    | a.m., p.m., noon, midnight        | 2     |
 * |                                 |     | bbbbb   | a, p, n, mi                       |       |
 * | Flexible day period             |  80 | B..BBB  | at night, in the morning, ...     |       |
 * |                                 |     | BBBB    | at night, in the morning, ...     | 2     |
 * |                                 |     | BBBBB   | at night, in the morning, ...     |       |
 * | Hour [1-12]                     |  70 | h       | 1, 2, ..., 11, 12                 |       |
 * |                                 |     | ho      | 1st, 2nd, ..., 11th, 12th         | 5     |
 * |                                 |     | hh      | 01, 02, ..., 11, 12               |       |
 * | Hour [0-23]                     |  70 | H       | 0, 1, 2, ..., 23                  |       |
 * |                                 |     | Ho      | 0th, 1st, 2nd, ..., 23rd          | 5     |
 * |                                 |     | HH      | 00, 01, 02, ..., 23               |       |
 * | Hour [0-11]                     |  70 | K       | 1, 2, ..., 11, 0                  |       |
 * |                                 |     | Ko      | 1st, 2nd, ..., 11th, 0th          | 5     |
 * |                                 |     | KK      | 01, 02, ..., 11, 00               |       |
 * | Hour [1-24]                     |  70 | k       | 24, 1, 2, ..., 23                 |       |
 * |                                 |     | ko      | 24th, 1st, 2nd, ..., 23rd         | 5     |
 * |                                 |     | kk      | 24, 01, 02, ..., 23               |       |
 * | Minute                          |  60 | m       | 0, 1, ..., 59                     |       |
 * |                                 |     | mo      | 0th, 1st, ..., 59th               | 5     |
 * |                                 |     | mm      | 00, 01, ..., 59                   |       |
 * | Second                          |  50 | s       | 0, 1, ..., 59                     |       |
 * |                                 |     | so      | 0th, 1st, ..., 59th               | 5     |
 * |                                 |     | ss      | 00, 01, ..., 59                   |       |
 * | Seconds timestamp               |  40 | t       | 512969520                         |       |
 * |                                 |     | tt      | ...                               | 2     |
 * | Fraction of second              |  30 | S       | 0, 1, ..., 9                      |       |
 * |                                 |     | SS      | 00, 01, ..., 99                   |       |
 * |                                 |     | SSS     | 000, 001, ..., 999                |       |
 * |                                 |     | SSSS    | ...                               | 2     |
 * | Milliseconds timestamp          |  20 | T       | 512969520900                      |       |
 * |                                 |     | TT      | ...                               | 2     |
 * | Timezone (ISO-8601 w/ Z)        |  10 | X       | -08, +0530, Z                     |       |
 * |                                 |     | XX      | -0800, +0530, Z                   |       |
 * |                                 |     | XXX     | -08:00, +05:30, Z                 |       |
 * |                                 |     | XXXX    | -0800, +0530, Z, +123456          | 2     |
 * |                                 |     | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
 * | Timezone (ISO-8601 w/o Z)       |  10 | x       | -08, +0530, +00                   |       |
 * |                                 |     | xx      | -0800, +0530, +0000               |       |
 * |                                 |     | xxx     | -08:00, +05:30, +00:00            | 2     |
 * |                                 |     | xxxx    | -0800, +0530, +0000, +123456      |       |
 * |                                 |     | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
 * | Long localized date             |  NA | P       | 05/29/1453                        | 5,8   |
 * |                                 |     | PP      | May 29, 1453                      |       |
 * |                                 |     | PPP     | May 29th, 1453                    |       |
 * |                                 |     | PPPP    | Sunday, May 29th, 1453            | 2,5,8 |
 * | Long localized time             |  NA | p       | 12:00 AM                          | 5,8   |
 * |                                 |     | pp      | 12:00:00 AM                       |       |
 * | Combination of date and time    |  NA | Pp      | 05/29/1453, 12:00 AM              |       |
 * |                                 |     | PPpp    | May 29, 1453, 12:00:00 AM         |       |
 * |                                 |     | PPPpp   | May 29th, 1453 at ...             |       |
 * |                                 |     | PPPPpp  | Sunday, May 29th, 1453 at ...     | 2,5,8 |
 * Notes:
 * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
 *    are the same as "stand-alone" units, but are different in some languages.
 *    "Formatting" units are declined according to the rules of the language
 *    in the context of a date. "Stand-alone" units are always nominative singular.
 *    In `format` function, they will produce different result:
 *
 *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
 *
 *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
 *
 *    `isMatch` will try to match both formatting and stand-alone units interchangably.
 *
 * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
 *    the single quote characters (see below).
 *    If the sequence is longer than listed in table:
 *    - for numerical units (`yyyyyyyy`) `isMatch` will try to match a number
 *      as wide as the sequence
 *    - for text units (`MMMMMMMM`) `isMatch` will try to match the widest variation of the unit.
 *      These variations are marked with "2" in the last column of the table.
 *
 * 3. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
 *    These tokens represent the shortest form of the quarter.
 *
 * 4. The main difference between `y` and `u` patterns are B.C. years:
 *
 *    | Year | `y` | `u` |
 *    |------|-----|-----|
 *    | AC 1 |   1 |   1 |
 *    | BC 1 |   1 |   0 |
 *    | BC 2 |   2 |  -1 |
 *
 *    Also `yy` will try to guess the century of two digit year by proximity with `referenceDate`:
 *
 *    `isMatch('50', 'yy') //=> true`
 *
 *    `isMatch('75', 'yy') //=> true`
 *
 *    while `uu` will use the year as is:
 *
 *    `isMatch('50', 'uu') //=> true`
 *
 *    `isMatch('75', 'uu') //=> true`
 *
 *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
 *    except local week-numbering years are dependent on `options.weekStartsOn`
 *    and `options.firstWeekContainsDate` (compare [setISOWeekYear]{@link https://date-fns.org/docs/setISOWeekYear}
 *    and [setWeekYear]{@link https://date-fns.org/docs/setWeekYear}).
 *
 * 5. These patterns are not in the Unicode Technical Standard #35:
 *    - `i`: ISO day of week
 *    - `I`: ISO week of year
 *    - `R`: ISO week-numbering year
 *    - `o`: ordinal number modifier
 *    - `P`: long localized date
 *    - `p`: long localized time
 *
 * 6. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
 *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * 7. `D` and `DD` tokens represent days of the year but they are ofthen confused with days of the month.
 *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * 8. `P+` tokens do not have a defined priority since they are merely aliases to other tokens based
 *    on the given locale.
 *
 *    using `en-US` locale: `P` => `MM/dd/yyyy`
 *    using `en-US` locale: `p` => `hh:mm a`
 *    using `pt-BR` locale: `P` => `dd/MM/yyyy`
 *    using `pt-BR` locale: `p` => `HH:mm`
 *
 * Values will be checked in the descending order of its unit's priority.
 * Units of an equal priority overwrite each other in the order of appearance.
 *
 * If no values of higher priority are matched (e.g. when matching string 'January 1st' without a year),
 * the values will be taken from today's using `new Date()` date which works as a context of parsing.
 *
 * The result may vary by locale.
 *
 * If `formatString` matches with `dateString` but does not provides tokens, `referenceDate` will be returned.
 *
 *
 *
 * @param {String} dateString - the date string to verify
 * @param {String} formatString - the string of tokens
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @param {1|2|3|4|5|6|7} [options.firstWeekContainsDate=1] - the day of January, which is always in the first week of the year
 * @param {Boolean} [options.useAdditionalWeekYearTokens=false] - if true, allows usage of the week-numbering year tokens `YY` and `YYYY`;
 *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @param {Boolean} [options.useAdditionalDayOfYearTokens=false] - if true, allows usage of the day of year tokens `D` and `DD`;
 *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @returns {Boolean}
 * @throws {TypeError} 2 arguments required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
 * @throws {RangeError} `options.locale` must contain `match` property
 * @throws {RangeError} use `yyyy` instead of `YYYY` for formatting years; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} use `yy` instead of `YY` for formatting years; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} use `d` instead of `D` for formatting days of the month; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} use `dd` instead of `DD` for formatting days of the month; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} format string contains an unescaped latin alphabet character
 *
 * @example
 * // Match 11 February 2014 from middle-endian format:
 * const result = isMatch('02/11/2014', 'MM/dd/yyyy')
 * //=> true
 *
 * @example
 * // Match 28th of February in Esperanto locale in the context of 2010 year:
 * import eo from 'date-fns/locale/eo'
 * const result = isMatch('28-a de februaro', "do 'de' MMMM", {
 *   locale: eo
 * })
 * //=> true
 */
function isMatch(dateString, formatString, options) {
  requiredArgs(2, arguments);
  return isValid(parse(dateString, formatString, new Date(), options));
}

var dateConfig = {
  parseDate: function parseDate(datestr, _format) {
    var pattern;
    if (isMatch(datestr, "dd-MM-yyyy")) {
      pattern = "dd-MM-yyyy";
    } else if (isMatch(datestr, "dd/MM/yyyy")) {
      pattern = "dd/MM/yyyy";
    } else if (isMatch(datestr, "dd MMM yyyy")) {
      pattern = "dd MMM yyyy";
    } else if (isMatch(datestr, "yyyy-MM-dd")) {
      pattern = "yyyy-MM-dd";
    } else {
      pattern = "dd-MMM-yyyy";
    }
    return parse(datestr, pattern, new Date());
  },
  locale: {
    firstDayOfWeek: 1,
    months: _objectSpread2$1(_objectSpread2$1({}, _defaultExports.english.months), {}, {
      shorthand: [].concat(_toConsumableArray(_defaultExports.english.months.shorthand), [
      // Allow users to input numbers in date field instead of Jan, Feb
      // Because we can't directly change `tokenRegex`, add the numbers to the
      // month shorthand locale, so they'll end up in the regexp string
      // See https://github.com/flatpickr/flatpickr/blob/614568f20daff9fdef906e8451876d8918c68d3c/src/index.ts#L2160
      // Alternative and cleaner approach would be to set our own `config.parseDate()` function
      // which has custom tokenRegex that fit our needs best.
      "01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"])
    })
  },
  dateFormat: "d-M-Y"
};
var timeConfig = {
  enableTime: true,
  noCalendar: true,
  time_24hr: true,
  dateFormat: "H:i"
};
var dateWithTimeConfig = {
  parseDate: function parseDate(datestr, _format) {
    var pattern;
    if (isMatch(datestr, "dd-MM-yyyy H:m")) {
      pattern = "dd-MM-yyyy H:m";
    } else if (isMatch(datestr, "dd/MM/yyyy H:m")) {
      pattern = "dd/MM/yyyy H:m";
    } else if (isMatch(datestr, "dd MMM yyyy H:m")) {
      pattern = "dd MMM yyyy H:m";
    } else if (isMatch(datestr, "yyyy-MM-dd H:m")) {
      pattern = "yyyy-MM-dd H:m";
    } else {
      pattern = "dd-MMM-yyyy H:m";
    }
    return parse(datestr, pattern, new Date());
  },
  enableTime: true,
  dateFormat: "d-M-Y H:i"
};
var _default$b = /*#__PURE__*/function (_Controller) {
  function _default() {
    _classCallCheck$1(this, _default);
    return _callSuper(this, _default, arguments);
  }
  _inherits$1(_default, _Controller);
  return _createClass$1(_default, [{
    key: "connect",
    value: function connect() {
      var config;
      if (this.dateWithTimeValue) {
        config = dateWithTimeConfig;
      } else if (this.timeOnlyValue) {
        config = timeConfig;
      } else {
        config = dateConfig;
      }
      config["maxDate"] = this.element.dataset.flatpickrMaxDate;
      config["minDate"] = this.element.dataset.flatpickrMinDate;
      config["allowInput"] = true;
      this.fp = flatpickr(this.element, config);
    }
  }, {
    key: "disconnect",
    value: function disconnect() {
      this.fp.destroy();
    }
  }]);
}(Controller);
_defineProperty$2(_default$b, "values", {
  timeOnly: Boolean,
  dateWithTime: Boolean
});

/*
  Adds a warning if selected value is not allowed
*/
var _default$a = /*#__PURE__*/function (_Controller) {
  function _default() {
    _classCallCheck$1(this, _default);
    return _callSuper(this, _default, arguments);
  }
  _inherits$1(_default, _Controller);
  return _createClass$1(_default, [{
    key: "connect",
    value: function connect() {
      this.toggleMessage();
    }
  }, {
    key: "change",
    value: function change() {
      this.toggleMessage();
    }
  }, {
    key: "toggleMessage",
    value: function toggleMessage() {
      if (this.notRecommendedValue.includes(this.inputTarget.value)) {
        this.messageTarget.classList.remove("hidden");
      } else {
        this.messageTarget.classList.add("hidden");
      }
    }
  }]);
}(Controller);
_defineProperty$2(_default$a, "values", {
  notRecommended: Array
});
_defineProperty$2(_default$a, "targets", ["input", "message"]);

var _default$9 = /*#__PURE__*/function (_Controller) {
  function _default() {
    _classCallCheck$1(this, _default);
    return _callSuper(this, _default, arguments);
  }
  _inherits$1(_default, _Controller);
  return _createClass$1(_default, [{
    key: "change",
    value: function change() {
      var url = this.element.selectedOptions[0].dataset.frameUrl;
      var frame = document.getElementById(this.frameIdValue);
      frame.src = url;
    }
  }]);
}(Controller);
_defineProperty$2(_default$9, "values", {
  frameId: String
});

// Inspired by https://stackoverflow.com/a/56952952/4405214
var _default$8 = /*#__PURE__*/function (_Controller) {
  function _default() {
    _classCallCheck$1(this, _default);
    return _callSuper(this, _default, arguments);
  }
  _inherits$1(_default, _Controller);
  return _createClass$1(_default, [{
    key: "connect",
    value: function connect() {
      this.doubleScroll(this.element);
    }
  }, {
    key: "doubleScroll",
    value: function doubleScroll(element) {
      var scrollbar = document.createElement("div");
      scrollbar.appendChild(document.createElement("div"));
      scrollbar.style.overflow = "auto";
      scrollbar.style.overflowY = "hidden";
      scrollbar.firstChild.style.width = element.scrollWidth + "px";
      scrollbar.firstChild.style.paddingTop = "1px";
      var running = false;
      // Keep scrollbar in sync when element size changes
      new ResizeObserver(function () {
        scrollbar.firstChild.style.width = element.scrollWidth + "px";
      }).observe(element);
      scrollbar.onscroll = function () {
        if (running) {
          running = false;
          return;
        }
        running = true;
        element.scrollLeft = scrollbar.scrollLeft;
      };
      element.onscroll = function () {
        if (running) {
          running = false;
          return;
        }
        running = true;
        scrollbar.scrollLeft = element.scrollLeft;
      };
      element.parentNode.insertBefore(scrollbar, element);
    }
  }]);
}(Controller);

var _default$7 = /*#__PURE__*/function (_Controller) {
  function _default() {
    _classCallCheck$1(this, _default);
    return _callSuper(this, _default, arguments);
  }
  _inherits$1(_default, _Controller);
  return _createClass$1(_default, [{
    key: "initialize",
    value: function initialize() {
      this.change = debounce$3(this.change.bind(this), 1000);
    }
  }, {
    key: "change",
    value: function change(e) {
      var url = new URL(this.srcValue);
      url.searchParams.set(this.queryParamValue, e.target.value);
      this.turboframeTarget.src = url.toString();
    }
  }]);
}(Controller);
_defineProperty$2(_default$7, "targets", ["turboframe"]);
_defineProperty$2(_default$7, "values", {
  src: String,
  queryParam: String
});

var _default$6 = /*#__PURE__*/function (_Controller) {
  function _default() {
    _classCallCheck$1(this, _default);
    return _callSuper(this, _default, arguments);
  }
  _inherits$1(_default, _Controller);
  return _createClass$1(_default, [{
    key: "connect",
    value: function connect() {
      this.open = false;
    }
  }, {
    key: "toggle",
    value: function toggle(event) {
      this.open === false ? this.show(event) : this.hide(event);
    }
  }, {
    key: "show",
    value: function show(event) {
      this.open = true;
      var target = event.target;
      target.innerHTML = this.lessTextValue;
      this.contentTarget.style.setProperty("--read-more-line-clamp", "'unset'");
      $('.mgrid > .row').masonry('layout');
    }
  }, {
    key: "hide",
    value: function hide(event) {
      this.open = false;
      var target = event.target;
      target.innerHTML = this.moreTextValue;
      this.contentTarget.style.removeProperty("--read-more-line-clamp");
      $('.mgrid > .row').masonry('layout');
    }
  }]);
}(Controller);
_defineProperty$2(_default$6, "targets", ["content"]);
_defineProperty$2(_default$6, "values", {
  moreText: String,
  lessText: String
});

var _default$5 = /*#__PURE__*/function (_Controller) {
  function _default() {
    _classCallCheck$1(this, _default);
    return _callSuper(this, _default, arguments);
  }
  _inherits$1(_default, _Controller);
  return _createClass$1(_default, [{
    key: "connect",
    value: function connect() {
      grid = this.element;
      // let rowHeight = parseInt(
      var rowHeight = parseInt(window.getComputedStyle(grid).getPropertyValue('grid-auto-rows'));
      var rowGap = parseInt(window.getComputedStyle(grid).getPropertyValue('grid-row-gap'));
      this.contentTargets.forEach(function (el) {
        var rowSpan = Math.ceil((el.querySelector(".content").getBoundingClientRect().height + rowGap) / (rowHeight + rowGap)) + 1;
        el.style.gridRowEnd = "span " + rowSpan;
      });
    }
  }]);
}(Controller);
_defineProperty$2(_default$5, "targets", ["content"]);

var $$2 = window.$;

/*
When this is controller is added to a table, if the table uses colgroups (eg historical pathology)
then as the mouse enters and leaves
*/
var _default$4 = /*#__PURE__*/function (_Controller) {
  function _default() {
    _classCallCheck$1(this, _default);
    return _callSuper(this, _default, arguments);
  }
  _inherits$1(_default, _Controller);
  return _createClass$1(_default, [{
    key: "connect",
    value: function connect() {
      var _this = this;
      this.element.addEventListener('mouseenter', function (e) {
        _this.highlight_colgroup(e);
      }, true);
      this.element.addEventListener('mouseleave', function (e) {
        _this.unhighlight_colgroup(e);
      }, true);
    }
  }, {
    key: "highlight_colgroup",
    value: function highlight_colgroup(e) {
      if (e.target.tagName == "TD") {
        $$2("colgroup").eq($$2(e.target).index()).addClass("hover");
      }
    }
  }, {
    key: "unhighlight_colgroup",
    value: function unhighlight_colgroup(e) {
      if (e.target.tagName == "TD") {
        $$2("colgroup").eq($$2(e.target).index()).removeClass("hover");
      }
    }
  }]);
}(Controller);

// Given the markup eg
//   ul.side-nav(data-controller="navbar"
//               data-navbar-rails-controller-value="xxx"
//               data-navbar-active-class="some css class")
//    li(data-navbar-target="nav" data-rails-controller="clinical/profiles")
//      a(href..) An menu item
// When the controller connects it will add a css class to any nav target where the
// the nav's data-rails-controller string occurs at the start of the rails controller value
// eg for current controller pathology/historical, the nav with data-rails-controller="pathology"
// will get the active class.
// Using js to highlight the menu on this context means we can cache it's partial.
var _default$3 = /*#__PURE__*/function (_Controller) {
  function _default() {
    _classCallCheck$1(this, _default);
    return _callSuper(this, _default, arguments);
  }
  _inherits$1(_default, _Controller);
  return _createClass$1(_default, [{
    key: "connect",
    value: function connect() {
      var _this = this;
      this.navTargets.forEach(function (nav) {
        if (_this.railsControllerValue.startsWith(nav.dataset.railsController)) {
          nav.classList.add(_this.activeClass);
        }
      });
    }
  }]);
}(Controller);
_defineProperty$2(_default$3, "targets", ["nav"]);
_defineProperty$2(_default$3, "values", {
  railsController: String
});
_defineProperty$2(_default$3, "classes", ["active"]);

var $$1 = window.$;
var _default$2 = /*#__PURE__*/function (_Controller) {
  function _default() {
    _classCallCheck$1(this, _default);
    return _callSuper(this, _default, arguments);
  }
  _inherits$1(_default, _Controller);
  return _createClass$1(_default, [{
    key: "connect",
    value: function connect() {
      $$1(".sub-nav:not('.no-js-selection') dd").each(function () {
        var href = $$1(this).find("a").attr('href');
        if (href === window.location.pathname) {
          $$1(this).addClass('active');
        }
      });
    }
  }]);
}(Controller);

var _default$1 = /*#__PURE__*/function (_Controller) {
  function _default() {
    _classCallCheck$1(this, _default);
    return _callSuper(this, _default, arguments);
  }
  _inherits$1(_default, _Controller);
  return _createClass$1(_default, [{
    key: "submitEnd",
    value:
    // Example usage:
    //  div(data-controller="turbo-modal" data-action="turbo:submit-end->turbo-modal#submitEnd")
    //
    // Note that the current Turbo support for breaking out of say a modal form after a successful
    // create, where we want to redirect somewhere else, is not very good. Until it is baked into to
    // Turbo, or there is a good recommended approach, we are currently using a "turbo:frame-missing"
    // handler in application.js
    // However the below approach also works but we are not currently using it:
    // When the Create button is hit in the modal and the rails controller successfully creates
    // the modal, it should return eg
    //   head :no_content, location: hd_slot_requests_path
    // and as long as the markup looks like the above, we will come into submitEnd and
    // detect the 204 and redirect to the specific url. This avoids a double render (a problem with
    // the "turbo:frame-missing" redirect solution)
    function submitEnd(event) {
      var _event$detail, _response$headers$get, _response$headers;
      var response = (_event$detail = event.detail) === null || _event$detail === void 0 || (_event$detail = _event$detail.fetchResponse) === null || _event$detail === void 0 ? void 0 : _event$detail.response;
      var status = response === null || response === void 0 ? void 0 : response.status;
      var url = (_response$headers$get = response === null || response === void 0 || (_response$headers = response.headers) === null || _response$headers === void 0 ? void 0 : _response$headers.get('location')) !== null && _response$headers$get !== void 0 ? _response$headers$get : null;
      if (status === 204 && url) {
        event.preventDefault();
        window.location = url;
        return false;
      }
    }
  }, {
    key: "close",
    value: function close(e) {
      e.preventDefault();
      this.element.remove();
    }
  }]);
}(Controller);

var _default = /*#__PURE__*/function (_Controller) {
  function _default() {
    _classCallCheck$1(this, _default);
    return _callSuper(this, _default, arguments);
  }
  _inherits$1(_default, _Controller);
  return _createClass$1(_default, [{
    key: "initialize",
    value: function initialize() {
      this.getJson();
    }
  }, {
    key: "updateChart",
    value: function updateChart(json) {
      Highcharts$1.chart(this.chartTarget, json);
    }
  }, {
    key: "getJson",
    value: function getJson() {
      var _this = this;
      fetch(this.urlValue, {
        credentials: "same-origin",
        headers: new Headers({
          "content-type": "application/json"
        })
      }).then(function (response) {
        return response.json();
      }).then(function (json) {
        _this.updateChart(json);
      });
    }
  }]);
}(Controller);
_defineProperty$2(_default, "targets", ["chart" // chart container
]);
_defineProperty$2(_default, "values", {
  url: String // API endpoint for chart json
});

application.register("toggle", _default$F);
application.register("hd-prescription-administration", _default$B);
application.register("home-delivery-modal", _default$A);
application.register("snippets", _default$z);
application.register("letters-form", _default$y);
application.register("prescriptions", _default$x);
application.register("charts", _default$w);
application.register("session", _default$v);
application.register("simple-toggle", _default$u);
application.register("show-on-selected", _default$t);
application.register("tabs", _default$s);
application.register("pd-pet-chart", _default$r);
application.register("pathology-sparklines", _default$q);
application.register("collapsible", _default$p);
application.register("dependent-select", _default$o);
application.register("patient-attachments", _default$n);
application.register("patient-search", _default$m);
application.register("sortable", _default$l);
application.register("select", _default$k);
application.register("radio-reset", _default$j);
application.register("conditional-display", _default$i);
application.register("slimselect", _default$h);
application.register("modal", _default$g);
application.register("form", _default$f);
application.register("alternative-form-submitter", _default$e);
application.register("flash", _default$d);
application.register("flatpickr", _default$b);
application.register("input-value-alerter", _default$a);
application.register("select-update-frame", _default$9);
application.register("clinics--bmi-calculator", _default$E);
application.register("clinics--weight-change-calculator", _default$D);
application.register("clinics--dietary-protein-calculator", _default$C);
application.register("add-top-horizontal-scrollbar", _default$8);
application.register("preview", _default$7);
application.register("read-more", _default$6);
application.register("grid-row-auto-span", _default$5);
application.register("table_column_hover", _default$4);
application.register("navbar", _default$3);
application.register("dropdown", i); // https://www.stimulus-components.com/docs/stimulus-dropdown/
application.register("tabbed-navigation", _default$2);
application.register("turbo-modal", _default$1);
application.register("charts-raw", _default);

/*!
Turbo 8.0.4
Copyright Â© 2024 37signals LLC
 */
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2019 Javan Makhmali
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

(function (prototype) {
  if (typeof prototype.requestSubmit == "function") return;
  prototype.requestSubmit = function (submitter) {
    if (submitter) {
      validateSubmitter(submitter, this);
      submitter.click();
    } else {
      submitter = document.createElement("input");
      submitter.type = "submit";
      submitter.hidden = true;
      this.appendChild(submitter);
      submitter.click();
      this.removeChild(submitter);
    }
  };
  function validateSubmitter(submitter, form) {
    submitter instanceof HTMLElement || raise(TypeError, "parameter 1 is not of type 'HTMLElement'");
    submitter.type == "submit" || raise(TypeError, "The specified element is not a submit button");
    submitter.form == form || raise(DOMException, "The specified element is not owned by this form element", "NotFoundError");
  }
  function raise(errorConstructor, message, name) {
    throw new errorConstructor("Failed to execute 'requestSubmit' on 'HTMLFormElement': " + message + ".", name);
  }
})(HTMLFormElement.prototype);
const submittersByForm = new WeakMap();
function findSubmitterFromClickTarget(target) {
  const element = target instanceof Element ? target : target instanceof Node ? target.parentElement : null;
  const candidate = element ? element.closest("input, button") : null;
  return candidate?.type == "submit" ? candidate : null;
}
function clickCaptured(event) {
  const submitter = findSubmitterFromClickTarget(event.target);
  if (submitter && submitter.form) {
    submittersByForm.set(submitter.form, submitter);
  }
}
(function () {
  if ("submitter" in Event.prototype) return;
  let prototype = window.Event.prototype;
  // Certain versions of Safari 15 have a bug where they won't
  // populate the submitter. This hurts TurboDrive's enable/disable detection.
  // See https://bugs.webkit.org/show_bug.cgi?id=229660
  if ("SubmitEvent" in window) {
    const prototypeOfSubmitEvent = window.SubmitEvent.prototype;
    if (/Apple Computer/.test(navigator.vendor) && !("submitter" in prototypeOfSubmitEvent)) {
      prototype = prototypeOfSubmitEvent;
    } else {
      return; // polyfill not needed
    }
  }
  addEventListener("click", clickCaptured, true);
  Object.defineProperty(prototype, "submitter", {
    get() {
      if (this.type == "submit" && this.target instanceof HTMLFormElement) {
        return submittersByForm.get(this.target);
      }
    }
  });
})();
const FrameLoadingStyle = {
  eager: "eager",
  lazy: "lazy"
};

/**
 * Contains a fragment of HTML which is updated based on navigation within
 * it (e.g. via links or form submissions).
 *
 * @customElement turbo-frame
 * @example
 *   <turbo-frame id="messages">
 *     <a href="/messages/expanded">
 *       Show all expanded messages in this frame.
 *     </a>
 *
 *     <form action="/messages">
 *       Show response from this form within this frame.
 *     </form>
 *   </turbo-frame>
 */
class FrameElement extends HTMLElement {
  static delegateConstructor = undefined;
  loaded = Promise.resolve();
  static get observedAttributes() {
    return ["disabled", "loading", "src"];
  }
  constructor() {
    super();
    this.delegate = new FrameElement.delegateConstructor(this);
  }
  connectedCallback() {
    this.delegate.connect();
  }
  disconnectedCallback() {
    this.delegate.disconnect();
  }
  reload() {
    return this.delegate.sourceURLReloaded();
  }
  attributeChangedCallback(name) {
    if (name == "loading") {
      this.delegate.loadingStyleChanged();
    } else if (name == "src") {
      this.delegate.sourceURLChanged();
    } else if (name == "disabled") {
      this.delegate.disabledChanged();
    }
  }

  /**
   * Gets the URL to lazily load source HTML from
   */
  get src() {
    return this.getAttribute("src");
  }

  /**
   * Sets the URL to lazily load source HTML from
   */
  set src(value) {
    if (value) {
      this.setAttribute("src", value);
    } else {
      this.removeAttribute("src");
    }
  }

  /**
   * Gets the refresh mode for the frame.
   */
  get refresh() {
    return this.getAttribute("refresh");
  }

  /**
   * Sets the refresh mode for the frame.
   */
  set refresh(value) {
    if (value) {
      this.setAttribute("refresh", value);
    } else {
      this.removeAttribute("refresh");
    }
  }

  /**
   * Determines if the element is loading
   */
  get loading() {
    return frameLoadingStyleFromString(this.getAttribute("loading") || "");
  }

  /**
   * Sets the value of if the element is loading
   */
  set loading(value) {
    if (value) {
      this.setAttribute("loading", value);
    } else {
      this.removeAttribute("loading");
    }
  }

  /**
   * Gets the disabled state of the frame.
   *
   * If disabled, no requests will be intercepted by the frame.
   */
  get disabled() {
    return this.hasAttribute("disabled");
  }

  /**
   * Sets the disabled state of the frame.
   *
   * If disabled, no requests will be intercepted by the frame.
   */
  set disabled(value) {
    if (value) {
      this.setAttribute("disabled", "");
    } else {
      this.removeAttribute("disabled");
    }
  }

  /**
   * Gets the autoscroll state of the frame.
   *
   * If true, the frame will be scrolled into view automatically on update.
   */
  get autoscroll() {
    return this.hasAttribute("autoscroll");
  }

  /**
   * Sets the autoscroll state of the frame.
   *
   * If true, the frame will be scrolled into view automatically on update.
   */
  set autoscroll(value) {
    if (value) {
      this.setAttribute("autoscroll", "");
    } else {
      this.removeAttribute("autoscroll");
    }
  }

  /**
   * Determines if the element has finished loading
   */
  get complete() {
    return !this.delegate.isLoading;
  }

  /**
   * Gets the active state of the frame.
   *
   * If inactive, source changes will not be observed.
   */
  get isActive() {
    return this.ownerDocument === document && !this.isPreview;
  }

  /**
   * Sets the active state of the frame.
   *
   * If inactive, source changes will not be observed.
   */
  get isPreview() {
    return this.ownerDocument?.documentElement?.hasAttribute("data-turbo-preview");
  }
}
function frameLoadingStyleFromString(style) {
  switch (style.toLowerCase()) {
    case "lazy":
      return FrameLoadingStyle.lazy;
    default:
      return FrameLoadingStyle.eager;
  }
}
function expandURL(locatable) {
  return new URL(locatable.toString(), document.baseURI);
}
function getAnchor(url) {
  let anchorMatch;
  if (url.hash) {
    return url.hash.slice(1);
    // eslint-disable-next-line no-cond-assign
  } else if (anchorMatch = url.href.match(/#(.*)$/)) {
    return anchorMatch[1];
  }
}
function getAction$1(form, submitter) {
  const action = submitter?.getAttribute("formaction") || form.getAttribute("action") || form.action;
  return expandURL(action);
}
function getExtension(url) {
  return (getLastPathComponent(url).match(/\.[^.]*$/) || [])[0] || "";
}
function isHTML(url) {
  return !!getExtension(url).match(/^(?:|\.(?:htm|html|xhtml|php))$/);
}
function isPrefixedBy(baseURL, url) {
  const prefix = getPrefix(url);
  return baseURL.href === expandURL(prefix).href || baseURL.href.startsWith(prefix);
}
function locationIsVisitable(location, rootLocation) {
  return isPrefixedBy(location, rootLocation) && isHTML(location);
}
function getRequestURL(url) {
  const anchor = getAnchor(url);
  return anchor != null ? url.href.slice(0, -(anchor.length + 1)) : url.href;
}
function toCacheKey(url) {
  return getRequestURL(url);
}
function urlsAreEqual(left, right) {
  return expandURL(left).href == expandURL(right).href;
}
function getPathComponents(url) {
  return url.pathname.split("/").slice(1);
}
function getLastPathComponent(url) {
  return getPathComponents(url).slice(-1)[0];
}
function getPrefix(url) {
  return addTrailingSlash(url.origin + url.pathname);
}
function addTrailingSlash(value) {
  return value.endsWith("/") ? value : value + "/";
}
class FetchResponse {
  constructor(response) {
    this.response = response;
  }
  get succeeded() {
    return this.response.ok;
  }
  get failed() {
    return !this.succeeded;
  }
  get clientError() {
    return this.statusCode >= 400 && this.statusCode <= 499;
  }
  get serverError() {
    return this.statusCode >= 500 && this.statusCode <= 599;
  }
  get redirected() {
    return this.response.redirected;
  }
  get location() {
    return expandURL(this.response.url);
  }
  get isHTML() {
    return this.contentType && this.contentType.match(/^(?:text\/([^\s;,]+\b)?html|application\/xhtml\+xml)\b/);
  }
  get statusCode() {
    return this.response.status;
  }
  get contentType() {
    return this.header("Content-Type");
  }
  get responseText() {
    return this.response.clone().text();
  }
  get responseHTML() {
    if (this.isHTML) {
      return this.response.clone().text();
    } else {
      return Promise.resolve(undefined);
    }
  }
  header(name) {
    return this.response.headers.get(name);
  }
}
function activateScriptElement(element) {
  if (element.getAttribute("data-turbo-eval") == "false") {
    return element;
  } else {
    const createdScriptElement = document.createElement("script");
    const cspNonce = getMetaContent("csp-nonce");
    if (cspNonce) {
      createdScriptElement.nonce = cspNonce;
    }
    createdScriptElement.textContent = element.textContent;
    createdScriptElement.async = false;
    copyElementAttributes(createdScriptElement, element);
    return createdScriptElement;
  }
}
function copyElementAttributes(destinationElement, sourceElement) {
  for (const {
    name,
    value
  } of sourceElement.attributes) {
    destinationElement.setAttribute(name, value);
  }
}
function createDocumentFragment(html) {
  const template = document.createElement("template");
  template.innerHTML = html;
  return template.content;
}
function dispatch(eventName, {
  target,
  cancelable,
  detail
} = {}) {
  const event = new CustomEvent(eventName, {
    cancelable,
    bubbles: true,
    composed: true,
    detail
  });
  if (target && target.isConnected) {
    target.dispatchEvent(event);
  } else {
    document.documentElement.dispatchEvent(event);
  }
  return event;
}
function nextRepaint() {
  if (document.visibilityState === "hidden") {
    return nextEventLoopTick();
  } else {
    return nextAnimationFrame();
  }
}
function nextAnimationFrame() {
  return new Promise(resolve => requestAnimationFrame(() => resolve()));
}
function nextEventLoopTick() {
  return new Promise(resolve => setTimeout(() => resolve(), 0));
}
function nextMicrotask() {
  return Promise.resolve();
}
function parseHTMLDocument(html = "") {
  return new DOMParser().parseFromString(html, "text/html");
}
function unindent(strings, ...values) {
  const lines = interpolate(strings, values).replace(/^\n/, "").split("\n");
  const match = lines[0].match(/^\s+/);
  const indent = match ? match[0].length : 0;
  return lines.map(line => line.slice(indent)).join("\n");
}
function interpolate(strings, values) {
  return strings.reduce((result, string, i) => {
    const value = values[i] == undefined ? "" : values[i];
    return result + string + value;
  }, "");
}
function uuid() {
  return Array.from({
    length: 36
  }).map((_, i) => {
    if (i == 8 || i == 13 || i == 18 || i == 23) {
      return "-";
    } else if (i == 14) {
      return "4";
    } else if (i == 19) {
      return (Math.floor(Math.random() * 4) + 8).toString(16);
    } else {
      return Math.floor(Math.random() * 15).toString(16);
    }
  }).join("");
}
function getAttribute(attributeName, ...elements) {
  for (const value of elements.map(element => element?.getAttribute(attributeName))) {
    if (typeof value == "string") return value;
  }
  return null;
}
function hasAttribute(attributeName, ...elements) {
  return elements.some(element => element && element.hasAttribute(attributeName));
}
function markAsBusy(...elements) {
  for (const element of elements) {
    if (element.localName == "turbo-frame") {
      element.setAttribute("busy", "");
    }
    element.setAttribute("aria-busy", "true");
  }
}
function clearBusyState(...elements) {
  for (const element of elements) {
    if (element.localName == "turbo-frame") {
      element.removeAttribute("busy");
    }
    element.removeAttribute("aria-busy");
  }
}
function waitForLoad(element, timeoutInMilliseconds = 2000) {
  return new Promise(resolve => {
    const onComplete = () => {
      element.removeEventListener("error", onComplete);
      element.removeEventListener("load", onComplete);
      resolve();
    };
    element.addEventListener("load", onComplete, {
      once: true
    });
    element.addEventListener("error", onComplete, {
      once: true
    });
    setTimeout(resolve, timeoutInMilliseconds);
  });
}
function getHistoryMethodForAction(action) {
  switch (action) {
    case "replace":
      return history.replaceState;
    case "advance":
    case "restore":
      return history.pushState;
  }
}
function isAction(action) {
  return action == "advance" || action == "replace" || action == "restore";
}
function getVisitAction(...elements) {
  const action = getAttribute("data-turbo-action", ...elements);
  return isAction(action) ? action : null;
}
function getMetaElement(name) {
  return document.querySelector(`meta[name="${name}"]`);
}
function getMetaContent(name) {
  const element = getMetaElement(name);
  return element && element.content;
}
function setMetaContent(name, content) {
  let element = getMetaElement(name);
  if (!element) {
    element = document.createElement("meta");
    element.setAttribute("name", name);
    document.head.appendChild(element);
  }
  element.setAttribute("content", content);
  return element;
}
function findClosestRecursively(element, selector) {
  if (element instanceof Element) {
    return element.closest(selector) || findClosestRecursively(element.assignedSlot || element.getRootNode()?.host, selector);
  }
}
function elementIsFocusable(element) {
  const inertDisabledOrHidden = "[inert], :disabled, [hidden], details:not([open]), dialog:not([open])";
  return !!element && element.closest(inertDisabledOrHidden) == null && typeof element.focus == "function";
}
function queryAutofocusableElement(elementOrDocumentFragment) {
  return Array.from(elementOrDocumentFragment.querySelectorAll("[autofocus]")).find(elementIsFocusable);
}
async function around(callback, reader) {
  const before = reader();
  callback();
  await nextAnimationFrame();
  const after = reader();
  return [before, after];
}
function doesNotTargetIFrame(anchor) {
  if (anchor.hasAttribute("target")) {
    for (const element of document.getElementsByName(anchor.target)) {
      if (element instanceof HTMLIFrameElement) return false;
    }
  }
  return true;
}
function findLinkFromClickTarget(target) {
  return findClosestRecursively(target, "a[href]:not([target^=_]):not([download])");
}
function getLocationForLink(link) {
  return expandURL(link.getAttribute("href") || "");
}
function debounce(fn, delay) {
  let timeoutId = null;
  return (...args) => {
    const callback = () => fn.apply(this, args);
    clearTimeout(timeoutId);
    timeoutId = setTimeout(callback, delay);
  };
}
class LimitedSet extends Set {
  constructor(maxSize) {
    super();
    this.maxSize = maxSize;
  }
  add(value) {
    if (this.size >= this.maxSize) {
      const iterator = this.values();
      const oldestValue = iterator.next().value;
      this.delete(oldestValue);
    }
    super.add(value);
  }
}
const recentRequests = new LimitedSet(20);
const nativeFetch = window.fetch;
function fetchWithTurboHeaders(url, options = {}) {
  const modifiedHeaders = new Headers(options.headers || {});
  const requestUID = uuid();
  recentRequests.add(requestUID);
  modifiedHeaders.append("X-Turbo-Request-Id", requestUID);
  return nativeFetch(url, {
    ...options,
    headers: modifiedHeaders
  });
}
function fetchMethodFromString(method) {
  switch (method.toLowerCase()) {
    case "get":
      return FetchMethod.get;
    case "post":
      return FetchMethod.post;
    case "put":
      return FetchMethod.put;
    case "patch":
      return FetchMethod.patch;
    case "delete":
      return FetchMethod.delete;
  }
}
const FetchMethod = {
  get: "get",
  post: "post",
  put: "put",
  patch: "patch",
  delete: "delete"
};
function fetchEnctypeFromString(encoding) {
  switch (encoding.toLowerCase()) {
    case FetchEnctype.multipart:
      return FetchEnctype.multipart;
    case FetchEnctype.plain:
      return FetchEnctype.plain;
    default:
      return FetchEnctype.urlEncoded;
  }
}
const FetchEnctype = {
  urlEncoded: "application/x-www-form-urlencoded",
  multipart: "multipart/form-data",
  plain: "text/plain"
};
class FetchRequest {
  abortController = new AbortController();
  #resolveRequestPromise = _value => {};
  constructor(delegate, method, location, requestBody = new URLSearchParams(), target = null, enctype = FetchEnctype.urlEncoded) {
    const [url, body] = buildResourceAndBody(expandURL(location), method, requestBody, enctype);
    this.delegate = delegate;
    this.url = url;
    this.target = target;
    this.fetchOptions = {
      credentials: "same-origin",
      redirect: "follow",
      method: method,
      headers: {
        ...this.defaultHeaders
      },
      body: body,
      signal: this.abortSignal,
      referrer: this.delegate.referrer?.href
    };
    this.enctype = enctype;
  }
  get method() {
    return this.fetchOptions.method;
  }
  set method(value) {
    const fetchBody = this.isSafe ? this.url.searchParams : this.fetchOptions.body || new FormData();
    const fetchMethod = fetchMethodFromString(value) || FetchMethod.get;
    this.url.search = "";
    const [url, body] = buildResourceAndBody(this.url, fetchMethod, fetchBody, this.enctype);
    this.url = url;
    this.fetchOptions.body = body;
    this.fetchOptions.method = fetchMethod;
  }
  get headers() {
    return this.fetchOptions.headers;
  }
  set headers(value) {
    this.fetchOptions.headers = value;
  }
  get body() {
    if (this.isSafe) {
      return this.url.searchParams;
    } else {
      return this.fetchOptions.body;
    }
  }
  set body(value) {
    this.fetchOptions.body = value;
  }
  get location() {
    return this.url;
  }
  get params() {
    return this.url.searchParams;
  }
  get entries() {
    return this.body ? Array.from(this.body.entries()) : [];
  }
  cancel() {
    this.abortController.abort();
  }
  async perform() {
    const {
      fetchOptions
    } = this;
    this.delegate.prepareRequest(this);
    const event = await this.#allowRequestToBeIntercepted(fetchOptions);
    try {
      this.delegate.requestStarted(this);
      if (event.detail.fetchRequest) {
        this.response = event.detail.fetchRequest.response;
      } else {
        this.response = fetchWithTurboHeaders(this.url.href, fetchOptions);
      }
      const response = await this.response;
      return await this.receive(response);
    } catch (error) {
      if (error.name !== "AbortError") {
        if (this.#willDelegateErrorHandling(error)) {
          this.delegate.requestErrored(this, error);
        }
        throw error;
      }
    } finally {
      this.delegate.requestFinished(this);
    }
  }
  async receive(response) {
    const fetchResponse = new FetchResponse(response);
    const event = dispatch("turbo:before-fetch-response", {
      cancelable: true,
      detail: {
        fetchResponse
      },
      target: this.target
    });
    if (event.defaultPrevented) {
      this.delegate.requestPreventedHandlingResponse(this, fetchResponse);
    } else if (fetchResponse.succeeded) {
      this.delegate.requestSucceededWithResponse(this, fetchResponse);
    } else {
      this.delegate.requestFailedWithResponse(this, fetchResponse);
    }
    return fetchResponse;
  }
  get defaultHeaders() {
    return {
      Accept: "text/html, application/xhtml+xml"
    };
  }
  get isSafe() {
    return isSafe(this.method);
  }
  get abortSignal() {
    return this.abortController.signal;
  }
  acceptResponseType(mimeType) {
    this.headers["Accept"] = [mimeType, this.headers["Accept"]].join(", ");
  }
  async #allowRequestToBeIntercepted(fetchOptions) {
    const requestInterception = new Promise(resolve => this.#resolveRequestPromise = resolve);
    const event = dispatch("turbo:before-fetch-request", {
      cancelable: true,
      detail: {
        fetchOptions,
        url: this.url,
        resume: this.#resolveRequestPromise
      },
      target: this.target
    });
    this.url = event.detail.url;
    if (event.defaultPrevented) await requestInterception;
    return event;
  }
  #willDelegateErrorHandling(error) {
    const event = dispatch("turbo:fetch-request-error", {
      target: this.target,
      cancelable: true,
      detail: {
        request: this,
        error: error
      }
    });
    return !event.defaultPrevented;
  }
}
function isSafe(fetchMethod) {
  return fetchMethodFromString(fetchMethod) == FetchMethod.get;
}
function buildResourceAndBody(resource, method, requestBody, enctype) {
  const searchParams = Array.from(requestBody).length > 0 ? new URLSearchParams(entriesExcludingFiles(requestBody)) : resource.searchParams;
  if (isSafe(method)) {
    return [mergeIntoURLSearchParams(resource, searchParams), null];
  } else if (enctype == FetchEnctype.urlEncoded) {
    return [resource, searchParams];
  } else {
    return [resource, requestBody];
  }
}
function entriesExcludingFiles(requestBody) {
  const entries = [];
  for (const [name, value] of requestBody) {
    if (value instanceof File) continue;else entries.push([name, value]);
  }
  return entries;
}
function mergeIntoURLSearchParams(url, requestBody) {
  const searchParams = new URLSearchParams(entriesExcludingFiles(requestBody));
  url.search = searchParams.toString();
  return url;
}
class AppearanceObserver {
  started = false;
  constructor(delegate, element) {
    this.delegate = delegate;
    this.element = element;
    this.intersectionObserver = new IntersectionObserver(this.intersect);
  }
  start() {
    if (!this.started) {
      this.started = true;
      this.intersectionObserver.observe(this.element);
    }
  }
  stop() {
    if (this.started) {
      this.started = false;
      this.intersectionObserver.unobserve(this.element);
    }
  }
  intersect = entries => {
    const lastEntry = entries.slice(-1)[0];
    if (lastEntry?.isIntersecting) {
      this.delegate.elementAppearedInViewport(this.element);
    }
  };
}
class StreamMessage {
  static contentType = "text/vnd.turbo-stream.html";
  static wrap(message) {
    if (typeof message == "string") {
      return new this(createDocumentFragment(message));
    } else {
      return message;
    }
  }
  constructor(fragment) {
    this.fragment = importStreamElements(fragment);
  }
}
function importStreamElements(fragment) {
  for (const element of fragment.querySelectorAll("turbo-stream")) {
    const streamElement = document.importNode(element, true);
    for (const inertScriptElement of streamElement.templateElement.content.querySelectorAll("script")) {
      inertScriptElement.replaceWith(activateScriptElement(inertScriptElement));
    }
    element.replaceWith(streamElement);
  }
  return fragment;
}
const PREFETCH_DELAY = 100;
class PrefetchCache {
  #prefetchTimeout = null;
  #prefetched = null;
  get(url) {
    if (this.#prefetched && this.#prefetched.url === url && this.#prefetched.expire > Date.now()) {
      return this.#prefetched.request;
    }
  }
  setLater(url, request, ttl) {
    this.clear();
    this.#prefetchTimeout = setTimeout(() => {
      request.perform();
      this.set(url, request, ttl);
      this.#prefetchTimeout = null;
    }, PREFETCH_DELAY);
  }
  set(url, request, ttl) {
    this.#prefetched = {
      url,
      request,
      expire: new Date(new Date().getTime() + ttl)
    };
  }
  clear() {
    if (this.#prefetchTimeout) clearTimeout(this.#prefetchTimeout);
    this.#prefetched = null;
  }
}
const cacheTtl = 10 * 1000;
const prefetchCache = new PrefetchCache();
const FormSubmissionState = {
  initialized: "initialized",
  requesting: "requesting",
  waiting: "waiting",
  receiving: "receiving",
  stopping: "stopping",
  stopped: "stopped"
};
class FormSubmission {
  state = FormSubmissionState.initialized;
  static confirmMethod(message, _element, _submitter) {
    return Promise.resolve(confirm(message));
  }
  constructor(delegate, formElement, submitter, mustRedirect = false) {
    const method = getMethod(formElement, submitter);
    const action = getAction(getFormAction(formElement, submitter), method);
    const body = buildFormData(formElement, submitter);
    const enctype = getEnctype(formElement, submitter);
    this.delegate = delegate;
    this.formElement = formElement;
    this.submitter = submitter;
    this.fetchRequest = new FetchRequest(this, method, action, body, formElement, enctype);
    this.mustRedirect = mustRedirect;
  }
  get method() {
    return this.fetchRequest.method;
  }
  set method(value) {
    this.fetchRequest.method = value;
  }
  get action() {
    return this.fetchRequest.url.toString();
  }
  set action(value) {
    this.fetchRequest.url = expandURL(value);
  }
  get body() {
    return this.fetchRequest.body;
  }
  get enctype() {
    return this.fetchRequest.enctype;
  }
  get isSafe() {
    return this.fetchRequest.isSafe;
  }
  get location() {
    return this.fetchRequest.url;
  }

  // The submission process

  async start() {
    const {
      initialized,
      requesting
    } = FormSubmissionState;
    const confirmationMessage = getAttribute("data-turbo-confirm", this.submitter, this.formElement);
    if (typeof confirmationMessage === "string") {
      const answer = await FormSubmission.confirmMethod(confirmationMessage, this.formElement, this.submitter);
      if (!answer) {
        return;
      }
    }
    if (this.state == initialized) {
      this.state = requesting;
      return this.fetchRequest.perform();
    }
  }
  stop() {
    const {
      stopping,
      stopped
    } = FormSubmissionState;
    if (this.state != stopping && this.state != stopped) {
      this.state = stopping;
      this.fetchRequest.cancel();
      return true;
    }
  }

  // Fetch request delegate

  prepareRequest(request) {
    if (!request.isSafe) {
      const token = getCookieValue(getMetaContent("csrf-param")) || getMetaContent("csrf-token");
      if (token) {
        request.headers["X-CSRF-Token"] = token;
      }
    }
    if (this.requestAcceptsTurboStreamResponse(request)) {
      request.acceptResponseType(StreamMessage.contentType);
    }
  }
  requestStarted(_request) {
    this.state = FormSubmissionState.waiting;
    this.submitter?.setAttribute("disabled", "");
    this.setSubmitsWith();
    markAsBusy(this.formElement);
    dispatch("turbo:submit-start", {
      target: this.formElement,
      detail: {
        formSubmission: this
      }
    });
    this.delegate.formSubmissionStarted(this);
  }
  requestPreventedHandlingResponse(request, response) {
    prefetchCache.clear();
    this.result = {
      success: response.succeeded,
      fetchResponse: response
    };
  }
  requestSucceededWithResponse(request, response) {
    if (response.clientError || response.serverError) {
      this.delegate.formSubmissionFailedWithResponse(this, response);
      return;
    }
    prefetchCache.clear();
    if (this.requestMustRedirect(request) && responseSucceededWithoutRedirect(response)) {
      const error = new Error("Form responses must redirect to another location");
      this.delegate.formSubmissionErrored(this, error);
    } else {
      this.state = FormSubmissionState.receiving;
      this.result = {
        success: true,
        fetchResponse: response
      };
      this.delegate.formSubmissionSucceededWithResponse(this, response);
    }
  }
  requestFailedWithResponse(request, response) {
    this.result = {
      success: false,
      fetchResponse: response
    };
    this.delegate.formSubmissionFailedWithResponse(this, response);
  }
  requestErrored(request, error) {
    this.result = {
      success: false,
      error
    };
    this.delegate.formSubmissionErrored(this, error);
  }
  requestFinished(_request) {
    this.state = FormSubmissionState.stopped;
    this.submitter?.removeAttribute("disabled");
    this.resetSubmitterText();
    clearBusyState(this.formElement);
    dispatch("turbo:submit-end", {
      target: this.formElement,
      detail: {
        formSubmission: this,
        ...this.result
      }
    });
    this.delegate.formSubmissionFinished(this);
  }

  // Private

  setSubmitsWith() {
    if (!this.submitter || !this.submitsWith) return;
    if (this.submitter.matches("button")) {
      this.originalSubmitText = this.submitter.innerHTML;
      this.submitter.innerHTML = this.submitsWith;
    } else if (this.submitter.matches("input")) {
      const input = this.submitter;
      this.originalSubmitText = input.value;
      input.value = this.submitsWith;
    }
  }
  resetSubmitterText() {
    if (!this.submitter || !this.originalSubmitText) return;
    if (this.submitter.matches("button")) {
      this.submitter.innerHTML = this.originalSubmitText;
    } else if (this.submitter.matches("input")) {
      const input = this.submitter;
      input.value = this.originalSubmitText;
    }
  }
  requestMustRedirect(request) {
    return !request.isSafe && this.mustRedirect;
  }
  requestAcceptsTurboStreamResponse(request) {
    return !request.isSafe || hasAttribute("data-turbo-stream", this.submitter, this.formElement);
  }
  get submitsWith() {
    return this.submitter?.getAttribute("data-turbo-submits-with");
  }
}
function buildFormData(formElement, submitter) {
  const formData = new FormData(formElement);
  const name = submitter?.getAttribute("name");
  const value = submitter?.getAttribute("value");
  if (name) {
    formData.append(name, value || "");
  }
  return formData;
}
function getCookieValue(cookieName) {
  if (cookieName != null) {
    const cookies = document.cookie ? document.cookie.split("; ") : [];
    const cookie = cookies.find(cookie => cookie.startsWith(cookieName));
    if (cookie) {
      const value = cookie.split("=").slice(1).join("=");
      return value ? decodeURIComponent(value) : undefined;
    }
  }
}
function responseSucceededWithoutRedirect(response) {
  return response.statusCode == 200 && !response.redirected;
}
function getFormAction(formElement, submitter) {
  const formElementAction = typeof formElement.action === "string" ? formElement.action : null;
  if (submitter?.hasAttribute("formaction")) {
    return submitter.getAttribute("formaction") || "";
  } else {
    return formElement.getAttribute("action") || formElementAction || "";
  }
}
function getAction(formAction, fetchMethod) {
  const action = expandURL(formAction);
  if (isSafe(fetchMethod)) {
    action.search = "";
  }
  return action;
}
function getMethod(formElement, submitter) {
  const method = submitter?.getAttribute("formmethod") || formElement.getAttribute("method") || "";
  return fetchMethodFromString(method.toLowerCase()) || FetchMethod.get;
}
function getEnctype(formElement, submitter) {
  return fetchEnctypeFromString(submitter?.getAttribute("formenctype") || formElement.enctype);
}
class Snapshot {
  constructor(element) {
    this.element = element;
  }
  get activeElement() {
    return this.element.ownerDocument.activeElement;
  }
  get children() {
    return [...this.element.children];
  }
  hasAnchor(anchor) {
    return this.getElementForAnchor(anchor) != null;
  }
  getElementForAnchor(anchor) {
    return anchor ? this.element.querySelector(`[id='${anchor}'], a[name='${anchor}']`) : null;
  }
  get isConnected() {
    return this.element.isConnected;
  }
  get firstAutofocusableElement() {
    return queryAutofocusableElement(this.element);
  }
  get permanentElements() {
    return queryPermanentElementsAll(this.element);
  }
  getPermanentElementById(id) {
    return getPermanentElementById(this.element, id);
  }
  getPermanentElementMapForSnapshot(snapshot) {
    const permanentElementMap = {};
    for (const currentPermanentElement of this.permanentElements) {
      const {
        id
      } = currentPermanentElement;
      const newPermanentElement = snapshot.getPermanentElementById(id);
      if (newPermanentElement) {
        permanentElementMap[id] = [currentPermanentElement, newPermanentElement];
      }
    }
    return permanentElementMap;
  }
}
function getPermanentElementById(node, id) {
  return node.querySelector(`#${id}[data-turbo-permanent]`);
}
function queryPermanentElementsAll(node) {
  return node.querySelectorAll("[id][data-turbo-permanent]");
}
class FormSubmitObserver {
  started = false;
  constructor(delegate, eventTarget) {
    this.delegate = delegate;
    this.eventTarget = eventTarget;
  }
  start() {
    if (!this.started) {
      this.eventTarget.addEventListener("submit", this.submitCaptured, true);
      this.started = true;
    }
  }
  stop() {
    if (this.started) {
      this.eventTarget.removeEventListener("submit", this.submitCaptured, true);
      this.started = false;
    }
  }
  submitCaptured = () => {
    this.eventTarget.removeEventListener("submit", this.submitBubbled, false);
    this.eventTarget.addEventListener("submit", this.submitBubbled, false);
  };
  submitBubbled = event => {
    if (!event.defaultPrevented) {
      const form = event.target instanceof HTMLFormElement ? event.target : undefined;
      const submitter = event.submitter || undefined;
      if (form && submissionDoesNotDismissDialog(form, submitter) && submissionDoesNotTargetIFrame(form, submitter) && this.delegate.willSubmitForm(form, submitter)) {
        event.preventDefault();
        event.stopImmediatePropagation();
        this.delegate.formSubmitted(form, submitter);
      }
    }
  };
}
function submissionDoesNotDismissDialog(form, submitter) {
  const method = submitter?.getAttribute("formmethod") || form.getAttribute("method");
  return method != "dialog";
}
function submissionDoesNotTargetIFrame(form, submitter) {
  if (submitter?.hasAttribute("formtarget") || form.hasAttribute("target")) {
    const target = submitter?.getAttribute("formtarget") || form.target;
    for (const element of document.getElementsByName(target)) {
      if (element instanceof HTMLIFrameElement) return false;
    }
    return true;
  } else {
    return true;
  }
}
class View {
  #resolveRenderPromise = _value => {};
  #resolveInterceptionPromise = _value => {};
  constructor(delegate, element) {
    this.delegate = delegate;
    this.element = element;
  }

  // Scrolling

  scrollToAnchor(anchor) {
    const element = this.snapshot.getElementForAnchor(anchor);
    if (element) {
      this.scrollToElement(element);
      this.focusElement(element);
    } else {
      this.scrollToPosition({
        x: 0,
        y: 0
      });
    }
  }
  scrollToAnchorFromLocation(location) {
    this.scrollToAnchor(getAnchor(location));
  }
  scrollToElement(element) {
    element.scrollIntoView();
  }
  focusElement(element) {
    if (element instanceof HTMLElement) {
      if (element.hasAttribute("tabindex")) {
        element.focus();
      } else {
        element.setAttribute("tabindex", "-1");
        element.focus();
        element.removeAttribute("tabindex");
      }
    }
  }
  scrollToPosition({
    x,
    y
  }) {
    this.scrollRoot.scrollTo(x, y);
  }
  scrollToTop() {
    this.scrollToPosition({
      x: 0,
      y: 0
    });
  }
  get scrollRoot() {
    return window;
  }

  // Rendering

  async render(renderer) {
    const {
      isPreview,
      shouldRender,
      willRender,
      newSnapshot: snapshot
    } = renderer;

    // A workaround to ignore tracked element mismatch reloads when performing
    // a promoted Visit from a frame navigation
    const shouldInvalidate = willRender;
    if (shouldRender) {
      try {
        this.renderPromise = new Promise(resolve => this.#resolveRenderPromise = resolve);
        this.renderer = renderer;
        await this.prepareToRenderSnapshot(renderer);
        const renderInterception = new Promise(resolve => this.#resolveInterceptionPromise = resolve);
        const options = {
          resume: this.#resolveInterceptionPromise,
          render: this.renderer.renderElement,
          renderMethod: this.renderer.renderMethod
        };
        const immediateRender = this.delegate.allowsImmediateRender(snapshot, options);
        if (!immediateRender) await renderInterception;
        await this.renderSnapshot(renderer);
        this.delegate.viewRenderedSnapshot(snapshot, isPreview, this.renderer.renderMethod);
        this.delegate.preloadOnLoadLinksForView(this.element);
        this.finishRenderingSnapshot(renderer);
      } finally {
        delete this.renderer;
        this.#resolveRenderPromise(undefined);
        delete this.renderPromise;
      }
    } else if (shouldInvalidate) {
      this.invalidate(renderer.reloadReason);
    }
  }
  invalidate(reason) {
    this.delegate.viewInvalidated(reason);
  }
  async prepareToRenderSnapshot(renderer) {
    this.markAsPreview(renderer.isPreview);
    await renderer.prepareToRender();
  }
  markAsPreview(isPreview) {
    if (isPreview) {
      this.element.setAttribute("data-turbo-preview", "");
    } else {
      this.element.removeAttribute("data-turbo-preview");
    }
  }
  markVisitDirection(direction) {
    this.element.setAttribute("data-turbo-visit-direction", direction);
  }
  unmarkVisitDirection() {
    this.element.removeAttribute("data-turbo-visit-direction");
  }
  async renderSnapshot(renderer) {
    await renderer.render();
  }
  finishRenderingSnapshot(renderer) {
    renderer.finishRendering();
  }
}
class FrameView extends View {
  missing() {
    this.element.innerHTML = `<strong class="turbo-frame-error">Content missing</strong>`;
  }
  get snapshot() {
    return new Snapshot(this.element);
  }
}
class LinkInterceptor {
  constructor(delegate, element) {
    this.delegate = delegate;
    this.element = element;
  }
  start() {
    this.element.addEventListener("click", this.clickBubbled);
    document.addEventListener("turbo:click", this.linkClicked);
    document.addEventListener("turbo:before-visit", this.willVisit);
  }
  stop() {
    this.element.removeEventListener("click", this.clickBubbled);
    document.removeEventListener("turbo:click", this.linkClicked);
    document.removeEventListener("turbo:before-visit", this.willVisit);
  }
  clickBubbled = event => {
    if (this.respondsToEventTarget(event.target)) {
      this.clickEvent = event;
    } else {
      delete this.clickEvent;
    }
  };
  linkClicked = event => {
    if (this.clickEvent && this.respondsToEventTarget(event.target) && event.target instanceof Element) {
      if (this.delegate.shouldInterceptLinkClick(event.target, event.detail.url, event.detail.originalEvent)) {
        this.clickEvent.preventDefault();
        event.preventDefault();
        this.delegate.linkClickIntercepted(event.target, event.detail.url, event.detail.originalEvent);
      }
    }
    delete this.clickEvent;
  };
  willVisit = _event => {
    delete this.clickEvent;
  };
  respondsToEventTarget(target) {
    const element = target instanceof Element ? target : target instanceof Node ? target.parentElement : null;
    return element && element.closest("turbo-frame, html") == this.element;
  }
}
class LinkClickObserver {
  started = false;
  constructor(delegate, eventTarget) {
    this.delegate = delegate;
    this.eventTarget = eventTarget;
  }
  start() {
    if (!this.started) {
      this.eventTarget.addEventListener("click", this.clickCaptured, true);
      this.started = true;
    }
  }
  stop() {
    if (this.started) {
      this.eventTarget.removeEventListener("click", this.clickCaptured, true);
      this.started = false;
    }
  }
  clickCaptured = () => {
    this.eventTarget.removeEventListener("click", this.clickBubbled, false);
    this.eventTarget.addEventListener("click", this.clickBubbled, false);
  };
  clickBubbled = event => {
    if (event instanceof MouseEvent && this.clickEventIsSignificant(event)) {
      const target = event.composedPath && event.composedPath()[0] || event.target;
      const link = findLinkFromClickTarget(target);
      if (link && doesNotTargetIFrame(link)) {
        const location = getLocationForLink(link);
        if (this.delegate.willFollowLinkToLocation(link, location, event)) {
          event.preventDefault();
          this.delegate.followedLinkToLocation(link, location);
        }
      }
    }
  };
  clickEventIsSignificant(event) {
    return !(event.target && event.target.isContentEditable || event.defaultPrevented || event.which > 1 || event.altKey || event.ctrlKey || event.metaKey || event.shiftKey);
  }
}
class FormLinkClickObserver {
  constructor(delegate, element) {
    this.delegate = delegate;
    this.linkInterceptor = new LinkClickObserver(this, element);
  }
  start() {
    this.linkInterceptor.start();
  }
  stop() {
    this.linkInterceptor.stop();
  }

  // Link hover observer delegate

  canPrefetchRequestToLocation(link, location) {
    return false;
  }
  prefetchAndCacheRequestToLocation(link, location) {
    return;
  }

  // Link click observer delegate

  willFollowLinkToLocation(link, location, originalEvent) {
    return this.delegate.willSubmitFormLinkToLocation(link, location, originalEvent) && (link.hasAttribute("data-turbo-method") || link.hasAttribute("data-turbo-stream"));
  }
  followedLinkToLocation(link, location) {
    const form = document.createElement("form");
    const type = "hidden";
    for (const [name, value] of location.searchParams) {
      form.append(Object.assign(document.createElement("input"), {
        type,
        name,
        value
      }));
    }
    const action = Object.assign(location, {
      search: ""
    });
    form.setAttribute("data-turbo", "true");
    form.setAttribute("action", action.href);
    form.setAttribute("hidden", "");
    const method = link.getAttribute("data-turbo-method");
    if (method) form.setAttribute("method", method);
    const turboFrame = link.getAttribute("data-turbo-frame");
    if (turboFrame) form.setAttribute("data-turbo-frame", turboFrame);
    const turboAction = getVisitAction(link);
    if (turboAction) form.setAttribute("data-turbo-action", turboAction);
    const turboConfirm = link.getAttribute("data-turbo-confirm");
    if (turboConfirm) form.setAttribute("data-turbo-confirm", turboConfirm);
    const turboStream = link.hasAttribute("data-turbo-stream");
    if (turboStream) form.setAttribute("data-turbo-stream", "");
    this.delegate.submittedFormLinkToLocation(link, location, form);
    document.body.appendChild(form);
    form.addEventListener("turbo:submit-end", () => form.remove(), {
      once: true
    });
    requestAnimationFrame(() => form.requestSubmit());
  }
}
class Bardo {
  static async preservingPermanentElements(delegate, permanentElementMap, callback) {
    const bardo = new this(delegate, permanentElementMap);
    bardo.enter();
    await callback();
    bardo.leave();
  }
  constructor(delegate, permanentElementMap) {
    this.delegate = delegate;
    this.permanentElementMap = permanentElementMap;
  }
  enter() {
    for (const id in this.permanentElementMap) {
      const [currentPermanentElement, newPermanentElement] = this.permanentElementMap[id];
      this.delegate.enteringBardo(currentPermanentElement, newPermanentElement);
      this.replaceNewPermanentElementWithPlaceholder(newPermanentElement);
    }
  }
  leave() {
    for (const id in this.permanentElementMap) {
      const [currentPermanentElement] = this.permanentElementMap[id];
      this.replaceCurrentPermanentElementWithClone(currentPermanentElement);
      this.replacePlaceholderWithPermanentElement(currentPermanentElement);
      this.delegate.leavingBardo(currentPermanentElement);
    }
  }
  replaceNewPermanentElementWithPlaceholder(permanentElement) {
    const placeholder = createPlaceholderForPermanentElement(permanentElement);
    permanentElement.replaceWith(placeholder);
  }
  replaceCurrentPermanentElementWithClone(permanentElement) {
    const clone = permanentElement.cloneNode(true);
    permanentElement.replaceWith(clone);
  }
  replacePlaceholderWithPermanentElement(permanentElement) {
    const placeholder = this.getPlaceholderById(permanentElement.id);
    placeholder?.replaceWith(permanentElement);
  }
  getPlaceholderById(id) {
    return this.placeholders.find(element => element.content == id);
  }
  get placeholders() {
    return [...document.querySelectorAll("meta[name=turbo-permanent-placeholder][content]")];
  }
}
function createPlaceholderForPermanentElement(permanentElement) {
  const element = document.createElement("meta");
  element.setAttribute("name", "turbo-permanent-placeholder");
  element.setAttribute("content", permanentElement.id);
  return element;
}
class Renderer {
  #activeElement = null;
  constructor(currentSnapshot, newSnapshot, renderElement, isPreview, willRender = true) {
    this.currentSnapshot = currentSnapshot;
    this.newSnapshot = newSnapshot;
    this.isPreview = isPreview;
    this.willRender = willRender;
    this.renderElement = renderElement;
    this.promise = new Promise((resolve, reject) => this.resolvingFunctions = {
      resolve,
      reject
    });
  }
  get shouldRender() {
    return true;
  }
  get reloadReason() {
    return;
  }
  prepareToRender() {
    return;
  }
  render() {
    // Abstract method
  }
  finishRendering() {
    if (this.resolvingFunctions) {
      this.resolvingFunctions.resolve();
      delete this.resolvingFunctions;
    }
  }
  async preservingPermanentElements(callback) {
    await Bardo.preservingPermanentElements(this, this.permanentElementMap, callback);
  }
  focusFirstAutofocusableElement() {
    const element = this.connectedSnapshot.firstAutofocusableElement;
    if (element) {
      element.focus();
    }
  }

  // Bardo delegate

  enteringBardo(currentPermanentElement) {
    if (this.#activeElement) return;
    if (currentPermanentElement.contains(this.currentSnapshot.activeElement)) {
      this.#activeElement = this.currentSnapshot.activeElement;
    }
  }
  leavingBardo(currentPermanentElement) {
    if (currentPermanentElement.contains(this.#activeElement) && this.#activeElement instanceof HTMLElement) {
      this.#activeElement.focus();
      this.#activeElement = null;
    }
  }
  get connectedSnapshot() {
    return this.newSnapshot.isConnected ? this.newSnapshot : this.currentSnapshot;
  }
  get currentElement() {
    return this.currentSnapshot.element;
  }
  get newElement() {
    return this.newSnapshot.element;
  }
  get permanentElementMap() {
    return this.currentSnapshot.getPermanentElementMapForSnapshot(this.newSnapshot);
  }
  get renderMethod() {
    return "replace";
  }
}
class FrameRenderer extends Renderer {
  static renderElement(currentElement, newElement) {
    const destinationRange = document.createRange();
    destinationRange.selectNodeContents(currentElement);
    destinationRange.deleteContents();
    const frameElement = newElement;
    const sourceRange = frameElement.ownerDocument?.createRange();
    if (sourceRange) {
      sourceRange.selectNodeContents(frameElement);
      currentElement.appendChild(sourceRange.extractContents());
    }
  }
  constructor(delegate, currentSnapshot, newSnapshot, renderElement, isPreview, willRender = true) {
    super(currentSnapshot, newSnapshot, renderElement, isPreview, willRender);
    this.delegate = delegate;
  }
  get shouldRender() {
    return true;
  }
  async render() {
    await nextRepaint();
    this.preservingPermanentElements(() => {
      this.loadFrameElement();
    });
    this.scrollFrameIntoView();
    await nextRepaint();
    this.focusFirstAutofocusableElement();
    await nextRepaint();
    this.activateScriptElements();
  }
  loadFrameElement() {
    this.delegate.willRenderFrame(this.currentElement, this.newElement);
    this.renderElement(this.currentElement, this.newElement);
  }
  scrollFrameIntoView() {
    if (this.currentElement.autoscroll || this.newElement.autoscroll) {
      const element = this.currentElement.firstElementChild;
      const block = readScrollLogicalPosition(this.currentElement.getAttribute("data-autoscroll-block"), "end");
      const behavior = readScrollBehavior(this.currentElement.getAttribute("data-autoscroll-behavior"), "auto");
      if (element) {
        element.scrollIntoView({
          block,
          behavior
        });
        return true;
      }
    }
    return false;
  }
  activateScriptElements() {
    for (const inertScriptElement of this.newScriptElements) {
      const activatedScriptElement = activateScriptElement(inertScriptElement);
      inertScriptElement.replaceWith(activatedScriptElement);
    }
  }
  get newScriptElements() {
    return this.currentElement.querySelectorAll("script");
  }
}
function readScrollLogicalPosition(value, defaultValue) {
  if (value == "end" || value == "start" || value == "center" || value == "nearest") {
    return value;
  } else {
    return defaultValue;
  }
}
function readScrollBehavior(value, defaultValue) {
  if (value == "auto" || value == "smooth") {
    return value;
  } else {
    return defaultValue;
  }
}
class ProgressBar {
  static animationDuration = 300; /*ms*/

  static get defaultCSS() {
    return unindent`
      .turbo-progress-bar {
        position: fixed;
        display: block;
        top: 0;
        left: 0;
        height: 3px;
        background: #0076ff;
        z-index: 2147483647;
        transition:
          width ${ProgressBar.animationDuration}ms ease-out,
          opacity ${ProgressBar.animationDuration / 2}ms ${ProgressBar.animationDuration / 2}ms ease-in;
        transform: translate3d(0, 0, 0);
      }
    `;
  }
  hiding = false;
  value = 0;
  visible = false;
  constructor() {
    this.stylesheetElement = this.createStylesheetElement();
    this.progressElement = this.createProgressElement();
    this.installStylesheetElement();
    this.setValue(0);
  }
  show() {
    if (!this.visible) {
      this.visible = true;
      this.installProgressElement();
      this.startTrickling();
    }
  }
  hide() {
    if (this.visible && !this.hiding) {
      this.hiding = true;
      this.fadeProgressElement(() => {
        this.uninstallProgressElement();
        this.stopTrickling();
        this.visible = false;
        this.hiding = false;
      });
    }
  }
  setValue(value) {
    this.value = value;
    this.refresh();
  }

  // Private

  installStylesheetElement() {
    document.head.insertBefore(this.stylesheetElement, document.head.firstChild);
  }
  installProgressElement() {
    this.progressElement.style.width = "0";
    this.progressElement.style.opacity = "1";
    document.documentElement.insertBefore(this.progressElement, document.body);
    this.refresh();
  }
  fadeProgressElement(callback) {
    this.progressElement.style.opacity = "0";
    setTimeout(callback, ProgressBar.animationDuration * 1.5);
  }
  uninstallProgressElement() {
    if (this.progressElement.parentNode) {
      document.documentElement.removeChild(this.progressElement);
    }
  }
  startTrickling() {
    if (!this.trickleInterval) {
      this.trickleInterval = window.setInterval(this.trickle, ProgressBar.animationDuration);
    }
  }
  stopTrickling() {
    window.clearInterval(this.trickleInterval);
    delete this.trickleInterval;
  }
  trickle = () => {
    this.setValue(this.value + Math.random() / 100);
  };
  refresh() {
    requestAnimationFrame(() => {
      this.progressElement.style.width = `${10 + this.value * 90}%`;
    });
  }
  createStylesheetElement() {
    const element = document.createElement("style");
    element.type = "text/css";
    element.textContent = ProgressBar.defaultCSS;
    if (this.cspNonce) {
      element.nonce = this.cspNonce;
    }
    return element;
  }
  createProgressElement() {
    const element = document.createElement("div");
    element.className = "turbo-progress-bar";
    return element;
  }
  get cspNonce() {
    return getMetaContent("csp-nonce");
  }
}
class HeadSnapshot extends Snapshot {
  detailsByOuterHTML = this.children.filter(element => !elementIsNoscript(element)).map(element => elementWithoutNonce(element)).reduce((result, element) => {
    const {
      outerHTML
    } = element;
    const details = outerHTML in result ? result[outerHTML] : {
      type: elementType(element),
      tracked: elementIsTracked(element),
      elements: []
    };
    return {
      ...result,
      [outerHTML]: {
        ...details,
        elements: [...details.elements, element]
      }
    };
  }, {});
  get trackedElementSignature() {
    return Object.keys(this.detailsByOuterHTML).filter(outerHTML => this.detailsByOuterHTML[outerHTML].tracked).join("");
  }
  getScriptElementsNotInSnapshot(snapshot) {
    return this.getElementsMatchingTypeNotInSnapshot("script", snapshot);
  }
  getStylesheetElementsNotInSnapshot(snapshot) {
    return this.getElementsMatchingTypeNotInSnapshot("stylesheet", snapshot);
  }
  getElementsMatchingTypeNotInSnapshot(matchedType, snapshot) {
    return Object.keys(this.detailsByOuterHTML).filter(outerHTML => !(outerHTML in snapshot.detailsByOuterHTML)).map(outerHTML => this.detailsByOuterHTML[outerHTML]).filter(({
      type
    }) => type == matchedType).map(({
      elements: [element]
    }) => element);
  }
  get provisionalElements() {
    return Object.keys(this.detailsByOuterHTML).reduce((result, outerHTML) => {
      const {
        type,
        tracked,
        elements
      } = this.detailsByOuterHTML[outerHTML];
      if (type == null && !tracked) {
        return [...result, ...elements];
      } else if (elements.length > 1) {
        return [...result, ...elements.slice(1)];
      } else {
        return result;
      }
    }, []);
  }
  getMetaValue(name) {
    const element = this.findMetaElementByName(name);
    return element ? element.getAttribute("content") : null;
  }
  findMetaElementByName(name) {
    return Object.keys(this.detailsByOuterHTML).reduce((result, outerHTML) => {
      const {
        elements: [element]
      } = this.detailsByOuterHTML[outerHTML];
      return elementIsMetaElementWithName(element, name) ? element : result;
    }, undefined | undefined);
  }
}
function elementType(element) {
  if (elementIsScript(element)) {
    return "script";
  } else if (elementIsStylesheet(element)) {
    return "stylesheet";
  }
}
function elementIsTracked(element) {
  return element.getAttribute("data-turbo-track") == "reload";
}
function elementIsScript(element) {
  const tagName = element.localName;
  return tagName == "script";
}
function elementIsNoscript(element) {
  const tagName = element.localName;
  return tagName == "noscript";
}
function elementIsStylesheet(element) {
  const tagName = element.localName;
  return tagName == "style" || tagName == "link" && element.getAttribute("rel") == "stylesheet";
}
function elementIsMetaElementWithName(element, name) {
  const tagName = element.localName;
  return tagName == "meta" && element.getAttribute("name") == name;
}
function elementWithoutNonce(element) {
  if (element.hasAttribute("nonce")) {
    element.setAttribute("nonce", "");
  }
  return element;
}
class PageSnapshot extends Snapshot {
  static fromHTMLString(html = "") {
    return this.fromDocument(parseHTMLDocument(html));
  }
  static fromElement(element) {
    return this.fromDocument(element.ownerDocument);
  }
  static fromDocument({
    documentElement,
    body,
    head
  }) {
    return new this(documentElement, body, new HeadSnapshot(head));
  }
  constructor(documentElement, body, headSnapshot) {
    super(body);
    this.documentElement = documentElement;
    this.headSnapshot = headSnapshot;
  }
  clone() {
    const clonedElement = this.element.cloneNode(true);
    const selectElements = this.element.querySelectorAll("select");
    const clonedSelectElements = clonedElement.querySelectorAll("select");
    for (const [index, source] of selectElements.entries()) {
      const clone = clonedSelectElements[index];
      for (const option of clone.selectedOptions) option.selected = false;
      for (const option of source.selectedOptions) clone.options[option.index].selected = true;
    }
    for (const clonedPasswordInput of clonedElement.querySelectorAll('input[type="password"]')) {
      clonedPasswordInput.value = "";
    }
    return new PageSnapshot(this.documentElement, clonedElement, this.headSnapshot);
  }
  get lang() {
    return this.documentElement.getAttribute("lang");
  }
  get headElement() {
    return this.headSnapshot.element;
  }
  get rootLocation() {
    const root = this.getSetting("root") ?? "/";
    return expandURL(root);
  }
  get cacheControlValue() {
    return this.getSetting("cache-control");
  }
  get isPreviewable() {
    return this.cacheControlValue != "no-preview";
  }
  get isCacheable() {
    return this.cacheControlValue != "no-cache";
  }
  get isVisitable() {
    return this.getSetting("visit-control") != "reload";
  }
  get prefersViewTransitions() {
    return this.headSnapshot.getMetaValue("view-transition") === "same-origin";
  }
  get shouldMorphPage() {
    return this.getSetting("refresh-method") === "morph";
  }
  get shouldPreserveScrollPosition() {
    return this.getSetting("refresh-scroll") === "preserve";
  }

  // Private

  getSetting(name) {
    return this.headSnapshot.getMetaValue(`turbo-${name}`);
  }
}
class ViewTransitioner {
  #viewTransitionStarted = false;
  #lastOperation = Promise.resolve();
  renderChange(useViewTransition, render) {
    if (useViewTransition && this.viewTransitionsAvailable && !this.#viewTransitionStarted) {
      this.#viewTransitionStarted = true;
      this.#lastOperation = this.#lastOperation.then(async () => {
        await document.startViewTransition(render).finished;
      });
    } else {
      this.#lastOperation = this.#lastOperation.then(render);
    }
    return this.#lastOperation;
  }
  get viewTransitionsAvailable() {
    return document.startViewTransition;
  }
}
const defaultOptions = {
  action: "advance",
  historyChanged: false,
  visitCachedSnapshot: () => {},
  willRender: true,
  updateHistory: true,
  shouldCacheSnapshot: true,
  acceptsStreamResponse: false
};
const TimingMetric = {
  visitStart: "visitStart",
  requestStart: "requestStart",
  requestEnd: "requestEnd",
  visitEnd: "visitEnd"
};
const VisitState = {
  initialized: "initialized",
  started: "started",
  canceled: "canceled",
  failed: "failed",
  completed: "completed"
};
const SystemStatusCode = {
  networkFailure: 0,
  timeoutFailure: -1,
  contentTypeMismatch: -2
};
const Direction = {
  advance: "forward",
  restore: "back",
  replace: "none"
};
class Visit {
  identifier = uuid(); // Required by turbo-ios
  timingMetrics = {};
  followedRedirect = false;
  historyChanged = false;
  scrolled = false;
  shouldCacheSnapshot = true;
  acceptsStreamResponse = false;
  snapshotCached = false;
  state = VisitState.initialized;
  viewTransitioner = new ViewTransitioner();
  constructor(delegate, location, restorationIdentifier, options = {}) {
    this.delegate = delegate;
    this.location = location;
    this.restorationIdentifier = restorationIdentifier || uuid();
    const {
      action,
      historyChanged,
      referrer,
      snapshot,
      snapshotHTML,
      response,
      visitCachedSnapshot,
      willRender,
      updateHistory,
      shouldCacheSnapshot,
      acceptsStreamResponse,
      direction
    } = {
      ...defaultOptions,
      ...options
    };
    this.action = action;
    this.historyChanged = historyChanged;
    this.referrer = referrer;
    this.snapshot = snapshot;
    this.snapshotHTML = snapshotHTML;
    this.response = response;
    this.isSamePage = this.delegate.locationWithActionIsSamePage(this.location, this.action);
    this.isPageRefresh = this.view.isPageRefresh(this);
    this.visitCachedSnapshot = visitCachedSnapshot;
    this.willRender = willRender;
    this.updateHistory = updateHistory;
    this.scrolled = !willRender;
    this.shouldCacheSnapshot = shouldCacheSnapshot;
    this.acceptsStreamResponse = acceptsStreamResponse;
    this.direction = direction || Direction[action];
  }
  get adapter() {
    return this.delegate.adapter;
  }
  get view() {
    return this.delegate.view;
  }
  get history() {
    return this.delegate.history;
  }
  get restorationData() {
    return this.history.getRestorationDataForIdentifier(this.restorationIdentifier);
  }
  get silent() {
    return this.isSamePage;
  }
  start() {
    if (this.state == VisitState.initialized) {
      this.recordTimingMetric(TimingMetric.visitStart);
      this.state = VisitState.started;
      this.adapter.visitStarted(this);
      this.delegate.visitStarted(this);
    }
  }
  cancel() {
    if (this.state == VisitState.started) {
      if (this.request) {
        this.request.cancel();
      }
      this.cancelRender();
      this.state = VisitState.canceled;
    }
  }
  complete() {
    if (this.state == VisitState.started) {
      this.recordTimingMetric(TimingMetric.visitEnd);
      this.adapter.visitCompleted(this);
      this.state = VisitState.completed;
      this.followRedirect();
      if (!this.followedRedirect) {
        this.delegate.visitCompleted(this);
      }
    }
  }
  fail() {
    if (this.state == VisitState.started) {
      this.state = VisitState.failed;
      this.adapter.visitFailed(this);
      this.delegate.visitCompleted(this);
    }
  }
  changeHistory() {
    if (!this.historyChanged && this.updateHistory) {
      const actionForHistory = this.location.href === this.referrer?.href ? "replace" : this.action;
      const method = getHistoryMethodForAction(actionForHistory);
      this.history.update(method, this.location, this.restorationIdentifier);
      this.historyChanged = true;
    }
  }
  issueRequest() {
    if (this.hasPreloadedResponse()) {
      this.simulateRequest();
    } else if (this.shouldIssueRequest() && !this.request) {
      this.request = new FetchRequest(this, FetchMethod.get, this.location);
      this.request.perform();
    }
  }
  simulateRequest() {
    if (this.response) {
      this.startRequest();
      this.recordResponse();
      this.finishRequest();
    }
  }
  startRequest() {
    this.recordTimingMetric(TimingMetric.requestStart);
    this.adapter.visitRequestStarted(this);
  }
  recordResponse(response = this.response) {
    this.response = response;
    if (response) {
      const {
        statusCode
      } = response;
      if (isSuccessful(statusCode)) {
        this.adapter.visitRequestCompleted(this);
      } else {
        this.adapter.visitRequestFailedWithStatusCode(this, statusCode);
      }
    }
  }
  finishRequest() {
    this.recordTimingMetric(TimingMetric.requestEnd);
    this.adapter.visitRequestFinished(this);
  }
  loadResponse() {
    if (this.response) {
      const {
        statusCode,
        responseHTML
      } = this.response;
      this.render(async () => {
        if (this.shouldCacheSnapshot) this.cacheSnapshot();
        if (this.view.renderPromise) await this.view.renderPromise;
        if (isSuccessful(statusCode) && responseHTML != null) {
          const snapshot = PageSnapshot.fromHTMLString(responseHTML);
          await this.renderPageSnapshot(snapshot, false);
          this.adapter.visitRendered(this);
          this.complete();
        } else {
          await this.view.renderError(PageSnapshot.fromHTMLString(responseHTML), this);
          this.adapter.visitRendered(this);
          this.fail();
        }
      });
    }
  }
  getCachedSnapshot() {
    const snapshot = this.view.getCachedSnapshotForLocation(this.location) || this.getPreloadedSnapshot();
    if (snapshot && (!getAnchor(this.location) || snapshot.hasAnchor(getAnchor(this.location)))) {
      if (this.action == "restore" || snapshot.isPreviewable) {
        return snapshot;
      }
    }
  }
  getPreloadedSnapshot() {
    if (this.snapshotHTML) {
      return PageSnapshot.fromHTMLString(this.snapshotHTML);
    }
  }
  hasCachedSnapshot() {
    return this.getCachedSnapshot() != null;
  }
  loadCachedSnapshot() {
    const snapshot = this.getCachedSnapshot();
    if (snapshot) {
      const isPreview = this.shouldIssueRequest();
      this.render(async () => {
        this.cacheSnapshot();
        if (this.isSamePage || this.isPageRefresh) {
          this.adapter.visitRendered(this);
        } else {
          if (this.view.renderPromise) await this.view.renderPromise;
          await this.renderPageSnapshot(snapshot, isPreview);
          this.adapter.visitRendered(this);
          if (!isPreview) {
            this.complete();
          }
        }
      });
    }
  }
  followRedirect() {
    if (this.redirectedToLocation && !this.followedRedirect && this.response?.redirected) {
      this.adapter.visitProposedToLocation(this.redirectedToLocation, {
        action: "replace",
        response: this.response,
        shouldCacheSnapshot: false,
        willRender: false
      });
      this.followedRedirect = true;
    }
  }
  goToSamePageAnchor() {
    if (this.isSamePage) {
      this.render(async () => {
        this.cacheSnapshot();
        this.performScroll();
        this.changeHistory();
        this.adapter.visitRendered(this);
      });
    }
  }

  // Fetch request delegate

  prepareRequest(request) {
    if (this.acceptsStreamResponse) {
      request.acceptResponseType(StreamMessage.contentType);
    }
  }
  requestStarted() {
    this.startRequest();
  }
  requestPreventedHandlingResponse(_request, _response) {}
  async requestSucceededWithResponse(request, response) {
    const responseHTML = await response.responseHTML;
    const {
      redirected,
      statusCode
    } = response;
    if (responseHTML == undefined) {
      this.recordResponse({
        statusCode: SystemStatusCode.contentTypeMismatch,
        redirected
      });
    } else {
      this.redirectedToLocation = response.redirected ? response.location : undefined;
      this.recordResponse({
        statusCode: statusCode,
        responseHTML,
        redirected
      });
    }
  }
  async requestFailedWithResponse(request, response) {
    const responseHTML = await response.responseHTML;
    const {
      redirected,
      statusCode
    } = response;
    if (responseHTML == undefined) {
      this.recordResponse({
        statusCode: SystemStatusCode.contentTypeMismatch,
        redirected
      });
    } else {
      this.recordResponse({
        statusCode: statusCode,
        responseHTML,
        redirected
      });
    }
  }
  requestErrored(_request, _error) {
    this.recordResponse({
      statusCode: SystemStatusCode.networkFailure,
      redirected: false
    });
  }
  requestFinished() {
    this.finishRequest();
  }

  // Scrolling

  performScroll() {
    if (!this.scrolled && !this.view.forceReloaded && !this.view.shouldPreserveScrollPosition(this)) {
      if (this.action == "restore") {
        this.scrollToRestoredPosition() || this.scrollToAnchor() || this.view.scrollToTop();
      } else {
        this.scrollToAnchor() || this.view.scrollToTop();
      }
      if (this.isSamePage) {
        this.delegate.visitScrolledToSamePageLocation(this.view.lastRenderedLocation, this.location);
      }
      this.scrolled = true;
    }
  }
  scrollToRestoredPosition() {
    const {
      scrollPosition
    } = this.restorationData;
    if (scrollPosition) {
      this.view.scrollToPosition(scrollPosition);
      return true;
    }
  }
  scrollToAnchor() {
    const anchor = getAnchor(this.location);
    if (anchor != null) {
      this.view.scrollToAnchor(anchor);
      return true;
    }
  }

  // Instrumentation

  recordTimingMetric(metric) {
    this.timingMetrics[metric] = new Date().getTime();
  }
  getTimingMetrics() {
    return {
      ...this.timingMetrics
    };
  }

  // Private

  getHistoryMethodForAction(action) {
    switch (action) {
      case "replace":
        return history.replaceState;
      case "advance":
      case "restore":
        return history.pushState;
    }
  }
  hasPreloadedResponse() {
    return typeof this.response == "object";
  }
  shouldIssueRequest() {
    if (this.isSamePage) {
      return false;
    } else if (this.action == "restore") {
      return !this.hasCachedSnapshot();
    } else {
      return this.willRender;
    }
  }
  cacheSnapshot() {
    if (!this.snapshotCached) {
      this.view.cacheSnapshot(this.snapshot).then(snapshot => snapshot && this.visitCachedSnapshot(snapshot));
      this.snapshotCached = true;
    }
  }
  async render(callback) {
    this.cancelRender();
    this.frame = await nextRepaint();
    await callback();
    delete this.frame;
  }
  async renderPageSnapshot(snapshot, isPreview) {
    await this.viewTransitioner.renderChange(this.view.shouldTransitionTo(snapshot), async () => {
      await this.view.renderPage(snapshot, isPreview, this.willRender, this);
      this.performScroll();
    });
  }
  cancelRender() {
    if (this.frame) {
      cancelAnimationFrame(this.frame);
      delete this.frame;
    }
  }
}
function isSuccessful(statusCode) {
  return statusCode >= 200 && statusCode < 300;
}
class BrowserAdapter {
  progressBar = new ProgressBar();
  constructor(session) {
    this.session = session;
  }
  visitProposedToLocation(location, options) {
    if (locationIsVisitable(location, this.navigator.rootLocation)) {
      this.navigator.startVisit(location, options?.restorationIdentifier || uuid(), options);
    } else {
      window.location.href = location.toString();
    }
  }
  visitStarted(visit) {
    this.location = visit.location;
    visit.loadCachedSnapshot();
    visit.issueRequest();
    visit.goToSamePageAnchor();
  }
  visitRequestStarted(visit) {
    this.progressBar.setValue(0);
    if (visit.hasCachedSnapshot() || visit.action != "restore") {
      this.showVisitProgressBarAfterDelay();
    } else {
      this.showProgressBar();
    }
  }
  visitRequestCompleted(visit) {
    visit.loadResponse();
  }
  visitRequestFailedWithStatusCode(visit, statusCode) {
    switch (statusCode) {
      case SystemStatusCode.networkFailure:
      case SystemStatusCode.timeoutFailure:
      case SystemStatusCode.contentTypeMismatch:
        return this.reload({
          reason: "request_failed",
          context: {
            statusCode
          }
        });
      default:
        return visit.loadResponse();
    }
  }
  visitRequestFinished(_visit) {}
  visitCompleted(_visit) {
    this.progressBar.setValue(1);
    this.hideVisitProgressBar();
  }
  pageInvalidated(reason) {
    this.reload(reason);
  }
  visitFailed(_visit) {
    this.progressBar.setValue(1);
    this.hideVisitProgressBar();
  }
  visitRendered(_visit) {}

  // Form Submission Delegate

  formSubmissionStarted(_formSubmission) {
    this.progressBar.setValue(0);
    this.showFormProgressBarAfterDelay();
  }
  formSubmissionFinished(_formSubmission) {
    this.progressBar.setValue(1);
    this.hideFormProgressBar();
  }

  // Private

  showVisitProgressBarAfterDelay() {
    this.visitProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay);
  }
  hideVisitProgressBar() {
    this.progressBar.hide();
    if (this.visitProgressBarTimeout != null) {
      window.clearTimeout(this.visitProgressBarTimeout);
      delete this.visitProgressBarTimeout;
    }
  }
  showFormProgressBarAfterDelay() {
    if (this.formProgressBarTimeout == null) {
      this.formProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay);
    }
  }
  hideFormProgressBar() {
    this.progressBar.hide();
    if (this.formProgressBarTimeout != null) {
      window.clearTimeout(this.formProgressBarTimeout);
      delete this.formProgressBarTimeout;
    }
  }
  showProgressBar = () => {
    this.progressBar.show();
  };
  reload(reason) {
    dispatch("turbo:reload", {
      detail: reason
    });
    window.location.href = this.location?.toString() || window.location.href;
  }
  get navigator() {
    return this.session.navigator;
  }
}
class CacheObserver {
  selector = "[data-turbo-temporary]";
  deprecatedSelector = "[data-turbo-cache=false]";
  started = false;
  start() {
    if (!this.started) {
      this.started = true;
      addEventListener("turbo:before-cache", this.removeTemporaryElements, false);
    }
  }
  stop() {
    if (this.started) {
      this.started = false;
      removeEventListener("turbo:before-cache", this.removeTemporaryElements, false);
    }
  }
  removeTemporaryElements = _event => {
    for (const element of this.temporaryElements) {
      element.remove();
    }
  };
  get temporaryElements() {
    return [...document.querySelectorAll(this.selector), ...this.temporaryElementsWithDeprecation];
  }
  get temporaryElementsWithDeprecation() {
    const elements = document.querySelectorAll(this.deprecatedSelector);
    if (elements.length) {
      console.warn(`The ${this.deprecatedSelector} selector is deprecated and will be removed in a future version. Use ${this.selector} instead.`);
    }
    return [...elements];
  }
}
class FrameRedirector {
  constructor(session, element) {
    this.session = session;
    this.element = element;
    this.linkInterceptor = new LinkInterceptor(this, element);
    this.formSubmitObserver = new FormSubmitObserver(this, element);
  }
  start() {
    this.linkInterceptor.start();
    this.formSubmitObserver.start();
  }
  stop() {
    this.linkInterceptor.stop();
    this.formSubmitObserver.stop();
  }

  // Link interceptor delegate

  shouldInterceptLinkClick(element, _location, _event) {
    return this.#shouldRedirect(element);
  }
  linkClickIntercepted(element, url, event) {
    const frame = this.#findFrameElement(element);
    if (frame) {
      frame.delegate.linkClickIntercepted(element, url, event);
    }
  }

  // Form submit observer delegate

  willSubmitForm(element, submitter) {
    return element.closest("turbo-frame") == null && this.#shouldSubmit(element, submitter) && this.#shouldRedirect(element, submitter);
  }
  formSubmitted(element, submitter) {
    const frame = this.#findFrameElement(element, submitter);
    if (frame) {
      frame.delegate.formSubmitted(element, submitter);
    }
  }
  #shouldSubmit(form, submitter) {
    const action = getAction$1(form, submitter);
    const meta = this.element.ownerDocument.querySelector(`meta[name="turbo-root"]`);
    const rootLocation = expandURL(meta?.content ?? "/");
    return this.#shouldRedirect(form, submitter) && locationIsVisitable(action, rootLocation);
  }
  #shouldRedirect(element, submitter) {
    const isNavigatable = element instanceof HTMLFormElement ? this.session.submissionIsNavigatable(element, submitter) : this.session.elementIsNavigatable(element);
    if (isNavigatable) {
      const frame = this.#findFrameElement(element, submitter);
      return frame ? frame != element.closest("turbo-frame") : false;
    } else {
      return false;
    }
  }
  #findFrameElement(element, submitter) {
    const id = submitter?.getAttribute("data-turbo-frame") || element.getAttribute("data-turbo-frame");
    if (id && id != "_top") {
      const frame = this.element.querySelector(`#${id}:not([disabled])`);
      if (frame instanceof FrameElement) {
        return frame;
      }
    }
  }
}
class History {
  location;
  restorationIdentifier = uuid();
  restorationData = {};
  started = false;
  pageLoaded = false;
  currentIndex = 0;
  constructor(delegate) {
    this.delegate = delegate;
  }
  start() {
    if (!this.started) {
      addEventListener("popstate", this.onPopState, false);
      addEventListener("load", this.onPageLoad, false);
      this.currentIndex = history.state?.turbo?.restorationIndex || 0;
      this.started = true;
      this.replace(new URL(window.location.href));
    }
  }
  stop() {
    if (this.started) {
      removeEventListener("popstate", this.onPopState, false);
      removeEventListener("load", this.onPageLoad, false);
      this.started = false;
    }
  }
  push(location, restorationIdentifier) {
    this.update(history.pushState, location, restorationIdentifier);
  }
  replace(location, restorationIdentifier) {
    this.update(history.replaceState, location, restorationIdentifier);
  }
  update(method, location, restorationIdentifier = uuid()) {
    if (method === history.pushState) ++this.currentIndex;
    const state = {
      turbo: {
        restorationIdentifier,
        restorationIndex: this.currentIndex
      }
    };
    method.call(history, state, "", location.href);
    this.location = location;
    this.restorationIdentifier = restorationIdentifier;
  }

  // Restoration data

  getRestorationDataForIdentifier(restorationIdentifier) {
    return this.restorationData[restorationIdentifier] || {};
  }
  updateRestorationData(additionalData) {
    const {
      restorationIdentifier
    } = this;
    const restorationData = this.restorationData[restorationIdentifier];
    this.restorationData[restorationIdentifier] = {
      ...restorationData,
      ...additionalData
    };
  }

  // Scroll restoration

  assumeControlOfScrollRestoration() {
    if (!this.previousScrollRestoration) {
      this.previousScrollRestoration = history.scrollRestoration ?? "auto";
      history.scrollRestoration = "manual";
    }
  }
  relinquishControlOfScrollRestoration() {
    if (this.previousScrollRestoration) {
      history.scrollRestoration = this.previousScrollRestoration;
      delete this.previousScrollRestoration;
    }
  }

  // Event handlers

  onPopState = event => {
    if (this.shouldHandlePopState()) {
      const {
        turbo
      } = event.state || {};
      if (turbo) {
        this.location = new URL(window.location.href);
        const {
          restorationIdentifier,
          restorationIndex
        } = turbo;
        this.restorationIdentifier = restorationIdentifier;
        const direction = restorationIndex > this.currentIndex ? "forward" : "back";
        this.delegate.historyPoppedToLocationWithRestorationIdentifierAndDirection(this.location, restorationIdentifier, direction);
        this.currentIndex = restorationIndex;
      }
    }
  };
  onPageLoad = async _event => {
    await nextMicrotask();
    this.pageLoaded = true;
  };

  // Private

  shouldHandlePopState() {
    // Safari dispatches a popstate event after window's load event, ignore it
    return this.pageIsLoaded();
  }
  pageIsLoaded() {
    return this.pageLoaded || document.readyState == "complete";
  }
}
class LinkPrefetchObserver {
  started = false;
  #prefetchedLink = null;
  constructor(delegate, eventTarget) {
    this.delegate = delegate;
    this.eventTarget = eventTarget;
  }
  start() {
    if (this.started) return;
    if (this.eventTarget.readyState === "loading") {
      this.eventTarget.addEventListener("DOMContentLoaded", this.#enable, {
        once: true
      });
    } else {
      this.#enable();
    }
  }
  stop() {
    if (!this.started) return;
    this.eventTarget.removeEventListener("mouseenter", this.#tryToPrefetchRequest, {
      capture: true,
      passive: true
    });
    this.eventTarget.removeEventListener("mouseleave", this.#cancelRequestIfObsolete, {
      capture: true,
      passive: true
    });
    this.eventTarget.removeEventListener("turbo:before-fetch-request", this.#tryToUsePrefetchedRequest, true);
    this.started = false;
  }
  #enable = () => {
    this.eventTarget.addEventListener("mouseenter", this.#tryToPrefetchRequest, {
      capture: true,
      passive: true
    });
    this.eventTarget.addEventListener("mouseleave", this.#cancelRequestIfObsolete, {
      capture: true,
      passive: true
    });
    this.eventTarget.addEventListener("turbo:before-fetch-request", this.#tryToUsePrefetchedRequest, true);
    this.started = true;
  };
  #tryToPrefetchRequest = event => {
    if (getMetaContent("turbo-prefetch") === "false") return;
    const target = event.target;
    const isLink = target.matches && target.matches("a[href]:not([target^=_]):not([download])");
    if (isLink && this.#isPrefetchable(target)) {
      const link = target;
      const location = getLocationForLink(link);
      if (this.delegate.canPrefetchRequestToLocation(link, location)) {
        this.#prefetchedLink = link;
        const fetchRequest = new FetchRequest(this, FetchMethod.get, location, new URLSearchParams(), target);
        prefetchCache.setLater(location.toString(), fetchRequest, this.#cacheTtl);
      }
    }
  };
  #cancelRequestIfObsolete = event => {
    if (event.target === this.#prefetchedLink) this.#cancelPrefetchRequest();
  };
  #cancelPrefetchRequest = () => {
    prefetchCache.clear();
    this.#prefetchedLink = null;
  };
  #tryToUsePrefetchedRequest = event => {
    if (event.target.tagName !== "FORM" && event.detail.fetchOptions.method === "get") {
      const cached = prefetchCache.get(event.detail.url.toString());
      if (cached) {
        // User clicked link, use cache response
        event.detail.fetchRequest = cached;
      }
      prefetchCache.clear();
    }
  };
  prepareRequest(request) {
    const link = request.target;
    request.headers["X-Sec-Purpose"] = "prefetch";
    const turboFrame = link.closest("turbo-frame");
    const turboFrameTarget = link.getAttribute("data-turbo-frame") || turboFrame?.getAttribute("target") || turboFrame?.id;
    if (turboFrameTarget && turboFrameTarget !== "_top") {
      request.headers["Turbo-Frame"] = turboFrameTarget;
    }
  }

  // Fetch request interface

  requestSucceededWithResponse() {}
  requestStarted(fetchRequest) {}
  requestErrored(fetchRequest) {}
  requestFinished(fetchRequest) {}
  requestPreventedHandlingResponse(fetchRequest, fetchResponse) {}
  requestFailedWithResponse(fetchRequest, fetchResponse) {}
  get #cacheTtl() {
    return Number(getMetaContent("turbo-prefetch-cache-time")) || cacheTtl;
  }
  #isPrefetchable(link) {
    const href = link.getAttribute("href");
    if (!href) return false;
    if (unfetchableLink(link)) return false;
    if (linkToTheSamePage(link)) return false;
    if (linkOptsOut(link)) return false;
    if (nonSafeLink(link)) return false;
    if (eventPrevented(link)) return false;
    return true;
  }
}
const unfetchableLink = link => {
  return link.origin !== document.location.origin || !["http:", "https:"].includes(link.protocol) || link.hasAttribute("target");
};
const linkToTheSamePage = link => {
  return link.pathname + link.search === document.location.pathname + document.location.search || link.href.startsWith("#");
};
const linkOptsOut = link => {
  if (link.getAttribute("data-turbo-prefetch") === "false") return true;
  if (link.getAttribute("data-turbo") === "false") return true;
  const turboPrefetchParent = findClosestRecursively(link, "[data-turbo-prefetch]");
  if (turboPrefetchParent && turboPrefetchParent.getAttribute("data-turbo-prefetch") === "false") return true;
  return false;
};
const nonSafeLink = link => {
  const turboMethod = link.getAttribute("data-turbo-method");
  if (turboMethod && turboMethod.toLowerCase() !== "get") return true;
  if (isUJS(link)) return true;
  if (link.hasAttribute("data-turbo-confirm")) return true;
  if (link.hasAttribute("data-turbo-stream")) return true;
  return false;
};
const isUJS = link => {
  return link.hasAttribute("data-remote") || link.hasAttribute("data-behavior") || link.hasAttribute("data-confirm") || link.hasAttribute("data-method");
};
const eventPrevented = link => {
  const event = dispatch("turbo:before-prefetch", {
    target: link,
    cancelable: true
  });
  return event.defaultPrevented;
};
class Navigator {
  constructor(delegate) {
    this.delegate = delegate;
  }
  proposeVisit(location, options = {}) {
    if (this.delegate.allowsVisitingLocationWithAction(location, options.action)) {
      this.delegate.visitProposedToLocation(location, options);
    }
  }
  startVisit(locatable, restorationIdentifier, options = {}) {
    this.stop();
    this.currentVisit = new Visit(this, expandURL(locatable), restorationIdentifier, {
      referrer: this.location,
      ...options
    });
    this.currentVisit.start();
  }
  submitForm(form, submitter) {
    this.stop();
    this.formSubmission = new FormSubmission(this, form, submitter, true);
    this.formSubmission.start();
  }
  stop() {
    if (this.formSubmission) {
      this.formSubmission.stop();
      delete this.formSubmission;
    }
    if (this.currentVisit) {
      this.currentVisit.cancel();
      delete this.currentVisit;
    }
  }
  get adapter() {
    return this.delegate.adapter;
  }
  get view() {
    return this.delegate.view;
  }
  get rootLocation() {
    return this.view.snapshot.rootLocation;
  }
  get history() {
    return this.delegate.history;
  }

  // Form submission delegate

  formSubmissionStarted(formSubmission) {
    // Not all adapters implement formSubmissionStarted
    if (typeof this.adapter.formSubmissionStarted === "function") {
      this.adapter.formSubmissionStarted(formSubmission);
    }
  }
  async formSubmissionSucceededWithResponse(formSubmission, fetchResponse) {
    if (formSubmission == this.formSubmission) {
      const responseHTML = await fetchResponse.responseHTML;
      if (responseHTML) {
        const shouldCacheSnapshot = formSubmission.isSafe;
        if (!shouldCacheSnapshot) {
          this.view.clearSnapshotCache();
        }
        const {
          statusCode,
          redirected
        } = fetchResponse;
        const action = this.#getActionForFormSubmission(formSubmission, fetchResponse);
        const visitOptions = {
          action,
          shouldCacheSnapshot,
          response: {
            statusCode,
            responseHTML,
            redirected
          }
        };
        this.proposeVisit(fetchResponse.location, visitOptions);
      }
    }
  }
  async formSubmissionFailedWithResponse(formSubmission, fetchResponse) {
    const responseHTML = await fetchResponse.responseHTML;
    if (responseHTML) {
      const snapshot = PageSnapshot.fromHTMLString(responseHTML);
      if (fetchResponse.serverError) {
        await this.view.renderError(snapshot, this.currentVisit);
      } else {
        await this.view.renderPage(snapshot, false, true, this.currentVisit);
      }
      if (!snapshot.shouldPreserveScrollPosition) {
        this.view.scrollToTop();
      }
      this.view.clearSnapshotCache();
    }
  }
  formSubmissionErrored(formSubmission, error) {
    console.error(error);
  }
  formSubmissionFinished(formSubmission) {
    // Not all adapters implement formSubmissionFinished
    if (typeof this.adapter.formSubmissionFinished === "function") {
      this.adapter.formSubmissionFinished(formSubmission);
    }
  }

  // Visit delegate

  visitStarted(visit) {
    this.delegate.visitStarted(visit);
  }
  visitCompleted(visit) {
    this.delegate.visitCompleted(visit);
  }
  locationWithActionIsSamePage(location, action) {
    const anchor = getAnchor(location);
    const currentAnchor = getAnchor(this.view.lastRenderedLocation);
    const isRestorationToTop = action === "restore" && typeof anchor === "undefined";
    return action !== "replace" && getRequestURL(location) === getRequestURL(this.view.lastRenderedLocation) && (isRestorationToTop || anchor != null && anchor !== currentAnchor);
  }
  visitScrolledToSamePageLocation(oldURL, newURL) {
    this.delegate.visitScrolledToSamePageLocation(oldURL, newURL);
  }

  // Visits

  get location() {
    return this.history.location;
  }
  get restorationIdentifier() {
    return this.history.restorationIdentifier;
  }
  #getActionForFormSubmission(formSubmission, fetchResponse) {
    const {
      submitter,
      formElement
    } = formSubmission;
    return getVisitAction(submitter, formElement) || this.#getDefaultAction(fetchResponse);
  }
  #getDefaultAction(fetchResponse) {
    const sameLocationRedirect = fetchResponse.redirected && fetchResponse.location.href === this.location?.href;
    return sameLocationRedirect ? "replace" : "advance";
  }
}
const PageStage = {
  initial: 0,
  loading: 1,
  interactive: 2,
  complete: 3
};
class PageObserver {
  stage = PageStage.initial;
  started = false;
  constructor(delegate) {
    this.delegate = delegate;
  }
  start() {
    if (!this.started) {
      if (this.stage == PageStage.initial) {
        this.stage = PageStage.loading;
      }
      document.addEventListener("readystatechange", this.interpretReadyState, false);
      addEventListener("pagehide", this.pageWillUnload, false);
      this.started = true;
    }
  }
  stop() {
    if (this.started) {
      document.removeEventListener("readystatechange", this.interpretReadyState, false);
      removeEventListener("pagehide", this.pageWillUnload, false);
      this.started = false;
    }
  }
  interpretReadyState = () => {
    const {
      readyState
    } = this;
    if (readyState == "interactive") {
      this.pageIsInteractive();
    } else if (readyState == "complete") {
      this.pageIsComplete();
    }
  };
  pageIsInteractive() {
    if (this.stage == PageStage.loading) {
      this.stage = PageStage.interactive;
      this.delegate.pageBecameInteractive();
    }
  }
  pageIsComplete() {
    this.pageIsInteractive();
    if (this.stage == PageStage.interactive) {
      this.stage = PageStage.complete;
      this.delegate.pageLoaded();
    }
  }
  pageWillUnload = () => {
    this.delegate.pageWillUnload();
  };
  get readyState() {
    return document.readyState;
  }
}
class ScrollObserver {
  started = false;
  constructor(delegate) {
    this.delegate = delegate;
  }
  start() {
    if (!this.started) {
      addEventListener("scroll", this.onScroll, false);
      this.onScroll();
      this.started = true;
    }
  }
  stop() {
    if (this.started) {
      removeEventListener("scroll", this.onScroll, false);
      this.started = false;
    }
  }
  onScroll = () => {
    this.updatePosition({
      x: window.pageXOffset,
      y: window.pageYOffset
    });
  };

  // Private

  updatePosition(position) {
    this.delegate.scrollPositionChanged(position);
  }
}
class StreamMessageRenderer {
  render({
    fragment
  }) {
    Bardo.preservingPermanentElements(this, getPermanentElementMapForFragment(fragment), () => {
      withAutofocusFromFragment(fragment, () => {
        withPreservedFocus(() => {
          document.documentElement.appendChild(fragment);
        });
      });
    });
  }

  // Bardo delegate

  enteringBardo(currentPermanentElement, newPermanentElement) {
    newPermanentElement.replaceWith(currentPermanentElement.cloneNode(true));
  }
  leavingBardo() {}
}
function getPermanentElementMapForFragment(fragment) {
  const permanentElementsInDocument = queryPermanentElementsAll(document.documentElement);
  const permanentElementMap = {};
  for (const permanentElementInDocument of permanentElementsInDocument) {
    const {
      id
    } = permanentElementInDocument;
    for (const streamElement of fragment.querySelectorAll("turbo-stream")) {
      const elementInStream = getPermanentElementById(streamElement.templateElement.content, id);
      if (elementInStream) {
        permanentElementMap[id] = [permanentElementInDocument, elementInStream];
      }
    }
  }
  return permanentElementMap;
}
async function withAutofocusFromFragment(fragment, callback) {
  const generatedID = `turbo-stream-autofocus-${uuid()}`;
  const turboStreams = fragment.querySelectorAll("turbo-stream");
  const elementWithAutofocus = firstAutofocusableElementInStreams(turboStreams);
  let willAutofocusId = null;
  if (elementWithAutofocus) {
    if (elementWithAutofocus.id) {
      willAutofocusId = elementWithAutofocus.id;
    } else {
      willAutofocusId = generatedID;
    }
    elementWithAutofocus.id = willAutofocusId;
  }
  callback();
  await nextRepaint();
  const hasNoActiveElement = document.activeElement == null || document.activeElement == document.body;
  if (hasNoActiveElement && willAutofocusId) {
    const elementToAutofocus = document.getElementById(willAutofocusId);
    if (elementIsFocusable(elementToAutofocus)) {
      elementToAutofocus.focus();
    }
    if (elementToAutofocus && elementToAutofocus.id == generatedID) {
      elementToAutofocus.removeAttribute("id");
    }
  }
}
async function withPreservedFocus(callback) {
  const [activeElementBeforeRender, activeElementAfterRender] = await around(callback, () => document.activeElement);
  const restoreFocusTo = activeElementBeforeRender && activeElementBeforeRender.id;
  if (restoreFocusTo) {
    const elementToFocus = document.getElementById(restoreFocusTo);
    if (elementIsFocusable(elementToFocus) && elementToFocus != activeElementAfterRender) {
      elementToFocus.focus();
    }
  }
}
function firstAutofocusableElementInStreams(nodeListOfStreamElements) {
  for (const streamElement of nodeListOfStreamElements) {
    const elementWithAutofocus = queryAutofocusableElement(streamElement.templateElement.content);
    if (elementWithAutofocus) return elementWithAutofocus;
  }
  return null;
}
class StreamObserver {
  sources = new Set();
  #started = false;
  constructor(delegate) {
    this.delegate = delegate;
  }
  start() {
    if (!this.#started) {
      this.#started = true;
      addEventListener("turbo:before-fetch-response", this.inspectFetchResponse, false);
    }
  }
  stop() {
    if (this.#started) {
      this.#started = false;
      removeEventListener("turbo:before-fetch-response", this.inspectFetchResponse, false);
    }
  }
  connectStreamSource(source) {
    if (!this.streamSourceIsConnected(source)) {
      this.sources.add(source);
      source.addEventListener("message", this.receiveMessageEvent, false);
    }
  }
  disconnectStreamSource(source) {
    if (this.streamSourceIsConnected(source)) {
      this.sources.delete(source);
      source.removeEventListener("message", this.receiveMessageEvent, false);
    }
  }
  streamSourceIsConnected(source) {
    return this.sources.has(source);
  }
  inspectFetchResponse = event => {
    const response = fetchResponseFromEvent(event);
    if (response && fetchResponseIsStream(response)) {
      event.preventDefault();
      this.receiveMessageResponse(response);
    }
  };
  receiveMessageEvent = event => {
    if (this.#started && typeof event.data == "string") {
      this.receiveMessageHTML(event.data);
    }
  };
  async receiveMessageResponse(response) {
    const html = await response.responseHTML;
    if (html) {
      this.receiveMessageHTML(html);
    }
  }
  receiveMessageHTML(html) {
    this.delegate.receivedMessageFromStream(StreamMessage.wrap(html));
  }
}
function fetchResponseFromEvent(event) {
  const fetchResponse = event.detail?.fetchResponse;
  if (fetchResponse instanceof FetchResponse) {
    return fetchResponse;
  }
}
function fetchResponseIsStream(response) {
  const contentType = response.contentType ?? "";
  return contentType.startsWith(StreamMessage.contentType);
}
class ErrorRenderer extends Renderer {
  static renderElement(currentElement, newElement) {
    const {
      documentElement,
      body
    } = document;
    documentElement.replaceChild(newElement, body);
  }
  async render() {
    this.replaceHeadAndBody();
    this.activateScriptElements();
  }
  replaceHeadAndBody() {
    const {
      documentElement,
      head
    } = document;
    documentElement.replaceChild(this.newHead, head);
    this.renderElement(this.currentElement, this.newElement);
  }
  activateScriptElements() {
    for (const replaceableElement of this.scriptElements) {
      const parentNode = replaceableElement.parentNode;
      if (parentNode) {
        const element = activateScriptElement(replaceableElement);
        parentNode.replaceChild(element, replaceableElement);
      }
    }
  }
  get newHead() {
    return this.newSnapshot.headSnapshot.element;
  }
  get scriptElements() {
    return document.documentElement.querySelectorAll("script");
  }
}

// base IIFE to define idiomorph
var Idiomorph = function () {
  //=============================================================================
  // AND NOW IT BEGINS...
  //=============================================================================
  let EMPTY_SET = new Set();

  // default configuration values, updatable by users now
  let defaults = {
    morphStyle: "outerHTML",
    callbacks: {
      beforeNodeAdded: noOp,
      afterNodeAdded: noOp,
      beforeNodeMorphed: noOp,
      afterNodeMorphed: noOp,
      beforeNodeRemoved: noOp,
      afterNodeRemoved: noOp,
      beforeAttributeUpdated: noOp
    },
    head: {
      style: 'merge',
      shouldPreserve: function (elt) {
        return elt.getAttribute("im-preserve") === "true";
      },
      shouldReAppend: function (elt) {
        return elt.getAttribute("im-re-append") === "true";
      },
      shouldRemove: noOp,
      afterHeadMorphed: noOp
    }
  };

  //=============================================================================
  // Core Morphing Algorithm - morph, morphNormalizedContent, morphOldNodeTo, morphChildren
  //=============================================================================
  function morph(oldNode, newContent, config = {}) {
    if (oldNode instanceof Document) {
      oldNode = oldNode.documentElement;
    }
    if (typeof newContent === 'string') {
      newContent = parseContent(newContent);
    }
    let normalizedContent = normalizeContent(newContent);
    let ctx = createMorphContext(oldNode, normalizedContent, config);
    return morphNormalizedContent(oldNode, normalizedContent, ctx);
  }
  function morphNormalizedContent(oldNode, normalizedNewContent, ctx) {
    if (ctx.head.block) {
      let oldHead = oldNode.querySelector('head');
      let newHead = normalizedNewContent.querySelector('head');
      if (oldHead && newHead) {
        let promises = handleHeadElement(newHead, oldHead, ctx);
        // when head promises resolve, call morph again, ignoring the head tag
        Promise.all(promises).then(function () {
          morphNormalizedContent(oldNode, normalizedNewContent, Object.assign(ctx, {
            head: {
              block: false,
              ignore: true
            }
          }));
        });
        return;
      }
    }
    if (ctx.morphStyle === "innerHTML") {
      // innerHTML, so we are only updating the children
      morphChildren(normalizedNewContent, oldNode, ctx);
      return oldNode.children;
    } else if (ctx.morphStyle === "outerHTML" || ctx.morphStyle == null) {
      // otherwise find the best element match in the new content, morph that, and merge its siblings
      // into either side of the best match
      let bestMatch = findBestNodeMatch(normalizedNewContent, oldNode, ctx);

      // stash the siblings that will need to be inserted on either side of the best match
      let previousSibling = bestMatch?.previousSibling;
      let nextSibling = bestMatch?.nextSibling;

      // morph it
      let morphedNode = morphOldNodeTo(oldNode, bestMatch, ctx);
      if (bestMatch) {
        // if there was a best match, merge the siblings in too and return the
        // whole bunch
        return insertSiblings(previousSibling, morphedNode, nextSibling);
      } else {
        // otherwise nothing was added to the DOM
        return [];
      }
    } else {
      throw "Do not understand how to morph style " + ctx.morphStyle;
    }
  }

  /**
   * @param possibleActiveElement
   * @param ctx
   * @returns {boolean}
   */
  function ignoreValueOfActiveElement(possibleActiveElement, ctx) {
    return ctx.ignoreActiveValue && possibleActiveElement === document.activeElement && possibleActiveElement !== document.body;
  }

  /**
   * @param oldNode root node to merge content into
   * @param newContent new content to merge
   * @param ctx the merge context
   * @returns {Element} the element that ended up in the DOM
   */
  function morphOldNodeTo(oldNode, newContent, ctx) {
    if (ctx.ignoreActive && oldNode === document.activeElement) ;else if (newContent == null) {
      if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return oldNode;
      oldNode.remove();
      ctx.callbacks.afterNodeRemoved(oldNode);
      return null;
    } else if (!isSoftMatch(oldNode, newContent)) {
      if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return oldNode;
      if (ctx.callbacks.beforeNodeAdded(newContent) === false) return oldNode;
      oldNode.parentElement.replaceChild(newContent, oldNode);
      ctx.callbacks.afterNodeAdded(newContent);
      ctx.callbacks.afterNodeRemoved(oldNode);
      return newContent;
    } else {
      if (ctx.callbacks.beforeNodeMorphed(oldNode, newContent) === false) return oldNode;
      if (oldNode instanceof HTMLHeadElement && ctx.head.ignore) ;else if (oldNode instanceof HTMLHeadElement && ctx.head.style !== "morph") {
        handleHeadElement(newContent, oldNode, ctx);
      } else {
        syncNodeFrom(newContent, oldNode, ctx);
        if (!ignoreValueOfActiveElement(oldNode, ctx)) {
          morphChildren(newContent, oldNode, ctx);
        }
      }
      ctx.callbacks.afterNodeMorphed(oldNode, newContent);
      return oldNode;
    }
  }

  /**
   * This is the core algorithm for matching up children.  The idea is to use id sets to try to match up
   * nodes as faithfully as possible.  We greedily match, which allows us to keep the algorithm fast, but
   * by using id sets, we are able to better match up with content deeper in the DOM.
   *
   * Basic algorithm is, for each node in the new content:
   *
   * - if we have reached the end of the old parent, append the new content
   * - if the new content has an id set match with the current insertion point, morph
   * - search for an id set match
   * - if id set match found, morph
   * - otherwise search for a "soft" match
   * - if a soft match is found, morph
   * - otherwise, prepend the new node before the current insertion point
   *
   * The two search algorithms terminate if competing node matches appear to outweigh what can be achieved
   * with the current node.  See findIdSetMatch() and findSoftMatch() for details.
   *
   * @param {Element} newParent the parent element of the new content
   * @param {Element } oldParent the old content that we are merging the new content into
   * @param ctx the merge context
   */
  function morphChildren(newParent, oldParent, ctx) {
    let nextNewChild = newParent.firstChild;
    let insertionPoint = oldParent.firstChild;
    let newChild;

    // run through all the new content
    while (nextNewChild) {
      newChild = nextNewChild;
      nextNewChild = newChild.nextSibling;

      // if we are at the end of the exiting parent's children, just append
      if (insertionPoint == null) {
        if (ctx.callbacks.beforeNodeAdded(newChild) === false) return;
        oldParent.appendChild(newChild);
        ctx.callbacks.afterNodeAdded(newChild);
        removeIdsFromConsideration(ctx, newChild);
        continue;
      }

      // if the current node has an id set match then morph
      if (isIdSetMatch(newChild, insertionPoint, ctx)) {
        morphOldNodeTo(insertionPoint, newChild, ctx);
        insertionPoint = insertionPoint.nextSibling;
        removeIdsFromConsideration(ctx, newChild);
        continue;
      }

      // otherwise search forward in the existing old children for an id set match
      let idSetMatch = findIdSetMatch(newParent, oldParent, newChild, insertionPoint, ctx);

      // if we found a potential match, remove the nodes until that point and morph
      if (idSetMatch) {
        insertionPoint = removeNodesBetween(insertionPoint, idSetMatch, ctx);
        morphOldNodeTo(idSetMatch, newChild, ctx);
        removeIdsFromConsideration(ctx, newChild);
        continue;
      }

      // no id set match found, so scan forward for a soft match for the current node
      let softMatch = findSoftMatch(newParent, oldParent, newChild, insertionPoint, ctx);

      // if we found a soft match for the current node, morph
      if (softMatch) {
        insertionPoint = removeNodesBetween(insertionPoint, softMatch, ctx);
        morphOldNodeTo(softMatch, newChild, ctx);
        removeIdsFromConsideration(ctx, newChild);
        continue;
      }

      // abandon all hope of morphing, just insert the new child before the insertion point
      // and move on
      if (ctx.callbacks.beforeNodeAdded(newChild) === false) return;
      oldParent.insertBefore(newChild, insertionPoint);
      ctx.callbacks.afterNodeAdded(newChild);
      removeIdsFromConsideration(ctx, newChild);
    }

    // remove any remaining old nodes that didn't match up with new content
    while (insertionPoint !== null) {
      let tempNode = insertionPoint;
      insertionPoint = insertionPoint.nextSibling;
      removeNode(tempNode, ctx);
    }
  }

  //=============================================================================
  // Attribute Syncing Code
  //=============================================================================

  /**
   * @param attr {String} the attribute to be mutated
   * @param to {Element} the element that is going to be updated
   * @param updateType {("update"|"remove")}
   * @param ctx the merge context
   * @returns {boolean} true if the attribute should be ignored, false otherwise
   */
  function ignoreAttribute(attr, to, updateType, ctx) {
    if (attr === 'value' && ctx.ignoreActiveValue && to === document.activeElement) {
      return true;
    }
    return ctx.callbacks.beforeAttributeUpdated(attr, to, updateType) === false;
  }

  /**
   * syncs a given node with another node, copying over all attributes and
   * inner element state from the 'from' node to the 'to' node
   *
   * @param {Element} from the element to copy attributes & state from
   * @param {Element} to the element to copy attributes & state to
   * @param ctx the merge context
   */
  function syncNodeFrom(from, to, ctx) {
    let type = from.nodeType;

    // if is an element type, sync the attributes from the
    // new node into the new node
    if (type === 1 /* element type */) {
      const fromAttributes = from.attributes;
      const toAttributes = to.attributes;
      for (const fromAttribute of fromAttributes) {
        if (ignoreAttribute(fromAttribute.name, to, 'update', ctx)) {
          continue;
        }
        if (to.getAttribute(fromAttribute.name) !== fromAttribute.value) {
          to.setAttribute(fromAttribute.name, fromAttribute.value);
        }
      }
      // iterate backwards to avoid skipping over items when a delete occurs
      for (let i = toAttributes.length - 1; 0 <= i; i--) {
        const toAttribute = toAttributes[i];
        if (ignoreAttribute(toAttribute.name, to, 'remove', ctx)) {
          continue;
        }
        if (!from.hasAttribute(toAttribute.name)) {
          to.removeAttribute(toAttribute.name);
        }
      }
    }

    // sync text nodes
    if (type === 8 /* comment */ || type === 3 /* text */) {
      if (to.nodeValue !== from.nodeValue) {
        to.nodeValue = from.nodeValue;
      }
    }
    if (!ignoreValueOfActiveElement(to, ctx)) {
      // sync input values
      syncInputValue(from, to, ctx);
    }
  }

  /**
   * @param from {Element} element to sync the value from
   * @param to {Element} element to sync the value to
   * @param attributeName {String} the attribute name
   * @param ctx the merge context
   */
  function syncBooleanAttribute(from, to, attributeName, ctx) {
    if (from[attributeName] !== to[attributeName]) {
      let ignoreUpdate = ignoreAttribute(attributeName, to, 'update', ctx);
      if (!ignoreUpdate) {
        to[attributeName] = from[attributeName];
      }
      if (from[attributeName]) {
        if (!ignoreUpdate) {
          to.setAttribute(attributeName, from[attributeName]);
        }
      } else {
        if (!ignoreAttribute(attributeName, to, 'remove', ctx)) {
          to.removeAttribute(attributeName);
        }
      }
    }
  }

  /**
   * NB: many bothans died to bring us information:
   *
   *  https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js
   *  https://github.com/choojs/nanomorph/blob/master/lib/morph.jsL113
   *
   * @param from {Element} the element to sync the input value from
   * @param to {Element} the element to sync the input value to
   * @param ctx the merge context
   */
  function syncInputValue(from, to, ctx) {
    if (from instanceof HTMLInputElement && to instanceof HTMLInputElement && from.type !== 'file') {
      let fromValue = from.value;
      let toValue = to.value;

      // sync boolean attributes
      syncBooleanAttribute(from, to, 'checked', ctx);
      syncBooleanAttribute(from, to, 'disabled', ctx);
      if (!from.hasAttribute('value')) {
        if (!ignoreAttribute('value', to, 'remove', ctx)) {
          to.value = '';
          to.removeAttribute('value');
        }
      } else if (fromValue !== toValue) {
        if (!ignoreAttribute('value', to, 'update', ctx)) {
          to.setAttribute('value', fromValue);
          to.value = fromValue;
        }
      }
    } else if (from instanceof HTMLOptionElement) {
      syncBooleanAttribute(from, to, 'selected', ctx);
    } else if (from instanceof HTMLTextAreaElement && to instanceof HTMLTextAreaElement) {
      let fromValue = from.value;
      let toValue = to.value;
      if (ignoreAttribute('value', to, 'update', ctx)) {
        return;
      }
      if (fromValue !== toValue) {
        to.value = fromValue;
      }
      if (to.firstChild && to.firstChild.nodeValue !== fromValue) {
        to.firstChild.nodeValue = fromValue;
      }
    }
  }

  //=============================================================================
  // the HEAD tag can be handled specially, either w/ a 'merge' or 'append' style
  //=============================================================================
  function handleHeadElement(newHeadTag, currentHead, ctx) {
    let added = [];
    let removed = [];
    let preserved = [];
    let nodesToAppend = [];
    let headMergeStyle = ctx.head.style;

    // put all new head elements into a Map, by their outerHTML
    let srcToNewHeadNodes = new Map();
    for (const newHeadChild of newHeadTag.children) {
      srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild);
    }

    // for each elt in the current head
    for (const currentHeadElt of currentHead.children) {
      // If the current head element is in the map
      let inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML);
      let isReAppended = ctx.head.shouldReAppend(currentHeadElt);
      let isPreserved = ctx.head.shouldPreserve(currentHeadElt);
      if (inNewContent || isPreserved) {
        if (isReAppended) {
          // remove the current version and let the new version replace it and re-execute
          removed.push(currentHeadElt);
        } else {
          // this element already exists and should not be re-appended, so remove it from
          // the new content map, preserving it in the DOM
          srcToNewHeadNodes.delete(currentHeadElt.outerHTML);
          preserved.push(currentHeadElt);
        }
      } else {
        if (headMergeStyle === "append") {
          // we are appending and this existing element is not new content
          // so if and only if it is marked for re-append do we do anything
          if (isReAppended) {
            removed.push(currentHeadElt);
            nodesToAppend.push(currentHeadElt);
          }
        } else {
          // if this is a merge, we remove this content since it is not in the new head
          if (ctx.head.shouldRemove(currentHeadElt) !== false) {
            removed.push(currentHeadElt);
          }
        }
      }
    }

    // Push the remaining new head elements in the Map into the
    // nodes to append to the head tag
    nodesToAppend.push(...srcToNewHeadNodes.values());
    let promises = [];
    for (const newNode of nodesToAppend) {
      let newElt = document.createRange().createContextualFragment(newNode.outerHTML).firstChild;
      if (ctx.callbacks.beforeNodeAdded(newElt) !== false) {
        if (newElt.href || newElt.src) {
          let resolve = null;
          let promise = new Promise(function (_resolve) {
            resolve = _resolve;
          });
          newElt.addEventListener('load', function () {
            resolve();
          });
          promises.push(promise);
        }
        currentHead.appendChild(newElt);
        ctx.callbacks.afterNodeAdded(newElt);
        added.push(newElt);
      }
    }

    // remove all removed elements, after we have appended the new elements to avoid
    // additional network requests for things like style sheets
    for (const removedElement of removed) {
      if (ctx.callbacks.beforeNodeRemoved(removedElement) !== false) {
        currentHead.removeChild(removedElement);
        ctx.callbacks.afterNodeRemoved(removedElement);
      }
    }
    ctx.head.afterHeadMorphed(currentHead, {
      added: added,
      kept: preserved,
      removed: removed
    });
    return promises;
  }
  function noOp() {}

  /*
    Deep merges the config object and the Idiomoroph.defaults object to
    produce a final configuration object
   */
  function mergeDefaults(config) {
    let finalConfig = {};
    // copy top level stuff into final config
    Object.assign(finalConfig, defaults);
    Object.assign(finalConfig, config);

    // copy callbacks into final config (do this to deep merge the callbacks)
    finalConfig.callbacks = {};
    Object.assign(finalConfig.callbacks, defaults.callbacks);
    Object.assign(finalConfig.callbacks, config.callbacks);

    // copy head config into final config  (do this to deep merge the head)
    finalConfig.head = {};
    Object.assign(finalConfig.head, defaults.head);
    Object.assign(finalConfig.head, config.head);
    return finalConfig;
  }
  function createMorphContext(oldNode, newContent, config) {
    config = mergeDefaults(config);
    return {
      target: oldNode,
      newContent: newContent,
      config: config,
      morphStyle: config.morphStyle,
      ignoreActive: config.ignoreActive,
      ignoreActiveValue: config.ignoreActiveValue,
      idMap: createIdMap(oldNode, newContent),
      deadIds: new Set(),
      callbacks: config.callbacks,
      head: config.head
    };
  }
  function isIdSetMatch(node1, node2, ctx) {
    if (node1 == null || node2 == null) {
      return false;
    }
    if (node1.nodeType === node2.nodeType && node1.tagName === node2.tagName) {
      if (node1.id !== "" && node1.id === node2.id) {
        return true;
      } else {
        return getIdIntersectionCount(ctx, node1, node2) > 0;
      }
    }
    return false;
  }
  function isSoftMatch(node1, node2) {
    if (node1 == null || node2 == null) {
      return false;
    }
    return node1.nodeType === node2.nodeType && node1.tagName === node2.tagName;
  }
  function removeNodesBetween(startInclusive, endExclusive, ctx) {
    while (startInclusive !== endExclusive) {
      let tempNode = startInclusive;
      startInclusive = startInclusive.nextSibling;
      removeNode(tempNode, ctx);
    }
    removeIdsFromConsideration(ctx, endExclusive);
    return endExclusive.nextSibling;
  }

  //=============================================================================
  // Scans forward from the insertionPoint in the old parent looking for a potential id match
  // for the newChild.  We stop if we find a potential id match for the new child OR
  // if the number of potential id matches we are discarding is greater than the
  // potential id matches for the new child
  //=============================================================================
  function findIdSetMatch(newContent, oldParent, newChild, insertionPoint, ctx) {
    // max id matches we are willing to discard in our search
    let newChildPotentialIdCount = getIdIntersectionCount(ctx, newChild, oldParent);
    let potentialMatch = null;

    // only search forward if there is a possibility of an id match
    if (newChildPotentialIdCount > 0) {
      let potentialMatch = insertionPoint;
      // if there is a possibility of an id match, scan forward
      // keep track of the potential id match count we are discarding (the
      // newChildPotentialIdCount must be greater than this to make it likely
      // worth it)
      let otherMatchCount = 0;
      while (potentialMatch != null) {
        // If we have an id match, return the current potential match
        if (isIdSetMatch(newChild, potentialMatch, ctx)) {
          return potentialMatch;
        }

        // computer the other potential matches of this new content
        otherMatchCount += getIdIntersectionCount(ctx, potentialMatch, newContent);
        if (otherMatchCount > newChildPotentialIdCount) {
          // if we have more potential id matches in _other_ content, we
          // do not have a good candidate for an id match, so return null
          return null;
        }

        // advanced to the next old content child
        potentialMatch = potentialMatch.nextSibling;
      }
    }
    return potentialMatch;
  }

  //=============================================================================
  // Scans forward from the insertionPoint in the old parent looking for a potential soft match
  // for the newChild.  We stop if we find a potential soft match for the new child OR
  // if we find a potential id match in the old parents children OR if we find two
  // potential soft matches for the next two pieces of new content
  //=============================================================================
  function findSoftMatch(newContent, oldParent, newChild, insertionPoint, ctx) {
    let potentialSoftMatch = insertionPoint;
    let nextSibling = newChild.nextSibling;
    let siblingSoftMatchCount = 0;
    while (potentialSoftMatch != null) {
      if (getIdIntersectionCount(ctx, potentialSoftMatch, newContent) > 0) {
        // the current potential soft match has a potential id set match with the remaining new
        // content so bail out of looking
        return null;
      }

      // if we have a soft match with the current node, return it
      if (isSoftMatch(newChild, potentialSoftMatch)) {
        return potentialSoftMatch;
      }
      if (isSoftMatch(nextSibling, potentialSoftMatch)) {
        // the next new node has a soft match with this node, so
        // increment the count of future soft matches
        siblingSoftMatchCount++;
        nextSibling = nextSibling.nextSibling;

        // If there are two future soft matches, bail to allow the siblings to soft match
        // so that we don't consume future soft matches for the sake of the current node
        if (siblingSoftMatchCount >= 2) {
          return null;
        }
      }

      // advanced to the next old content child
      potentialSoftMatch = potentialSoftMatch.nextSibling;
    }
    return potentialSoftMatch;
  }
  function parseContent(newContent) {
    let parser = new DOMParser();

    // remove svgs to avoid false-positive matches on head, etc.
    let contentWithSvgsRemoved = newContent.replace(/<svg(\s[^>]*>|>)([\s\S]*?)<\/svg>/gim, '');

    // if the newContent contains a html, head or body tag, we can simply parse it w/o wrapping
    if (contentWithSvgsRemoved.match(/<\/html>/) || contentWithSvgsRemoved.match(/<\/head>/) || contentWithSvgsRemoved.match(/<\/body>/)) {
      let content = parser.parseFromString(newContent, "text/html");
      // if it is a full HTML document, return the document itself as the parent container
      if (contentWithSvgsRemoved.match(/<\/html>/)) {
        content.generatedByIdiomorph = true;
        return content;
      } else {
        // otherwise return the html element as the parent container
        let htmlElement = content.firstChild;
        if (htmlElement) {
          htmlElement.generatedByIdiomorph = true;
          return htmlElement;
        } else {
          return null;
        }
      }
    } else {
      // if it is partial HTML, wrap it in a template tag to provide a parent element and also to help
      // deal with touchy tags like tr, tbody, etc.
      let responseDoc = parser.parseFromString("<body><template>" + newContent + "</template></body>", "text/html");
      let content = responseDoc.body.querySelector('template').content;
      content.generatedByIdiomorph = true;
      return content;
    }
  }
  function normalizeContent(newContent) {
    if (newContent == null) {
      // noinspection UnnecessaryLocalVariableJS
      const dummyParent = document.createElement('div');
      return dummyParent;
    } else if (newContent.generatedByIdiomorph) {
      // the template tag created by idiomorph parsing can serve as a dummy parent
      return newContent;
    } else if (newContent instanceof Node) {
      // a single node is added as a child to a dummy parent
      const dummyParent = document.createElement('div');
      dummyParent.append(newContent);
      return dummyParent;
    } else {
      // all nodes in the array or HTMLElement collection are consolidated under
      // a single dummy parent element
      const dummyParent = document.createElement('div');
      for (const elt of [...newContent]) {
        dummyParent.append(elt);
      }
      return dummyParent;
    }
  }
  function insertSiblings(previousSibling, morphedNode, nextSibling) {
    let stack = [];
    let added = [];
    while (previousSibling != null) {
      stack.push(previousSibling);
      previousSibling = previousSibling.previousSibling;
    }
    while (stack.length > 0) {
      let node = stack.pop();
      added.push(node); // push added preceding siblings on in order and insert
      morphedNode.parentElement.insertBefore(node, morphedNode);
    }
    added.push(morphedNode);
    while (nextSibling != null) {
      stack.push(nextSibling);
      added.push(nextSibling); // here we are going in order, so push on as we scan, rather than add
      nextSibling = nextSibling.nextSibling;
    }
    while (stack.length > 0) {
      morphedNode.parentElement.insertBefore(stack.pop(), morphedNode.nextSibling);
    }
    return added;
  }
  function findBestNodeMatch(newContent, oldNode, ctx) {
    let currentElement;
    currentElement = newContent.firstChild;
    let bestElement = currentElement;
    let score = 0;
    while (currentElement) {
      let newScore = scoreElement(currentElement, oldNode, ctx);
      if (newScore > score) {
        bestElement = currentElement;
        score = newScore;
      }
      currentElement = currentElement.nextSibling;
    }
    return bestElement;
  }
  function scoreElement(node1, node2, ctx) {
    if (isSoftMatch(node1, node2)) {
      return .5 + getIdIntersectionCount(ctx, node1, node2);
    }
    return 0;
  }
  function removeNode(tempNode, ctx) {
    removeIdsFromConsideration(ctx, tempNode);
    if (ctx.callbacks.beforeNodeRemoved(tempNode) === false) return;
    tempNode.remove();
    ctx.callbacks.afterNodeRemoved(tempNode);
  }

  //=============================================================================
  // ID Set Functions
  //=============================================================================

  function isIdInConsideration(ctx, id) {
    return !ctx.deadIds.has(id);
  }
  function idIsWithinNode(ctx, id, targetNode) {
    let idSet = ctx.idMap.get(targetNode) || EMPTY_SET;
    return idSet.has(id);
  }
  function removeIdsFromConsideration(ctx, node) {
    let idSet = ctx.idMap.get(node) || EMPTY_SET;
    for (const id of idSet) {
      ctx.deadIds.add(id);
    }
  }
  function getIdIntersectionCount(ctx, node1, node2) {
    let sourceSet = ctx.idMap.get(node1) || EMPTY_SET;
    let matchCount = 0;
    for (const id of sourceSet) {
      // a potential match is an id in the source and potentialIdsSet, but
      // that has not already been merged into the DOM
      if (isIdInConsideration(ctx, id) && idIsWithinNode(ctx, id, node2)) {
        ++matchCount;
      }
    }
    return matchCount;
  }

  /**
   * A bottom up algorithm that finds all elements with ids inside of the node
   * argument and populates id sets for those nodes and all their parents, generating
   * a set of ids contained within all nodes for the entire hierarchy in the DOM
   *
   * @param node {Element}
   * @param {Map<Node, Set<String>>} idMap
   */
  function populateIdMapForNode(node, idMap) {
    let nodeParent = node.parentElement;
    // find all elements with an id property
    let idElements = node.querySelectorAll('[id]');
    for (const elt of idElements) {
      let current = elt;
      // walk up the parent hierarchy of that element, adding the id
      // of element to the parent's id set
      while (current !== nodeParent && current != null) {
        let idSet = idMap.get(current);
        // if the id set doesn't exist, create it and insert it in the  map
        if (idSet == null) {
          idSet = new Set();
          idMap.set(current, idSet);
        }
        idSet.add(elt.id);
        current = current.parentElement;
      }
    }
  }

  /**
   * This function computes a map of nodes to all ids contained within that node (inclusive of the
   * node).  This map can be used to ask if two nodes have intersecting sets of ids, which allows
   * for a looser definition of "matching" than tradition id matching, and allows child nodes
   * to contribute to a parent nodes matching.
   *
   * @param {Element} oldContent  the old content that will be morphed
   * @param {Element} newContent  the new content to morph to
   * @returns {Map<Node, Set<String>>} a map of nodes to id sets for the
   */
  function createIdMap(oldContent, newContent) {
    let idMap = new Map();
    populateIdMapForNode(oldContent, idMap);
    populateIdMapForNode(newContent, idMap);
    return idMap;
  }

  //=============================================================================
  // This is what ends up becoming the Idiomorph global object
  //=============================================================================
  return {
    morph,
    defaults
  };
}();
class PageRenderer extends Renderer {
  static renderElement(currentElement, newElement) {
    if (document.body && newElement instanceof HTMLBodyElement) {
      document.body.replaceWith(newElement);
    } else {
      document.documentElement.appendChild(newElement);
    }
  }
  get shouldRender() {
    return this.newSnapshot.isVisitable && this.trackedElementsAreIdentical;
  }
  get reloadReason() {
    if (!this.newSnapshot.isVisitable) {
      return {
        reason: "turbo_visit_control_is_reload"
      };
    }
    if (!this.trackedElementsAreIdentical) {
      return {
        reason: "tracked_element_mismatch"
      };
    }
  }
  async prepareToRender() {
    this.#setLanguage();
    await this.mergeHead();
  }
  async render() {
    if (this.willRender) {
      await this.replaceBody();
    }
  }
  finishRendering() {
    super.finishRendering();
    if (!this.isPreview) {
      this.focusFirstAutofocusableElement();
    }
  }
  get currentHeadSnapshot() {
    return this.currentSnapshot.headSnapshot;
  }
  get newHeadSnapshot() {
    return this.newSnapshot.headSnapshot;
  }
  get newElement() {
    return this.newSnapshot.element;
  }
  #setLanguage() {
    const {
      documentElement
    } = this.currentSnapshot;
    const {
      lang
    } = this.newSnapshot;
    if (lang) {
      documentElement.setAttribute("lang", lang);
    } else {
      documentElement.removeAttribute("lang");
    }
  }
  async mergeHead() {
    const mergedHeadElements = this.mergeProvisionalElements();
    const newStylesheetElements = this.copyNewHeadStylesheetElements();
    this.copyNewHeadScriptElements();
    await mergedHeadElements;
    await newStylesheetElements;
    if (this.willRender) {
      this.removeUnusedDynamicStylesheetElements();
    }
  }
  async replaceBody() {
    await this.preservingPermanentElements(async () => {
      this.activateNewBody();
      await this.assignNewBody();
    });
  }
  get trackedElementsAreIdentical() {
    return this.currentHeadSnapshot.trackedElementSignature == this.newHeadSnapshot.trackedElementSignature;
  }
  async copyNewHeadStylesheetElements() {
    const loadingElements = [];
    for (const element of this.newHeadStylesheetElements) {
      loadingElements.push(waitForLoad(element));
      document.head.appendChild(element);
    }
    await Promise.all(loadingElements);
  }
  copyNewHeadScriptElements() {
    for (const element of this.newHeadScriptElements) {
      document.head.appendChild(activateScriptElement(element));
    }
  }
  removeUnusedDynamicStylesheetElements() {
    for (const element of this.unusedDynamicStylesheetElements) {
      document.head.removeChild(element);
    }
  }
  async mergeProvisionalElements() {
    const newHeadElements = [...this.newHeadProvisionalElements];
    for (const element of this.currentHeadProvisionalElements) {
      if (!this.isCurrentElementInElementList(element, newHeadElements)) {
        document.head.removeChild(element);
      }
    }
    for (const element of newHeadElements) {
      document.head.appendChild(element);
    }
  }
  isCurrentElementInElementList(element, elementList) {
    for (const [index, newElement] of elementList.entries()) {
      // if title element...
      if (element.tagName == "TITLE") {
        if (newElement.tagName != "TITLE") {
          continue;
        }
        if (element.innerHTML == newElement.innerHTML) {
          elementList.splice(index, 1);
          return true;
        }
      }

      // if any other element...
      if (newElement.isEqualNode(element)) {
        elementList.splice(index, 1);
        return true;
      }
    }
    return false;
  }
  removeCurrentHeadProvisionalElements() {
    for (const element of this.currentHeadProvisionalElements) {
      document.head.removeChild(element);
    }
  }
  copyNewHeadProvisionalElements() {
    for (const element of this.newHeadProvisionalElements) {
      document.head.appendChild(element);
    }
  }
  activateNewBody() {
    document.adoptNode(this.newElement);
    this.activateNewBodyScriptElements();
  }
  activateNewBodyScriptElements() {
    for (const inertScriptElement of this.newBodyScriptElements) {
      const activatedScriptElement = activateScriptElement(inertScriptElement);
      inertScriptElement.replaceWith(activatedScriptElement);
    }
  }
  async assignNewBody() {
    await this.renderElement(this.currentElement, this.newElement);
  }
  get unusedDynamicStylesheetElements() {
    return this.oldHeadStylesheetElements.filter(element => {
      return element.getAttribute("data-turbo-track") === "dynamic";
    });
  }
  get oldHeadStylesheetElements() {
    return this.currentHeadSnapshot.getStylesheetElementsNotInSnapshot(this.newHeadSnapshot);
  }
  get newHeadStylesheetElements() {
    return this.newHeadSnapshot.getStylesheetElementsNotInSnapshot(this.currentHeadSnapshot);
  }
  get newHeadScriptElements() {
    return this.newHeadSnapshot.getScriptElementsNotInSnapshot(this.currentHeadSnapshot);
  }
  get currentHeadProvisionalElements() {
    return this.currentHeadSnapshot.provisionalElements;
  }
  get newHeadProvisionalElements() {
    return this.newHeadSnapshot.provisionalElements;
  }
  get newBodyScriptElements() {
    return this.newElement.querySelectorAll("script");
  }
}
class MorphRenderer extends PageRenderer {
  async render() {
    if (this.willRender) await this.#morphBody();
  }
  get renderMethod() {
    return "morph";
  }

  // Private

  async #morphBody() {
    this.#morphElements(this.currentElement, this.newElement);
    this.#reloadRemoteFrames();
    dispatch("turbo:morph", {
      detail: {
        currentElement: this.currentElement,
        newElement: this.newElement
      }
    });
  }
  #morphElements(currentElement, newElement, morphStyle = "outerHTML") {
    this.isMorphingTurboFrame = this.#isFrameReloadedWithMorph(currentElement);
    Idiomorph.morph(currentElement, newElement, {
      morphStyle: morphStyle,
      callbacks: {
        beforeNodeAdded: this.#shouldAddElement,
        beforeNodeMorphed: this.#shouldMorphElement,
        beforeAttributeUpdated: this.#shouldUpdateAttribute,
        beforeNodeRemoved: this.#shouldRemoveElement,
        afterNodeMorphed: this.#didMorphElement
      }
    });
  }
  #shouldAddElement = node => {
    return !(node.id && node.hasAttribute("data-turbo-permanent") && document.getElementById(node.id));
  };
  #shouldMorphElement = (oldNode, newNode) => {
    if (oldNode instanceof HTMLElement) {
      if (!oldNode.hasAttribute("data-turbo-permanent") && (this.isMorphingTurboFrame || !this.#isFrameReloadedWithMorph(oldNode))) {
        const event = dispatch("turbo:before-morph-element", {
          cancelable: true,
          target: oldNode,
          detail: {
            newElement: newNode
          }
        });
        return !event.defaultPrevented;
      } else {
        return false;
      }
    }
  };
  #shouldUpdateAttribute = (attributeName, target, mutationType) => {
    const event = dispatch("turbo:before-morph-attribute", {
      cancelable: true,
      target,
      detail: {
        attributeName,
        mutationType
      }
    });
    return !event.defaultPrevented;
  };
  #didMorphElement = (oldNode, newNode) => {
    if (newNode instanceof HTMLElement) {
      dispatch("turbo:morph-element", {
        target: oldNode,
        detail: {
          newElement: newNode
        }
      });
    }
  };
  #shouldRemoveElement = node => {
    return this.#shouldMorphElement(node);
  };
  #reloadRemoteFrames() {
    this.#remoteFrames().forEach(frame => {
      if (this.#isFrameReloadedWithMorph(frame)) {
        this.#renderFrameWithMorph(frame);
        frame.reload();
      }
    });
  }
  #renderFrameWithMorph(frame) {
    frame.addEventListener("turbo:before-frame-render", event => {
      event.detail.render = this.#morphFrameUpdate;
    }, {
      once: true
    });
  }
  #morphFrameUpdate = (currentElement, newElement) => {
    dispatch("turbo:before-frame-morph", {
      target: currentElement,
      detail: {
        currentElement,
        newElement
      }
    });
    this.#morphElements(currentElement, newElement.children, "innerHTML");
  };
  #isFrameReloadedWithMorph(element) {
    return element.src && element.refresh === "morph";
  }
  #remoteFrames() {
    return Array.from(document.querySelectorAll('turbo-frame[src]')).filter(frame => {
      return !frame.closest('[data-turbo-permanent]');
    });
  }
}
class SnapshotCache {
  keys = [];
  snapshots = {};
  constructor(size) {
    this.size = size;
  }
  has(location) {
    return toCacheKey(location) in this.snapshots;
  }
  get(location) {
    if (this.has(location)) {
      const snapshot = this.read(location);
      this.touch(location);
      return snapshot;
    }
  }
  put(location, snapshot) {
    this.write(location, snapshot);
    this.touch(location);
    return snapshot;
  }
  clear() {
    this.snapshots = {};
  }

  // Private

  read(location) {
    return this.snapshots[toCacheKey(location)];
  }
  write(location, snapshot) {
    this.snapshots[toCacheKey(location)] = snapshot;
  }
  touch(location) {
    const key = toCacheKey(location);
    const index = this.keys.indexOf(key);
    if (index > -1) this.keys.splice(index, 1);
    this.keys.unshift(key);
    this.trim();
  }
  trim() {
    for (const key of this.keys.splice(this.size)) {
      delete this.snapshots[key];
    }
  }
}
class PageView extends View {
  snapshotCache = new SnapshotCache(10);
  lastRenderedLocation = new URL(location.href);
  forceReloaded = false;
  shouldTransitionTo(newSnapshot) {
    return this.snapshot.prefersViewTransitions && newSnapshot.prefersViewTransitions;
  }
  renderPage(snapshot, isPreview = false, willRender = true, visit) {
    const shouldMorphPage = this.isPageRefresh(visit) && this.snapshot.shouldMorphPage;
    const rendererClass = shouldMorphPage ? MorphRenderer : PageRenderer;
    const renderer = new rendererClass(this.snapshot, snapshot, PageRenderer.renderElement, isPreview, willRender);
    if (!renderer.shouldRender) {
      this.forceReloaded = true;
    } else {
      visit?.changeHistory();
    }
    return this.render(renderer);
  }
  renderError(snapshot, visit) {
    visit?.changeHistory();
    const renderer = new ErrorRenderer(this.snapshot, snapshot, ErrorRenderer.renderElement, false);
    return this.render(renderer);
  }
  clearSnapshotCache() {
    this.snapshotCache.clear();
  }
  async cacheSnapshot(snapshot = this.snapshot) {
    if (snapshot.isCacheable) {
      this.delegate.viewWillCacheSnapshot();
      const {
        lastRenderedLocation: location
      } = this;
      await nextEventLoopTick();
      const cachedSnapshot = snapshot.clone();
      this.snapshotCache.put(location, cachedSnapshot);
      return cachedSnapshot;
    }
  }
  getCachedSnapshotForLocation(location) {
    return this.snapshotCache.get(location);
  }
  isPageRefresh(visit) {
    return !visit || this.lastRenderedLocation.pathname === visit.location.pathname && visit.action === "replace";
  }
  shouldPreserveScrollPosition(visit) {
    return this.isPageRefresh(visit) && this.snapshot.shouldPreserveScrollPosition;
  }
  get snapshot() {
    return PageSnapshot.fromElement(this.element);
  }
}
class Preloader {
  selector = "a[data-turbo-preload]";
  constructor(delegate, snapshotCache) {
    this.delegate = delegate;
    this.snapshotCache = snapshotCache;
  }
  start() {
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", this.#preloadAll);
    } else {
      this.preloadOnLoadLinksForView(document.body);
    }
  }
  stop() {
    document.removeEventListener("DOMContentLoaded", this.#preloadAll);
  }
  preloadOnLoadLinksForView(element) {
    for (const link of element.querySelectorAll(this.selector)) {
      if (this.delegate.shouldPreloadLink(link)) {
        this.preloadURL(link);
      }
    }
  }
  async preloadURL(link) {
    const location = new URL(link.href);
    if (this.snapshotCache.has(location)) {
      return;
    }
    const fetchRequest = new FetchRequest(this, FetchMethod.get, location, new URLSearchParams(), link);
    await fetchRequest.perform();
  }

  // Fetch request delegate

  prepareRequest(fetchRequest) {
    fetchRequest.headers["X-Sec-Purpose"] = "prefetch";
  }
  async requestSucceededWithResponse(fetchRequest, fetchResponse) {
    try {
      const responseHTML = await fetchResponse.responseHTML;
      const snapshot = PageSnapshot.fromHTMLString(responseHTML);
      this.snapshotCache.put(fetchRequest.url, snapshot);
    } catch (_) {
      // If we cannot preload that is ok!
    }
  }
  requestStarted(fetchRequest) {}
  requestErrored(fetchRequest) {}
  requestFinished(fetchRequest) {}
  requestPreventedHandlingResponse(fetchRequest, fetchResponse) {}
  requestFailedWithResponse(fetchRequest, fetchResponse) {}
  #preloadAll = () => {
    this.preloadOnLoadLinksForView(document.body);
  };
}
class Cache {
  constructor(session) {
    this.session = session;
  }
  clear() {
    this.session.clearCache();
  }
  resetCacheControl() {
    this.#setCacheControl("");
  }
  exemptPageFromCache() {
    this.#setCacheControl("no-cache");
  }
  exemptPageFromPreview() {
    this.#setCacheControl("no-preview");
  }
  #setCacheControl(value) {
    setMetaContent("turbo-cache-control", value);
  }
}
class Session {
  navigator = new Navigator(this);
  history = new History(this);
  view = new PageView(this, document.documentElement);
  adapter = new BrowserAdapter(this);
  pageObserver = new PageObserver(this);
  cacheObserver = new CacheObserver();
  linkPrefetchObserver = new LinkPrefetchObserver(this, document);
  linkClickObserver = new LinkClickObserver(this, window);
  formSubmitObserver = new FormSubmitObserver(this, document);
  scrollObserver = new ScrollObserver(this);
  streamObserver = new StreamObserver(this);
  formLinkClickObserver = new FormLinkClickObserver(this, document.documentElement);
  frameRedirector = new FrameRedirector(this, document.documentElement);
  streamMessageRenderer = new StreamMessageRenderer();
  cache = new Cache(this);
  drive = true;
  enabled = true;
  progressBarDelay = 500;
  started = false;
  formMode = "on";
  #pageRefreshDebouncePeriod = 150;
  constructor(recentRequests) {
    this.recentRequests = recentRequests;
    this.preloader = new Preloader(this, this.view.snapshotCache);
    this.debouncedRefresh = this.refresh;
    this.pageRefreshDebouncePeriod = this.pageRefreshDebouncePeriod;
  }
  start() {
    if (!this.started) {
      this.pageObserver.start();
      this.cacheObserver.start();
      this.linkPrefetchObserver.start();
      this.formLinkClickObserver.start();
      this.linkClickObserver.start();
      this.formSubmitObserver.start();
      this.scrollObserver.start();
      this.streamObserver.start();
      this.frameRedirector.start();
      this.history.start();
      this.preloader.start();
      this.started = true;
      this.enabled = true;
    }
  }
  disable() {
    this.enabled = false;
  }
  stop() {
    if (this.started) {
      this.pageObserver.stop();
      this.cacheObserver.stop();
      this.linkPrefetchObserver.stop();
      this.formLinkClickObserver.stop();
      this.linkClickObserver.stop();
      this.formSubmitObserver.stop();
      this.scrollObserver.stop();
      this.streamObserver.stop();
      this.frameRedirector.stop();
      this.history.stop();
      this.preloader.stop();
      this.started = false;
    }
  }
  registerAdapter(adapter) {
    this.adapter = adapter;
  }
  visit(location, options = {}) {
    const frameElement = options.frame ? document.getElementById(options.frame) : null;
    if (frameElement instanceof FrameElement) {
      const action = options.action || getVisitAction(frameElement);
      frameElement.delegate.proposeVisitIfNavigatedWithAction(frameElement, action);
      frameElement.src = location.toString();
    } else {
      this.navigator.proposeVisit(expandURL(location), options);
    }
  }
  refresh(url, requestId) {
    const isRecentRequest = requestId && this.recentRequests.has(requestId);
    if (!isRecentRequest) {
      this.visit(url, {
        action: "replace",
        shouldCacheSnapshot: false
      });
    }
  }
  connectStreamSource(source) {
    this.streamObserver.connectStreamSource(source);
  }
  disconnectStreamSource(source) {
    this.streamObserver.disconnectStreamSource(source);
  }
  renderStreamMessage(message) {
    this.streamMessageRenderer.render(StreamMessage.wrap(message));
  }
  clearCache() {
    this.view.clearSnapshotCache();
  }
  setProgressBarDelay(delay) {
    this.progressBarDelay = delay;
  }
  setFormMode(mode) {
    this.formMode = mode;
  }
  get location() {
    return this.history.location;
  }
  get restorationIdentifier() {
    return this.history.restorationIdentifier;
  }
  get pageRefreshDebouncePeriod() {
    return this.#pageRefreshDebouncePeriod;
  }
  set pageRefreshDebouncePeriod(value) {
    this.refresh = debounce(this.debouncedRefresh.bind(this), value);
    this.#pageRefreshDebouncePeriod = value;
  }

  // Preloader delegate

  shouldPreloadLink(element) {
    const isUnsafe = element.hasAttribute("data-turbo-method");
    const isStream = element.hasAttribute("data-turbo-stream");
    const frameTarget = element.getAttribute("data-turbo-frame");
    const frame = frameTarget == "_top" ? null : document.getElementById(frameTarget) || findClosestRecursively(element, "turbo-frame:not([disabled])");
    if (isUnsafe || isStream || frame instanceof FrameElement) {
      return false;
    } else {
      const location = new URL(element.href);
      return this.elementIsNavigatable(element) && locationIsVisitable(location, this.snapshot.rootLocation);
    }
  }

  // History delegate

  historyPoppedToLocationWithRestorationIdentifierAndDirection(location, restorationIdentifier, direction) {
    if (this.enabled) {
      this.navigator.startVisit(location, restorationIdentifier, {
        action: "restore",
        historyChanged: true,
        direction
      });
    } else {
      this.adapter.pageInvalidated({
        reason: "turbo_disabled"
      });
    }
  }

  // Scroll observer delegate

  scrollPositionChanged(position) {
    this.history.updateRestorationData({
      scrollPosition: position
    });
  }

  // Form click observer delegate

  willSubmitFormLinkToLocation(link, location) {
    return this.elementIsNavigatable(link) && locationIsVisitable(location, this.snapshot.rootLocation);
  }
  submittedFormLinkToLocation() {}

  // Link hover observer delegate

  canPrefetchRequestToLocation(link, location) {
    return this.elementIsNavigatable(link) && locationIsVisitable(location, this.snapshot.rootLocation);
  }

  // Link click observer delegate

  willFollowLinkToLocation(link, location, event) {
    return this.elementIsNavigatable(link) && locationIsVisitable(location, this.snapshot.rootLocation) && this.applicationAllowsFollowingLinkToLocation(link, location, event);
  }
  followedLinkToLocation(link, location) {
    const action = this.getActionForLink(link);
    const acceptsStreamResponse = link.hasAttribute("data-turbo-stream");
    this.visit(location.href, {
      action,
      acceptsStreamResponse
    });
  }

  // Navigator delegate

  allowsVisitingLocationWithAction(location, action) {
    return this.locationWithActionIsSamePage(location, action) || this.applicationAllowsVisitingLocation(location);
  }
  visitProposedToLocation(location, options) {
    extendURLWithDeprecatedProperties(location);
    this.adapter.visitProposedToLocation(location, options);
  }

  // Visit delegate

  visitStarted(visit) {
    if (!visit.acceptsStreamResponse) {
      markAsBusy(document.documentElement);
      this.view.markVisitDirection(visit.direction);
    }
    extendURLWithDeprecatedProperties(visit.location);
    if (!visit.silent) {
      this.notifyApplicationAfterVisitingLocation(visit.location, visit.action);
    }
  }
  visitCompleted(visit) {
    this.view.unmarkVisitDirection();
    clearBusyState(document.documentElement);
    this.notifyApplicationAfterPageLoad(visit.getTimingMetrics());
  }
  locationWithActionIsSamePage(location, action) {
    return this.navigator.locationWithActionIsSamePage(location, action);
  }
  visitScrolledToSamePageLocation(oldURL, newURL) {
    this.notifyApplicationAfterVisitingSamePageLocation(oldURL, newURL);
  }

  // Form submit observer delegate

  willSubmitForm(form, submitter) {
    const action = getAction$1(form, submitter);
    return this.submissionIsNavigatable(form, submitter) && locationIsVisitable(expandURL(action), this.snapshot.rootLocation);
  }
  formSubmitted(form, submitter) {
    this.navigator.submitForm(form, submitter);
  }

  // Page observer delegate

  pageBecameInteractive() {
    this.view.lastRenderedLocation = this.location;
    this.notifyApplicationAfterPageLoad();
  }
  pageLoaded() {
    this.history.assumeControlOfScrollRestoration();
  }
  pageWillUnload() {
    this.history.relinquishControlOfScrollRestoration();
  }

  // Stream observer delegate

  receivedMessageFromStream(message) {
    this.renderStreamMessage(message);
  }

  // Page view delegate

  viewWillCacheSnapshot() {
    if (!this.navigator.currentVisit?.silent) {
      this.notifyApplicationBeforeCachingSnapshot();
    }
  }
  allowsImmediateRender({
    element
  }, options) {
    const event = this.notifyApplicationBeforeRender(element, options);
    const {
      defaultPrevented,
      detail: {
        render
      }
    } = event;
    if (this.view.renderer && render) {
      this.view.renderer.renderElement = render;
    }
    return !defaultPrevented;
  }
  viewRenderedSnapshot(_snapshot, _isPreview, renderMethod) {
    this.view.lastRenderedLocation = this.history.location;
    this.notifyApplicationAfterRender(renderMethod);
  }
  preloadOnLoadLinksForView(element) {
    this.preloader.preloadOnLoadLinksForView(element);
  }
  viewInvalidated(reason) {
    this.adapter.pageInvalidated(reason);
  }

  // Frame element

  frameLoaded(frame) {
    this.notifyApplicationAfterFrameLoad(frame);
  }
  frameRendered(fetchResponse, frame) {
    this.notifyApplicationAfterFrameRender(fetchResponse, frame);
  }

  // Application events

  applicationAllowsFollowingLinkToLocation(link, location, ev) {
    const event = this.notifyApplicationAfterClickingLinkToLocation(link, location, ev);
    return !event.defaultPrevented;
  }
  applicationAllowsVisitingLocation(location) {
    const event = this.notifyApplicationBeforeVisitingLocation(location);
    return !event.defaultPrevented;
  }
  notifyApplicationAfterClickingLinkToLocation(link, location, event) {
    return dispatch("turbo:click", {
      target: link,
      detail: {
        url: location.href,
        originalEvent: event
      },
      cancelable: true
    });
  }
  notifyApplicationBeforeVisitingLocation(location) {
    return dispatch("turbo:before-visit", {
      detail: {
        url: location.href
      },
      cancelable: true
    });
  }
  notifyApplicationAfterVisitingLocation(location, action) {
    return dispatch("turbo:visit", {
      detail: {
        url: location.href,
        action
      }
    });
  }
  notifyApplicationBeforeCachingSnapshot() {
    return dispatch("turbo:before-cache");
  }
  notifyApplicationBeforeRender(newBody, options) {
    return dispatch("turbo:before-render", {
      detail: {
        newBody,
        ...options
      },
      cancelable: true
    });
  }
  notifyApplicationAfterRender(renderMethod) {
    return dispatch("turbo:render", {
      detail: {
        renderMethod
      }
    });
  }
  notifyApplicationAfterPageLoad(timing = {}) {
    return dispatch("turbo:load", {
      detail: {
        url: this.location.href,
        timing
      }
    });
  }
  notifyApplicationAfterVisitingSamePageLocation(oldURL, newURL) {
    dispatchEvent(new HashChangeEvent("hashchange", {
      oldURL: oldURL.toString(),
      newURL: newURL.toString()
    }));
  }
  notifyApplicationAfterFrameLoad(frame) {
    return dispatch("turbo:frame-load", {
      target: frame
    });
  }
  notifyApplicationAfterFrameRender(fetchResponse, frame) {
    return dispatch("turbo:frame-render", {
      detail: {
        fetchResponse
      },
      target: frame,
      cancelable: true
    });
  }

  // Helpers

  submissionIsNavigatable(form, submitter) {
    if (this.formMode == "off") {
      return false;
    } else {
      const submitterIsNavigatable = submitter ? this.elementIsNavigatable(submitter) : true;
      if (this.formMode == "optin") {
        return submitterIsNavigatable && form.closest('[data-turbo="true"]') != null;
      } else {
        return submitterIsNavigatable && this.elementIsNavigatable(form);
      }
    }
  }
  elementIsNavigatable(element) {
    const container = findClosestRecursively(element, "[data-turbo]");
    const withinFrame = findClosestRecursively(element, "turbo-frame");

    // Check if Drive is enabled on the session or we're within a Frame.
    if (this.drive || withinFrame) {
      // Element is navigatable by default, unless `data-turbo="false"`.
      if (container) {
        return container.getAttribute("data-turbo") != "false";
      } else {
        return true;
      }
    } else {
      // Element isn't navigatable by default, unless `data-turbo="true"`.
      if (container) {
        return container.getAttribute("data-turbo") == "true";
      } else {
        return false;
      }
    }
  }

  // Private

  getActionForLink(link) {
    return getVisitAction(link) || "advance";
  }
  get snapshot() {
    return this.view.snapshot;
  }
}

// Older versions of the Turbo Native adapters referenced the
// `Location#absoluteURL` property in their implementations of
// the `Adapter#visitProposedToLocation()` and `#visitStarted()`
// methods. The Location class has since been removed in favor
// of the DOM URL API, and accordingly all Adapter methods now
// receive URL objects.
//
// We alias #absoluteURL to #toString() here to avoid crashing
// older adapters which do not expect URL objects. We should
// consider removing this support at some point in the future.

function extendURLWithDeprecatedProperties(url) {
  Object.defineProperties(url, deprecatedLocationPropertyDescriptors);
}
const deprecatedLocationPropertyDescriptors = {
  absoluteURL: {
    get() {
      return this.toString();
    }
  }
};
const session = new Session(recentRequests);
const {
  cache,
  navigator: navigator$1
} = session;

/**
 * Starts the main session.
 * This initialises any necessary observers such as those to monitor
 * link interactions.
 */
function start() {
  session.start();
}

/**
 * Registers an adapter for the main session.
 *
 * @param adapter Adapter to register
 */
function registerAdapter(adapter) {
  session.registerAdapter(adapter);
}

/**
 * Performs an application visit to the given location.
 *
 * @param location Location to visit (a URL or path)
 * @param options Options to apply
 * @param options.action Type of history navigation to apply ("restore",
 * "replace" or "advance")
 * @param options.historyChanged Specifies whether the browser history has
 * already been changed for this visit or not
 * @param options.referrer Specifies the referrer of this visit such that
 * navigations to the same page will not result in a new history entry.
 * @param options.snapshotHTML Cached snapshot to render
 * @param options.response Response of the specified location
 */
function visit(location, options) {
  session.visit(location, options);
}

/**
 * Connects a stream source to the main session.
 *
 * @param source Stream source to connect
 */
function connectStreamSource(source) {
  session.connectStreamSource(source);
}

/**
 * Disconnects a stream source from the main session.
 *
 * @param source Stream source to disconnect
 */
function disconnectStreamSource(source) {
  session.disconnectStreamSource(source);
}

/**
 * Renders a stream message to the main session by appending it to the
 * current document.
 *
 * @param message Message to render
 */
function renderStreamMessage(message) {
  session.renderStreamMessage(message);
}

/**
 * Removes all entries from the Turbo Drive page cache.
 * Call this when state has changed on the server that may affect cached pages.
 *
 * @deprecated since version 7.2.0 in favor of `Turbo.cache.clear()`
 */
function clearCache() {
  console.warn("Please replace `Turbo.clearCache()` with `Turbo.cache.clear()`. The top-level function is deprecated and will be removed in a future version of Turbo.`");
  session.clearCache();
}

/**
 * Sets the delay after which the progress bar will appear during navigation.
 *
 * The progress bar appears after 500ms by default.
 *
 * Note that this method has no effect when used with the iOS or Android
 * adapters.
 *
 * @param delay Time to delay in milliseconds
 */
function setProgressBarDelay(delay) {
  session.setProgressBarDelay(delay);
}
function setConfirmMethod(confirmMethod) {
  FormSubmission.confirmMethod = confirmMethod;
}
function setFormMode(mode) {
  session.setFormMode(mode);
}
var Turbo = /*#__PURE__*/Object.freeze({
  __proto__: null,
  navigator: navigator$1,
  session: session,
  cache: cache,
  PageRenderer: PageRenderer,
  PageSnapshot: PageSnapshot,
  FrameRenderer: FrameRenderer,
  fetch: fetchWithTurboHeaders,
  start: start,
  registerAdapter: registerAdapter,
  visit: visit,
  connectStreamSource: connectStreamSource,
  disconnectStreamSource: disconnectStreamSource,
  renderStreamMessage: renderStreamMessage,
  clearCache: clearCache,
  setProgressBarDelay: setProgressBarDelay,
  setConfirmMethod: setConfirmMethod,
  setFormMode: setFormMode
});
class TurboFrameMissingError extends Error {}
class FrameController {
  fetchResponseLoaded = _fetchResponse => Promise.resolve();
  #currentFetchRequest = null;
  #resolveVisitPromise = () => {};
  #connected = false;
  #hasBeenLoaded = false;
  #ignoredAttributes = new Set();
  action = null;
  constructor(element) {
    this.element = element;
    this.view = new FrameView(this, this.element);
    this.appearanceObserver = new AppearanceObserver(this, this.element);
    this.formLinkClickObserver = new FormLinkClickObserver(this, this.element);
    this.linkInterceptor = new LinkInterceptor(this, this.element);
    this.restorationIdentifier = uuid();
    this.formSubmitObserver = new FormSubmitObserver(this, this.element);
  }

  // Frame delegate

  connect() {
    if (!this.#connected) {
      this.#connected = true;
      if (this.loadingStyle == FrameLoadingStyle.lazy) {
        this.appearanceObserver.start();
      } else {
        this.#loadSourceURL();
      }
      this.formLinkClickObserver.start();
      this.linkInterceptor.start();
      this.formSubmitObserver.start();
    }
  }
  disconnect() {
    if (this.#connected) {
      this.#connected = false;
      this.appearanceObserver.stop();
      this.formLinkClickObserver.stop();
      this.linkInterceptor.stop();
      this.formSubmitObserver.stop();
    }
  }
  disabledChanged() {
    if (this.loadingStyle == FrameLoadingStyle.eager) {
      this.#loadSourceURL();
    }
  }
  sourceURLChanged() {
    if (this.#isIgnoringChangesTo("src")) return;
    if (this.element.isConnected) {
      this.complete = false;
    }
    if (this.loadingStyle == FrameLoadingStyle.eager || this.#hasBeenLoaded) {
      this.#loadSourceURL();
    }
  }
  sourceURLReloaded() {
    const {
      src
    } = this.element;
    this.element.removeAttribute("complete");
    this.element.src = null;
    this.element.src = src;
    return this.element.loaded;
  }
  loadingStyleChanged() {
    if (this.loadingStyle == FrameLoadingStyle.lazy) {
      this.appearanceObserver.start();
    } else {
      this.appearanceObserver.stop();
      this.#loadSourceURL();
    }
  }
  async #loadSourceURL() {
    if (this.enabled && this.isActive && !this.complete && this.sourceURL) {
      this.element.loaded = this.#visit(expandURL(this.sourceURL));
      this.appearanceObserver.stop();
      await this.element.loaded;
      this.#hasBeenLoaded = true;
    }
  }
  async loadResponse(fetchResponse) {
    if (fetchResponse.redirected || fetchResponse.succeeded && fetchResponse.isHTML) {
      this.sourceURL = fetchResponse.response.url;
    }
    try {
      const html = await fetchResponse.responseHTML;
      if (html) {
        const document = parseHTMLDocument(html);
        const pageSnapshot = PageSnapshot.fromDocument(document);
        if (pageSnapshot.isVisitable) {
          await this.#loadFrameResponse(fetchResponse, document);
        } else {
          await this.#handleUnvisitableFrameResponse(fetchResponse);
        }
      }
    } finally {
      this.fetchResponseLoaded = () => Promise.resolve();
    }
  }

  // Appearance observer delegate

  elementAppearedInViewport(element) {
    this.proposeVisitIfNavigatedWithAction(element, getVisitAction(element));
    this.#loadSourceURL();
  }

  // Form link click observer delegate

  willSubmitFormLinkToLocation(link) {
    return this.#shouldInterceptNavigation(link);
  }
  submittedFormLinkToLocation(link, _location, form) {
    const frame = this.#findFrameElement(link);
    if (frame) form.setAttribute("data-turbo-frame", frame.id);
  }

  // Link interceptor delegate

  shouldInterceptLinkClick(element, _location, _event) {
    return this.#shouldInterceptNavigation(element);
  }
  linkClickIntercepted(element, location) {
    this.#navigateFrame(element, location);
  }

  // Form submit observer delegate

  willSubmitForm(element, submitter) {
    return element.closest("turbo-frame") == this.element && this.#shouldInterceptNavigation(element, submitter);
  }
  formSubmitted(element, submitter) {
    if (this.formSubmission) {
      this.formSubmission.stop();
    }
    this.formSubmission = new FormSubmission(this, element, submitter);
    const {
      fetchRequest
    } = this.formSubmission;
    this.prepareRequest(fetchRequest);
    this.formSubmission.start();
  }

  // Fetch request delegate

  prepareRequest(request) {
    request.headers["Turbo-Frame"] = this.id;
    if (this.currentNavigationElement?.hasAttribute("data-turbo-stream")) {
      request.acceptResponseType(StreamMessage.contentType);
    }
  }
  requestStarted(_request) {
    markAsBusy(this.element);
  }
  requestPreventedHandlingResponse(_request, _response) {
    this.#resolveVisitPromise();
  }
  async requestSucceededWithResponse(request, response) {
    await this.loadResponse(response);
    this.#resolveVisitPromise();
  }
  async requestFailedWithResponse(request, response) {
    await this.loadResponse(response);
    this.#resolveVisitPromise();
  }
  requestErrored(request, error) {
    console.error(error);
    this.#resolveVisitPromise();
  }
  requestFinished(_request) {
    clearBusyState(this.element);
  }

  // Form submission delegate

  formSubmissionStarted({
    formElement
  }) {
    markAsBusy(formElement, this.#findFrameElement(formElement));
  }
  formSubmissionSucceededWithResponse(formSubmission, response) {
    const frame = this.#findFrameElement(formSubmission.formElement, formSubmission.submitter);
    frame.delegate.proposeVisitIfNavigatedWithAction(frame, getVisitAction(formSubmission.submitter, formSubmission.formElement, frame));
    frame.delegate.loadResponse(response);
    if (!formSubmission.isSafe) {
      session.clearCache();
    }
  }
  formSubmissionFailedWithResponse(formSubmission, fetchResponse) {
    this.element.delegate.loadResponse(fetchResponse);
    session.clearCache();
  }
  formSubmissionErrored(formSubmission, error) {
    console.error(error);
  }
  formSubmissionFinished({
    formElement
  }) {
    clearBusyState(formElement, this.#findFrameElement(formElement));
  }

  // View delegate

  allowsImmediateRender({
    element: newFrame
  }, options) {
    const event = dispatch("turbo:before-frame-render", {
      target: this.element,
      detail: {
        newFrame,
        ...options
      },
      cancelable: true
    });
    const {
      defaultPrevented,
      detail: {
        render
      }
    } = event;
    if (this.view.renderer && render) {
      this.view.renderer.renderElement = render;
    }
    return !defaultPrevented;
  }
  viewRenderedSnapshot(_snapshot, _isPreview, _renderMethod) {}
  preloadOnLoadLinksForView(element) {
    session.preloadOnLoadLinksForView(element);
  }
  viewInvalidated() {}

  // Frame renderer delegate

  willRenderFrame(currentElement, _newElement) {
    this.previousFrameElement = currentElement.cloneNode(true);
  }
  visitCachedSnapshot = ({
    element
  }) => {
    const frame = element.querySelector("#" + this.element.id);
    if (frame && this.previousFrameElement) {
      frame.replaceChildren(...this.previousFrameElement.children);
    }
    delete this.previousFrameElement;
  };

  // Private

  async #loadFrameResponse(fetchResponse, document) {
    const newFrameElement = await this.extractForeignFrameElement(document.body);
    if (newFrameElement) {
      const snapshot = new Snapshot(newFrameElement);
      const renderer = new FrameRenderer(this, this.view.snapshot, snapshot, FrameRenderer.renderElement, false, false);
      if (this.view.renderPromise) await this.view.renderPromise;
      this.changeHistory();
      await this.view.render(renderer);
      this.complete = true;
      session.frameRendered(fetchResponse, this.element);
      session.frameLoaded(this.element);
      await this.fetchResponseLoaded(fetchResponse);
    } else if (this.#willHandleFrameMissingFromResponse(fetchResponse)) {
      this.#handleFrameMissingFromResponse(fetchResponse);
    }
  }
  async #visit(url) {
    const request = new FetchRequest(this, FetchMethod.get, url, new URLSearchParams(), this.element);
    this.#currentFetchRequest?.cancel();
    this.#currentFetchRequest = request;
    return new Promise(resolve => {
      this.#resolveVisitPromise = () => {
        this.#resolveVisitPromise = () => {};
        this.#currentFetchRequest = null;
        resolve();
      };
      request.perform();
    });
  }
  #navigateFrame(element, url, submitter) {
    const frame = this.#findFrameElement(element, submitter);
    frame.delegate.proposeVisitIfNavigatedWithAction(frame, getVisitAction(submitter, element, frame));
    this.#withCurrentNavigationElement(element, () => {
      frame.src = url;
    });
  }
  proposeVisitIfNavigatedWithAction(frame, action = null) {
    this.action = action;
    if (this.action) {
      const pageSnapshot = PageSnapshot.fromElement(frame).clone();
      const {
        visitCachedSnapshot
      } = frame.delegate;
      frame.delegate.fetchResponseLoaded = async fetchResponse => {
        if (frame.src) {
          const {
            statusCode,
            redirected
          } = fetchResponse;
          const responseHTML = await fetchResponse.responseHTML;
          const response = {
            statusCode,
            redirected,
            responseHTML
          };
          const options = {
            response,
            visitCachedSnapshot,
            willRender: false,
            updateHistory: false,
            restorationIdentifier: this.restorationIdentifier,
            snapshot: pageSnapshot
          };
          if (this.action) options.action = this.action;
          session.visit(frame.src, options);
        }
      };
    }
  }
  changeHistory() {
    if (this.action) {
      const method = getHistoryMethodForAction(this.action);
      session.history.update(method, expandURL(this.element.src || ""), this.restorationIdentifier);
    }
  }
  async #handleUnvisitableFrameResponse(fetchResponse) {
    console.warn(`The response (${fetchResponse.statusCode}) from <turbo-frame id="${this.element.id}"> is performing a full page visit due to turbo-visit-control.`);
    await this.#visitResponse(fetchResponse.response);
  }
  #willHandleFrameMissingFromResponse(fetchResponse) {
    this.element.setAttribute("complete", "");
    const response = fetchResponse.response;
    const visit = async (url, options) => {
      if (url instanceof Response) {
        this.#visitResponse(url);
      } else {
        session.visit(url, options);
      }
    };
    const event = dispatch("turbo:frame-missing", {
      target: this.element,
      detail: {
        response,
        visit
      },
      cancelable: true
    });
    return !event.defaultPrevented;
  }
  #handleFrameMissingFromResponse(fetchResponse) {
    this.view.missing();
    this.#throwFrameMissingError(fetchResponse);
  }
  #throwFrameMissingError(fetchResponse) {
    const message = `The response (${fetchResponse.statusCode}) did not contain the expected <turbo-frame id="${this.element.id}"> and will be ignored. To perform a full page visit instead, set turbo-visit-control to reload.`;
    throw new TurboFrameMissingError(message);
  }
  async #visitResponse(response) {
    const wrapped = new FetchResponse(response);
    const responseHTML = await wrapped.responseHTML;
    const {
      location,
      redirected,
      statusCode
    } = wrapped;
    return session.visit(location, {
      response: {
        redirected,
        statusCode,
        responseHTML
      }
    });
  }
  #findFrameElement(element, submitter) {
    const id = getAttribute("data-turbo-frame", submitter, element) || this.element.getAttribute("target");
    return getFrameElementById(id) ?? this.element;
  }
  async extractForeignFrameElement(container) {
    let element;
    const id = CSS.escape(this.id);
    try {
      element = activateElement(container.querySelector(`turbo-frame#${id}`), this.sourceURL);
      if (element) {
        return element;
      }
      element = activateElement(container.querySelector(`turbo-frame[src][recurse~=${id}]`), this.sourceURL);
      if (element) {
        await element.loaded;
        return await this.extractForeignFrameElement(element);
      }
    } catch (error) {
      console.error(error);
      return new FrameElement();
    }
    return null;
  }
  #formActionIsVisitable(form, submitter) {
    const action = getAction$1(form, submitter);
    return locationIsVisitable(expandURL(action), this.rootLocation);
  }
  #shouldInterceptNavigation(element, submitter) {
    const id = getAttribute("data-turbo-frame", submitter, element) || this.element.getAttribute("target");
    if (element instanceof HTMLFormElement && !this.#formActionIsVisitable(element, submitter)) {
      return false;
    }
    if (!this.enabled || id == "_top") {
      return false;
    }
    if (id) {
      const frameElement = getFrameElementById(id);
      if (frameElement) {
        return !frameElement.disabled;
      }
    }
    if (!session.elementIsNavigatable(element)) {
      return false;
    }
    if (submitter && !session.elementIsNavigatable(submitter)) {
      return false;
    }
    return true;
  }

  // Computed properties

  get id() {
    return this.element.id;
  }
  get enabled() {
    return !this.element.disabled;
  }
  get sourceURL() {
    if (this.element.src) {
      return this.element.src;
    }
  }
  set sourceURL(sourceURL) {
    this.#ignoringChangesToAttribute("src", () => {
      this.element.src = sourceURL ?? null;
    });
  }
  get loadingStyle() {
    return this.element.loading;
  }
  get isLoading() {
    return this.formSubmission !== undefined || this.#resolveVisitPromise() !== undefined;
  }
  get complete() {
    return this.element.hasAttribute("complete");
  }
  set complete(value) {
    if (value) {
      this.element.setAttribute("complete", "");
    } else {
      this.element.removeAttribute("complete");
    }
  }
  get isActive() {
    return this.element.isActive && this.#connected;
  }
  get rootLocation() {
    const meta = this.element.ownerDocument.querySelector(`meta[name="turbo-root"]`);
    const root = meta?.content ?? "/";
    return expandURL(root);
  }
  #isIgnoringChangesTo(attributeName) {
    return this.#ignoredAttributes.has(attributeName);
  }
  #ignoringChangesToAttribute(attributeName, callback) {
    this.#ignoredAttributes.add(attributeName);
    callback();
    this.#ignoredAttributes.delete(attributeName);
  }
  #withCurrentNavigationElement(element, callback) {
    this.currentNavigationElement = element;
    callback();
    delete this.currentNavigationElement;
  }
}
function getFrameElementById(id) {
  if (id != null) {
    const element = document.getElementById(id);
    if (element instanceof FrameElement) {
      return element;
    }
  }
}
function activateElement(element, currentURL) {
  if (element) {
    const src = element.getAttribute("src");
    if (src != null && currentURL != null && urlsAreEqual(src, currentURL)) {
      throw new Error(`Matching <turbo-frame id="${element.id}"> element has a source URL which references itself`);
    }
    if (element.ownerDocument !== document) {
      element = document.importNode(element, true);
    }
    if (element instanceof FrameElement) {
      element.connectedCallback();
      element.disconnectedCallback();
      return element;
    }
  }
}
const StreamActions = {
  after() {
    this.targetElements.forEach(e => e.parentElement?.insertBefore(this.templateContent, e.nextSibling));
  },
  append() {
    this.removeDuplicateTargetChildren();
    this.targetElements.forEach(e => e.append(this.templateContent));
  },
  before() {
    this.targetElements.forEach(e => e.parentElement?.insertBefore(this.templateContent, e));
  },
  prepend() {
    this.removeDuplicateTargetChildren();
    this.targetElements.forEach(e => e.prepend(this.templateContent));
  },
  remove() {
    this.targetElements.forEach(e => e.remove());
  },
  replace() {
    this.targetElements.forEach(e => e.replaceWith(this.templateContent));
  },
  update() {
    this.targetElements.forEach(targetElement => {
      targetElement.innerHTML = "";
      targetElement.append(this.templateContent);
    });
  },
  refresh() {
    session.refresh(this.baseURI, this.requestId);
  }
};

// <turbo-stream action=replace target=id><template>...

/**
 * Renders updates to the page from a stream of messages.
 *
 * Using the `action` attribute, this can be configured one of four ways:
 *
 * - `append` - appends the result to the container
 * - `prepend` - prepends the result to the container
 * - `replace` - replaces the contents of the container
 * - `remove` - removes the container
 * - `before` - inserts the result before the target
 * - `after` - inserts the result after the target
 *
 * @customElement turbo-stream
 * @example
 *   <turbo-stream action="append" target="dom_id">
 *     <template>
 *       Content to append to container designated with the dom_id.
 *     </template>
 *   </turbo-stream>
 */
class StreamElement extends HTMLElement {
  static async renderElement(newElement) {
    await newElement.performAction();
  }
  async connectedCallback() {
    try {
      await this.render();
    } catch (error) {
      console.error(error);
    } finally {
      this.disconnect();
    }
  }
  async render() {
    return this.renderPromise ??= (async () => {
      const event = this.beforeRenderEvent;
      if (this.dispatchEvent(event)) {
        await nextRepaint();
        await event.detail.render(this);
      }
    })();
  }
  disconnect() {
    try {
      this.remove();
      // eslint-disable-next-line no-empty
    } catch {}
  }

  /**
   * Removes duplicate children (by ID)
   */
  removeDuplicateTargetChildren() {
    this.duplicateChildren.forEach(c => c.remove());
  }

  /**
   * Gets the list of duplicate children (i.e. those with the same ID)
   */
  get duplicateChildren() {
    const existingChildren = this.targetElements.flatMap(e => [...e.children]).filter(c => !!c.id);
    const newChildrenIds = [...(this.templateContent?.children || [])].filter(c => !!c.id).map(c => c.id);
    return existingChildren.filter(c => newChildrenIds.includes(c.id));
  }

  /**
   * Gets the action function to be performed.
   */
  get performAction() {
    if (this.action) {
      const actionFunction = StreamActions[this.action];
      if (actionFunction) {
        return actionFunction;
      }
      this.#raise("unknown action");
    }
    this.#raise("action attribute is missing");
  }

  /**
   * Gets the target elements which the template will be rendered to.
   */
  get targetElements() {
    if (this.target) {
      return this.targetElementsById;
    } else if (this.targets) {
      return this.targetElementsByQuery;
    } else {
      this.#raise("target or targets attribute is missing");
    }
  }

  /**
   * Gets the contents of the main `<template>`.
   */
  get templateContent() {
    return this.templateElement.content.cloneNode(true);
  }

  /**
   * Gets the main `<template>` used for rendering
   */
  get templateElement() {
    if (this.firstElementChild === null) {
      const template = this.ownerDocument.createElement("template");
      this.appendChild(template);
      return template;
    } else if (this.firstElementChild instanceof HTMLTemplateElement) {
      return this.firstElementChild;
    }
    this.#raise("first child element must be a <template> element");
  }

  /**
   * Gets the current action.
   */
  get action() {
    return this.getAttribute("action");
  }

  /**
   * Gets the current target (an element ID) to which the result will
   * be rendered.
   */
  get target() {
    return this.getAttribute("target");
  }

  /**
   * Gets the current "targets" selector (a CSS selector)
   */
  get targets() {
    return this.getAttribute("targets");
  }

  /**
   * Reads the request-id attribute
   */
  get requestId() {
    return this.getAttribute("request-id");
  }
  #raise(message) {
    throw new Error(`${this.description}: ${message}`);
  }
  get description() {
    return (this.outerHTML.match(/<[^>]+>/) ?? [])[0] ?? "<turbo-stream>";
  }
  get beforeRenderEvent() {
    return new CustomEvent("turbo:before-stream-render", {
      bubbles: true,
      cancelable: true,
      detail: {
        newStream: this,
        render: StreamElement.renderElement
      }
    });
  }
  get targetElementsById() {
    const element = this.ownerDocument?.getElementById(this.target);
    if (element !== null) {
      return [element];
    } else {
      return [];
    }
  }
  get targetElementsByQuery() {
    const elements = this.ownerDocument?.querySelectorAll(this.targets);
    if (elements.length !== 0) {
      return Array.prototype.slice.call(elements);
    } else {
      return [];
    }
  }
}
class StreamSourceElement extends HTMLElement {
  streamSource = null;
  connectedCallback() {
    this.streamSource = this.src.match(/^ws{1,2}:/) ? new WebSocket(this.src) : new EventSource(this.src);
    connectStreamSource(this.streamSource);
  }
  disconnectedCallback() {
    if (this.streamSource) {
      this.streamSource.close();
      disconnectStreamSource(this.streamSource);
    }
  }
  get src() {
    return this.getAttribute("src") || "";
  }
}
FrameElement.delegateConstructor = FrameController;
if (customElements.get("turbo-frame") === undefined) {
  customElements.define("turbo-frame", FrameElement);
}
if (customElements.get("turbo-stream") === undefined) {
  customElements.define("turbo-stream", StreamElement);
}
if (customElements.get("turbo-stream-source") === undefined) {
  customElements.define("turbo-stream-source", StreamSourceElement);
}
(() => {
  let element = document.currentScript;
  if (!element) return;
  if (element.hasAttribute("data-turbo-suppress-warning")) return;
  element = element.parentElement;
  while (element) {
    if (element == document.body) {
      return console.warn(unindent`
        You are loading Turbo from a <script> element inside the <body> element. This is probably not what you meant to do!

        Load your applicationâs JavaScript bundle inside the <head> element instead. <script> elements in <body> are evaluated with each page change.

        For more information, see: https://turbo.hotwired.dev/handbook/building#working-with-script-elements

        ââ
        Suppress this warning by adding a "data-turbo-suppress-warning" attribute to: %s
      `, element.outerHTML);
    }
    element = element.parentElement;
  }
})();
window.Turbo = {
  ...Turbo,
  StreamActions
};
start();

var Turbo$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	FetchEnctype: FetchEnctype,
	FetchMethod: FetchMethod,
	FetchRequest: FetchRequest,
	FetchResponse: FetchResponse,
	FrameElement: FrameElement,
	FrameLoadingStyle: FrameLoadingStyle,
	FrameRenderer: FrameRenderer,
	PageRenderer: PageRenderer,
	PageSnapshot: PageSnapshot,
	StreamActions: StreamActions,
	StreamElement: StreamElement,
	StreamSourceElement: StreamSourceElement,
	cache: cache,
	clearCache: clearCache,
	connectStreamSource: connectStreamSource,
	disconnectStreamSource: disconnectStreamSource,
	fetch: fetchWithTurboHeaders,
	fetchEnctypeFromString: fetchEnctypeFromString,
	fetchMethodFromString: fetchMethodFromString,
	isSafe: isSafe,
	navigator: navigator$1,
	registerAdapter: registerAdapter,
	renderStreamMessage: renderStreamMessage,
	session: session,
	setConfirmMethod: setConfirmMethod,
	setFormMode: setFormMode,
	setProgressBarDelay: setProgressBarDelay,
	start: start,
	visit: visit
});

let consumer;
async function getConsumer() {
  return consumer || setConsumer(createConsumer$1().then(setConsumer));
}
function setConsumer(newConsumer) {
  return consumer = newConsumer;
}
async function createConsumer$1() {
  const {
    createConsumer
  } = await Promise.resolve().then(function () { return index; });
  return createConsumer();
}
async function subscribeTo(channel, mixin) {
  const {
    subscriptions
  } = await getConsumer();
  return subscriptions.create(channel, mixin);
}

// Based on https://github.com/nathan7/snakeize
//
// This software is released under the MIT license:
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
// the Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
function walk(obj) {
  if (!obj || typeof obj !== 'object') return obj;
  if (obj instanceof Date || obj instanceof RegExp) return obj;
  if (Array.isArray(obj)) return obj.map(walk);
  return Object.keys(obj).reduce(function (acc, key) {
    var camel = key[0].toLowerCase() + key.slice(1).replace(/([A-Z]+)/g, function (m, x) {
      return '_' + x.toLowerCase();
    });
    acc[camel] = walk(obj[key]);
    return acc;
  }, {});
}

class TurboCableStreamSourceElement extends HTMLElement {
  async connectedCallback() {
    connectStreamSource(this);
    this.subscription = await subscribeTo(this.channel, {
      received: this.dispatchMessageEvent.bind(this),
      connected: this.subscriptionConnected.bind(this),
      disconnected: this.subscriptionDisconnected.bind(this)
    });
  }
  disconnectedCallback() {
    disconnectStreamSource(this);
    if (this.subscription) this.subscription.unsubscribe();
  }
  dispatchMessageEvent(data) {
    const event = new MessageEvent("message", {
      data
    });
    return this.dispatchEvent(event);
  }
  subscriptionConnected() {
    this.setAttribute("connected", "");
  }
  subscriptionDisconnected() {
    this.removeAttribute("connected");
  }
  get channel() {
    const channel = this.getAttribute("channel");
    const signed_stream_name = this.getAttribute("signed-stream-name");
    return {
      channel,
      signed_stream_name,
      ...walk({
        ...this.dataset
      })
    };
  }
}
if (customElements.get("turbo-cable-stream-source") === undefined) {
  customElements.define("turbo-cable-stream-source", TurboCableStreamSourceElement);
}

function encodeMethodIntoRequestBody(event) {
  if (event.target instanceof HTMLFormElement) {
    const {
      target: form,
      detail: {
        fetchOptions
      }
    } = event;
    form.addEventListener("turbo:submit-start", ({
      detail: {
        formSubmission: {
          submitter
        }
      }
    }) => {
      const body = isBodyInit(fetchOptions.body) ? fetchOptions.body : new URLSearchParams();
      const method = determineFetchMethod(submitter, body, form);
      if (!/get/i.test(method)) {
        if (/post/i.test(method)) {
          body.delete("_method");
        } else {
          body.set("_method", method);
        }
        fetchOptions.method = "post";
      }
    }, {
      once: true
    });
  }
}
function determineFetchMethod(submitter, body, form) {
  const formMethod = determineFormMethod(submitter);
  const overrideMethod = body.get("_method");
  const method = form.getAttribute("method") || "get";
  if (typeof formMethod == "string") {
    return formMethod;
  } else if (typeof overrideMethod == "string") {
    return overrideMethod;
  } else {
    return method;
  }
}
function determineFormMethod(submitter) {
  if (submitter instanceof HTMLButtonElement || submitter instanceof HTMLInputElement) {
    // Rails 7 ActionView::Helpers::FormBuilder#button method has an override
    // for formmethod if the button does not have name or value attributes
    // set, which is the default. This means that if you use <%= f.button
    // formmethod: :delete %>, it will generate a <button name="_method"
    // value="delete" formmethod="post">. Therefore, if the submitter's name
    // is already _method, it's value attribute already contains the desired
    // method.
    if (submitter.name === '_method') {
      return submitter.value;
    } else if (submitter.hasAttribute("formmethod")) {
      return submitter.formMethod;
    } else {
      return null;
    }
  } else {
    return null;
  }
}
function isBodyInit(body) {
  return body instanceof FormData || body instanceof URLSearchParams;
}

window.Turbo = Turbo$1;
addEventListener("turbo:before-fetch-request", encodeMethodIntoRequestBody);

//
// Entry point for the build script in package.json
//

session.drive = false; // By default disable Turbo on all pages

// Handle the situation where a modal has created an object and the controller wants to
// redirect to another page but not render it inside the frame. In this case we will get a
// turbo:frame-missing event so handle this and redirect to the relevant page.
// This does involve a double render though -
// - create button in modal inside turbo_frame "modal" is clicked
// - controller creates model successfully and returns 301 redirect
// - browser redirects (first render)
// - Turbo cannot find the "modal" turbo-frame tag in the page, so (below) we redirect again
//   this time at the window level so there is a full navigation (second render)
// Various discussion here
// https://github.com/hotwired/turbo/issues/257#issuecomment-1591737862
document.addEventListener("turbo:frame-missing", function (event) {
  event.preventDefault();
  event.detail.visit(event.detail.response);
});

var adapters = {
  logger: self.console,
  WebSocket: self.WebSocket
};

// The logger is disabled by default. You can enable it with:
//
//   ActionCable.logger.enabled = true
//
//   Example:
//
//   import * as ActionCable from '@rails/actioncable'
//
//   ActionCable.logger.enabled = true
//   ActionCable.logger.log('Connection Established.')
//

var logger = {
  log(...messages) {
    if (this.enabled) {
      messages.push(Date.now());
      adapters.logger.log("[ActionCable]", ...messages);
    }
  }
};

// Responsible for ensuring the cable connection is in good health by validating the heartbeat pings sent from the server, and attempting
// revival reconnections if things go astray. Internal class, not intended for direct user manipulation.

const now = () => new Date().getTime();
const secondsSince = time => (now() - time) / 1000;
class ConnectionMonitor {
  constructor(connection) {
    this.visibilityDidChange = this.visibilityDidChange.bind(this);
    this.connection = connection;
    this.reconnectAttempts = 0;
  }
  start() {
    if (!this.isRunning()) {
      this.startedAt = now();
      delete this.stoppedAt;
      this.startPolling();
      addEventListener("visibilitychange", this.visibilityDidChange);
      logger.log(`ConnectionMonitor started. stale threshold = ${this.constructor.staleThreshold} s`);
    }
  }
  stop() {
    if (this.isRunning()) {
      this.stoppedAt = now();
      this.stopPolling();
      removeEventListener("visibilitychange", this.visibilityDidChange);
      logger.log("ConnectionMonitor stopped");
    }
  }
  isRunning() {
    return this.startedAt && !this.stoppedAt;
  }
  recordPing() {
    this.pingedAt = now();
  }
  recordConnect() {
    this.reconnectAttempts = 0;
    this.recordPing();
    delete this.disconnectedAt;
    logger.log("ConnectionMonitor recorded connect");
  }
  recordDisconnect() {
    this.disconnectedAt = now();
    logger.log("ConnectionMonitor recorded disconnect");
  }

  // Private

  startPolling() {
    this.stopPolling();
    this.poll();
  }
  stopPolling() {
    clearTimeout(this.pollTimeout);
  }
  poll() {
    this.pollTimeout = setTimeout(() => {
      this.reconnectIfStale();
      this.poll();
    }, this.getPollInterval());
  }
  getPollInterval() {
    const {
      staleThreshold,
      reconnectionBackoffRate
    } = this.constructor;
    const backoff = Math.pow(1 + reconnectionBackoffRate, Math.min(this.reconnectAttempts, 10));
    const jitterMax = this.reconnectAttempts === 0 ? 1.0 : reconnectionBackoffRate;
    const jitter = jitterMax * Math.random();
    return staleThreshold * 1000 * backoff * (1 + jitter);
  }
  reconnectIfStale() {
    if (this.connectionIsStale()) {
      logger.log(`ConnectionMonitor detected stale connection. reconnectAttempts = ${this.reconnectAttempts}, time stale = ${secondsSince(this.refreshedAt)} s, stale threshold = ${this.constructor.staleThreshold} s`);
      this.reconnectAttempts++;
      if (this.disconnectedRecently()) {
        logger.log(`ConnectionMonitor skipping reopening recent disconnect. time disconnected = ${secondsSince(this.disconnectedAt)} s`);
      } else {
        logger.log("ConnectionMonitor reopening");
        this.connection.reopen();
      }
    }
  }
  get refreshedAt() {
    return this.pingedAt ? this.pingedAt : this.startedAt;
  }
  connectionIsStale() {
    return secondsSince(this.refreshedAt) > this.constructor.staleThreshold;
  }
  disconnectedRecently() {
    return this.disconnectedAt && secondsSince(this.disconnectedAt) < this.constructor.staleThreshold;
  }
  visibilityDidChange() {
    if (document.visibilityState === "visible") {
      setTimeout(() => {
        if (this.connectionIsStale() || !this.connection.isOpen()) {
          logger.log(`ConnectionMonitor reopening stale connection on visibilitychange. visibilityState = ${document.visibilityState}`);
          this.connection.reopen();
        }
      }, 200);
    }
  }
}
ConnectionMonitor.staleThreshold = 6; // Server::Connections::BEAT_INTERVAL * 2 (missed two pings)
ConnectionMonitor.reconnectionBackoffRate = 0.15;

var INTERNAL = {
  "message_types": {
    "welcome": "welcome",
    "disconnect": "disconnect",
    "ping": "ping",
    "confirmation": "confirm_subscription",
    "rejection": "reject_subscription"
  },
  "disconnect_reasons": {
    "unauthorized": "unauthorized",
    "invalid_request": "invalid_request",
    "server_restart": "server_restart"
  },
  "default_mount_path": "/cable",
  "protocols": ["actioncable-v1-json", "actioncable-unsupported"]
};

// Encapsulate the cable connection held by the consumer. This is an internal class not intended for direct user manipulation.

const {
  message_types,
  protocols
} = INTERNAL;
const supportedProtocols = protocols.slice(0, protocols.length - 1);
const indexOf = [].indexOf;
class Connection {
  constructor(consumer) {
    this.open = this.open.bind(this);
    this.consumer = consumer;
    this.subscriptions = this.consumer.subscriptions;
    this.monitor = new ConnectionMonitor(this);
    this.disconnected = true;
  }
  send(data) {
    if (this.isOpen()) {
      this.webSocket.send(JSON.stringify(data));
      return true;
    } else {
      return false;
    }
  }
  open() {
    if (this.isActive()) {
      logger.log(`Attempted to open WebSocket, but existing socket is ${this.getState()}`);
      return false;
    } else {
      logger.log(`Opening WebSocket, current state is ${this.getState()}, subprotocols: ${protocols}`);
      if (this.webSocket) {
        this.uninstallEventHandlers();
      }
      this.webSocket = new adapters.WebSocket(this.consumer.url, protocols);
      this.installEventHandlers();
      this.monitor.start();
      return true;
    }
  }
  close({
    allowReconnect
  } = {
    allowReconnect: true
  }) {
    if (!allowReconnect) {
      this.monitor.stop();
    }
    // Avoid closing websockets in a "connecting" state due to Safari 15.1+ bug. See: https://github.com/rails/rails/issues/43835#issuecomment-1002288478
    if (this.isOpen()) {
      return this.webSocket.close();
    }
  }
  reopen() {
    logger.log(`Reopening WebSocket, current state is ${this.getState()}`);
    if (this.isActive()) {
      try {
        return this.close();
      } catch (error) {
        logger.log("Failed to reopen WebSocket", error);
      } finally {
        logger.log(`Reopening WebSocket in ${this.constructor.reopenDelay}ms`);
        setTimeout(this.open, this.constructor.reopenDelay);
      }
    } else {
      return this.open();
    }
  }
  getProtocol() {
    if (this.webSocket) {
      return this.webSocket.protocol;
    }
  }
  isOpen() {
    return this.isState("open");
  }
  isActive() {
    return this.isState("open", "connecting");
  }

  // Private

  isProtocolSupported() {
    return indexOf.call(supportedProtocols, this.getProtocol()) >= 0;
  }
  isState(...states) {
    return indexOf.call(states, this.getState()) >= 0;
  }
  getState() {
    if (this.webSocket) {
      for (let state in adapters.WebSocket) {
        if (adapters.WebSocket[state] === this.webSocket.readyState) {
          return state.toLowerCase();
        }
      }
    }
    return null;
  }
  installEventHandlers() {
    for (let eventName in this.events) {
      const handler = this.events[eventName].bind(this);
      this.webSocket[`on${eventName}`] = handler;
    }
  }
  uninstallEventHandlers() {
    for (let eventName in this.events) {
      this.webSocket[`on${eventName}`] = function () {};
    }
  }
}
Connection.reopenDelay = 500;
Connection.prototype.events = {
  message(event) {
    if (!this.isProtocolSupported()) {
      return;
    }
    const {
      identifier,
      message,
      reason,
      reconnect,
      type
    } = JSON.parse(event.data);
    switch (type) {
      case message_types.welcome:
        this.monitor.recordConnect();
        return this.subscriptions.reload();
      case message_types.disconnect:
        logger.log(`Disconnecting. Reason: ${reason}`);
        return this.close({
          allowReconnect: reconnect
        });
      case message_types.ping:
        return this.monitor.recordPing();
      case message_types.confirmation:
        this.subscriptions.confirmSubscription(identifier);
        return this.subscriptions.notify(identifier, "connected");
      case message_types.rejection:
        return this.subscriptions.reject(identifier);
      default:
        return this.subscriptions.notify(identifier, "received", message);
    }
  },
  open() {
    logger.log(`WebSocket onopen event, using '${this.getProtocol()}' subprotocol`);
    this.disconnected = false;
    if (!this.isProtocolSupported()) {
      logger.log("Protocol is unsupported. Stopping monitor and disconnecting.");
      return this.close({
        allowReconnect: false
      });
    }
  },
  close(event) {
    logger.log("WebSocket onclose event");
    if (this.disconnected) {
      return;
    }
    this.disconnected = true;
    this.monitor.recordDisconnect();
    return this.subscriptions.notifyAll("disconnected", {
      willAttemptReconnect: this.monitor.isRunning()
    });
  },
  error() {
    logger.log("WebSocket onerror event");
  }
};

// A new subscription is created through the ActionCable.Subscriptions instance available on the consumer.
// It provides a number of callbacks and a method for calling remote procedure calls on the corresponding
// Channel instance on the server side.
//
// An example demonstrates the basic functionality:
//
//   App.appearance = App.cable.subscriptions.create("AppearanceChannel", {
//     connected() {
//       // Called once the subscription has been successfully completed
//     },
//
//     disconnected({ willAttemptReconnect: boolean }) {
//       // Called when the client has disconnected with the server.
//       // The object will have an `willAttemptReconnect` property which
//       // says whether the client has the intention of attempting
//       // to reconnect.
//     },
//
//     appear() {
//       this.perform('appear', {appearing_on: this.appearingOn()})
//     },
//
//     away() {
//       this.perform('away')
//     },
//
//     appearingOn() {
//       $('main').data('appearing-on')
//     }
//   })
//
// The methods #appear and #away forward their intent to the remote AppearanceChannel instance on the server
// by calling the `perform` method with the first parameter being the action (which maps to AppearanceChannel#appear/away).
// The second parameter is a hash that'll get JSON encoded and made available on the server in the data parameter.
//
// This is how the server component would look:
//
//   class AppearanceChannel < ApplicationActionCable::Channel
//     def subscribed
//       current_user.appear
//     end
//
//     def unsubscribed
//       current_user.disappear
//     end
//
//     def appear(data)
//       current_user.appear on: data['appearing_on']
//     end
//
//     def away
//       current_user.away
//     end
//   end
//
// The "AppearanceChannel" name is automatically mapped between the client-side subscription creation and the server-side Ruby class name.
// The AppearanceChannel#appear/away public methods are exposed automatically to client-side invocation through the perform method.

const extend = function (object, properties) {
  if (properties != null) {
    for (let key in properties) {
      const value = properties[key];
      object[key] = value;
    }
  }
  return object;
};
class Subscription {
  constructor(consumer, params = {}, mixin) {
    this.consumer = consumer;
    this.identifier = JSON.stringify(params);
    extend(this, mixin);
  }

  // Perform a channel action with the optional data passed as an attribute
  perform(action, data = {}) {
    data.action = action;
    return this.send(data);
  }
  send(data) {
    return this.consumer.send({
      command: "message",
      identifier: this.identifier,
      data: JSON.stringify(data)
    });
  }
  unsubscribe() {
    return this.consumer.subscriptions.remove(this);
  }
}

// Responsible for ensuring channel subscribe command is confirmed, retrying until confirmation is received.
// Internal class, not intended for direct user manipulation.

class SubscriptionGuarantor {
  constructor(subscriptions) {
    this.subscriptions = subscriptions;
    this.pendingSubscriptions = [];
  }
  guarantee(subscription) {
    if (this.pendingSubscriptions.indexOf(subscription) == -1) {
      logger.log(`SubscriptionGuarantor guaranteeing ${subscription.identifier}`);
      this.pendingSubscriptions.push(subscription);
    } else {
      logger.log(`SubscriptionGuarantor already guaranteeing ${subscription.identifier}`);
    }
    this.startGuaranteeing();
  }
  forget(subscription) {
    logger.log(`SubscriptionGuarantor forgetting ${subscription.identifier}`);
    this.pendingSubscriptions = this.pendingSubscriptions.filter(s => s !== subscription);
  }
  startGuaranteeing() {
    this.stopGuaranteeing();
    this.retrySubscribing();
  }
  stopGuaranteeing() {
    clearTimeout(this.retryTimeout);
  }
  retrySubscribing() {
    this.retryTimeout = setTimeout(() => {
      if (this.subscriptions && typeof this.subscriptions.subscribe === "function") {
        this.pendingSubscriptions.map(subscription => {
          logger.log(`SubscriptionGuarantor resubscribing ${subscription.identifier}`);
          this.subscriptions.subscribe(subscription);
        });
      }
    }, 500);
  }
}

// Collection class for creating (and internally managing) channel subscriptions.
// The only method intended to be triggered by the user is ActionCable.Subscriptions#create,
// and it should be called through the consumer like so:
//
//   App = {}
//   App.cable = ActionCable.createConsumer("ws://example.com/accounts/1")
//   App.appearance = App.cable.subscriptions.create("AppearanceChannel")
//
// For more details on how you'd configure an actual channel subscription, see ActionCable.Subscription.

class Subscriptions {
  constructor(consumer) {
    this.consumer = consumer;
    this.guarantor = new SubscriptionGuarantor(this);
    this.subscriptions = [];
  }
  create(channelName, mixin) {
    const channel = channelName;
    const params = typeof channel === "object" ? channel : {
      channel
    };
    const subscription = new Subscription(this.consumer, params, mixin);
    return this.add(subscription);
  }

  // Private

  add(subscription) {
    this.subscriptions.push(subscription);
    this.consumer.ensureActiveConnection();
    this.notify(subscription, "initialized");
    this.subscribe(subscription);
    return subscription;
  }
  remove(subscription) {
    this.forget(subscription);
    if (!this.findAll(subscription.identifier).length) {
      this.sendCommand(subscription, "unsubscribe");
    }
    return subscription;
  }
  reject(identifier) {
    return this.findAll(identifier).map(subscription => {
      this.forget(subscription);
      this.notify(subscription, "rejected");
      return subscription;
    });
  }
  forget(subscription) {
    this.guarantor.forget(subscription);
    this.subscriptions = this.subscriptions.filter(s => s !== subscription);
    return subscription;
  }
  findAll(identifier) {
    return this.subscriptions.filter(s => s.identifier === identifier);
  }
  reload() {
    return this.subscriptions.map(subscription => this.subscribe(subscription));
  }
  notifyAll(callbackName, ...args) {
    return this.subscriptions.map(subscription => this.notify(subscription, callbackName, ...args));
  }
  notify(subscription, callbackName, ...args) {
    let subscriptions;
    if (typeof subscription === "string") {
      subscriptions = this.findAll(subscription);
    } else {
      subscriptions = [subscription];
    }
    return subscriptions.map(subscription => typeof subscription[callbackName] === "function" ? subscription[callbackName](...args) : undefined);
  }
  subscribe(subscription) {
    if (this.sendCommand(subscription, "subscribe")) {
      this.guarantor.guarantee(subscription);
    }
  }
  confirmSubscription(identifier) {
    logger.log(`Subscription confirmed ${identifier}`);
    this.findAll(identifier).map(subscription => this.guarantor.forget(subscription));
  }
  sendCommand(subscription, command) {
    const {
      identifier
    } = subscription;
    return this.consumer.send({
      command,
      identifier
    });
  }
}

// The ActionCable.Consumer establishes the connection to a server-side Ruby Connection object. Once established,
// the ActionCable.ConnectionMonitor will ensure that its properly maintained through heartbeats and checking for stale updates.
// The Consumer instance is also the gateway to establishing subscriptions to desired channels through the #createSubscription
// method.
//
// The following example shows how this can be set up:
//
//   App = {}
//   App.cable = ActionCable.createConsumer("ws://example.com/accounts/1")
//   App.appearance = App.cable.subscriptions.create("AppearanceChannel")
//
// For more details on how you'd configure an actual channel subscription, see ActionCable.Subscription.
//
// When a consumer is created, it automatically connects with the server.
//
// To disconnect from the server, call
//
//   App.cable.disconnect()
//
// and to restart the connection:
//
//   App.cable.connect()
//
// Any channel subscriptions which existed prior to disconnecting will
// automatically resubscribe.

class Consumer {
  constructor(url) {
    this._url = url;
    this.subscriptions = new Subscriptions(this);
    this.connection = new Connection(this);
  }
  get url() {
    return createWebSocketURL(this._url);
  }
  send(data) {
    return this.connection.send(data);
  }
  connect() {
    return this.connection.open();
  }
  disconnect() {
    return this.connection.close({
      allowReconnect: false
    });
  }
  ensureActiveConnection() {
    if (!this.connection.isActive()) {
      return this.connection.open();
    }
  }
}
function createWebSocketURL(url) {
  if (typeof url === "function") {
    url = url();
  }
  if (url && !/^wss?:/i.test(url)) {
    const a = document.createElement("a");
    a.href = url;
    // Fix populating Location properties in IE. Otherwise, protocol will be blank.
    a.href = a.href;
    a.protocol = a.protocol.replace("http", "ws");
    return a.href;
  } else {
    return url;
  }
}

function createConsumer(url = getConfig("url") || INTERNAL.default_mount_path) {
  return new Consumer(url);
}
function getConfig(name) {
  const element = document.head.querySelector(`meta[name='action-cable-${name}']`);
  if (element) {
    return element.getAttribute("content");
  }
}

var index = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Connection: Connection,
	ConnectionMonitor: ConnectionMonitor,
	Consumer: Consumer,
	INTERNAL: INTERNAL,
	Subscription: Subscription,
	SubscriptionGuarantor: SubscriptionGuarantor,
	Subscriptions: Subscriptions,
	adapters: adapters,
	createConsumer: createConsumer,
	createWebSocketURL: createWebSocketURL,
	getConfig: getConfig,
	logger: logger
});
//# sourceMappingURL=built.js.map
